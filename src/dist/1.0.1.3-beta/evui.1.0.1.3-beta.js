/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/


/**Root namespace declaration for all objects included in the EventUI code library.
@namespace*/
EVUI = {};

/**Root shorthand reference container for EventUI commands. All functions listed here are shorthand for functions found deeper in the API: these merely call the API commands and there is no difference
between them and the fully qualified function name.
@static*/
$evui = {};

/**Root namespace declaration for all the modules that EventUI uses.
@namespace*/
EVUI.Modules = {};


/********************************************************Binding.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.Binding|Binding)#*/
/*#REPLACE(EVUI.Modules.Binding|Binding)#*/

/**Module for data binding an object hierarchy to a set of DOM nodes.
@module*/
EVUI.Modules.Binding = {};

/*#MODULEDEF(Binding|"1.0"|"Binding")#*/
/*#VERSIONCHECK(EVUI.Modules.Binding|Binding)#*/

EVUI.Modules.Binding.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
    DomTree: Object.freeze({ version: "1.0", required: true }),
    Diff: Object.freeze({ version: "1.0", required: true }),
    EventStream: Object.freeze({ version: "1.0", required: true }),
    Dom: Object.freeze({ version: "1.0", required: true }),
    Observers: Object.freeze({ version: "1.0", required: true }),
    Http: Object.freeze({ version: "1.0", required: false })
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.Binding.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumerable: true
        });
})();

Object.freeze(EVUI.Modules.Binding.Dependencies);

EVUI.Modules.Binding.Constants = {};
EVUI.Modules.Binding.Constants.Attr_HtmlContentKey = "evui-binder-html-key";
EVUI.Modules.Binding.Constants.Attr_HtmlContentUrl = "evui-binder-html-src";
EVUI.Modules.Binding.Constants.Attr_BoundObj = "evui-binder-source";
EVUI.Modules.Binding.Constants.Attr_Mode = "evui-binder-mode";
EVUI.Modules.Binding.Constants.Attr_BindingTemplateName = "evui-binder-template-name";

EVUI.Modules.Binding.Constants.Event_OnBind = "evui.binder.bind";
EVUI.Modules.Binding.Constants.Event_OnSetHtmlContent = "evui.binder.get.htmlContent";
EVUI.Modules.Binding.Constants.Event_OnSetBindings = "evui.binder.get.bindings";
EVUI.Modules.Binding.Constants.Event_OnBindHtmlContent = "evui.binder.bind.htmlContent";
EVUI.Modules.Binding.Constants.Event_OnBindChildren = "evui.binder.bind.children";
EVUI.Modules.Binding.Constants.Event_OnBoundChildren = "evui.binder.bound.children";
EVUI.Modules.Binding.Constants.Event_OnBound = "evui.binder.bound";

/**Callback function definition for when a Binding has completed its work or was canceled.
@param {EVUI.Modules.Binding.Binding} binding The Binding that was created or re-bound.*/
EVUI.Modules.Binding.Constants.Fn_BindingCallback = function (binding) { };

/**Predicate function used to select Bindings underneath a given Binding. Return true to include in result set.
@param {EVUI.Modules.Binding.Binding} binding The Binding to test for a positive search result.
@returns {Boolean}*/
EVUI.Modules.Binding.Constants.Fn_SearchBindings = function (binding) { };

/**Predicate function used to select instances of BindingHtmlContent. Return true to include in result set.
@param {EVUI.Modules.Binding.BindingHtmlContent} bindingHtmlContent The BindingHtmlContent to test for a positive search result.
@returns {Boolean}*/
EVUI.Modules.Binding.Constants.Fn_SearchHtmlContent = function (bindingHtmlContent) { };

/**Predicate function used to select instances of BindingTemplate. Return true to include in result set.
@param {EVUI.Modules.Binding.BindingTemplate} bindingTemplate The Binding to test for a positive search result.
@returns {Boolean}*/
EVUI.Modules.Binding.Constants.Fn_SearchBindingTemplates = function (bindingTemplate) { };

/**Function that acts as an event handler for any of the events that can occur on a Binding or the BindingController.
@param {EVUI.Modules.Binding.BinderEventArgs} bindingEventArgs The event arguments for the binding process.*/
EVUI.Modules.Binding.Constants.Fn_BindingEventHandler = function (bindingEventArgs) { };

Object.freeze(EVUI.Modules.Binding.Constants);

/**Data-binding controller used for recursively binding object to DOM Nodes.
@class*/
EVUI.Modules.Binding.BindingController = function (services) 
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Binding.Dependencies);

    var _self = this; //self-reference for closures
    var _callbackCounter = 0; //counter to identify and sort callbacks in order of addition
    var _escapeRegexRegex = /[+^?.*$(){}|\[\]\\]/g; //RegExp to replace RegExp characters in property names when merging property values into html content
    var _bindingIDCounter = 0; //the ID counter for BindingHandle objects.
    var _bindingStateIDCounter = 0; //the ID counter for BindingHandleState objects.
    var _sessionIDCounter = 0; //the ID counter for BindingSession objects.
    var _dispatchIDCounter = 0; //the ID counter for BindingDispatchHandles
    var _batchIDCounter = 0; //the ID counter for BindingSessionBatches
    var _escapedPathCahce = {}; //dictionary of BoundProperty names to their RegExp escaped names (so we don't have to run the RegExp over every property every time)
    var _maxBatch = 25; //the maximum number of sessions that can be executed at a time in a single batch.
    var _salt = "@eventui&" + EVUI.Modules.Core.Utils.makeGuid() + "&"; //the hash salt used to make the hash codes for BindingDispatchHandle keys unique across application sessions.
    var _hashMarker = EVUI.Modules.Core.Utils.getHashCode(EVUI.Modules.Core.Utils.makeGuid()).toString(36).replace(".", ""); //a hidden hash value that is used to look up information about objects or nodes that will never occur in a user's code.
    var _hashMarkerLength = _hashMarker.length; //the cached length of the hashMarker so it doesn't need to be recalculated over and over
    var _bubblingEvents = new EVUI.Modules.EventStream.BubblingEventManager();


    /**Additional information about all the htmlContent that has been bound.
    @type {HtmlContentMetadata[]}*/
    var _htmlContentMetadata = [];

    /**All of the BindingHtmlContentEntries that have been loaded into the BindingController.
    @type {BindingHtmlContentEntry[]}*/
    var _bindingHtmlContentEntries = [];

    /**Array. All of the BindingTemplates that have been loaded into the BindingController.
    @type {EVUI.Modules.Binding.BindingTemplate[]}*/
    var _bindingTemplates = [];

    /**Object. A dictionary mapping hash codes to a particular event handler for a bound element.
    @type {Object}*/
    var _invocationDictionary = {};

    /**Object. Injected services into this controller to use custom 
    @type {EVUI.Modules.Binding.BindingControllerServices}*/
    var _services = services;

    /**The root level container for all batching operations.
    @type {BindingSessionBatchContainer}*/
    var _batchContainer = null;

    /**A lookup table of batches keyed by their ID's.
    @type {Object}*/
    var _batchLookup = {};

    /**Gets a BindingHtmlContent from the controller's internal store of BindingHtmlContents.
    @param {String|EVUI.Modules.Binding.Constants.Fn_SearchHtmlContent} keyOrSelector The string key or selector predicate to select the set of BindingHtmlContent to return.
    @param {Boolean} returnFirstMatch Whether or not to return the first successful match as soon as it is found. False by default.
    @returns {EVUI.Modules.Binding.BindingHtmlContent[]|EVUI.Modules.Binding.BindingHtmlContent} */
    this.getHtmlContent = function (keyOrSelector, returnFirstMatch)
    {
        var selectorType = typeof keyOrSelector;
        if (selectorType !== "string" && selectorType !== "function") throw Error("String or function expected.");

        var numItems = _bindingHtmlContentEntries.length;
        var copyList = _bindingHtmlContentEntries.slice();
        var matches = [];

        for (var x = 0; x < numItems; x++)
        {
            var curContentEntry = copyList[x];
            if (selectorType === "string")
            {
                if (curContentEntry.item.key === keyOrSelector) return curContentEntry.item;
            }
            else
            {
                if (keyOrSelector(curContentEntry.item) === true)
                {
                    if (returnFirstMatch === true)
                    {
                        return curContentEntry.item;
                    }
                    else
                    {
                        matches.push(curContentEntry.item);
                    }
                }
            }
        }

        if (selectorType === "function" && returnFirstMatch !== true) return matches;

        return null;
    };

    /**Adds Html to the internal store of BindingHtmlContents that can be referenced in Bindings.
    @param {String|EVUI.Modules.Binding.BindingHtmlContent} key Either a unique string key of content to add or a YOLO BindingHtmlContent object.
    @param {String} htmlContent The Html content to associate with the string key.
    @param {String} url A URL to get the Html content from if it is going to be loaded remotely.
    @returns {EVUI.Modules.Binding.BindingHtmlContent}*/
    this.addHtmlContent = function (key, htmlContent, url)
    {
        var entry = addCachedHtmlContent(key, htmlContent, url);
        return entry.item;
    };

    /**Removes a BindingHtmlContent entry from the controller's internal store of BindingHtmlContents.
    @param {String} key The key of the BindingHtmlContent entry to remove.
    @returns {Boolean}*/
    this.removeHtmlContent = function (key)
    {
        if (typeof key === "object") key = key.key;
        return removeCachedHtmlContent(key);
    };

    /**Binds an object to the DOM using some Html content that is inserted relative to a target element.
    @param {EVUI.Modules.Binding.Binding|EVUI.Modules.Binding.BindArgs|EVUI.Modules.Binding.BindingTemplate|String} bindingOrArgs Either: A YOLO Binding object, a YOLO BindArgs object, a YOLO BindingTemplate object, or the name of the BindingTemplate to use.
    @param {EVUI.Modules.Binding.BindArgs} bindArgsOrSource Either a YOLO BindArgs object or the source object to base the Binding off of.
    @param {EVUI.Modules.Binding.Constants.Fn_BindingCallback} callback A callback function that is fired when the Binding process completes.*/
    this.bind = function (bindingOrArgs, bindArgsOrSource, callback)
    {
        if (bindingOrArgs == null) throw Error("String or Object expected.");
        if (typeof bindArgsOrSource === "function" && typeof callback !== "function")
        {
            callback = bindArgsOrSource;
            bindArgsOrSource = null;
        }

        if (typeof callback !== "function") callback = function (binding) { };

        var bindingHandle = getBindingHandleAmbiguously(bindingOrArgs);
        if (bindingHandle == null)
        {
            throw Error("Failed to resolve binding.");
        }

        if (bindArgsOrSource == null) bindArgsOrSource = bindingOrArgs;
        triggerBind(bindingHandle, bindArgsOrSource, null, callback);
    };

    /**Awaitable. Binds an object to the DOM using some Html content that is inserted relative to a target element.
    @param {EVUI.Modules.Binding.Binding|EVUI.Modules.Binding.BindArgs|EVUI.Modules.Binding.BindingTemplate|String} bindingOrArgs Either: A YOLO Binding object, a YOLO BindArgs object, a YOLO BindingTemplate object, or the name of the BindingTemplate to use.
    @param {EVUI.Modules.Binding.BindArgs} bindArgsOrSource Either a YOLO BindArgs object or the source object to base the Binding off of.
    @returns {Promise<EVUI.Modules.Binding.Binding>}*/
    this.bindAsync = function (bindingOrArgs, bindArgsOrSource)
    {
        return new Promise(function (resolve)
        {
            _self.bind(bindingOrArgs, bindArgsOrSource, function (binding)
            {
                resolve(binding);
            });
        });
    };

    /**Adds a set of pre-configured options for Bindings to use that can be referenced by name.
    @param {EVUI.Modules.Binding.BindingTemplate} bindingTemplate A YOLO BindingTemplate object.
    @returns {EVUI.Modules.Binding.BindingTemplate}*/
    this.addBindingTemplate = function (bindingTemplate)
    {
        if (bindingTemplate == null || typeof bindingTemplate !== "object") throw Error("Object expected.");
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(bindingTemplate.templateName) === true) throw Error("BindingTemplate name must be a non-whitespace string.");

        var existing = getBindingTemplate(bindingTemplate.templateName);
        if (existing != null) throw Error("A BindingTemplate with the name \"" + bindingTemplate.templateName + "\" already exists.");

        var bindingTemplateEntry = new BindingTemplateEntry();
        bindingTemplateEntry.templateName = bindingTemplate.templateName;

        var bindingTemplate = makeBindingTemplate(bindingTemplate, null, bindingTemplateEntry);
        _bindingTemplates.push(bindingTemplate);

        return bindingTemplate;
    };

    /**Removes a BindingTemplate from the controller.
    @param {String} bindingTemplateName The name of the BindingTemplate to remove.
    @returns {Boolean} */
    this.removeBindingTemplate = function (bindingTemplateName)
    {
        if (bindingTemplateName == null) return false;
        if (typeof bindingTemplateName === "object") bindingTemplateName = bindingTemplateName.templateName;

        var existing = getBindingTemplate(bindingTemplateName);
        if (existing != null)
        {
            var index = _bindingTemplates.indexOf(existing);
            if (index !== -1)
            {
                _bindingTemplates.splice(x, 1);
                return true;
            }
        }

        return false;
    };

    /**Gets a BindingTemplate from the controller's internal store of BindingTemplates.
    @param {String|EVUI.Modules.Binding.Constants.Fn_SearchBindingTemplates} bindingNameOrSelector The string key or selector predicate to select the set of BindingHtmlContent to return.
    @param {Boolean} returnFirstMatch Whether or not to return the first successful match as soon as it is found. False by default.
    @returns {EVUI.Modules.Binding.BindingTemplate[]|EVUI.Modules.Binding.BindingTemplate} */
    this.getBindingTemplate = function (bindingNameOrSelector, returnFirstMatch)
    {
        var selectorType = typeof bindingNameOrSelector;
        if (selectorType !== "string" && selectorType !== "function") throw Error("String or function expected.");

        var numItems = _bindingTemplates.length;
        var listCopy = _bindingTemplates.slice();
        var matches = [];

        for (var x = 0; x < numItems; x++)
        {
            var curTemplate = listCopy[x];
            if (selectorType === "string")
            {
                if (curTemplate.templateName === bindingNameOrSelector) return curTemplate;
            }
            else
            {
                if (bindingNameOrSelector(curTemplate) === true)
                {
                    if (returnFirstMatch === true)
                    {
                        return curTemplate;
                    }
                    else
                    {
                        matches.push(curTemplate);
                    }
                }
            }
        }

        if (selectorType === "function" && returnFirstMatch !== true) return matches;

        return null;
    };

    /**Add an event listener to fire after an event with the same name has been executed.
    @param {String} eventName The name of the event in the EventStream to execute after.
    @param {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler} handler The function to fire.
    @param {EVUI.Modules.EventStream.EventStreamEventListenerOptions} options Options for configuring the event.
    @returns {EVUI.Modules.EventStream.EventStreamEventListener}*/
    this.addEventListener = function (eventName, handler, options)
    {
        return _bubblingEvents.addEventListener(eventName, handler, options);
    };

    /**Removes an EventStreamEventListener based on its event name, its id, or its handling function.
    @param {String} eventNameOrId The name or ID of the event to remove.
    @param {Function} handler The handling function of the event to remove.
    @returns {Boolean}*/
    this.removeEventListener = function (eventNameOrId, handler)
    {
        return _bubblingEvents.removeEventListener(eventNameOrId, handler);
    };

    /**Event that fires immediately before the binding process begins.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onBind = null;

    /**Event that fires when the htmlContent for the binding has been obtained.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onSetHtmlContent = null;

    /**Event that fires when the htmlContent has been finalized and the bindings in the htmlContent
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onSetBindings = null;

    /**Event that fires when the htmlContent has been populated with the values from the bound object.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onBindHtmlContent = null;

    /**Event that fires when the child bindings of the current binding have been found and are about to be bound.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onBindChildren = null;

    /**Event that fires when the htmlContent has been populated with the values from the bound object and has had all of its child bindings injected into it.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onChildrenBound = null;

    /**Event that fires when the binding operation is complete and the complete content and all its children has been injected.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onBound = null;

    /**Ensures that the required service dependencies from other modules are present for the Binder to do its job.*/
    var ensureServices = function ()
    {
        _batchContainer = new BindingSessionBatchContainer()

        if (_services == null || typeof _services !== "object")
        {
            _services = new EVUI.Modules.Binding.BindingControllerServices();
        }

        if (_services.diffController == null || typeof _services.diffController !== "object")
        {
            _services.diffController = EVUI.Modules.Diff.Comparer;
        }

        if (_services.domTreeConverter == null || typeof _services.domTreeConverter !== "object")
        {
            _services.domTreeConverter = EVUI.Modules.DomTree.Converter;
        }

        if (_services.httpManager == null || typeof _services.httpManager !== "object") //because this is an optional dependency we make a special getter that is effectively a "lazy" load that won't crash if the dependency is missing
        {
            Object.defineProperty(_services, "httpManager", {
                get: function ()
                {
                    return EVUI.Modules.Http.Http;
                },
                configurable: false,
                enumerable: true
            })
        }
    };

    /********************************************************************BINDING EXECUTION*************************************************************************/

    /**Triggers the Binding disposal logic for the given BindingHandle and all its children.
    @param {BindingHandle} bindingHandle The BindingHandle to remove from the DOM and from it's parent Binding.
    @returns {Boolean}*/
    var triggerDispose = function (bindingHandle)
    {
        if (bindingHandle.disposing === true) return false;
        bindingHandle.disposing = true;
        bindingHandle.completionState = EVUI.Modules.Binding.BindingCompletionState.Disposed;

        //dispose of its children before disposing of it itself
        var numChildren = bindingHandle.currentState.childBindingHandles.length;
        var offset = 0;
        while (numChildren > 0)
        {
            var curChild = bindingHandle.currentState.childBindingHandles[offset];
            if (curChild.disposing === true || triggerDispose(curChild) === true) //the child removed itself from the parent list, so don't increment the index and reduce the child count
            {
                numChildren--;
                if (curChild.disposing === true) offset++;
            }
        }

        //only dispose if the binding isn't in the middle of doing something.
        if (bindingHandle.progressState === EVUI.Modules.Binding.BindingProgressStateFlags.Idle)
        {
            disposeBinding(bindingHandle);
            return true;
        }
        else
        {
            return false;
        }
    };

    /**Disposes of a single BindingHandle; removes its DOM Nodes from the DOM, removes its states and event handlers, removes it from it's parent's binding list, and effectively resets the binding to a blank state.
    @param {BindingHandle} bindingHandle The BindingHandle to dispose of.*/
    var disposeBinding = function (bindingHandle)
    {
        //don't re-dispose if already disposing
        if (bindingHandle.disposing === false) return;

        //flush old states
        bindingHandle.oldState = null;
        bindingHandle.pendingState = null;

        //remove all existing content that's attached to the DOM
        var numBoundContent = (bindingHandle.currentState.boundContent != null) ? bindingHandle.currentState.boundContent.length : 0;
        for (var x = 0; x < numBoundContent; x++)
        {
            var curContent = bindingHandle.currentState.boundContent[x];
            if (curContent.isConnected === true)
            {
                curContent.remove();
            }
        }

        //disconnect and remove from parent if it has a parent binding handle
        if (bindingHandle.currentState.parentBindingHandle != null)
        {
            var parentIndex = bindingHandle.currentState.parentBindingHandle.currentState.childBindingHandles.indexOf(bindingHandle);
            if (parentIndex !== -1)
            {
                bindingHandle.currentState.parentBindingHandle.currentState.childBindingHandles.splice(parentIndex, 1);
            }

            //if we had an array, the element is always the previous element's last bound content in the array, so we never want to remove it.
            if (EVUI.Modules.Core.Utils.isArray(bindingHandle.currentState.parentBindingHandle.currentState.source) === false)
            {
                //if it was a child of a parent, the element would have been contained by the parent and should be removed.
                bindingHandle.currentState.element.remove();
            }
        }

        //remove all of the events associated with this binding, otherwise a memory leak is created
        disposeBindingDispatchHandles(bindingHandle);

        bindingHandle.dispatchHandles = [];

        //reset all bindingHandle properties
        bindingHandle.newStateBound = false;
        bindingHandle.oldStateBound = false;
        bindingHandle.progressState = EVUI.Modules.Binding.BindingProgressStateFlags.Idle;
        bindingHandle.templateName = null;

        //make a new state
        bindingHandle.currentState = new BindingHandleState();

        //unset the disposing flag
        bindingHandle.disposing = false;
    };

    /**Disposes of all the BindingDispatchHandles associated with a BindingHandle.
    @param {BindingHandle} bindingHandle The BindingHandle to purge the BindingDispatchHandles from*/
    var disposeBindingDispatchHandles = function (bindingHandle)
    {
        var numEventBindings = bindingHandle.dispatchHandles.length;
        for (var x = 0; x < numEventBindings; x++)
        {
            bindingHandle.dispatchHandles[x].dispose();
        }
    };

    /**Triggers the full binding process for a BindingHandle and all of its children, forcing the entire hierarchy to be re-evaluated.
    @param {BindingHandle} bindingHandle The BindingHandle to execute.
    @param {EVUI.Modules.Binding.BindArgs} bindArgsOrSource Either the BindArgs or source object passed in from the bind or bindAsync calls.
    @param {BindingSession} parentSession The parent BindingSession to this BindingSession.
    @param {EVUI.Modules.Binding.Constants.Fn_BindingCallback} callback A callback function to call once the binding process is complete.*/
    var triggerBind = function (bindingHandle, bindArgsOrSource, parentSession, callback)
    {
        var bindArgsType = typeof bindArgsOrSource;
        var callbackType = typeof callback;
        var bindArgs = new EVUI.Modules.Binding.BindArgs();

        var elementBindingState = bindingHandle.currentState;
        var sourceBindingState = bindingHandle.currentState;

        if (bindArgsType === "function") //we have no bind args
        {
            if (typeof callback !== "function") callback = bindArgsOrSource;
        }
        else if (bindArgsType === "object" && bindArgsOrSource != null)
        {
            if (EVUI.Modules.Core.Utils.instanceOf(bindArgsOrSource, EVUI.Modules.Binding.BindArgs) === false)
            {
                var bindingSource = (bindArgsOrSource.source != null) ? bindArgsOrSource.source : bindArgsOrSource.bindingSource;
                var ele = (bindArgsOrSource.element != null) ? bindArgsOrSource.element : bindArgsOrSource.bindingTarget;
                var context = bindArgsOrSource.bindingContext;

                if (ele === undefined && bindingSource === undefined && context === undefined) //did not have any property, use it as the source object by itself
                {
                    bindArgs.bindingSource = bindArgsOrSource;
                }
                else //had at least one property
                {
                    if (bindingSource !== undefined) bindArgs.bindingSource = bindingSource; //we have a binding source

                    var extracted = getValidElement(ele);
                    if (extracted != null) bindArgs.bindingTarget = extracted; //we have a target
                    if (context !== undefined) bindArgs.bindingContext = context;
                }

                bindArgs.bindingContext = bindArgsOrSource.bindingContext;
            }
            else //was already an instance, just clone it
            {
                bindArgs = EVUI.Modules.Core.Utils.shallowExtend(bindArgs, bindArgsOrSource);
            }
        }

        if (bindingHandle.pendingState != null && bindingHandle.pendingState.elementSet === true) elementBindingState = bindingHandle.pendingState; //if we set the pending state for the element, use them
        if (bindingHandle.pendingState != null && bindingHandle.pendingState.sourceSet === true) sourceBindingState = bindingHandle.pendingState; //if we set the pending state for the source, use them

        if (bindArgs.bindingTarget == null) //target was not set, fall back to the old state if it was valid
        {
            if (elementBindingState === bindingHandle.currentState && elementBindingState.element == null && elementBindingState.elementSet === false)
            {
                if (bindingHandle.oldState != null && bindingHandle.oldState.elementSet === true) bindArgs.bindingTarget = bindingHandle.oldState.element;
            }
            else //if it's not the current state, it was the pending state
            {
                bindArgs.bindingTarget = elementBindingState.element;
            }
        }

        if (bindArgs.bindingSource == null) //source was not set, fall back to the old state if it was valid
        {
            if (sourceBindingState === bindingHandle.currentState && elementBindingState.source == null && elementBindingState.sourceSet === false)
            {
                if (bindingHandle.oldState != null && bindingHandle.oldState.sourceSet === true) bindArgs.bindingSource = bindingHandle.oldState.source;
            }
            else  //if it's not the current state, it was the pending state
            {
                bindArgs.bindingSource = sourceBindingState.source;
            }
        }

        if (callbackType !== "function") callback = function (binding) { };

        var session = new BindingSession(); //make the new session to hold all the info about the Binding operation
        session.bindingArgs = bindArgs;
        session.bindingHandle = bindingHandle;
        session.parentSession = parentSession;
        session.sessionMode = BindingSessionMode.Bind;

        if (parentSession != null) //if we have a parent session, register this as a child session of that parent.
        {
            parentSession.childSessions.push(session);
            if (parentSession.bindingHandle.oldStateBound === false) session.maintainCurrentState = true;

            if (parentSession.context != null) //apply the context rules if needed
            {
                if (parentSession.bindingHandle.binding.options.shareContextMode === EVUI.Modules.Binding.ShareContextMode.Clone)
                {
                    if (typeof parentSession.context === "object")
                    {
                        session.context = EVUI.Modules.Core.Utils.shallowExtend(session.context, parentSession.context);
                    }
                    else
                    {
                        session.context = parentSession.context;
                    }
                }
                else if (parentSession.bindingHandle.binding.options.shareContextMode === EVUI.Modules.Binding.ShareContextMode.ShareReference)
                {
                    session.context = parentSession.context;
                }
            }
        }
        else
        {
            session.context = session.bindingArgs.bindingContext;
        }

        //make a container to hold this binding's callback to ensure it gets called eventually by this or another (subsequent) binding
        var callbackEntry = new BindingCallbackEntry();
        callbackEntry.session = session;
        callbackEntry.callback = callback;
        callbackEntry.id = _callbackCounter++;

        session.callbacks.push(callbackEntry);

        //build all the events/jobs for the event stream
        buildEventStream(session);

        //and add the job to the batching logic
        batchJobs(session);
    };

    /**Triggers the update process for a BindingHandle and all of its changed children, which only requires what has changed to re-evaluate itself.
    @param {BindingHandle} bindingHandle The BindingHandle to trigger the update process on.
    @param {EVUI.Modules.Binding.UpdateArgs} updateArgs The arguments passed into the update operation.
    @param {BindingSession} parentSession The parent BindingSession to this BindingSession.
    @param {EVUI.Modules.Binding.Constants.Fn_BindingCallback} callback  A callback function to call once the update process is complete.*/
    var triggerUpdate = function (bindingHandle, updateArgs, parentSession, callback)
    {
        if (typeof updateArgs === "function" && callback == null)
        {
            callback = updateArgs;
            updateArgs = null;
        }

        if (typeof callback !== "function") callback = function (session) { };

        //make a new binding session for the update session
        var session = new BindingSession();

        //make some dummy "bind args" to hold any new information about the binding to be updated.
        session.bindingArgs = new EVUI.Modules.Binding.BindArgs();
        session.bindingArgs.bindingSource = (bindingHandle.pendingState != null && bindingHandle.pendingState.sourceSet === true) ? bindingHandle.pendingState.source : bindingHandle.currentState.source;
        session.bindingArgs.bindingTarget = (bindingHandle.pendingState != null && bindingHandle.pendingState.elementSet === true) ? bindingHandle.pendingState.element : bindingHandle.currentState.element;

        if (updateArgs != null && typeof updateArgs === "object") //if we have a update args object, see if it has any properties we can use
        {
            if (updateArgs.bindingSource === undefined && updateArgs.bindingContext === undefined) //it does not, so it can be used as the source object
            {
                session.bindingArgs.bindingSource = updateArgs;
            }
            else //it does - use the properties
            {
                if (updateArgs.bindingSource !== undefined) session.bindingArgs.bindingSource = updateArgs.bindingSource;
                if (updateArgs.bindingContext !== undefined) session.bindingArgs.bindingContext = updateArgs.bindingContext;
            }
        }

        session.bindingHandle = bindingHandle;
        session.parentSession = parentSession;
        session.sessionMode = BindingSessionMode.Update;

        //if we were canceled after calculating the differences between the two objects, force a re-bind instead of doing the update logic. This will be slower, but it will get things back in sync with whatever changed.
        if (session.bindingHandle.canceledDuringReBind === true) session.sessionMode = BindingSessionMode.Bind;

        if (parentSession != null) //if we have a parent session, register this as a child session of that parent.
        {
            parentSession.childSessions.push(session);
            if (parentSession.bindingHandle.oldStateBound === false) session.maintainCurrentState = true;

            if (parentSession.context != null)  //apply the context rules if needed
            {
                if (parentSession.bindingHandle.binding.options.shareContextMode === EVUI.Modules.Binding.ShareContextMode.Clone)
                {
                    if (typeof parentSession.context === "object")
                    {
                        session.context = EVUI.Modules.Core.Utils.shallowExtend(session.context, parentSession.context);
                    }
                    else
                    {
                        session.context = parentSession.context;
                    }
                }
                else if (parentSession.bindingHandle.binding.options.shareContextMode === EVUI.Modules.Binding.ShareContextMode.ShareReference)
                {
                    session.context = parentSession.context;
                }
            }
        }
        else
        {
            session.context = session.bindingArgs.bindingContext;
        }

        //make a container to hold this binding's callback to ensure it gets called eventually by this or another (subsequent) binding
        var callbackEntry = new BindingCallbackEntry();
        callbackEntry.session = session;
        callbackEntry.callback = callback;
        callbackEntry.id = _callbackCounter++;

        session.callbacks.push(callbackEntry);

        //build all the events/jobs for the event stream
        buildEventStream(session);

        //and add the job to the batching logic
        batchJobs(session);
    };


    /**Batches jobs so that the checks to ensure that no race conditions occur only operate on a small array and not a gigantic one.
    @param {BindingSession} session The session to either execute or queue to be batched.*/
    var batchJobs = function (session)
    {
        var batch = null;
        var shouldExecute = false;

        //first, get the right batch container. this will be the default batch if this binding session has no parent - if it does have a parent, it will be the batch container that contains the parent's batch.
        var parentContainer = _batchContainer;
        if (session.parentSession != null)
        {
            var parentBatch = _batchLookup[session.parentSession.batchId];
            parentContainer = parentBatch.batchContainer;
        }

        //we want a child container to put the batch into, so we either make one or find one and use that as our context going forward
        if (parentContainer.numChildContainers === 0)
        {
            var childContainer = new BindingSessionBatchContainer();
            childContainer.parentContainer = parentContainer;

            parentContainer.childContainers = [];
            parentContainer.numChildContainers = parentContainer.childContainers.push(childContainer);
            parentContainer = childContainer;
        }
        else
        {
            //we want to get the child container furthest back in the list
            var lastChild = parentContainer.childContainers[parentContainer.numChildContainers - 1];
            var lastBatch = lastChild.batches[lastChild.numBatches - 1];
            if (lastBatch != null)
            {
                //if we have a batch in progress, go look at the sequence number (sessionId) of the incoming session and the last session in the list.
                //If they arent next to each other, we want to put the new session in its own container to keep the last batch from stalling if one
                //relies on the other finishing first and deadlock instead.
                var lastItem = lastBatch.sessions[lastBatch.numSessions - 1];
                var idDelta = (lastItem == null) ? 1 : session.sessionId - lastItem.sessionId;
                if (lastItem != null && (idDelta !== 1 && idDelta !== -1))
                {
                    var childContainer = new BindingSessionBatchContainer();

                    childContainer.parentContainer = parentContainer;
                    parentContainer.numChildContainers = parentContainer.childContainers.push(childContainer);
                    parentContainer = childContainer;
                }
                else //next to each other, use the last child session to hold this session
                {
                    parentContainer = lastChild;
                }
            }
            else //if all else fails they get the 0th child.
            {
                parentContainer = (lastChild == null) ? parentContainer.childContainers[0] : lastChild;
            }
        }

        //if there aren't any batches to hold the incoming session, make a new one
        if (parentContainer.numBatches === 0)
        {
            batch = new BindingSessionBatch();
            batch.batchContainer = parentContainer;

            _batchLookup[batch.id] = batch;

            parentContainer.currentBatch = batch;
            parentContainer.numBatches = parentContainer.batches.push(batch);
        }
        else //otherwise use the current batch being loaded in the container
        {
            batch = parentContainer.currentBatch;
        }

        //flag the session with the batchId so we can look it up in the _batchLookup table later.
        session.batchId = batch.id;

        batch.numSessions = batch.sessions.push(session);

        //if we're on the first batch, execute the session as we havent met the minimum batch size to start spooling sessions yet
        shouldExecute = parentContainer.numBatches <= 1;

        //if we are over the batch size, make a new batch and set it to be the currentBatch to load up with future sessions.
        if (batch.numSessions >= _maxBatch)
        {
            var newBatch = new BindingSessionBatch();
            newBatch.batchContainer = parentContainer;

            _batchLookup[newBatch.id] = newBatch;

            parentContainer.currentBatch = newBatch;
            parentContainer.numBatches = parentContainer.batches.push(newBatch);
        }

        //finally, kick off the binding if we're under the batch size
        if (shouldExecute === true)
        {
            executeSession(session);
        }
    }

    /**Kicks off the next batch in a batch container.
    @param {BindingSessionBatch} batch The batch that has just completed.*/
    var triggerNextBatch = function (batch)
    {
        //remove the batch from the lookup table since we're done with it forever
        delete _batchLookup[batch.id];

        var parentContainer = batch.batchContainer;

        //get the next batch, which is sometimes the first batch in the container, so we get it twice sometimes to make sure we're not re-running the batch
        var nextBatch = parentContainer.batches.shift();
        while (nextBatch != null && nextBatch.id === batch.id)
        {
            nextBatch = parentContainer.batches.shift();
        }

        parentContainer.numBatches = parentContainer.batches.length;

        if (nextBatch == null) //didn't find another batch - this container is done
        {
            parentContainer.currentBatch = null;
            if (parentContainer.parentContainer != null)
            {
                var indexToRemove = parentContainer.parentContainer.childContainers.indexOf(parentContainer);
                if (indexToRemove > -1)
                {
                    parentContainer.parentContainer.childContainers.splice(indexToRemove, 1);
                    parentContainer.parentContainer.numChildContainers--;
                }
            }
        }
        else
        {
            if (nextBatch.numSessions === 0) //an empty batch, recursively clean up
            {
                triggerNextBatch(nextBatch);
            }
            else //otherwise launch all the sessions in the batch. The completed sessions will trigger the next batch when it finishes
            {
                for (var x = 0; x < nextBatch.numSessions; x++)
                {
                    executeSession(nextBatch.sessions[x]);
                }
            }
        }
    }

    /**Gets all the sessions that are operating with either the same binding or on the same reference element. Helps detect race conditions and enforces the rule that only one binding can execute on an element at a time.
    @param {BindingSession} newSession The new BindingSession to check against the existing binding sessions that are being executed.
    @returns {BindingSessionMatch[]} */
    var getMatchingSessions = function (newSession)
    {
        var matches = [];

        var sessionArray = _batchLookup[newSession.batchId].sessions;
        var numSessions = sessionArray.length;
        for (var x = 0; x < numSessions; x++)
        {
            var curSession = sessionArray[x];

            if (curSession.sessionId !== newSession.sessionId)
            {
                var match = compareSessions(newSession, curSession);
                if (match != null)
                {
                    matches.push(match);
                }
            }
        }

        return matches;
    };

    /**Compares two sessions to determine if they could possibly cause a race condition if executed in the same batch.
    @param {BindingSession} currentSesison The current BindingSession that is about to be executed.
    @param {BindingSession} otherSession A different executing or queued BindingSession to compare against.
    @returns {BindingSessionMatch}*/
    var compareSessions = function (currentSession, otherSession)
    {
        var match = null;
        var flags = BindingSessionMatchTypeFlags.None;

        if (otherSession.bindingHandle.id === currentSession.bindingHandle.id) //same binding in different sessions, only one can go at a time
        {
            flags |= BindingSessionMatchTypeFlags.SameBinding;
        }

        if (currentSession.bindingArgs.bindingTarget != null && currentSession.bindingArgs.bindingTarget === otherSession.bindingArgs.bindingTarget) //same element used by two different bindings, only one can use the same element at a time
        {
            if (isFirstArrayElementOf(currentSession, otherSession) === false && isFirstArrayElementOf(otherSession, currentSession) === false) //test against the edge case where the first element in an array has the same element as its parent Binding
            {
                flags |= BindingSessionMatchTypeFlags.SameElement;
            }
        }

        if (flags > 0) //if either case was true, return a match
        {
            var match = new BindingSessionMatch();
            match.session = otherSession;
            match.flags = flags;

            return match;
        }

        return null;
    };

    /**Determines if the two sessions meet the criteria for the edge case where the first element of a bound array matches the element of its parent binding. Only applies to arrays that are being bound for the second time.
    @param {BindingSession} session1 A BindingSession to check.
    @param {BindingSession} session2 The other BindingSession to check.
    @returns {Boolean}*/
    var isFirstArrayElementOf = function (session1, session2)
    {
        if (session1.parentSession != null) //check the case where session1 is the parent of session2 and session2 is the first child of session1.
        {
            if (session1.parentSession.isArray === false) return false;
            if (session1.parentSession.bindingHandle.oldStateBound === false) return false;
            if (session1.parentSession.bindingHandle.oldState.childBindingHandles.length === 0) return false;
            if (session1.parentSession.bindingHandle.oldState.childBindingHandles[0].element === session2.bindingHandle.element)
            {
                return true;
            }
        }
        else if (session1.isArray === true) //check the case where session2 is the first child of session 1's bound array
        {
            if (session1.bindingHandle.oldStateBound === false) return false;
            if (session1.bindingHandle.oldState.childBindingHandles.length === 0) return false;
            if (session1.bindingHandle.oldState.childBindingHandles[0].element === session2.bindingHandle.element)
            {
                return true;
            }
        }

        return false;
    };

    /**First step in the binding process. Stores the current (soon to be old) state and makes a new state to hold the information about the binding in progress.
    @param {BindingSession} session The BindingSession that is in the process of being bound.*/
    var swapStates = function (session)
    {
        if (session.maintainCurrentState === true) //this is binding is a new child binding of a parent session who has not yet been bound
        {
            session.isArray = EVUI.Modules.Core.Utils.isArray(session.bindingHandle.currentState.source);
            session.maintainCurrentState = false;
            return;
        }

        var newState = new BindingHandleState();

        if (session.bindingHandle.pendingState != null) //if we have a pending state, apply it to the current state
        {
            var pending = session.bindingHandle.pendingState;
            if (pending.normalizedPath != null) newState.normalizedPath = pending.normalizedPath;
            if (pending.parentBindingHandle != null) newState.parentBindingHandle = pending.parentBindingHandle;
            if (pending.parentBindingKey != null) newState.parentBindingKey = pending.parentBindingKey;
            if (pending.parentBindingPath != null) newState.parentBindingPath = pending.parentBindingPath;
        }
        else if (session.bindingHandle.currentState != null && session.bindingHandle.newStateBound === true) //if we don't have a pending state, but are re-binding, maintain the link between the parent and child bindings
        {
            EVUI.Modules.Core.Utils.shallowExtend(newState, session.bindingHandle.currentState, ["stateId", "boundContent", "boundProperties", "childBindingHandles", "sourceSet", "htmlContentSet", "elementSet", "sourceObserver", "element"]);
            if (session.bindingHandle.currentState.boundContent != null) newState.boundContent = session.bindingHandle.currentState.boundContent.slice();
            if (session.bindingHandle.currentState.boundProperties != null) newState.boundProperties = session.bindingHandle.currentState.boundProperties.slice();
        }

        //the bindingArgs have been normalized up to this point and are guaranteed to have the actual values to use when we get to this step regardless if the user used a binding args object or not.
        newState.element = session.bindingArgs.bindingTarget;
        newState.source = session.bindingArgs.bindingSource;

        //get the correct html content for the new state from wherever it was set last.
        if (session.bindingHandle.pendingState != null && session.bindingHandle.pendingState.htmlContentSet === true)
        {
            newState.htmlContent = session.bindingHandle.pendingState.htmlContent;
        }
        else if (session.bindingHandle.currentState.htmlContentSet === true)
        {
            newState.htmlContent = session.bindingHandle.currentState.htmlContent;
        }
        else if (session.bindingHandle.oldState != null && session.bindingHandle.oldState.htmlContentSet === true)
        {
            newState.htmlContent = session.bindingHandle.oldState.htmlContent;
        }
        else
        {
            newState.htmlContent = session.bindingHandle.currentState.htmlContent;
        }

        //remember the old state to use to roll back to in the event of a cancel operation.
        session.rollbackState = session.bindingHandle.oldState;
        session.rollbackPendingState = session.bindingHandle.pendingState;
        session.rollbackStateBound = session.bindingHandle.oldStateBound;

        //swap the states and set the flags for whether or not the current and old states have been bound
        session.bindingHandle.oldState = session.bindingHandle.currentState;
        session.bindingHandle.currentState = newState;
        session.bindingHandle.pendingState = null;
        session.bindingHandle.oldStateBound = session.bindingHandle.newStateBound;
        session.bindingHandle.newStateBound = false;
        session.isArray = EVUI.Modules.Core.Utils.isArray(newState.source);

        //assign the parent if there was one
        if (session.parentSession != null)
        {
            session.bindingHandle.currentState.parentBindingHandle = session.parentSession.bindingHandle;
        }

        session.bindingHandle.completionState = EVUI.Modules.Binding.BindingCompletionState.Executing;
    };

    /**In the event that a binding operation was canceled, this reverts the BindingHandle back to its previous state so that the same operation can be tried again without corrupting the state.
    @param {BindingSession} session The session that was canceled.*/
    var rollBackStates = function (session)
    {
        if (EVUI.Modules.Core.Utils.hasFlag(session.bindingHandle.progressState, EVUI.Modules.Binding.BindingProgressStateFlags.Injected) === true) return; //can't roll back states after the binding operation is complete

        if (session.bindingHandle.oldState != null)
        {
            //restore the current state to be the old state
            session.bindingHandle.currentState = session.bindingHandle.oldState;
            session.bindingHandle.newStateBound = session.bindingHandle.oldStateBound;
        }

        //if there was an old state prior to the operation beginning, restore it as well
        if (session.rollbackState != null)
        {
            session.bindingHandle.oldState = session.rollbackState;
            session.bindingHandle.oldStateBound = true;
        }

        //if there was a pending state, restore that as well
        session.bindingHandle.pendingState = session.rollbackPendingState;

        //if we have passed the "got htmlContent" step, we have calculated the diffs for a re-bind and may not be able to detect those same diffs again.
        if (EVUI.Modules.Core.Utils.hasFlag(session.bindingHandle.progressState, EVUI.Modules.Binding.BindingProgressStateFlags.GotHtmlContent) === true && session.shouldReBind === true)
        {
            session.bindingHandle.canceledDuringReBind = true;
        }

        //the htmlContent was bound, which means we set the dispatch handles to their new values, so we need to restore them back to their original values.
        if (EVUI.Modules.Core.Utils.hasFlag(session.bindingHandle.progressState, EVUI.Modules.Binding.BindingProgressStateFlags.GotBoundProperties) === true)
        {
            var numCurHandles = session.bindingHandle.dispatchHandles.length;
            var numRollbackHandles = session.rollbackDispatchHandles.length;
            for (var x = 0; x < numRollbackHandles; x++)
            {
                var curHandle = session.rollbackDispatchHandles[x];

                //re-set the reference in the invocation dictionary so the old handler is called
                _invocationDictionary[curHandle.hashKey] = curHandle;

                //then go re-set the reference in the dispatch handles array
                for (var y = 0; y < numCurHandles; y++)
                {
                    var curExisting = session.bindingHandle.dispatchHandles[y];
                    if (curExisting.hashKey === curHandle.hashKey)
                    {
                        session.bindingHandle.dispatchHandles[y] = curHandle;
                        break;
                    }
                }
            }
        }
    };

    /**Executes the event stream backing the BindingSession, thus beginning the binding process.
    @param {BindingSession} session The BindingSession to execute. */
    var executeSession = function (session)
    {
        session.bindingHandle.progressState = EVUI.Modules.Binding.BindingProgressStateFlags.Queued; //set the status from idle to queued (the binding starts asynchronously)
        session.bindingHandle.completionState = EVUI.Modules.Binding.BindingCompletionState.Queued;

        session.bindingArgs.bindingTarget = getValidElement(session.bindingArgs.bindingTarget); //make sure we have a valid element to work with
        if (typeof session.bindingArgs.bindingTarget === "string") //if we have a CSS selector go find the element it's referring to.
        {
            var eh = null;
            if (session.bindingHandle.binding.parentBinding != null && session.bindingHandle.options.scopedCSSSelectors !== false) //if we're a child binding and are using scoped selectors, look inside the parent for the element
            {
                eh = new EVUI.Modules.Dom.DomHelper(session.bindingArgs.bindingTarget, session.bindingHandle.binding.parentBinding.boundContentFragment);
            }
            else //otherwise look in the whole document.
            {
                eh = new EVUI.Modules.Dom.DomHelper(session.bindingArgs.bindingTarget);
            }

            session.bindingArgs.bindingTarget = eh.elements[0];
        }

        //if we have no element to act as the binding target, set it to be a document fragment as a placeholder.
        //if (session.bindingArgs.bindingTarget == null) session.bindingArgs.bindingTarget = document.createDocumentFragment();

        //figure out if any sessions will race with this one to update the same binding or element
        var matchingSessions = getMatchingSessions(session);

        //cancel every existing session and move it's callback stack into the current binding (i.e. "last touch wins" rule, the last binding to use an element is the one that gets to go and the previous ones get canceled)
        var numMatches = matchingSessions.length;
        for (var x = 0; x < numMatches; x++)
        {
            var curMatch = matchingSessions[x];
            if (curMatch.session.cancel === false)
            {
                //move the callbacks from the old session into the new one which ensures that the bindings won't complete until the one that actually executes completes.
                session.callbacks = curMatch.session.callbacks.concat(session.callbacks);

                //flag the match as canceled (the next step will cancel it - we can't just cancel the event streams because it may have not started yet)
                curMatch.session.cancel = true;

                //remove the old callback stack
                curMatch.session.callbacks = [];
            }
        }

        //kick off the binding process
        session.eventStream.execute();
    };

    /**Builds the EventStream that will execute the BindingProcess
    @param {BindingSession} session The BindingSession to build the EventStream for.*/
    var buildEventStream = function (session)
    {
        session.eventStream = new EVUI.Modules.EventStream.EventStream();
        session.eventStream.eventState = session.context;
        session.eventStream.bubblingEvents = _bubblingEvents;
        session.eventStream.context = session.bindingHandle.binding;

        //set up the factory to create the biding event args
        session.eventStream.processInjectedEventArgs = function (eventStreamArgs)
        {
            var bindingArgs = new EVUI.Modules.Binding.BinderEventArgs(session);
            bindingArgs.cancel = eventStreamArgs.cancel;
            bindingArgs.context = eventStreamArgs.state;
            bindingArgs.key = eventStreamArgs.key;
            bindingArgs.pause = eventStreamArgs.pause;
            bindingArgs.resume = eventStreamArgs.resume;
            bindingArgs.stopPropagation = eventStreamArgs.stopPropagation;

            return bindingArgs;
        };

        //set up the handler that will ensure that any state set in the event args carries over between events
        session.eventStream.processReturnedEventArgs = function (eventStreamArgs)
        {
            session.eventStream.eventState = eventStreamArgs.context;
        };

        //make sure both cancel and error cancel all children if a parent fails and then fast-forward to the final callback execution/clean up step
        session.eventStream.onCancel = function (eventStreamArgs)
        {
            session.bindingHandle.completionState = EVUI.Modules.Binding.BindingCompletionState.Canceled;
            rollBackStates(session); //roll back to the previous completed state
            cancelAllChildren(session); //tell all children to cancel themselves on their next step
            session.eventStream.seek("finishBinding");
        };

        session.eventStream.onError = function (eventStreamArgs, ex)
        {
            session.bindingHandle.completionState = EVUI.Modules.Binding.BindingCompletionState.Failed;
            rollBackStates(session); //roll back to the previous completed state
            cancelAllChildren(session); //tell all children to cancel themselves on their next step
            session.eventStream.seek("finishBinding");
        };

        session.eventStream.onComplete = function (eventStreamArgs)
        {
            var batch = _batchLookup[session.batchId];

            batch.numComplete++;
            if (batch.numComplete >= batch.numSessions)
            {
                triggerNextBatch(batch);
            }
        }

        //add all the steps for the event stream to function
        addOnBindSteps(session);
        addOnSetHtmlContentSteps(session);
        addonSetBindingsSteps(session);
        addOnBindHtmlContentSteps(session);
        addOnBindChildrenSteps(session);
        addProcessChildrenSteps(session);
        addOnChildrenBoundSteps(session);
        addInjectMergeSteps(session);
        addFinalStep(session);
    };

    /**Triggers the onBind events and then performs the state swap that begins the binding process.
    @param {BindingSession} session The BindingSession being executed.*/
    var addOnBindSteps = function (session)
    {
        if (session.bindingHandle.currentState.parentBindingHandle != null && session.bindingHandle.currentState.parentBindingHandle.options.suppressChildEvents === true) //no child events, just fire the onBindJob step
        {
            session.eventStream.addJob(EVUI.Modules.Binding.Constants.Event_OnBind, "bindBegin", function (jobArgs)
            {
                onBindJob(session, jobArgs);
            });            
        }
        else
        {
            session.eventStream.addJob(EVUI.Modules.Binding.Constants.Event_OnBind, "bindBegin", function (jobArgs)
            {
                onBindJob(session, jobArgs);
            });

            //otherwise we do the first two events before modifying anything and the once those have passed we modify the state into 
            session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnBind, "onBind", function (eventArgs)
            {
                if (validateSession(session, eventArgs) === false) return;
                if (typeof session.bindingHandle.binding.onBind === "function")
                {
                    eventArgs.reBinding = session.bindingHandle.newStateBound; //we haven't swapped the states yet, so we set these to the values they would be after the swap.
                    if (eventArgs.reBinding === true)
                    {
                        eventArgs.originalContent = (session.bindingHandle.currentState != null && session.bindingHandle.currentState.boundContent != null) ? session.bindingHandle.currentState.boundContent.slice() : null;
                        eventArgs.originalSource = (session.bindingHandle.currentState != null) ? session.bindingHandle.currentState.source : null;
                    }

                    return session.bindingHandle.binding.onBind(eventArgs);
                }
            });

            session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnBind, "onBind", function (eventArgs)
            {
                if (validateSession(session, eventArgs) === false) return;

                if (typeof _self.onBind === "function")
                {
                    eventArgs.reBinding = session.bindingHandle.newStateBound; //we haven't swapped the states yet, so we set these to the values they would be after the swap.
                    if (eventArgs.reBinding === true)
                    {
                        eventArgs.originalContent = (session.bindingHandle.currentState != null && session.bindingHandle.currentState.boundContent != null) ? session.bindingHandle.currentState.boundContent.slice() : null;
                        eventArgs.originalSource = (session.bindingHandle.currentState != null) ? session.bindingHandle.currentState.source : null;
                    }

                    return _self.onBind(eventArgs);
                }
            });        


        }
    };

    /**Job that executes after the onBind events have been executed. Swaps out the current state and turns it into the old state while generating a new state to hold the data for the binding process going forward.
    @param {BindingSession} session The BindingSession being executed.
    @param {EVUI.Modules.EventStream.EventStreamJobArgs} jobArgs The JobArgs for the operation.*/
    var onBindJob = function (session, jobArgs)
    {
        if (session.cancel === true || session.bindingHandle.disposing === true) return jobArgs.cancel();

        //flip the states so that we have a new state to populate and that the current state becomes the old state.
        swapStates(session);

        if (validateSession(session, jobArgs) == false) return jobArgs.resolve();
        if (session.bindingHandle.currentState.source == null)
        {
            var parentPath = "Parent object path: " + ((EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(session.bindingHandle.currentState.parentBindingPath) === true) ? "root." : "root." + session.bindingHandle.currentState.parentBindingPath + ".");
            triggerDispose(session.bindingHandle);            

            return jobArgs.reject("Cannot bind a null reference. " + parentPath);
        }

        jobArgs.resolve();
    };

    /**Adds the steps that resolve the htmlContent used to perform the data binding operation.
    @param {BindingSession} session The BindingSession being executed.*/
    var addOnSetHtmlContentSteps = function (session)
    {
        //get the htmlContent so that it can be edited in the next steps
        session.eventStream.addJob(EVUI.Modules.Binding.Constants.Event_OnSetHtmlContent, "getHtmlContent", function (jobArgs)
        {
            onGetHtmlContent(session, jobArgs);
        });

        if (session.bindingHandle.currentState.parentBindingHandle != null && session.bindingHandle.currentState.parentBindingHandle.options.suppressChildEvents === true) return;

        session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnSetHtmlContent, "onSetHtmlContent", function (eventArgs)
        {
            if (validateSession(session, eventArgs) === false) return;
            if (typeof session.bindingHandle.binding.onSetHtmlContent === "function")
            {
                return session.bindingHandle.binding.onSetHtmlContent(eventArgs);
            }
        });

        session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnSetHtmlContent, "onSetHtmlContent", function (eventArgs)
        {
            if (validateSession(session, eventArgs) === false) return;

            if (typeof _self.onSetHtmlContent === "function")
            {
                return _self.onSetHtmlContent(eventArgs);
            }
        });        
    };

    /**Job that resolves ambiguous input into usable htmlContent that can be used for data binding.
    @param {BindingSession} session The BindingSession being executed.
    @param {EVUI.Modules.EventStream.EventStreamJobArgs} jobArgs The job arguments from the EventStream for this step.*/
    var onGetHtmlContent = function (session, jobArgs)
    {
        if (validateSession(session, jobArgs) == false) return jobArgs.resolve();

        //go get the htmlContent. This may be asynchronous if it involves a http call.
        getHtmlContent(session, function (htmlContent)
        {
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(htmlContent) === false) //we may not have a htmlContent yet, the user has the next two events to set the htmlContent before we fail due to the lack of a htmlContent
            {
                session.bindingHandle.currentState.htmlContent = htmlContent;
            }

            jobArgs.resolve();
        });
    }

    /**Adds the steps that execute once the html content has been obtained, these steps pull out the binding points from the html content and pair them to their values in the source object.
    @param {BindingSession} session The BindingSession being executed.*/
    var addonSetBindingsSteps = function (session)
    {
        session.eventStream.addJob(EVUI.Modules.Binding.Constants.Event_OnSetBindings, "getBindings", function (jobArgs)
        {
            onGetBindingsJob(session, jobArgs);
        });

        if (session.bindingHandle.currentState.parentBindingHandle != null && session.bindingHandle.currentState.parentBindingHandle.options.suppressChildEvents === true) return;

        session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnSetBindings, "onSetBindings", function (eventArgs)
        {
            if (validateSession(session, eventArgs) === false) return;
            if (typeof session.bindingHandle.binding.onSetBindings === "function")
            {
                return session.bindingHandle.binding.onSetBindings(eventArgs);
            }
        });

        session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnSetHtmlContent, "onSetBindings", function (eventArgs)
        {
            if (validateSession(session, eventArgs) === false) return;

            if (typeof _self.onSetBindings === "function")
            {
                return _self.onSetBindings(eventArgs);
            }
        });        
    };

    /**Optionally get the html content again if it was changed in the previous events, then checks to see if the Binding needs to be re-bound if this is not the first time it has been bound, then gets the bound tokens from the htmlContent and pairs them with their values from the source object if the Binding needs to be rebound.
    @param {BindingSession} session The BindingSession being executed.
    @param {EVUI.Modules.EventStream.EventStreamJobArgs} jobArgs The arguments for this job.*/
    var onGetBindingsJob = function (session, jobArgs)
    {
        if (validateSession(session, jobArgs) == false) return jobArgs.resolve();
        session.bindingHandle.progressState |= EVUI.Modules.Binding.BindingProgressStateFlags.GotHtmlContent;

        //if this is not the first time this Binding has been bound, go see if it has any changes that would necessitate doing the binding process over again.
        if (session.bindingHandle.oldStateBound === true)
        {
            session.shouldReBind = shouldReBind(session);
            if (session.shouldReBind === false) //not re-binding
            {
                //no old state, but the source objects match so we need to make a new ObjectObserver for the currentState
                if (session.bindingHandle.oldState.source === session.bindingHandle.currentState.source && session.bindingHandle.oldStateBound === false)
                {
                    session.bindingHandle.currentState.sourceObserver = getCurrentSourceObjectObserver(session); //new EVUI.Modules.Observers.ObjectObserver(session.bindingHandle.currentState.source);
                }
                else
                {
                    if (session.bindingHandle.oldState.source === session.bindingHandle.currentState.source)
                    {
                        session.bindingHandle.currentState.sourceObserver = session.bindingHandle.oldState.sourceObserver; //re-use the old observer if possible
                    }
                    else
                    {
                        session.bindingHandle.currentState.sourceObserver = getCurrentSourceObjectObserver(session); //new EVUI.Modules.Observers.ObjectObserver(session.bindingHandle.currentState.source); //otherwise make a new one for the new source
                    }
                }

                //make a copy of the bound properties since we're not calculating them again if we can
                if (session.bindingHandle.oldState.boundProperties != null)
                {
                    session.bindingHandle.currentState.boundProperties = session.bindingHandle.oldState.boundProperties.map(function (prop) { var newProp = new EVUI.Modules.Binding.BoundProperty(prop.path); newProp.value = prop.value; return newProp; });
                    session.originalBoundProps = session.bindingHandle.oldState.boundProperties;
                }

                return jobArgs.resolve();
            }
        }

        getBoundProperties(session, function (boundProps)
        {
            if (boundProps == null)
            {
                jobArgs.reject("Failed to get boundProperties due to a failure to get valid htmlContent.");
            }
            else
            {
                session.originalBoundProps = boundProps;

                //make a copy of the bound properties to attach that can be publicly edited by the user in the events that follow this one without disturbing the ones we just pulled out of the htmlContent and source
                session.bindingHandle.currentState.boundProperties = boundProps.map(function (boundProp)
                {
                    var prop = new EVUI.Modules.Binding.BoundProperty(boundProp.path);
                    prop.value = boundProp.value;

                    return prop;
                });

                jobArgs.resolve();
            }
        });
    };

    /**Adds the steps that full in the gaps in the htmlContent with values from the source object.
    @param {BindingSession} session The BindingSession being executed. */
    var addOnBindHtmlContentSteps = function (session)
    {
        session.eventStream.addJob(EVUI.Modules.Binding.Constants.Event_OnBindHtmlContent, "bindHtmlContent", function (jobArgs)
        {
            onBindHtmlContentJob(session, jobArgs);
        });

        if (session.bindingHandle.currentState.parentBindingHandle != null && session.bindingHandle.currentState.parentBindingHandle.options.suppressChildEvents === true) return;

        session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnBindHtmlContent, "onBindHtmlContent", function (eventArgs)
        {
            if (validateSession(session, eventArgs) === false) return;
            if (typeof session.bindingHandle.binding.onBindHtmlContent === "function")
            {
                return session.bindingHandle.binding.onBindHtmlContent(eventArgs);
            }
        });

        session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnBindHtmlContent, "onBindHtmlContent", function (eventArgs)
        {
            if (validateSession(session, eventArgs) === false) return;

            if (typeof _self.onBindHtmlContent === "function")
            {
                return _self.onBindHtmlContent(eventArgs);
            }
        });
    };

    /**Performs the mail-merge of the htmlContent with the boundProperties to produce the final mergedTemplate that will eventually be merged with the existing DOM content.
    @param {BindingSession} session The BindingSession being executed.
    @param {EVUI.Modules.EventStream.EventStreamJobArgs} jobArgs The job arguments for this step.*/
    var onBindHtmlContentJob = function (session, jobArgs)
    {
        if (validateSession(session, jobArgs) == false) return jobArgs.resolve();
        session.bindingHandle.progressState |= EVUI.Modules.Binding.BindingProgressStateFlags.GotBoundProperties;

        var isArray = isArrayMode(session);

        //check to see if the bound properties were changed in the previous events and then sync them with the bound object. IS THIS NEEDED? PROBABLY NOT
        //var propsChanged = areBoundPropsChanged(session.originalBoundProps, session.bindingHandle.binding.boundProperties);

        //if the object the properties are referencing changed, go get the new property values
        session.bindingHandle.currentState.boundProperties = syncBoundProperties2(session, isArray);

        if (isArray === false)
        {
            if (session.bindingHandle.oldStateBound === true /*&& propsChanged === false*/ && session.shouldReBind === false) //if not an array and we're not rebinding, just use the old content from the last run
            {
                session.bindingHandle.currentState.mergedHtmlContent = session.bindingHandle.oldState.mergedHtmlContent;
                session.bindingHandle.currentState.boundContentTree = session.bindingHandle.oldState.boundContentTree;
            }
            else //otherwise, go re-generate the merged template and make a DomTree out of it
            {
                var htmlContent = session.bindingHandle.htmlContent;
                if (htmlContent == null) htmlContent = session.bindingHandle.currentState.htmlContent;

                var contentMetadata = getHtmlContentMetadata(htmlContent);

                var mergedHtmlContent = duplicateHtmlContent(session, session.bindingHandle.currentState.htmlContent, session.bindingHandle.currentState.boundProperties, contentMetadata);
                session.bindingHandle.currentState.mergedHtmlContent = mergedHtmlContent;
                session.bindingHandle.currentState.boundContentTree = stringToDomTree(session, mergedHtmlContent, contentMetadata);
            }
        }
        else //if it is an array, we have less work to do, we don't do any actual merging for the top parent of the array.
        {
            if (session.bindingHandle.oldStateBound === true && session.shouldReBind === false) //if we aren't rebinding, just take the old state's content as the merged template and use its dummy tree as well
            {
                session.bindingHandle.currentState.mergedHtmlContent = session.bindingHandle.oldState.htmlContent;
                session.bindingHandle.currentState.boundContentTree = session.bindingHandle.oldState.boundContentTree;
            }
            else //otherwise we have no actual work to do, we just use the htmlContent as the merged htmlContent and we make a dummy tree out of a document fragment as a placeholder
            {
                session.bindingHandle.currentState.mergedHtmlContent = session.bindingHandle.currentState.htmlContent;
                session.bindingHandle.currentState.boundContentTree = _services.domTreeConverter.toDomTreeElement(document.createDocumentFragment());
            }
        }

        jobArgs.resolve();
    };

    /**Adds the steps that calculate which children to bind and generates a list of potential child bindings to create that the user then has a chance to edit.
    @param {BindingSession} session The BindingSession being executed.*/
    var addOnBindChildrenSteps = function (session)
    {
        session.eventStream.addJob(EVUI.Modules.Binding.Constants.Event_OnBindChildren, "bindChildren", function (jobArgs)
        {
            onBindChildrenJob(session, jobArgs);
        });

        if ((session.bindingHandle.currentState.parentBindingHandle != null && session.bindingHandle.currentState.parentBindingHandle.options.suppressChildEvents === true) || session.bindingHandle.options.recursive !== true) return;

        session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnBindChildren, "onBindChildren", function (eventArgs)
        {
            if (validateSession(session, eventArgs) === false) return;
            if (typeof session.bindingHandle.binding.onBindChildren === "function")
            {
                return session.bindingHandle.binding.onBindChildren(eventArgs);
            }
        });

        session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnBindChildren, "onBindChildren", function (eventArgs)
        {
            if (validateSession(session, eventArgs) === false) return;
            if (typeof _self.onBindChildren === "function")
            {
                return _self.onBindChildren(eventArgs);
            }
        });
    };

    /**Gets all the potential children that will be bound as child Bindings of the current Binding.
    @param {BindingSession} session The BindingSession being executed.
    @param {EVUI.Modules.EventStream.EventStreamJobArgs} jobArgs The job args for the step.*/
    var onBindChildrenJob = function (session, jobArgs)
    {
        if (validateSession(session, jobArgs) == false) return jobArgs.resolve();

        session.bindingHandle.progressState |= EVUI.Modules.Binding.BindingProgressStateFlags.BoundHtmlContent;

        //if we're not doing recursive bindings, don't execute the logic below
        if (session.bindingHandle.options.recursive !== true) return jobArgs.resolve();

        var arrayMode = isArrayMode(session);
        if (session.bindingHandle.oldStateBound === true && arrayMode === false) //if we're re-binding an object that is not an array, go recalculate the existing children with the new children from the boundContentTree or boundDocumentFragment.
        {
            reMapBoundChildren(session);
        }
        else
        {
            if (arrayMode === true)
            {
                if (session.bindingHandle.oldStateBound === false) //if we're binding a new array, go make a bindingHandle for each child entry
                {
                    session.bindingHandle.currentState.childBindingHandles = makeArrayChildren(session);
                }
                else //otherwise re-map the existing children onto new indexes if things were moved around or add new children to the end if the array grew
                {
                    reMapArrayChildren(session);
                }
            }
            else //otherwise it is a non-array thats has not been bound before, go look for any child bindings in the boundContentTree or boundDocumentFragment.
            {
                var boundChildren = getBoundChildren(session);
                session.bindingHandle.currentState.childBindingHandles = makeChildBindings(session, boundChildren);
            }
        }

        jobArgs.resolve();
    };

    /**Adds the step that takes the list of bound children from the previous job and events and then finalizes the list into the true list of childBindingHandles to evaluate.
    @param {BindingSession} session The BindingSession being executed.*/
    var addProcessChildrenSteps = function (session)
    {
        session.eventStream.addJob("evui.binder.process.children", "processChildren", function (jobArgs)
        {
            onProcessChildrenJob(session, jobArgs);
        });
    };

    /**The job where the child bindings made in the previous steps are finalized into childBindingHandles and are triggered to be updated or bound, depending on the BindingSession's sessionMode. 
    @param {BindingSession} session The session being executed.
    @param {EVUI.Modules.EventStream.EventStreamJobArgs} jobArgs The job args for this step.*/
    var onProcessChildrenJob = function (session, jobArgs)
    {
        if (validateSession(session, jobArgs) == false) return jobArgs.resolve();

        session.bindingHandle.progressState |= EVUI.Modules.Binding.BindingProgressStateFlags.GotChildren | EVUI.Modules.Binding.BindingProgressStateFlags.BindingChildren;

        //turn all of the entries made in the previous job and those modified/added/removed by the user into the true list of all child bindings for this binding
        var validChildren = validateChildBindings(session);
        var numValidChildren = validChildren.length;

        session.bindingHandle.currentState.childBindingHandles = validChildren;
        if (numValidChildren === 0) //no children, nothing to do, just return
        {
            return jobArgs.resolve();
        }

        if (session.sessionMode === BindingSessionMode.Update) //if updating, calculate which children changed and only trigger the binding process on those children.
        {
            var changedChildren = getChangedChildBindings(session);

            var numChanged = changedChildren.length;
            if (numChanged === 0) return jobArgs.resolve(); //no children were changed, nothing to do, just return.

            var childrenFinished = [];
            var commonCallback = function (session)
            {
                var numDone = childrenFinished.push(session);
                if (numDone === numChanged)
                {
                    return jobArgs.resolve();
                }
            };

            for (var x = 0; x < numChanged; x++) //trigger a job for each child and advance to the next step once they all have completed
            {
                triggerUpdate(changedChildren[x], null, session, function (childSession)
                {
                    commonCallback(childSession);
                });
            }
        }
        else //if we're not updating only the changed children, we're going to re-evaluate all the children
        {
            var childrenFinished = [];
            var commonCallback = function (session)
            {
                var numDone = childrenFinished.push(session);
                if (numDone === numValidChildren)
                {
                    return jobArgs.resolve();
                }
            };

            var numChildren = session.bindingHandle.currentState.childBindingHandles.length;
            for (var x = 0; x < numChildren; x++) //trigger a binding job for each child and continue to the next step once they have all completed.
            {
                triggerBind(session.bindingHandle.currentState.childBindingHandles[x], null, session, function (childSession)
                {
                    commonCallback(childSession);
                });
            }
        }
    };

    /**Events that fire once all child Bindings of this Binding are complete.
    @param {BindingSession} session The BindingSession being executed. */
    var addOnChildrenBoundSteps = function (session)
    {
        session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnBindChildren, "onChildrenBound", function (eventArgs)
        {
            session.bindingHandle.progressState |= EVUI.Modules.Binding.BindingProgressStateFlags.BoundChildren;
            if (validateSession(session, eventArgs) === false) return;
            if (session.bindingHandle.currentState.childBindingHandles.length === 0) return;
            if ((session.bindingHandle.currentState.parentBindingHandle != null && session.bindingHandle.currentState.parentBindingHandle.options.suppressChildEvents === true) || session.bindingHandle.options.recursive !== true) return;

            if (typeof session.bindingHandle.binding.onChildrenBound === "function")
            {
                return session.bindingHandle.binding.onChildrenBound(eventArgs);
            }
        });

        if ((session.bindingHandle.currentState.parentBindingHandle != null && session.bindingHandle.currentState.parentBindingHandle.options.suppressChildEvents === true) || session.bindingHandle.options.recursive !== true) return;

        session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnBindChildren, "onChildrenBound", function (eventArgs)
        {
            if (validateSession(session, eventArgs) === false) return;
            if (session.bindingHandle.currentState.childBindingHandles.length === 0) return;

            if (typeof _self.onChildrenBound === "function")
            {
                return _self.onChildrenBound(eventArgs);
            }
        });
    };

    /**Adds the steps that do the actual DOM Node manipulation to get the DOM in sync with the source's bound properties while doing as little DOM Node creation and manipulation possible.
    @param {BindingSession} session The BindingSession being executed.*/
    var addInjectMergeSteps = function (session)
    {
        session.eventStream.addJob(EVUI.Modules.Binding.Constants.Event_OnBound, "inject", function (jobArgs)
        {
            onInjectJob(session, jobArgs);
        });

        if (session.bindingHandle.currentState.parentBindingHandle != null && session.bindingHandle.currentState.parentBindingHandle.options.suppressChildEvents === true) return;

        session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnBound, "onBound", function (eventArgs)
        {
            if (session.cancel === true || session.bindingHandle.disposing === true) return eventArgs.cancel();
            if (typeof session.bindingHandle.binding.onBound === "function")
            {
                return session.bindingHandle.binding.onBound(eventArgs);
            }
        });

        session.eventStream.addEvent(EVUI.Modules.Binding.Constants.Event_OnBound, "onBound", function (eventArgs)
        {
            if (session.cancel === true || session.bindingHandle.disposing === true) return eventArgs.cancel();

            if (typeof _self.onBound === "function")
            {
                return _self.onBound(eventArgs);
            }
        });
    }

    /**The job that does the actual DOM manipulation required to make the required changes needed to get the DOM in sync with the source object.
    @param {BindingSession} session The BindingSession being executed.*/
    var onInjectJob = function (session, jobArgs)
    {
        if (validateSession(session, jobArgs) == false) return jobArgs.resolve();

        //DOM manipulation entry point
        injectContent(session);

        //make sure the boundContentTree's node references are removed since some of the nodes are now in the DOM and some are not.
        purgeDomTreeNodes(session.bindingHandle.currentState.boundContentTree);

        session.bindingHandle.progressState |= EVUI.Modules.Binding.BindingProgressStateFlags.Injected;
        session.bindingHandle.newStateBound = true;

        jobArgs.resolve();
    };

    /**Adds the final step in the process that calls all the related callbacks, sets the state back to idle, and cleans up any unneeded resources.
    @param {BindingSession} session The BindingSession being executed.*/
    var addFinalStep = function (session)
    {
        session.eventStream.addJob("finishBinding", "finishBinding", function (jobArgs)
        {
            onFinishBindingJob(session, jobArgs);
        });
    };

    /**Job that finishes the binding process by calling its callbacks and cleaning up whatever resources are no longer needed.
    @param {BindingSession} session The BindingSession being executed.
    @param {EVUI.Modules.EventStream.EventStreamJobArgs} jobArgs The job args for the step.*/
    var onFinishBindingJob = function (session, jobArgs)
    {
        var callbacks = [];

        //factory function that makes a callback function that calls the REAL callback function with the correct parameters (because the AsyncFunctionExecutor can only use one parameter when we will need a different parameter for each function).
        var addCallback = function (item)
        {
            var cb = function ()
            {
                //set it back to idle and dispose of it if it is flagged as needing to be disposed.
                item.session.bindingHandle.progressState = EVUI.Modules.Binding.BindingProgressStateFlags.Idle;
                if (item.session.bindingHandle.completionState === EVUI.Modules.Binding.BindingCompletionState.Executing) item.session.bindingHandle.completionState = EVUI.Modules.Binding.BindingCompletionState.Success;
                if (item.session.bindingHandle.disposing === true) disposeBinding(item.session.bindingHandle);

                //finally, call it's callback
                return item.callback(item.session.bindingHandle.binding);
            }

            callbacks.push(cb);
        };

        //sort the callbacks so that they are called in order of queuing
        session.callbacks.sort(function (a, b) { return a.id - b.id; });

        //make the modified wrapper function callbacks to use
        var numCallbacks = session.callbacks.length;
        for (var x = 0; x < numCallbacks; x++)
        {
            addCallback(session.callbacks[x]);
        }

        //if we had no callbacks, do the same cleanup for the current session as is in the callbacks. Sometimes a binding can get canceled twice and wind up in a state where it's progress flags don't reset.
        if (callbacks.length === 0)
        {
            session.bindingHandle.progressState = EVUI.Modules.Binding.BindingProgressStateFlags.Idle;
            if (session.bindingHandle.completionState === EVUI.Modules.Binding.BindingCompletionState.Executing) session.bindingHandle.completionState = EVUI.Modules.Binding.BindingCompletionState.Success;
            if (session.bindingHandle.disposing === true) disposeBinding(session.bindingHandle);

            postBindCleanUp(session);
            return jobArgs.resolve();
        }

        //execute all the callbacks in order.
        var exeArgs = new EVUI.Modules.Core.AsyncSequenceExecutionArgs();
        exeArgs.forceCompletion = true;
        exeArgs.functions = callbacks;

        EVUI.Modules.Core.AsyncSequenceExecutor.execute(exeArgs, function (error)
        {
            postBindCleanUp(session);
            jobArgs.resolve();
        });
    };

    /**Validates that the session has not been canceled or disposed of during its execution process.
    @param {BindingSession} session The BindingSession being executed.
    @returns {Boolean} */
    var validateSession = function (session, jobOrEventArgs)
    {
        var isWorking = session.eventStream.isWorking();
        if (session.cancel === true || session.bindingHandle.disposing === true)
        {
            if (session.bindingHandle.disposing === true) session.cancel = true;
            if (isWorking === true)
            {
                if (jobOrEventArgs != null)
                {
                    jobOrEventArgs.cancel();
                }
                else
                {
                    session.eventStream.cancel();
                }
            }

            return false;
        }

        //check the two failure cases that will either tank the browser (a circular reference) or cause erratic output (child moved from under parent)
        if (session.bindingHandle.currentState.parentBindingHandle != null)
        {
            if (isCircularChildReference(session) && isWorking === true)
            {
                throw Error("Child Binding's source was a circular reference to one of its parent Binding's sources.");
            }
            //else if (isChildElementUnderParent(session) === false && isWorking === true) //caused more problems than it solved
            //{
            //    throw Error("Child Binding's element was no longer contained by the root parent's boundContentFragment.")
            //}
        }

        return true;
    };

    /**Recursively sets the canceled flag on all of a BindingSession's child BindingSessions.
    @param {BindingSession} session The BindingSession being executed.*/
    var cancelAllChildren = function (session)
    {
        var numChildren = session.childSessions;
        for (var x = 0; x < numChildren; x++)
        {
            var curChild = session.childSessions[x];
            curChild.cancel = true;

            if (curChild.childSessions.length > 0)
            {
                cancelAllChildren(curChild);
            }
        }
    };

    /**Clean up of old resources that are no longer needed after the current state has been bound.
    @param {BindingSession} session The BindingSession that has finished executing.*/
    var postBindCleanUp = function (session)
    {
        //don't clear anything if the session was canceled - it will roll back to the previous good state and the data below will still be needed if present.
        if (session.cancel === true) return;

        //clear the old and pending states as they are never used again
        session.bindingHandle.oldState = null;
        session.bindingHandle.pendingState = null;

        //null out the boundContentFragment as it is now empty. If this doesn't happen, the empty version is re-used and re-bindings don't work.
        session.bindingHandle.currentState.boundContentFragment = null;
    };

    /*****************************************************************************************INJECTION***************************************************************************/

    /**Injects or merges new content into the DOM.
    @param {BindingSession} session The BindingSesion being executed.*/
    var injectContent = function (session)
    {
        var insertionMode = session.bindingHandle.binding.insertionMode;
        var bindingMode = session.bindingHandle.binding.bindingMode;

        if (bindingMode === EVUI.Modules.Binding.BindingMode.Merge) //if merging content, we will attempt to preserve any DOM nodes possible
        {
            if (session.bindingHandle.oldStateBound === true) //old state is already in the DOM, so we may need to update what's already there
            {
                if (session.shouldReBind === true) //we do need to update what's already there - merge the new content into the old and keep the old content's element reference.
                {
                    mergeContent(session);

                    if (EVUI.Modules.Core.Utils.isOrphanedNode(session.bindingHandle.oldState.element) === false)
                    {
                        session.bindingHandle.currentState.element = session.bindingHandle.oldState.element;
                    }
                }
                else //we don't need to update anything
                {
                    if (session.bindingHandle.currentState.childBindingHandles.length === 0) //no children to update, which means nothing changed. Just use the old references for content
                    {
                        session.bindingHandle.currentState.boundContent = session.bindingHandle.oldState.boundContent.slice();
                    }
                    else
                    {
                        if (session.isArray === true) //go make sure that if any of the array children beneath this one changed that this Binding's boundContent list includes all the children and make sure that the children correctly refer to each other in a linked-list fashion
                        {
                            session.bindingHandle.currentState.boundContent = reAssignArrayElementReferences2(session);
                        }
                        else //re-use the old boundContent as nothing changed on this level.
                        {
                            session.bindingHandle.currentState.boundContent = session.bindingHandle.oldState.boundContent.slice();
                        }
                    }

                    if (EVUI.Modules.Core.Utils.isOrphanedNode(session.bindingHandle.oldState.element) === false)
                    {
                        //always point it back at the old element as the "new" reference point as it was not changed.
                        session.bindingHandle.currentState.element = session.bindingHandle.oldState.element;
                    }
                }
            }
            else //old state was not bound, inserting new content and blowing away any old content if it's there
            {
                if (session.isArray === true) //arrays never are injected directly but are rather a wrapper for their children, so we have nothing to do for the actual array. Just make sure its boundContent list is correct and the children's relationships to each other is correct.
                {
                    session.bindingHandle.currentState.boundContent = reAssignArrayElementReferences2(session);
                }
                else //we have an object to inject that is not an array, add it's contents to the DOM.
                {
                    //if the bound htmlContent fragment has never been created, we need to make it now to inject the whole set of DOM nodes at once.
                    if (session.bindingHandle.currentState.boundContentFragment == null) session.bindingHandle.currentState.boundContentFragment = toDomNode(session.bindingHandle.currentState.boundContentTree); //session.bindingHandle.currentState.boundContentTree.toNode();

                    //grab the child node references BEFORE insertion since the document fragment will be empty once its children are in the DOM.
                    var nodeChildren = getNodeListFromFragment(session.bindingHandle.currentState.boundContentFragment);

                    //if we have no element reference (this is usually the case with a child binding that is an array member), insert the child into the content tree and give it a reference element.
                    if (session.bindingHandle.currentState.element == null)
                    {
                        insertMissingNode2(session, session.bindingHandle.currentState.boundContentFragment);
                    }
                    else //otherwise, just inject the content as it would be normall.y
                    {
                        injectNode(session, insertionMode, session.bindingHandle.currentState.element, session.bindingHandle.currentState.boundContentFragment);
                    }

                    session.bindingHandle.currentState.boundContent = nodeChildren;
                }
            }
        }
        else if (bindingMode === EVUI.Modules.Binding.BindingMode.Overwrite) //overwriting existing content. Since this is a recursive setting, the children will have taken care of updating their own nodes and we just have to worry about the parent nodes.
        {
            if (session.isArray === true) //arrays never are injected directly but are rather a wrapper for their children, so we have nothing to do for the actual array. Just make sure its boundContent list is correct and the children's relationships to each other is correct.
            {
                session.bindingHandle.currentState.boundContent = reAssignArrayElementReferences2(session);
            }
            else //we have an object to inject that is not an array, add it's contents to the DOM.
            {
                //if the old state was bound and we have children, we need to do another merge - this is because the children are already merged into the DOM and simply removing the old content and inserting the current content will disconnect all the children.
                if (session.bindingHandle.oldStateBound === true && session.bindingHandle.currentState.childBindingHandles.length > 0)
                {
                    mergeContent(session);
                }
                else
                {
                    //if the bound htmlContent fragment has never been created, we need to make it now to inject the whole set of DOM nodes at once.
                    if (session.bindingHandle.currentState.boundContentFragment == null) session.bindingHandle.currentState.boundContentFragment = session.bindingHandle.currentState.boundContentTree.toNode();

                    //grab the child node references BEFORE insertion since the document fragment will be empty once its children are in the DOM.
                    var nodeChildren = getNodeListFromFragment(session.bindingHandle.currentState.boundContentFragment);

                    //if we have no element reference (this is usually the case with a child binding that is an array member), insert the child into the content tree and give it a reference element.
                    if (session.bindingHandle.currentState.element == null)
                    {
                        insertMissingNode2(session, session.bindingHandle.currentState.boundContentFragment);
                    }
                    else //otherwise, just inject the content as it would be normall.y
                    {
                        injectNode(session, insertionMode, session.bindingHandle.currentState.element, session.bindingHandle.currentState.boundContentFragment);
                    }

                    session.bindingHandle.currentState.boundContent = nodeChildren;
                }
            }
        }
        else //garbage input, crash.
        {
            throw Error("Unrecognized bindingMode: \"" + bindingMode + "\".");
        }

        //finally after all the content changes have been made, clean up everything that no longer should be there.
        cleanUpOldNodes2(session);
    };

    /**Injects a Node relative to another Node.
    @param {BindingSession} session The BindingSession being executed.
    @param {String} insertionMode A value from the EVUI.Modules.Binding.BindingInsertionMode enum indicating how to insert the Node relative to its other node.
    @param {Node} referenceEle The reference element to insert the node relative to.
    @param {Node} node The node to inject.*/
    var injectNode = function (session, insertionMode, referenceEle, node)
    {
        var lastNode = (node.childNodes.length > 0) ? node.lastChild : node;
        session.lastInsertedNode = lastNode;

        switch (insertionMode)
        {
            case EVUI.Modules.Binding.BindingInsertionMode.Append:
            case EVUI.Modules.Binding.BindingInsertionMode.Default:
                referenceEle.append(node);
                break;

            case EVUI.Modules.Binding.BindingInsertionMode.Prepend:
                referenceEle.prepend(node);
                break;

            case EVUI.Modules.Binding.BindingInsertionMode.Fragment:
                referenceEle.append(node);
                return;

            case EVUI.Modules.Binding.BindingInsertionMode.InsertAfter:
                referenceEle.after(node);
                break;

            case EVUI.Modules.Binding.BindingInsertionMode.InsertBefore:
                referenceEle.before(node);
                break;

            case EVUI.Modules.Binding.BindingInsertionMode.ReplaceChildren:
                referenceEle.innerHTML = null;
                referenceEle.append(node);
                break;

            case EVUI.Modules.Binding.BindingInsertionMode.Shadow:
                var shadow = sparentNode.shadowRoot;
                if (shadow == null) shadow = sparentNode.attachShadow({ mode: "open" });
                shadow.append(node);
                break;

            default:
                throw Error("Invalid insertionMode: \"" + insertionMode + "\"");
        }
    };

    /**Merges an old set of Nodes with a new set of Nodes to update the DOM to be in sync with the latest changes made to the Html derived from the source object and the htmlContent of the Binding.
    @param {BindingSession} session The session being executed.*/
    var mergeContent = function (session)
    {
        if (session.isArray === false) //if the session is not an array, merge all the contents with the existing contents.
        {
            var newContentTrees = null;

            //if we have a document fragment it means the user accessed the boundContentFragment from the Binding and caused it to be generated based on the boundContentTree. In this case we need to go scoop up whatever they changed and re-create the trees instead of using the DomTrees we already made.
            if (session.bindingHandle.currentState.boundContentFragment != null) 
            {
                var numChildren = session.bindingHandle.currentState.boundContentFragment.childNodes.length;
                newContentTrees = [];

                for (var x = 0; x < numChildren; x++)
                {
                    newContentTrees.push(_services.domTreeConverter.toDomTreeElement(session.bindingHandle.currentState.boundContentFragment.childNodes[x], { includeNodeReferences: true }));
                }
            }
            else //otherwise we just use the pre-existing trees.
            {
                newContentTrees = session.bindingHandle.currentState.boundContentTree.content.slice();
            }

            //merging content only applies to content that has been changed rather than has been replaced with a new object
            var existingContentTrees = [];
            if (session.bindingHandle.oldState != null && session.bindingHandle.oldState.boundContent != null && session.bindingHandle.oldState.source === session.bindingHandle.currentState.source)
            {
                var numCurContent = session.bindingHandle.oldState.boundContent.length;
                for (var x = 0; x < numCurContent; x++)
                {
                    var curContent = session.bindingHandle.oldState.boundContent[x];
                    if (EVUI.Modules.Core.Utils.isOrphanedNode(curContent) === true) continue;

                    existingContentTrees.push(_services.domTreeConverter.toDomTreeElement(curContent, { includeNodeReferences: true }));
                }

                if (session.bindingHandle.oldState.childBindingHandles.length > 0)
                {
                    removeOldChildTrees(session, existingContentTrees, newContentTrees);
                }
            }

            var numNewContent = newContentTrees.length;

            if (EVUI.Modules.DomTree.DomTreeElement[EVUI.Modules.Core.Constants.Symbol_ObjectProperties] == null)
            {
                EVUI.Modules.Core.Utils.cacheProperties(new EVUI.Modules.DomTree.DomTreeElement());
                EVUI.Modules.Core.Utils.cacheProperties(new EVUI.Modules.DomTree.DomTreeElementAttribute());
            }

            //diff the existing content with the new content to get the list of everything that is different in the markup of the two trees.
            var diff = _services.diffController.compare(existingContentTrees, newContentTrees, { compareValuesOnly: true });

            //process the diff and make any required changes to the DOM to bring things back in sync
            processDiffs(session, diff);

            var final = [];
            //once that is done, we walk all the child comparisons of the root comparison (which will be the top-level nodes that were changed) and assign the nodes that are there and attached to the final bound content list. We may not know which tree's nodes were used as they were merged together, so we check for both. 
            for (var x = 0; x < numNewContent; x++)
            {
                var contentDiff = diff.rootComparison.childComparisons[x];
                if (contentDiff.a != null && contentDiff.a.node != null && contentDiff.a.node.isConnected === true)
                {
                    final.push(contentDiff.a.node);
                }
                else if (contentDiff.b != null && contentDiff.b.node != null && (contentDiff.b.node.isConnected === true || contentDiff.a == null))
                {
                    final.push(contentDiff.b.node);
                }
            }

            session.bindingHandle.currentState.boundContent = final;
        }
        else //if the session was an array we never do any actual merging for the real array, we just roll up the nodes that were made instead and make sure the "linked list" of Binding-to-element relationships are correct.
        {
            session.bindingHandle.currentState.boundContent = reAssignArrayElementReferences2(session);
        }
    };

    /**Removes any sub-trees from the DomTreeElement trees used for doing the main diff comparison in the context of a multi-level recursive binding scenario.
    @param {BindingSession} session
    @param {EVUI.Modules.DomTree.DomTreeElement[]} existingContentTrees
    @param {EVUI.Modules.DomTree.DomTreeElement[]} newContentTrees*/
    var removeOldChildTrees = function (session, existingContentTrees, newContentTrees)
    {
        var aggregateOldTree = new EVUI.Modules.DomTree.DomTreeElement();
        aggregateOldTree.content = existingContentTrees;

        var aggregateNewTree = new EVUI.Modules.DomTree.DomTreeElement();
        aggregateNewTree.content = newContentTrees;

        var oldParentPaths = [];
        var newParentPaths = [];
        var contentRemoverPathDic = {};
        var contentRemovers = [];

        //go make a list of all the trees that had their content added outside of their element reference, they will need to have their boundContent removed explicitly. Otherwise we can just replace the contents of the element with its current contents to get it in sync with this hierarchical level of the binding.
        var numChildren = session.bindingHandle.oldState.childBindingHandles.length;
        for (var x = 0; x < numChildren; x++)
        {
            var childHandle = session.bindingHandle.oldState.childBindingHandles[x];
            oldParentPaths.push(childHandle.currentState.parentBindingPath);

            if (childHandle.binding.insertionMode === EVUI.Modules.Binding.BindingInsertionMode.InsertAfter ||
                childHandle.binding.insertionMode === EVUI.Modules.Binding.BindingInsertionMode.InsertBefore)
            {
                if (childHandle.oldState != null)
                {
                    contentRemoverPathDic[childHandle.currentState.parentBindingPath] = true;
                    contentRemovers.push(childHandle);
                }
            }
        }

        //also, for both, make a list of all the parent binding paths so we can go find their respective DomTrees
        var numChildren = session.bindingHandle.currentState.childBindingHandles.length;
        for (var x = 0; x < numChildren; x++)
        {
            var childHandle = session.bindingHandle.currentState.childBindingHandles[x];
            newParentPaths.push(childHandle.currentState.parentBindingPath);
        }

        //find the trees that serve as the reference elements for both the old and new content sets
        var matchingOldTrees = getMatchingChildTreesByPath(session, aggregateOldTree, oldParentPaths);
        var matchingNewTrees = getMatchingChildTreesByPath(session, aggregateNewTree, newParentPaths);

        var numRemovers = contentRemovers.length;
        var numOld = matchingOldTrees.length;
        var numNew = matchingNewTrees.length;

        //since we need to amend the old content tree, we walk the list of all the old content and edit each part needing changing
        for (var x = 0; x < numOld; x++)
        {
            var curOld = matchingOldTrees[x];
            var remover = contentRemoverPathDic[curOld.path];
            if (remover === true) //we have an "insert after" or "insert before" style binding, so we need to remove its content from the old content tree for it to match the new one
            {
                var matchingBinding = null;
                for (var y = 0; y < numRemovers; y++)
                {
                    var curRemover = contentRemovers[y];
                    if (curRemover.oldState.parentBindingPath === curOld.path)
                    {
                        matchingBinding = curRemover;
                        contentRemovers.splice(y, 1);
                        numRemovers--;
                        break;
                    }
                }

                //either no binding or no content, continue to the next
                if (matchingBinding == null || matchingBinding.oldState.boundContent == null) continue;
                var numContent = matchingBinding.oldState.boundContent.length;

                //for every piece of content, go find the parent of it's node reference and remove the whole node from the content list
                for (var y = 0; y < numContent; y++)
                {
                    var curBoundContent = matchingBinding.oldState.boundContent[y];
                    aggregateOldTree.search(function (ele)
                    {
                        if (EVUI.Modules.Core.Utils.isArray(ele.content) === true)
                        {
                            var numContent = ele.content;
                            for (var z = 0; z < numContent; z++)
                            {
                                var curContent = ele.content[z];
                                if (curContent.node === curBoundContent)
                                {
                                    ele.content.splice(z, 1);
                                    return true;
                                }
                            }
                        }
                    }, true);
                }
            }
            else //otherwise it was a piece of content that was inserted as children to another element, so we clone the matching element and simply swap out the content with the clone to get things in sync
            {
                for (var y = 0; y < numNew; y++)
                {
                    var curNew = matchingNewTrees[y];
                    if (curNew.path === curOld.path)
                    {
                        found = true;
                        var newClone = curNew.tree.clone();
                        curOld.tree.content = newClone.content;
                        curOld.tree.shadow = newClone.shadow;

                        matchingNewTrees.splice(y, 1);
                        numNew--;

                        break;
                    }
                }
            }
        }
    };

    /**
     * 
     * @param {BindingSession} session
     * @param {EVUI.Modules.DomTree.DomTreeElement} aggregateTree
     * @param {String[]} parentPaths
     */
    var getMatchingChildTreesByPath = function (session, aggregateTree, parentPaths)
    {
        var treeKeyPairs = [];

        var results = aggregateTree.search(function (elementTree)
        {
            if (elementTree.attrs == null) return;
            var numAttrs = elementTree.attrs.length;

            for (var x = 0; x < numAttrs; x++)
            {
                var curAttr = elementTree.attrs[x];
                if (curAttr.key !== EVUI.Modules.Binding.Constants.Attr_BoundObj) continue;

                if (parentPaths.indexOf(curAttr.val) !== -1)
                {
                    treeKeyPairs.push({ path: curAttr.val, tree: elementTree });
                    return true;
                }
                else
                {
                    return false;
                }
            }
        });

        return treeKeyPairs;
    };

    /**Re-assigns all of the boundContent of the array's parent to be the combined content of all of its child Bindings and ensures that each array child's element references the last piece of content from the array child that comes directly before it, except for the first node which always references the parent Binding's element as its own element.
    @param {BindingSession} session The BindingSession being executed.
    @returns {Node[]} */
    var reAssignArrayElementReferences2 = function (session)
    {
        var final = [];

        //some wacky cleanup for arrays. When the array list is re-assigned, all the elements get set to null, so we need to go re-assign each binding's element to the last content in the previous binding's bound content list.
        var previousNoEle = false;
        var previousHandle = null;
        var lastContent = null;
        var numChildren = session.bindingHandle.currentState.childBindingHandles.length;
        for (var x = 0; x < numChildren; x++)
        {
            var curHandle = session.bindingHandle.currentState.childBindingHandles[x];

            var noEle = curHandle.currentState.element == null || curHandle.currentState.element.isConnected === false || curHandle.currentState.element === session.bindingHandle.currentState.element; //if it's null, disconnected, or the parent's element (which it can be if the sequence of children went out of order due to async delays)

            if (x === 0 && noEle === true) //if we're the first element in the array, the reference element is always the parent session's element.
            {
                curHandle.currentState.element = session.bindingHandle.currentState.element;
                noEle = false;
            }
            else if (previousNoEle === true && previousHandle != null) //if the previous handle had no element, assign it to the last content of the current element's bound content list.
            {
                previousHandle.currentState.element = lastContent;
            }
            else if (noEle === false && x > 0)
            {
                var previous = session.bindingHandle.currentState.childBindingHandles[x - 1];
                if (curHandle.currentState.element !== previous.currentState.boundContent[previous.currentState.boundContent.length - 1]) //if the element does not reference the previous binding's last content as its content, it needs to be reset.
                {
                    noEle = true;
                }
            }

            if (curHandle.currentState.boundContent != null)
            {
                var numContent = curHandle.currentState.boundContent.length;
                for (var y = 0; y < numContent; y++)
                {
                    var curContent = curHandle.currentState.boundContent[y];
                    final.push(curContent);
                }

                lastContent = curContent;
            }

            if (x === numChildren - 1 && noEle === true) //if we're the last child in the array, we need to reference the last content from the last binding as the reference element as the loop above won't assign it.
            {
                curHandle.element = lastContent;
            }

            previousNoEle = noEle;
            previousHandle = curHandle;
        }

        return final;
    };


    /**Gets an array of Nodes from a DocumentFragment. Exists because Array.from is mysteriously slower than the for loop equivalent.
    @param {DocumentFragment} documentFragment
    @returns {Node[]} */
    var getNodeListFromFragment = function (documentFragment)
    {
        var nodeList = [];
        if (documentFragment == null) return nodeList;

        var numNodes = documentFragment.childNodes.length;
        for (var x = 0; x < numNodes; x++)
        {
            nodeList.push(documentFragment.childNodes[x]);
        }

        return nodeList;
    };

    /**Cleans up all existing Bindings that have been removed from their parent Binding and disposes of them. Both clears the DOM and prevents memory leaks.
    @param {BindingSession} session The BindingSession being executed.*/
    var cleanUpOldNodes = function (session)
    {
        if (session.bindingHandle.oldStateBound === false) return; //no old state to clean up

        var oldChildBindings = session.bindingHandle.oldState.childBindingHandles.slice();
        var numOldBindings = oldChildBindings.length;

        if (session.observedDifferences == null) return; //no detected differences between old and new states, so there is nothing that changed and needs to be removed

        if (EVUI.Modules.Core.Utils.isArray(session.observedDifferences) === true) //the diff is an array of ObservedChangedProperty, walk each one and find all the bindings that were removed and dispose of them.
        {
            if (numOldBindings === 0) return; //no bindings to remove

            var numObservedDiffs = session.observedDifferences.length;
            for (var x = 0; x < numObservedDiffs; x++)
            {
                var curDiff = session.observedDifferences[x];
                if (curDiff.type !== EVUI.Modules.Observers.ObservedObjectChangeType.Removed) continue;

                for (var y = 0; y < numOldBindings; y++)
                {
                    var curOldBinding = oldChildBindings[y];
                    if (curOldBinding.currentState.source !== curDiff.originalValue) continue;
                    if (curOldBinding.currentState.parentBindingKey !== curDiff.name) continue;

                    oldChildBindings.splice(y, 1);
                    numOldBindings--;

                    triggerDispose(curOldBinding);
                    break;
                }
            }
        }
        else //otherwise we diff two different objects from each other
        {
            var numDiffs = session.observedDifferences.rootComparison.differences.length;

            if (numOldBindings === 0) //if we had no old bindings but compared two different objects there is some potential clean up to be done
            {
                var inBoth = false;

                for (var x = 0; x < numDiffs; x++) //walk all the differences and see if there are any properties that are in one object and not the other
                {
                    var curDiff = session.observedDifferences.rootComparison.differences[x];
                    if (EVUI.Modules.Core.Utils.hasFlag(curDiff.flags, EVUI.Modules.Diff.DiffFlags.AOnly) === false && EVUI.Modules.Core.Utils.hasFlag(curDiff.flags, EVUI.Modules.Diff.DiffFlags.BOnly) === false)
                    {
                        inBoth = true;
                        break;
                    }
                }

                if (inBoth === false) //if there was nothing in common between the two objects, we can safely remove the old content - but NOT dispose of it because that would kill the current binding.
                {
                    var numOldBoundContent = session.bindingHandle.oldState.boundContent.length;
                    for (var x = 0; x < numOldBoundContent; x++)
                    {
                        var curContent = session.bindingHandle.oldState.boundContent[x];
                        curContent.remove();
                    }
                }

                return;
            }


            for (var x = 0; x < numDiffs; x++)
            {
                var curDiff = session.observedDifferences.rootComparison.differences[x];
                if (curDiff.a == null && curDiff.b != null && typeof curDiff.b !== "object") continue;
                if (EVUI.Modules.Core.Utils.hasFlag(curDiff.flags, EVUI.Modules.Diff.DiffFlags.AOnly) === true) continue; //anything that's in A gets to stay, things that are only in B get removed.

                for (var y = 0; y < numOldBindings; y++)
                {
                    var curOldBinding = oldChildBindings[y];
                    if (curOldBinding.currentState.source !== curDiff.b) continue;
                    oldChildBindings.splice(y, 1);
                    numOldBindings--;

                    triggerDispose(curOldBinding);
                    break;
                }
            }
        }
    }

    /**Cleans up all existing Bindings that have been removed from their parent Binding and disposes of them. Both clears the DOM and prevents memory leaks.
    @param {BindingSession} session The BindingSession being executed.*/
    var cleanUpOldNodes2 = function (session)
    {
        //no old state, no references to nodes to clean up
        if (session.bindingHandle.oldState == null) return;

        if (session.bindingHandle.oldStateBound === false) //if we have an old state that wasn't bound, this means we have a new binding at the same path as an old binding, but with a different source object, so we need to remove the old nodes
        {
            if (session.bindingHandle.oldState.source !== session.bindingHandle.currentState.source && session.bindingHandle.oldState.boundContent != null)
            {
                var numOld = session.bindingHandle.oldState.boundContent.length;
                for (var x = 0; x < numOld; x++)
                {
                    session.bindingHandle.oldState.boundContent[x].remove();
                }
            }

            return;
        }

        //otherwise, we have a re-bound object who potentially has two sets of nodes
        var oldHandles = session.bindingHandle.oldState.childBindingHandles.slice();
        var newHandleDic = makeChangeDictionary(session, session.bindingHandle.currentState.childBindingHandles);

        var numOldChildren = session.bindingHandle.oldState.childBindingHandles.length;

        for (var x = 0; x < numOldChildren; x++)
        {
            var curOldHandle = oldHandles[x];
            var matchingBinding = newHandleDic[curOldHandle.currentState.normalizedPath];

            if (matchingBinding == null)
            {
                triggerDispose(curOldHandle);
                continue;
            }
        }

        if (session.bindingHandle.currentState.source === session.bindingHandle.oldState.source) return;

        var numDiffs = session.observedDifferences.rootComparison.differences.length;
        if (numOldChildren === 0) //if we had no old bindings but had two different objects there is some clean up to be done as the new object's nodes replaced the old object's nodes
        {

            var numOldBoundContent = session.bindingHandle.oldState.boundContent.length;
            for (var x = 0; x < numOldBoundContent; x++)
            {
                var curContent = session.bindingHandle.oldState.boundContent[x];
                curContent.remove();
            }

            return;
        }
    };

    /**Processes the diff result between the old and new DomTreeElement hierarchies.
    @param {BindingSession} session The BindingSession being executed.
    @param {EVUI.Modules.Diff.CompareResult} diff The diff result between the two tree hierarchies.*/
    var processDiffs = function (session, diff)
    {
        var numDifferences = diff.rootComparison.differences.length;
        for (var x = 0; x < numDifferences; x++)
        {
            var curDiff = diff.rootComparison.differences[x];
            var aIsTree = isDomTreeElement(curDiff.a);
            var bIsTree = isDomTreeElement(curDiff.b);
            var aIsArray = (aIsTree === false) ? EVUI.Modules.Core.Utils.isArray(curDiff.a) : false;
            var bIsArray = (bIsTree === false) ? EVUI.Modules.Core.Utils.isArray(curDiff.b) : false;
            if (aIsTree === false && bIsTree === false && aIsArray === false && bIsArray === false) continue; //we only care about arrays and trees (an array can be an array of attributes or trees)

            if (aIsTree === true || bIsTree === true)
            {
                processTreeDiff(session, diff, curDiff);
            }
            else if (aIsArray === true || bIsArray === true)
            {
                processArrayDiff(session, diff, curDiff, 0);
            }
        }
    };

    /**Either gets a new ObjectObserver or extracts one from the parentBindingHandle's ObjectObserver.
    @param {BindingSession} session The BindingSession being executed.
    @returns {EVUI.Modules.Observers.ObjectObserver} */
    var getCurrentSourceObjectObserver = function (session)
    {
        if (session.bindingHandle.currentState.parentBindingHandle != null && session.bindingHandle.currentState.parentBindingHandle.currentState.sourceObserver != null)
        {
            var child = session.bindingHandle.currentState.parentBindingHandle.currentState.sourceObserver.getChildObserver(session.bindingHandle.currentState.parentBindingKey, true);
            if (child != null) return child;
        }

        return new EVUI.Modules.Observers.ObjectObserver(session.bindingHandle.currentState.source);
    };

    /**Processes a diff that is a diff between two arrays of DomTreeElements.
    @param {BindingSession} session The BindingSession being executed.
    @param {EVUI.Modules.Diff.CompareResult} diffResult The diff result from comparing the two DomTreeElement hierarchies.
    @param {EVUI.Modules.Diff.Comparison} arrayDiff The current diff that contains the arrays to compare.*/
    var processArrayDiff = function (session, diffResult, arrayDiff)
    {
        var numArrayDiffs = arrayDiff.differences.length;
        for (var x = 0; x < numArrayDiffs; x++)
        {
            var curDiff = arrayDiff.differences[x];
            if (curDiff.diffType !== EVUI.Modules.Diff.DiffType.String && curDiff.parentComparison != null && curDiff.parentComparison.propName !== "content") continue;
            processTreeDiff(session, diffResult, curDiff);
        }
    }

    /**Processes a diff that is between two DomTreeElements. Lazily merges and creates nodes as they are needed and always attempts to re-use whatever nodes can be reused.
    @param {BindingSession} session The BindingSession being executed.
    @param {EVUI.Modules.Diff.CompareResult} diffResult The diff result from comparing the two DomTreeElement hierarchies.
    @param {EVUI.Modules.Diff.Comparison} treeDiff The current diff that contains the DomTreeElements */
    var processTreeDiff = function (session, diffResult, treeDiff)
    {
        var numTreeDiffs = treeDiff.differences.length;
        var tagDiff = null;
        var contentDiff = null;
        var attributeDiff = null;
        var shadowDiff = null;

        var diffA = treeDiff.a;
        var diffB = treeDiff.b;

        var aType = (diffA == null) ? null : typeof diffA;
        var bType = (diffB == null) ? null : typeof diffB;

        if (aType === "string" && bType === "string") //replacing string contents
        {
            var parentNode = getParentNodeDiff(session, treeDiff);

            if (session.bindingHandle.binding.bindingMode === EVUI.Modules.Binding.BindingMode.Overwrite) //overwriting, replace the text node
            {
                parent.a.node.replaceWith(toDomNode(parentNode.b)); //parentNode.b.toNode());
            }
            else //otherwise just update it's text content
            {
                parentNode.a.node.textContent = parentNode.b.content;
            }
        }
        else if (aType === "string" || bType === "string") //either replacing a string node with an element or vice-versa
        {
            var parentNode = getParentNodeDiff(session, treeDiff);
            var aTarget = parentNode.a.node;
            var bTarget = parentNode.b.node;

            if (aType === "string") //current is a string
            {
                if (bType === "object") //new is a node
                {
                    if (bTarget == null) bTarget = toDomNode(parentNode.b); //parentNode.b.toNode(); //lazily create the node
                    if (isDomTreeElement(diffB) === true)
                    {
                        aTarget.replaceWith(bTarget);
                    }
                    else
                    {
                        bTarget.replaceWith(aTarget);
                    }
                }
                else if (bType == null)
                {
                    aTarget.remove();
                }
            }
            else if (bType === "string") //new is a string
            {
                if (aType === "object") //old is a node
                {
                    if (bTarget == null) bTarget = toDomNode(parentNode.b); //parentNode.b.toNode(); //lazily create the node
                    if (isDomTreeElement(diffA) === true)
                    {
                        bTarget.replaceWith(aTarget);
                    }
                    else
                    {
                        aTarget.replaceWith(bTarget);
                    }
                }
                else if (aType == null)
                {
                    if (bTarget != null) bTarget.remove(); //if be was made, remove it
                }
            }
        }
        else if ((aType === "object" || bType === "object") && aType !== bType) //one is an object, the other is not.
        {
            var parentNode = getParentNodeDiff(session, treeDiff);
            if (parentNode == null) //there is no parent node, so we go look at the next highest comparison (which is a contents list)
            {
                var parentNode = treeDiff.parentComparison;
                var longer = Math.max(parentNode.a.length, parentNode.b.length);
                for (var x = 0; x < longer; x++) //walk the array and replace/remove nodes as necessary
                {
                    var aTree = parentNode.a[x];
                    var bTree = parentNode.b[x];

                    if (aTree != null && bTree != null) //both are nodes, swap them
                    {
                        toDomNode(bTree); //bTree.toNode();
                        aTree.node.replaceWith(bTree.node);
                    }
                    else if (bTree == null) //b is not there, remove existing
                    {
                        aTree.node.remove();
                    }
                    else if (aTree == null) //existing is not there, add the missing b node
                    {
                        toDomNode(bTree); //bTree.toNode();
                        insertMissingNode2(session, bTree.node);
                    }
                }
            }
            else //we have a parent
            {
                var aTarget = parentNode.a.node;
                var bTarget = toDomNode(parentNode.b); //parentNode.b.toNode();

                if (aType === "object") //parent existing was there, but there is no new matching node
                {                   
                    //aTarget.remove();
                    treeDiff.a.node.remove();
                }
                else if (bType === "object") 
                {
                    

                    if (aTarget.lastChild == null)
                    {
                        aTarget.replaceWith(bTarget);
                    }
                    else
                    {
                        injectNode(session, EVUI.Modules.Binding.BindingInsertionMode.InsertAfter, aTarget.lastChild, toDomNode(treeDiff.b)); //.toNode());
                    }
                }
            }
        }
        else if (aType === "object" && bType === "object") //both are nodes, do a contents comparison
        {
            for (var y = 0; y < numTreeDiffs; y++)
            {
                var curTreeDiff = treeDiff.differences[y];
                if (curTreeDiff.propName === "tagName")
                {
                    tagDiff = curTreeDiff;
                }
                else if (curTreeDiff.propName === "content")
                {
                    contentDiff = curTreeDiff;
                }
                else if (curTreeDiff.propName === "attrs")
                {
                    attributeDiff = curTreeDiff;
                }
                else if (curTreeDiff.propName === "shadow")
                {
                    shadowDiff = curTreeDiff;
                }

                if (tagDiff != null && contentDiff != null && attributeDiff != null && shadowDiff != null) break;
            }

            if (tagDiff != null || session.bindingHandle.binding.insertionMode === EVUI.Modules.Binding.BindingMode.Overwrite) //tags are different, they have to be different elements or we are overwriting the old content with new content explicitly
            {
                var aTarget = treeDiff.a.node;
                var bTarget = toDomNode(treeDiff.b); //.toNode();
                aTarget.replaceWith(bTarget);

                if (session.bindingHandle.binding.insertionMode === EVUI.Modules.Binding.BindingMode.Overwrite && contentDiff != null && session.bindingHandle.currentState.childBindingHandles.length > 0) //if we're overwriting it's possible to have children that were already merged, so attempt to merge in the existing content under this one
                {
                    if (contentDiff.differences.length === 0 || contentDiff.diffType === EVUI.Modules.Diff.DiffType.String)
                    {
                        processTreeDiff(session, diffResult, contentDiff, 0);
                    }
                    else
                    {
                        processArrayDiff(session, diffResult, contentDiff, 0);
                    }
                }
            }
            else //tags the same, we just update the child contents.
            {
                if (contentDiff != null)
                {
                    if (contentDiff.differences.length === 0 || contentDiff.diffType === EVUI.Modules.Diff.DiffType.String)
                    {
                        processTreeDiff(session, diffResult, contentDiff, 0);
                    }
                    else
                    {
                        processArrayDiff(session, diffResult, contentDiff, 0);
                    }
                }

                if (attributeDiff != null)
                {
                    processAttributeDiff(session, diffResult, attributeDiff, treeDiff.a.node);
                }
            }
        }
    };

    /**Processes the result of a difference in attributes on an element.
     * 
     * @param {BindingSession} session
     * @param {EVUI.Modules.Diff.CompareResult} diffResult
     * @param {EVUI.Modules.Diff.Comparison} attrDiff
     * @param {Node} targetNode
     */
    var processAttributeDiff = function (session, diffResult, attrDiff, targetNode)
    {
        var attributeData = buildAttributeDictionary(attrDiff);
        var currentMeta = getElementMetadata(attrDiff.parentComparison.a.node);
        var newMeta = getElementMetadata(toDomNode(attrDiff.parentComparison.b));

        var numKeys = attributeData.keys.length;
        for (var x = 0; x < numKeys; x++)
        {
            var curKey = attributeData.keys[x];
            var values = attributeData.dictionary[curKey];

            var newAttrMeta = getNewAttributeMetadata(session, curKey, values.currentValue, values.newValue, currentMeta, newMeta);
            currentMeta.attributes[curKey] = newAttrMeta;

            if (newMeta == null || newAttrMeta.value === values.currentValue) continue;

            targetNode.setAttribute(curKey, newAttrMeta.value);
        }
    };

    /**
     * 
     * @param {EVUI.Modules.Diff.Comparison} attrDiff
     */
    var buildAttributeDictionary = function (attrDiff)
    {
        var attributeDic = {};
        var keys = [];

        var numAttrDiffs = attrDiff.differences.length;
        for (var x = 0; x < numAttrDiffs; x++)
        {
            var curDiff = attrDiff.differences[x];
            if (curDiff.a != null)
            {
                var entry = attributeDic[curDiff.a.key];
                if (entry == null)
                {
                    entry = {};
                    attributeDic[curDiff.a.key] = entry;
                    keys.push(curDiff.a.key);
                }

                entry.currentValue = curDiff.a.val;
            }

            if (curDiff.b != null)
            {
                var entry = attributeDic[curDiff.b.key];
                if (entry == null)
                {
                    entry = {};
                    attributeDic[curDiff.b.key] = entry;
                    keys.push(curDiff.b.key);
                }

                entry.newValue = curDiff.b.val;
            }
        }

        return { dictionary: attributeDic, keys: keys };
    }

    /**
     * 
     * @param {BindingSession} session
     * @param {String} currentValue
     * @param {String} newValue
     * @param {ElementMetadata} currentMeta The data attached to the element that is already in the DOM.
     * @param {ElementMetadata} newMeta The data that is attached to the element that could be injected into the DOM.
     */
    var getNewAttributeMetadata = function (session, attrName, currentValue, newValue, currentMeta, newMeta)
    {
        var original = currentValue;
        var currentAttrMeta = (currentMeta != null) ? currentMeta.getAttributeMetadata(attrName) : null;
        var newAttrMeta = (newMeta != null) ? newMeta.getAttributeMetadata(attrName) : null;

        //if we have no metadata about what was set or bound to the attributes, we have no way of knowing what is really supposed to be there if the two are different, 
        //so the safest thing to do is just take what's already in the DOM. This case can occur if an attribute was added to the DOM that is not in the merged htmlContent or if a node was made outside of the binder
        if (currentAttrMeta == null || newAttrMeta == null) return currentAttrMeta;

        if (currentValue === newValue) return currentAttrMeta; //exactly the same, do nothing

        //normalize the strings whitespace
        currentValue = (currentValue != null) ? currentValue.replace(/\s+/g, " ").trim() : "";
        newValue = (newValue != null) ? newValue.replace(/\s+/g, " ").trim() : "";

        //normalized strings match
        if (currentValue === newValue) return currentAttrMeta;

        var unchanged = (currentValue === currentAttrMeta.value);
        if (unchanged === true) //if the attribute wasn't changed since it was last bound, but the new and current values are different, take the new value
        {
            return newAttrMeta;
        }

        var replacmentMeta = new AttributeMetadata();
        replacmentMeta.name = attrName;

        //if we get here, the attribute was changed at runtime and we have to figure out what is the "correct" new value for the attribute given a change in the backing data source.
        var changes = getAttributeChanges(currentValue, currentAttrMeta.value, newValue);
        var valueMappings = mapReBoundAttributeValues(currentAttrMeta, newAttrMeta);
        var numKeys = changes.keys.length;

        var currentValues = EVUI.Modules.Core.Utils.toDictionary(currentAttrMeta.values, function (valueMeta)
        {
            return valueMeta.value;
        });

        var newValues = EVUI.Modules.Core.Utils.toDictionary(newAttrMeta.values, function (valueMeta)
        {
            return valueMeta.value;
        });

        var finalValue = "";
        var tokenizedValue = "";
        var processedAttrs = {};

        for (var x = 0; x < numKeys; x++)
        {
            var curAttrValue = changes.keys[x];

            if (processedAttrs[curAttrValue] === true) continue;
            processedAttrs[curAttrValue] = true;

            var curChange = changes.dictionary[curAttrValue];
            var inCurrent = EVUI.Modules.Core.Utils.hasFlag(curChange.flags, AttributeDifferenceFlags.InCurrent);
            var inOld = EVUI.Modules.Core.Utils.hasFlag(curChange.flags, AttributeDifferenceFlags.InOld);
            var inNew = EVUI.Modules.Core.Utils.hasFlag(curChange.flags, AttributeDifferenceFlags.InNew);
            var valueToAdd = null;
            var tokenToAdd = null;
            var valueMeta = null;

            if (inCurrent === true && inOld === true && inNew === true) //same value was present in all three sources, keep it
            {
                valueToAdd = curAttrValue;
                valueMeta = newValues[curAttrValue];
            }
            else if (inCurrent === true && inOld === true && inNew === false) //same value was in the current and old, but not the new, so check and see if it was one of our bound values
            {
                var mappedValue = valueMappings[curAttrValue]; //if we have a mapping, use the new mapped value. If we don't omit the attribute value.
                if (mappedValue != null)
                {
                    replacmentMeta.containsBoundValues = true;
                    valueToAdd = mappedValue.value;
                    valueMeta = newValues[mappedValue.value];

                    processedAttrs[mappedValue.value] = true;
                }
                else
                {
                    continue;
                }
            }
            else if (inCurrent === true && inOld === false && inNew === true) //a value that is present in the current and new attribute, but not the old - this means it was probably added at runtime and was picked up in a re-bind
            {
                valueToAdd = curAttrValue;
                valueMeta = newValues[curAttrValue];
            }
            else if (inCurrent === true && inOld === false && inNew === false) //a value that's in the current but nowhere else, it's either a rebind or something added at runtime
            {
                var mappedValue = valueMappings[curAttrValue];
                if (mappedValue != null) //it was a rebind, use the rebind
                {
                    replacmentMeta.containsBoundValues = true;
                    valueToAdd = mappedValue.value;
                    valueMeta = newValues[mappedValue.value];

                    processedAttrs[mappedValue.value] = true;
                }
                else //it was added at runtime
                {
                    valueToAdd = curAttrValue;
                    valueMeta = currentValues[curAttrValue];

                    if (valueMeta == null)
                    {
                        valueMeta = new AttributeValueMetadata();
                        valueMeta.tokenizedString = valueToAdd;
                        valueMeta.value = valueToAdd;
                        valueMeta.wasBound = false;
                    }
                }
            }
            else if (inCurrent === false && inOld === true && inNew === true) //a value that was there and is in the rebind, but was likely removed at runtime. Don't include.
            {
                continue;
            }
            else if (inCurrent === false && inOld === true & inNew === false) //a value that was there on the previous bind, but is not there on the new or current rebinds, it was probably removed at runtime. Don't include
            {
                continue;
            }
            else if (inCurrent === false && inOld === false && inNew === true) //a value that was never on the attribute but is in the re-bind list, add it
            {
                var mappedValue = valueMappings[curAttrValue];
                if (mappedValue != null && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(mappedValue.value) === false) //it was a rebind, use the rebind
                {
                    replacmentMeta.containsBoundValues = true;
                    valueToAdd = mappedValue.value;
                    valueMeta = newValues[mappedValue.value];

                    processedAttrs[mappedValue.value] = true;
                }
            }
            else //if it was in nothing, this block is hit, which shouldn't be possible. It's here for debug purposes.
            {
                continue;
            }

            if (valueToAdd != null) finalValue += valueToAdd + " ";
            if (valueMeta != null)
            {
                tokenizedValue += valueMeta.tokenizedString + " ";
                valueMeta = cloneAttributeValueMetadata(valueMeta);
                replacmentMeta.values.push(valueMeta);
            }
        }

        replacmentMeta.tokenizedValue = tokenizedValue.trim();
        replacmentMeta.value = finalValue.trim();

        return replacmentMeta;
    };

    /**
     * 
     * @param {AttributeValueMetadata} valueMeta
     */
    var cloneAttributeValueMetadata = function (valueMeta)
    {
        var newMeta = new AttributeValueMetadata();
        newMeta.tokenizedString = valueMeta.tokenizedString;
        newMeta.value = valueMeta.value;
        newMeta.wasBound = valueMeta.wasBound;

        var numBindings = valueMeta.boundValues.length;
        for (var x = 0; x < numBindings; x++)
        {
            var curBinding = valueMeta.boundValues[x];
            var newBinding = new BoundAttributeValueMetadata();
            newBinding.boundContent = curBinding.boundContent;
            newBinding.boundPath = curBinding.boundPath;

            newMeta.boundValues.push(newBinding);
        }

        return newMeta;
    };

    var getAttributeChanges = function (currentValue, oldValue, newValue)
    {
        var currentValues = currentValue.split(/\s+/);
        var oldValues = oldValue.split(/\s+/);
        var newValues = newValue.split(/\s+/);

        var valueDic = {};
        var allKeys = [];

        var numCurrent = currentValues.length;
        for (var x = 0; x < numCurrent; x++)
        {
            var attrVal = currentValues[x];
            var difference = valueDic[attrVal];
            if (difference == null)
            {
                difference = new AttributeDifference();
                allKeys.push(attrVal);

                valueDic[attrVal] = difference;
            }

            difference.flags |= AttributeDifferenceFlags.InCurrent;
        }

        var numOld = oldValues.length;
        for (var x = 0; x < numOld; x++)
        {
            var attrVal = oldValues[x];
            var difference = valueDic[attrVal];
            if (difference == null)
            {
                difference = new AttributeDifference();
                allKeys.push(attrVal);

                valueDic[attrVal] = difference;
            }

            difference.flags |= AttributeDifferenceFlags.InOld;
        }

        var numNew = newValues.length;
        for (var x = 0; x < numNew; x++)
        {
            var attrVal = newValues[x];
            var difference = valueDic[attrVal];
            if (difference == null)
            {
                difference = new AttributeDifference();
                allKeys.push(attrVal);

                valueDic[attrVal] = difference;
            }

            difference.flags |= AttributeDifferenceFlags.InNew;
        }

        return { dictionary: valueDic, keys: allKeys };
    };


    /**
     * 
     * @param {AttributeMetadata} currentMeta
     * @param {AttributeMetadata} newMeta
     */
    var mapReBoundAttributeValues = function (currentMeta, newMeta)
    {
        var mappings = {};
        if (currentMeta.containsBoundValues === false || newMeta.containsBoundValues === false) return mappings;

        var currentTokenDic = EVUI.Modules.Core.Utils.toDictionary(currentMeta.values, function (valueMeta)
        {
            if (valueMeta.wasBound === false) return;
            return valueMeta.tokenizedString;
        });

        var newTokenDic = EVUI.Modules.Core.Utils.toDictionary(newMeta.values, function (valueMeta)
        {
            if (valueMeta.wasBound === false) return;
            return valueMeta.tokenizedString;
        });

        var numCurVals = currentMeta.values.length;
        for (var x = 0; x < numCurVals; x++)
        {
            var curVal = currentMeta.values[x];
            if (curVal.wasBound === false) continue;

            var existingBoundVal = currentTokenDic[curVal.tokenizedString];
            if (existingBoundVal == null) continue;
            if (mappings[existingBoundVal.value] != null) continue;

            var newBoundVal = newTokenDic[curVal.tokenizedString];
            mappings[existingBoundVal.value] = newBoundVal;
        }

        var numNewVals = newMeta.values.length;
        for (var x = 0; x < numNewVals; x++)
        {
            var curVal = newMeta.values[x];
            if (curVal.wasBound === false) continue;

            var existingBoundVal = newTokenDic[curVal.tokenizedString];
            if (existingBoundVal == null) continue;
            if (mappings[existingBoundVal.value] != null) continue;

            var newBoundVal = currentTokenDic[curVal.tokenizedString];
            mappings[existingBoundVal.value] = newBoundVal;
        }

        return mappings;
    };

    var AttributeDifference = function ()
    {
        this.flags = AttributeDifferenceFlags.None;
    };

    var AttributeDifferenceFlags =
    {
        None: 0,
        InCurrent: 1,
        InOld: 2,
        InNew: 4
    }

    /**Inserts a Node that is not yet in the DOM and does not have an equivalent replacement node.
    @param {BindingSession} session The BindingSession being executed.
    @param {Node} node The node to insert.*/
    var insertMissingNode = function (session, node)
    {
        //get the target element to insert the node relative to.
        var targetEle = session.bindingHandle.currentState.element;
        if (targetEle != null && targetEle.isConnected === false)
        {
            if (session.bindingHandle.oldState != null) //if the node is not connected, fall back to the old state's node
            {
                targetEle = session.bindingHandle.oldState.element;
            }
        }

        //if we have no target element or it is not connected, but we do have a parent session we could get a reference node out of
        if ((targetEle == null || targetEle.isConnected === false) && session.parentSession != null)
        {
            var numPeers = session.parentSession.bindingHandle.currentState.childBindingHandles.length;
            if (numPeers > 0) //we have "peer" nodes we can insert the node relative to
            {
                if (targetEle != null) //we have a disconnected node, inject the target node relative to the parent's element, then inject the node relative to the target node
                {
                    injectNode(session, session.parentSession.bindingHandle.binding.insertionMode, session.parentSession.bindingHandle.currentState.element, targetEle);
                    injectNode(session, session.bindingHandle.binding.insertionMode, targetEle, node);
                }
                else //we have no node. Go find the nearest piece of content and insert relative to that.
                {
                    var lastBoundContent = null;
                    var childIndex = (session.parentSession.isArray) ? parseInt(session.bindingHandle.currentState.parentBindingKey) - 1 : numPeers - 1; //start at the end, or if the parent is an array, start at the index of the child in the array
                    var lastChild = null;

                    //walk backwards from the starting point to look for some content to inject relative to
                    while (lastBoundContent == null && childIndex >= 0)
                    {
                        lastChild = session.parentSession.bindingHandle.currentState.childBindingHandles[childIndex];
                        lastBoundContent = (lastChild.currentState.boundContent == null) ? null : lastChild.currentState.boundContent[lastChild.currentState.boundContent.length - 1];
                        childIndex--;
                    }

                    if (lastBoundContent != null) //found some content. Because the location of where the content belongs is ambiguous, we just stick it after the last piece of content that has already been inserted
                    {
                        lastBoundContent.after(node);
                        if (session.bindingHandle.currentState.element == null || session.bindingHandle.currentState.element.isConnected === false) session.bindingHandle.currentState.element = lastBoundContent;
                    }
                    else //didn't find any content. The element reference becomes the parent element's reference and we insert the content relative to that
                    {
                        session.bindingHandle.currentState.element = session.parentSession.bindingHandle.currentState.element;
                        injectNode(session, session.bindingHandle.binding.insertionMode, session.bindingHandle.currentState.element, node);
                    }
                }
            }
            else //no peers, insert reference element relative to the parent's element, then insert node relative to reference node
            {
                if (targetEle != null) 
                {
                    injectNode(session, session.parentSession.bindingHandle.binding.insertionMode, session.parentSession.bindingHandle.currentState.element, targetEle);
                }
                else //had no element, set it to be the parent's element
                {
                    session.bindingHandle.currentState.element = session.parentSession.bindingHandle.currentState.element;
                }

                injectNode(session, session.bindingHandle.binding.insertionMode, targetEle, node);
            }
        }
        else
        {
            if (session.lastInsertedNode != null && node.contains(session.lastInsertedNode)) return;

            if (session.bindingHandle.binding.insertionMode === EVUI.Modules.Binding.BindingInsertionMode.InsertAfter || session.bindingHandle.binding.insertionMode === EVUI.Modules.Binding.BindingInsertionMode.InsertBefore)
            {
                injectNode(session, session.bindingHandle.binding.insertionMode, (session.lastInsertedNode == null ? session.bindingHandle.currentState.element : session.lastInsertedNode), node);
            }
            else if (session.bindingHandle.binding.insertionMode === EVUI.Modules.Binding.BindingInsertionMode.ReplaceChildren || session.bindingHandle.binding.insertionMode === EVUI.Modules.Binding.BindingInsertionMode.Shadow)
            {
                if (session.lastInsertedNode != null)
                {
                    injectNode(session, session.bindingHandle.binding.insertionMode, targetEle, node);
                }
                else
                {
                    if (session.bindingHandle.binding.insertionMode === EVUI.Modules.Binding.BindingInsertionMode.Shadow)
                    {
                        injectNode(session, EVUI.Modules.Binding.BindingInsertionMode.Append, targetEle.shadowRoot, node);
                    }
                    else
                    {
                        injectNode(session, EVUI.Modules.Binding.BindingInsertionMode.Append, targetEle, node);
                    }
                }
            }
            else
            {
                injectNode(session, session.bindingHandle.binding.insertionMode, targetEle, node);
            }
        }
    };

    /**Inserts a Node that is not yet in the DOM and does not have an equivalent replacement node.
    @param {BindingSession} session The BindingSession being executed.
    @param {Node} node The node to insert.*/
    var insertMissingNode2 = function (session, node)
    {
        //get the target element to insert the node relative to.
        var targetEle = session.bindingHandle.currentState.element;

        if (targetEle == null) //no element
        {
            if (session.bindingHandle.currentState.parentBindingHandle != null)
            {
                var parentHandle = session.bindingHandle.currentState.parentBindingHandle;
                var numPeers = parentHandle.currentState.childBindingHandles.length;
                if (numPeers > 0) //no target, but we have peers to use to find the nearest element to insert it relative to
                {
                    var lastBoundContent = null;
                    var childIndex = (EVUI.Modules.Core.Utils.isArray(parentHandle.currentState.source) === true) ? parseInt(session.bindingHandle.currentState.parentBindingKey) - 1 : numPeers - 1; //start at the end, or if the parent is an array, start at the index of the child in the array
                    var lastChild = null;

                    //walk backwards from the starting point to look for some content to inject relative to
                    while (lastBoundContent == null && childIndex >= 0)
                    {
                        lastChild = parentHandle.currentState.childBindingHandles[childIndex];
                        lastBoundContent = (lastChild.currentState.boundContent == null) ? null : lastChild.currentState.boundContent[lastChild.currentState.boundContent.length - 1];
                        childIndex--;
                    }

                    if (lastBoundContent != null) //found some content. Because the location of where the content belongs is ambiguous, we just stick it after the last piece of content that has already been inserted
                    {
                        lastBoundContent.after(node);
                        if (session.bindingHandle.currentState.element == null || session.bindingHandle.currentState.element.isConnected === false) session.bindingHandle.currentState.element = lastBoundContent;
                    }
                    else //didn't find any content. The element reference becomes the parent element's reference and we insert the content relative to that
                    {
                        var parentTarget = parentHandle.currentState.element;
                        if (parentTarget == null)
                        {
                            if (session.parentSession != null)
                            {
                                if (session.parentSession.bindingHandle.currentState.boundContentFragment == null) session.parentSession.bindingHandle.currentState.boundContentFragment = toDomNode(session.parentSession.bindingHandle.currentState.boundContentTree); // toNode();
                                insertMissingNode2(session.parentSession, session.parentSession.bindingHandle.currentState.boundContentFragment);
                            }
                            else
                            {
                                throw Error("Unresolvable parent element target in binding " + session.bindingHandle.id + ".");
                            }
                        }
                        else if (parentTarget.isConnected === false && parentHandle.oldStateBound === true && parentHandle.oldState.element != null && parentHandle.oldState.element.isConnected === true)
                        {
                            session.bindingHandle.currentState.element = parentHandle.oldState.element;
                        }
                        else
                        {
                            session.bindingHandle.currentState.element = parentHandle.currentState.element;
                        }

                        if (session.bindingHandle.currentState.element != null)
                        {
                            injectNode(session, session.bindingHandle.binding.insertionMode, session.bindingHandle.currentState.element, node);
                        }
                    }
                }
                else //we have no node and no other peers in the handle to insert relative to.
                {
                    if (session.lastInsertedNode != null) //we've inserted a node so far, insert after that node as the next most logical place to put the content.
                    {
                        session.bindingHandle.currentState.element = session.lastInsertedNode;
                        injectNode(session, session.bindingHandle.binding.insertionMode, session.bindingHandle.currentState.element, node);
                    }
                    else //we have no reference where to put the node, put it under the parent
                    {
                        var numParentContent = parentHandle.currentState.boundContent.length;
                        if (numParentContent > 0)
                        {
                            session.bindingHandle.currentState.element = parentHandle.currentState.boundContent[numParentContent - 1];
                            injectNode(session, EVUI.Modules.Binding.BindingInsertionMode.InsertAfter, session.bindingHandle.currentState.element, node);
                        }
                        else
                        {
                            session.bindingHandle.currentState.element = parentHandle.currentState.element;
                            injectNode(session, parentHandle.binding.insertionMode, session.bindingHandle.currentState.element, node);
                        }
                    }
                }
            }
            else
            {
                if (session.lastInsertedNode != null) //we've inserted a node so far, insert after that node as the next most logical place to put the content.
                {
                    session.bindingHandle.currentState.element = session.lastInsertedNode;
                    injectNode(session, session.bindingHandle.binding.insertionMode, session.bindingHandle.currentState.element, node);
                }
                else //we have no reference where to put the node, put it under the parent
                {
                    var parentHandle = session.bindingHandle.currentState.parentBindingHandle;
                    if (parentHandle != null)
                    {
                        var numParentContent = session.bindingHandle.currentState.boundContent.length;
                        if (numParentContent > 0)
                        {
                            session.bindingHandle.currentState.element = parentHandle.currentState.boundContent[numParentContent - 1];
                            injectNode(session, EVUI.Modules.Binding.BindingInsertionMode.InsertAfter, session.bindingHandle.currentState.element, node);
                        }
                        else
                        {
                            session.bindingHandle.currentState.element = parentHandle.currentState.element;
                            injectNode(session, parentHandle.binding.insertionMode, session.bindingHandle.currentState.element, node);
                        }
                    }
                    else
                    {
                        injectNode(session, session.bindingHandle.binding.insertionMode, session.bindingHandle.currentState.element, node);
                    }
                }
            }
        }
        else //connected element
        {
            injectNode(session, session.bindingHandle.binding.insertionMode, session.bindingHandle.currentState.element, node);
        }
    };

    /**Determines whether or not a value is actually a DomTreeElement based on duck-typing.
    @param {Object} value The value to test.
    @returns {Boolean}*/
    var isDomTreeElement = function (value)
    {
        if (value != null && typeof value.type === "number" && typeof value.tagName === "string")
        {
            return true;
        }

        return false;
    };

    /**Gets the parentComparison of a given diff that contains the parentNode of the nodes in the original diff.
    @param {BinidngSession} session The BindingSession being executed.
    @param {EVUI.Modules.Diff.Comparison} diff The comparison of DomTree's to get the parent DomTrees or node of.
    @returns {EVUI.Modules.Diff.Comparison}*/
    var getParentNodeDiff = function (session, diff)
    {
        if (isDomTreeElement(diff.a) === true || isDomTreeElement(diff.b) === true)
        {
            var parentComp = diff.parentComparison; //will always be an array
            if (parentComp.parentComparison == null)
            {
                return null;
            }
            else
            {
                return parentComp.parentComparison;
            }

        }
        else //comp is an array, parent is always an element
        {
            return diff.parentComparison;
        }
    };

    var toDomNode = function (domTreeEle)
    {
        var node = domTreeEle.toNode();
        assignElementMetadata(domTreeEle);

        return node;
    };

    /********************************************************************************BINDING HTML PROCESSING***************************************************************************/

    /**Turns a string of Html into a DomTreeElement representing a DocumentFragment containing the parsed Html.
    @param {BindingSession} session The BindingSession being executed.
    @param {String} htmlStr The string of Html to turn into a DomTreeElement.
    @param {HtmlContentMetadata}  htmlContentMetadata The metadata that describes the special properties of the html content.
    @returns {EVUI.Modules.DomTree.DomTreeElement}*/
    var stringToDomTree = function (session, htmlStr, htmlContentMetadata)
    {
        var tree = _services.domTreeConverter.htmlToDomTree(htmlStr);
        if (tree == null)
        {
            tree = _services.domTreeConverter.toDomTreeElement(document.createTextNode(""));
        }

        session.boundPropertyDictionary = {};
        var numProps = session.bindingHandle.currentState.boundProperties.length;
        for (var x = 0; x < numProps; x++)
        {
            var curProp = session.bindingHandle.currentState.boundProperties[x];

            if (typeof curProp.value === "function")
            {
                session.boundPropertyDictionary[curProp.path] = { value: "$evui.dispatch(event, '" + getInvocationHash(session, curProp) + "'" };
            }
            else
            {
                session.boundPropertyDictionary[curProp.path] = { value: curProp.value };
            }
        }

        tree.search(function (ele)
        {
            var metadata = buildElementMetadata(session, ele);
            if (metadata != null) ele[_hashMarker] = metadata;
        });

        return tree;
    };

    /**Removes all of the Node references from a DomTreeElement.
    @param {BindingSession} session The BindingSession being executed.
    @param {EVUI.Modules.DomTree.DomTreeElement} domTree The DomTreeElement hierarchy to purge node references from.*/
    var purgeDomTreeNodes = function (domTree)
    {
        if (domTree == null) return;

        domTree.node = undefined;
        if (domTree.content == null || typeof domTree.content === "string") return;

        var numChildren = domTree.content.length;
        for (var x = 0; x < numChildren; x++)
        {
            purgeDomTreeNodes(domTree.content[x]);
        }
    };

    var assignElementMetadata = function (domTree)
    {
        if (domTree == null) return;

        var node = domTree.node;
        if (node == null) return;

        var metadata = domTree[_hashMarker];
        if (metadata == null) return;

        node[_hashMarker] = metadata;

        if (domTree.content == null || typeof domTree.content === "string") return;

        var numChildren = domTree.content.length;
        for (var x = 0; x < numChildren; x++)
        {
            assignElementMetadata(domTree.content[x]);
        }
    };

    /**Gets the htmlContent to use in a binding.
    @param {BindingSession} session The BindingSession being executed.
    @param {Function} callback A callback function that is called when the htmlContent is resolved. Takes the htmlContent as a parameter.*/
    var getHtmlContent = function (session, callback)
    {
        if (typeof callback !== "function") callback = function (htmlContent) { };

        //if it's an object, treat it like it's a BindingHtmlContent, or possibly an element.
        if (typeof session.bindingHandle.currentState.htmlContent === "object" && session.bindingHandle.currentState.htmlContent != null)
        {
            if (EVUI.Modules.Core.Utils.isElement(session.bindingHandle.currentState.htmlContent) === true)
            {
                return callback(session.bindingHandle.currentState.htmlContent.outerHTML);
            }
            else
            {
                return gethtmlContentFromBindingHtmlContent(session, session.bindingHandle.currentState.htmlContent, function (result)
                {
                    callback(result);
                });
            }
        }
        else if (typeof session.bindingHandle.currentState.htmlContent === "string" && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(session.bindingHandle.currentState.htmlContent) === false)
        {
            //if we have a string of htmlContent, it's either an actual piece of htmlContent or is the name of some pre-loaded html.
            var htmlContentEntry = getHtmlContentEntry(session.bindingHandle.currentState.htmlContent);
            if (htmlContentEntry != null) //it was the name of a content entry, use it's html
            {
                session.bindingHandle.htmlContent = htmlContentEntry;
                if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(htmlContentEntry.content) === true && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(htmlContentEntry.url) === false) //if the content is empty but the URL is not, we need to make a HTTP request to go get the content.
                {
                    return getHtmlContentViaHttp(session, htmlContentEntry, function (content)
                    {
                        return callback(content);
                    });
                }
                else //otherwise just return the html content
                {
                    return callback(session.bindingHandle.htmlContent.content);
                }
            }
            else //was not the name of a content entry, use it by itself as the html content
            {
                return callback(session.bindingHandle.currentState.htmlContent);
            }
        }
        else //invalid input
        {
            return callback(null);
        }
    };

    /**Gets the boundProperties for a a given piece of htmlContent and the source object being used to populate it with.
    @param {BindingSession} session The bindingSession being executed.
    @param {Function} callback A callback function to call once the bindings are resolved. Takes an array of BoundProperty as a parameter.*/
    var getBoundProperties = function (session, callback)
    {
        //the html content was set in the events, go get it again
        if (session.bindingHandle.currentState.htmlContentSet === true)
        {
            getHtmlContent(session, function (htmlContent)
            {
                if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(htmlContent) === true) //get content failed, this will fail the binding operation
                {
                    return callback(null);
                }
                else
                {
                    session.bindingHandle.currentState.htmlContent = htmlContent;

                    var bindings = getTokenMappings(session);

                    //if the source observer hasn't been set yet, go get it either from the old state if we're re-binding the same object, or make a new one/get part of the parent's observer.
                    if (session.bindingHandle.currentState.sourceObserver == null)
                    {
                        if (session.bindingHandle.oldStateBound === true && session.bindingHandle.currentState.source === session.bindingHandle.oldState.source && session.bindingHandle.oldState.sourceObserver != null)
                        {
                            session.bindingHandle.currentState.sourceObserver = session.bindingHandle.oldState.sourceObserver;
                        }
                        else
                        {
                            session.bindingHandle.currentState.sourceObserver = getCurrentSourceObjectObserver(session); //new EVUI.Modules.Observers.ObjectObserver(session.bindingHandle.currentState.source);
                        }
                    }

                    //finally, get the values for the bindings from the source object.
                    callback(getBoundPropertyValues(session, bindings));
                }
            });
        }
        else //the html content was unchanged
        {
            //if the htmlContent is an entry, get it's actual html string content
            if (session.bindingHandle.currentState.htmlContent != null && typeof session.bindingHandle.currentState.htmlContent === "object") session.bindingHandle.currentState.htmlContent = session.bindingHandle.currentState.htmlContent.content;

            //we have no html content. Fail.
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(session.bindingHandle.currentState.htmlContent) === true) return callback(null);

            //if the source observer hasn't been set yet, go get it either from the old state if we're re-binding the same object, or make a new one/get part of the parent's observer.
            if (session.bindingHandle.currentState.sourceObserver == null)
            {
                if (session.bindingHandle.oldStateBound === true && session.bindingHandle.currentState.source === session.bindingHandle.oldState.source && session.bindingHandle.oldState.sourceObserver != null)
                {
                    session.bindingHandle.currentState.sourceObserver = session.bindingHandle.oldState.sourceObserver;
                }
                else
                {
                    session.bindingHandle.currentState.sourceObserver = getCurrentSourceObjectObserver(session); // new EVUI.Modules.Observers.ObjectObserver(session.bindingHandle.currentState.source);
                }
            }

            var bindings = null;
            if (session.parentSession != null && session.parentSession.isArray === true && session.parentSession.bindingHandle.currentState.boundProperties != null && session.parentSession.bindingHandle.currentState.htmlContent === session.bindingHandle.currentState.htmlContent) //arrays always have the same bindings for their children, so make a copy of them rather than going and getting them again.
            {
                return callback(session.parentSession.bindingHandle.currentState.boundProperties.map(function (bp) { return new EVUI.Modules.Binding.BoundProperty(bp.path); }));
            }
            else
            {
                bindings = getTokenMappings(session);
            }

            //finally, get the values for the bindings from the source object.
            return callback(getBoundPropertyValues(session, bindings));
        }
    };

    /**Determines if there was a change in any of the bound properties from their original values.
    @param {EVUI.Modules.Binding.BoundProperty[]} oldProps The original properties that were calculated for the Binding.
    @param {EVUI.Modules.Binding.BoundProperty[]} newProps The properties that the user had access to and could have changed.
    @returns {Boolean} */
    var areBoundPropsChanged = function (oldProps, newProps)
    {
        newProps = newProps.slice();
        var numOld = oldProps.length;
        var numNew = newProps.length;

        if (numOld !== numNew) return true;

        for (var x = 0; x < numOld; x++)
        {
            var curOld = oldProps[x];
            for (var y = 0; y < numNew; y++)
            {
                var curNew = newProps[y];
                if (curNew.path === curOld.path && curNew.value === curOld.value)
                {
                    numNew--;
                    newProps.splice(y, 1);
                    break;
                }
            }
        }

        if (numNew > 0) return true;
        return false;
    };

    /**Determines whether or not a Binding should re-bind itself in response to changes made to its source object. Only changes made directly to the source object dictate if it should be re-bound or not, child object changes are ignored.
    @param {BindingSession} session The BindingSession being executed.
    @returns {Boolean}*/
    var shouldReBind = function (session)
    {
        //if (session.bindingHandle.oldState.htmlContent === session.bindingHandle.currentState.htmlContent) //can only re-bind if the html content is still the same
        //{
        if (session.bindingHandle.oldState.source === session.bindingHandle.currentState.source) //re-binding the same object
        {
            if (session.bindingHandle.currentState.sourceObserver == null)
            {
                if (session.bindingHandle.oldStateBound === true && session.bindingHandle.oldState.sourceObserver != null)
                {
                    session.bindingHandle.currentState.sourceObserver = session.bindingHandle.oldState.sourceObserver;
                }
                else
                {
                    session.bindingHandle.currentState.sourceObserver = getCurrentSourceObjectObserver(session); //new EVUI.Modules.Observers.ObjectObserver(session.bindingHandle.currentState.source);
                }
            }

            //if we have child handles, go get the current state of the object before updating it in the object observer
            if (session.bindingHandle.oldState.childBindingHandles.length > 0)
            {
                session.oldStateDictionary = session.bindingHandle.currentState.sourceObserver.getObservedProperties();
            }
            else if (session.parentSession != null && session.parentSession.oldStateDictionary != null) //if we have a parent, we need to go get our copy of the oldStateDictionary because getting all the changes from the sourceObserver makes the child observers not detect any changes.
            {
                session.oldStateDictionary = session.parentSession.oldStateDictionary.getChild(session.bindingHandle.currentState.parentBindingKey);
            }

            session.observedDifferences = (session.observedDifferences != null) ? session.observedDifferences : session.bindingHandle.currentState.sourceObserver.getChanges(true);
            if (session.bindingHandle.canceledDuringReBind === true)
            {
                session.bindingHandle.canceledDuringReBind = false;
                return true;
            }

            //if we're a child with a parent, use the oldStateDictionary to determine if we changed or not.
            if (session.oldStateDictionary != null && session.parentSession != null)
            {
                if (session.oldStateDictionary.haveChildrenChanged() === true) return true;
            }

            if (session.bindingHandle.oldState.htmlContent !== session.bindingHandle.currentState.htmlContent) return true;

            var numDiffs = session.observedDifferences.length;
            if (numDiffs === 0)
            {
                return false;
            }
            else
            {
                var changed = false;
                for (var x = 0; x < numDiffs; x++)
                {
                    var curDiff = session.observedDifferences[x];
                    if (curDiff.hostObject === session.bindingHandle.currentState.source)
                    {
                        changed = true;
                        break;
                    }
                }


                if (changed === false) return false;
            }
        }
        else //binding a new object
        {
            if (session.bindingHandle.currentState.sourceObserver == null)
            {
                session.bindingHandle.currentState.sourceObserver = getCurrentSourceObjectObserver(session);

                if (session.bindingHandle.oldState.childBindingHandles.length > 0)
                {
                    session.oldStateDictionary = session.bindingHandle.currentState.sourceObserver.getObservedProperties();
                }
                else if (session.parentSession != null && session.parentSession.oldStateDictionary != null)
                {
                    session.oldStateDictionary = session.parentSession.oldStateDictionary.getChild(session.bindingHandle.currentState.parentBindingKey);
                }
            }

            //get the differences including any new object references if we're binding a new object
            session.observedDifferences = (session.observedDifferences != null) ? session.observedDifferences : _services.diffController.compare(session.bindingHandle.currentState.source, session.bindingHandle.oldState.source);
            if (session.bindingHandle.canceledDuringReBind === true)
            {
                session.bindingHandle.canceledDuringReBind = false;
                return true;
            }


            return true; //we always re-bind new objects.

            //if (session.bindingHandle.oldState.htmlContent !== session.bindingHandle.currentState.htmlContent) return true;

            //see if any of the root comparisons was an actual change to this object
            //var changed = false;
            //var numDiffs = session.observedDifferences.rootComparison.differences.length;
            //for (var x = 0; x < numDiffs; x++)
            //{
            //    var curDiff = session.observedDifferences.rootComparison.differences[x];
            //    if (curDiff.flags != EVUI.Modules.Diff.DiffFlags.Children)
            //    {
            //        changed = true;
            //        break;
            //    }
            //}

            if (changed === false) return false;
        }
        //}

        session.bindingHandle.canceledDuringReBind = false;
        return true;
    };

    /**Determines whether or not the current session will use special behavior when using an array.
    @param {BindingSession} session The BindingSession being executed.
    @returns {Boolean}*/
    var isArrayMode = function (session)
    {
        if (session.bindingHandle.options.enumerateArrays === true && session.isArray === true)
        {
            return true;
        }

        return false;
    }

    /**Makes sure that the value of a bound property is updated to be the value of the path in the source object if the value was not explicitly changed by the user in an event.
    @param {BindingSession} session The BindingSession being executed.
    @returns {EVUI.Modules.Binding.BoundProperty[]} */
    var syncBoundProperties2 = function (session)
    {
        var originals = session.originalBoundProps;
        var numOriginals = originals.length;
        var originalDic = {};
        var newProps = session.bindingHandle.binding.getBoundProperties(); //session.bindingHandle.binding.boundProperties;
        var numNew = newProps.length;
        var finals = [];
        var finalDic = {};

        for (var x = 0; x < numOriginals; x++)
        {
            var curOrig = originals[x];
            originalDic[curOrig.path] = curOrig;
        }


        for (var x = 0; x < numNew; x++)
        {
            var curNew = newProps[x];
            if (curNew == null || EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(curNew.path)) continue;

            var original = originalDic[curNew.path];
            var final = finalDic[curNew.path];
            var finalExisted = final == null;

            if (final == null) final = new EVUI.Modules.Binding.BoundProperty(curNew.path);

            final.value = curNew.value;

            if (original != null) 
            {
                if (curNew.value === original.value && session.isArray === false) //the value was never set, update the final property record. If the value was set to anything else, we use that instead.
                {
                    var curValue = (session.isArray === true) ? null : EVUI.Modules.Core.Utils.getValue(curNew.path, session.bindingHandle.currentState.source);
                    if (curNew.value !== curValue) //value is different than what is in the object
                    {
                        final.value = curValue;
                    }
                }
            }

            if (finalExisted === true)
            {
                finalDic[curNew.path] = final;
                finals.push(final);
            }
        }

        return finals;
    };


    /**Gets the names of the bound properties that were found in the htmlContent. Gets them either directly from the htmlContent or from the HtmlContentEntry's list of cached tokenMappings.
    @param {BindingSession} session The BindingSession being executed.
    @returns {TokenMapping[]} */
    var getTokenMappings = function (session)
    {
        var mappings = [];
        if (session.bindingHandle.htmlContent != null && session.bindingHandle.htmlContent.content === session.bindingHandle.currentState.htmlContent)
        {
            if (session.bindingHandle.htmlContent.needsRecalcuation === false && session.bindingHandle.htmlContent.tokenMappings != null) //if we have a HtmlContentEntry with existing token mappings, use them
            {
                mappings = session.bindingHandle.htmlContent.tokenMappings;
            }
            else //otherwise go get them and assign them to the entry
            {
                mappings = getTokenMappingsFromHtmlContent(session.bindingHandle.htmlContent.content);
                session.bindingHandle.htmlContent.needsRecalcuation = false;
                session.bindingHandle.htmlContent.tokenMappings = mappings;
            }
        }
        else
        {
            mappings = getTokenMappingsFromHtmlContent(session.bindingHandle.currentState.htmlContent);
        }

        return mappings;
    };


    /**Gets all the values from the source object that match the properties at the given paths.
    @param {BindingSession} session The BindingSession being executed.
    @param {TokenMapping[]} mappings The token mappings of the bound properties that were found in the htmlContent.
    @returns {EVUI.Modules.Binding.BoundProperty[]} */
    var getBoundPropertyValues = function (session, mappings)
    {
        var boundProps = [];
        var isArray = isArrayMode(session);
        var numMappings = mappings.length;
        for (var x = 0; x < numMappings; x++)
        {
            var curToken = mappings[x];
            var boundProp = new EVUI.Modules.Binding.BoundProperty(curToken.path);

            if (isArray === false || (session.bindingHandle.currentState.parentBinding != null && curToken.value !== undefined))
            {
                try
                {
                    boundProp.value = EVUI.Modules.Core.Utils.getValue(curToken.path, session.bindingHandle.currentState.source);
                }
                catch (ex)
                {
                    EVUI.Modules.Core.Utils.log(ex);
                }
            }

            boundProps.push(boundProp);
        }

        return boundProps;
    };

    /**Gets the actual HTML content from a BindingHtmlContent object.
    @param {BindingSession} session The BindingSession being executed.
    @param {EVUI.Modules.Binding.BindingHtmlContent} contentEntry The container for the Html content.
    @param {Function} callback A callback function to call to pass the raw Html into.*/
    var gethtmlContentFromBindingHtmlContent = function (session, contentEntry, callback)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(contentEntry.content) === false) //we have a valid htmlContent, use it
        {
            session.bindingHandle.htmlContent = getHtmlContentEntry(contentEntry.key);
            return callback(contentEntry.content);
        }
        else //we do not have a valid htmlContent, go get it
        {
            var freshEntry = false;
            var entry = null;
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(contentEntry.key) === false) //lookup by key to see if we have a match
            {
                entry = getHtmlContentEntry(contentEntry.key);
            }
            else if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(contentEntry.url) === false) //lookup by URL to see if we have a match
            {
                var numEntries = _bindingHtmlContentEntries.length;
                for (var x = 0; x < numEntries; x++)
                {
                    var curEntry = _bindingHtmlContentEntries[x];
                    if (curEntry.url === contentEntry.url && curEntry.ignoreUrl === false)
                    {
                        entry = curEntry;
                        break;
                    }
                }
            }

            if (entry == null) //both lookups failed, make a new entry
            {
                entry = new BindingHtmlContentEntry();
                entry.key = contentEntry.key;
                entry.url = contentEntry.url;

                freshEntry = true;
            }

            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(entry.content) === false) return callback(entry.content); //lookup found an existing valid htmlContent
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(entry.url) === false) //no htmlContent yet, but we have a URL
            {
                if (freshEntry === true && session.bindingHandle.options.addMissingHtmlContent !== false)
                {
                    if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(entry.key) === true) entry.key = EVUI.Modules.Core.Utils.makeGuid();
                    _bindingHtmlContentEntries.push(entry);

                    session.bindingHandle.htmlContent = entry;
                }

                return getHtmlContentViaHttp(session, entry, function (result)
                {
                    callback(result);
                });
            }
            else //no htmlContent match and no url means no htmlContent can be found
            {
                return callback(null);
            }
        }
    };

    /**********************************************************************************BINDING CHILD SESSIONS******************************************************************************* */

    /**Gets all the children of the current Binding based on the presence of the "evui-binder-obj" attribute on a child node of the current Binding's boundContentFragment or boundContentTree.
    @param {BindingSession} session The BindingSession being executed.
    @returns {BoundChild[]} */
    var getBoundChildren = function (session)
    {
        var boundChildren = [];
        if (session.bindingHandle.currentState.boundContentFragment != null) //if we have a fragment, search it for bound children - this will be true if the user accessed the bound content fragment from the binding object.
        {
            var elements = new EVUI.Modules.Dom.DomHelper("[" + EVUI.Modules.Binding.Constants.Attr_BoundObj + "]", session.bindingHandle.currentState.boundContentFragment);
            var numEles = elements.elements.length;
            for (var x = 0; x < numEles; x++)
            {
                var curEle = elements.elements[x];
                var path = curEle.getAttribute(EVUI.Modules.Binding.Constants.Attr_BoundObj);
                if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(path) === true) continue;

                var boundChild = new BoundChild();
                boundChild.element = curEle;
                boundChild.path = path;
                boundChild.source = EVUI.Modules.Core.Utils.getValue(path, session.bindingHandle.currentState.source);

                boundChildren.push(boundChild);
            }
        }
        else if (session.bindingHandle.currentState.boundContentTree != null && session.bindingHandle.currentState.mergedHtmlContent.indexOf(EVUI.Modules.Binding.Constants.Attr_BoundObj) !== -1) //otherwise, search the DomElementTree for nodes with the matching attribute name on them (but only if the merged content actually has the attribute name in it)
        {
            var boundParents = session.bindingHandle.currentState.boundContentTree.search(function (domTree)
            {
                if (domTree.attrs == null) return false;
                var numAttrs = domTree.attrs.length;
                for (var x = 0; x < numAttrs; x++)
                {
                    var curAttr = domTree.attrs[x];
                    if (curAttr.key === EVUI.Modules.Binding.Constants.Attr_BoundObj)
                    {
                        return true;
                    }
                }
            }, true);

            if (boundParents != null && boundParents.length > 0) //we found some elements that have the correct attribute, turn the whole tree into a document fragment and go get the bound children out of it like normal.
            {
                session.bindingHandle.currentState.boundContentFragment = toDomNode(session.bindingHandle.currentState.boundContentTree); //session.bindingHandle.currentState.boundContentTree.toNode();
                if (session.bindingHandle.currentState.boundContentFragment != null) return getBoundChildren(session);
            }
        }

        return boundChildren;
    };

    /**Makes a BindingHandle for each child of a Binding who's source is an array of objects.
    @param {BindingSession} session The BindingSession being executed.
    @returns {BindingHandle[]}*/
    var makeArrayChildren = function (session)
    {
        //arrays of arrays without some sort of anchor or wrapping object or anchoring element don't work correctly, so we just ignore them.
        if (session.parentSession != null && session.parentSession.isArray === true && session.bindingHandle.currentState.element == null) return [];

        var boundChildren = [];
        var numChildren = session.bindingHandle.currentState.source.length;

        for (var x = 0; x < numChildren; x++)
        {
            var path = x.toString();
            var partialBinding = new EVUI.Modules.Binding.BindArgs();

            var insertionMode = session.bindingHandle.binding.insertionMode;
            if (insertionMode === EVUI.Modules.Binding.BindingInsertionMode.Default)
            {
                if (x === 0) //first element is always appended beneath the parent element if it was set to default, otherwise it's an "insert after" insertion
                {
                    insertionMode = EVUI.Modules.Binding.BindingInsertionMode.Default;
                }
                else
                {
                    insertionMode = EVUI.Modules.Binding.BindingInsertionMode.InsertAfter;
                }
            }

            partialBinding.bindingSource = session.bindingHandle.currentState.source[x];
            partialBinding.templateName = session.bindingHandle.templateName;
            partialBinding.htmlContent = (session.bindingHandle.htmlContent != null) ? session.bindingHandle.htmlContent.key : session.bindingHandle.currentState.htmlContent;
            partialBinding.bindingMode = session.bindingHandle.binding.bindingMode;
            partialBinding.insertionMode = insertionMode;

            var bindingHandle = getBindingHandleAmbiguously(partialBinding, session.bindingHandle);
            if (bindingHandle == null) continue;

            bindingHandle.currentState.parentBindingHandle = session.bindingHandle;
            bindingHandle.currentState.parentBindingPath = path;
            bindingHandle.currentState.parentBindingKey = path;
            bindingHandle.currentState.boundProperties = session.bindingHandle.currentState.boundProperties.map(function (prop) { var newProp = new EVUI.Modules.Binding.BoundProperty(prop.path); newProp.value = prop.value; return newProp });

            boundChildren.push(bindingHandle);
        }

        return boundChildren;
    }

    /**Recalculates the child bindings of the Binding and re-maps the existing ones to new property names if their property names changed and adds new children if new children were added.
    @param {BindingSession} session The BindingSession being executed.*/
    var reMapBoundChildren = function (session)
    {
        //get all the bound children from the markup
        var boundChildren = getBoundChildren(session);
        var numBoundChildren = boundChildren.length;
        if (numBoundChildren === 0) return;

        var pathDic = makeChangeDictionary(session, session.bindingHandle.oldState.childBindingHandles);
        var unfoundPathDic = makeChangeDictionary(session, session.bindingHandle.oldState.childBindingHandles);

        var numChildren = session.bindingHandle.oldState.childBindingHandles.length;
        var childBindings = session.bindingHandle.oldState.childBindingHandles.slice();
        var remainingIndexes = {};
        var hashes = makeChangeHashDictionary(session, session.bindingHandle.oldState.childBindingHandles);

        //make a dictionary of all the children based on their paths from the Binding's source to the object being bound and a dictionary of all the indexes to search (which is all of them, but elements are removed form that dictionary as they are found later on)
        for (var x = 0; x < numChildren; x++)
        {
            //var curChild = childBindings[x];
            //pathDic[curChild.currentState.parentBindingPath] = { binding: curChild, index: x }; //get the binding and the index paired together since things are likely out of order when listed in the childBinindgs list vs the bouncChildren 
            remainingIndexes[x] = x;
        }

        //make a temporary object to hold the state for the re-mapping process
        var mappingSession = {};
        mappingSession.pathDic = pathDic; //dictionary of all paths to bindings
        mappingSession.unfoundPathDic = unfoundPathDic;
        mappingSession.numChildren = numChildren; //the number children in the old list
        mappingSession.childBindings = childBindings; //the old child bindings
        mappingSession.numOldChildren = numChildren; //the total number of remaining old children to loop through (is decreased every time an old binding is located)
        mappingSession.remainingIndexes = remainingIndexes; //dictionary of all the indexes left to search
        mappingSession.indexKeys = Object.keys(remainingIndexes); //the keys in the dictionary of indexes left to search (so we only have to get it once)
        mappingSession.numKeys = mappingSession.indexKeys.length; //the number of keys (so we only have to look it up once)
        mappingSession.makeNewKeys = false; //flag indicating whether or not the keys of remainingIndexes needs to be calculated again
        mappingSession.hashDic = hashes;

        //re-map each bound child that was found in the final boundContentFragment
        for (var x = 0; x < numBoundChildren; x++)
        {
            var curBoundChild = boundChildren[x];
            var path = curBoundChild.path;
            var source = curBoundChild.source;
            var ele = curBoundChild.element;

            reMapChild(session, mappingSession, path, source, ele);
        }

        removeObjectHashes(session, session.bindingHandle.oldState.childBindingHandles);
        removeObjectHashes(session, session.bindingHandle.currentState.childBindingHandles);
    };

    /**Walks the list of new children of an array and re-maps the existing children into new locations if they were moved within the array or creates binding handles for new children who were previously not in the array.
    @param {BindingSession} session The BindingSession being executed.*/
    var reMapArrayChildren = function (session)
    {
        var pathDic = makeChangeDictionary(session, session.bindingHandle.oldState.childBindingHandles);
        var unfoundPathDic = makeChangeDictionary(session, session.bindingHandle.oldState.childBindingHandles);
        var arrayLength = session.bindingHandle.currentState.source.length;
        var numChildren = session.bindingHandle.oldState.childBindingHandles.length;
        var childBindings = session.bindingHandle.oldState.childBindingHandles.slice();
        var remainingIndexes = {}; //[];
        var hashes = makeChangeHashDictionary(session, session.bindingHandle.oldState.childBindingHandles);

         //make a dictionary of all the children based on their paths from the Binding's source to the object being bound and a dictionary of all the indexes to search (which is all of them, but elements are removed form that dictionary as they are found later on)
        for (var x = 0; x < numChildren; x++)
        {
            //var curChild = childBindings[x];
            //pathDic[curChild.currentState.parentBindingPath] = { binding: curChild, index: x };
            remainingIndexes[x] = x;
        }

        //make a temporary object to hold the state for the re-mapping process
        var mappingSession = {};
        mappingSession.pathDic = pathDic; //dictionary of all paths to bindings
        mappingSession.unfoundPathDic = unfoundPathDic;
        mappingSession.numChildren = numChildren; //the number children in the old list
        mappingSession.childBindings = childBindings; //the old child bindings
        mappingSession.numOldChildren = numChildren; //the total number of remaining old children to loop through (is decreased every time an old binding is located)
        mappingSession.remainingIndexes = remainingIndexes; //dictionary of all the indexes left to search
        mappingSession.indexKeys = Object.keys(remainingIndexes); //the keys in the dictionary of indexes left to search (so we only have to get it once)
        mappingSession.numKeys = mappingSession.indexKeys.length;  //the number of keys (so we only have to look it up once)
        mappingSession.makeNewKeys = false;  //flag indicating whether or not the keys of remainingIndexes needs to be calculated again
        mappingSession.hashDic = hashes;

        //each object in the array is a child and needs to be re mapped
        for (var x = 0; x < arrayLength; x++)
        {
            var path = x.toString();
            var curObj = session.bindingHandle.currentState.source[x];

            reMapChild(session, mappingSession, path, curObj);
        }

        removeObjectHashes(session, session.bindingHandle.oldState.childBindingHandles);
        removeObjectHashes(session, session.bindingHandle.currentState.childBindingHandles);
    };

    /**Re-maps a child binding into a new or the same location when re-binding a Binding with child mappings.
    @param {BindingSession} session The parent BindingSession of the objects being bound.
    @param {Object} mappingSession All of the state variables used to re-map all the children of the parent BindingSession being executed.
    @param {String} path The path from the BindingSession's current source to the object being bound.
    @param {Object} curObj The object found at the path.
    @param {Element} ele The element that pointed at the object found at the path.*/
    var reMapChild = function (session, mappingSession, path, curObj, ele)
    {
        var found = false;

        var existing = getBindingContentList(mappingSession.pathDic, getNormalizedPath(path));
        var unprocessed = (existing != null) ? existing.getNextUnprocessedBinding() : null;
        if (unprocessed != null) unprocessed.processed = true;

        if (unprocessed == null || (unprocessed.binding.currentState.source !== curObj && session.bindingHandle.currentState.source === session.bindingHandle.oldState.source)) //same source object, but missing binding or different child objects found
        {
            if (curObj != null)
            {
                var objHash = curObj[_hashMarker];
                if (objHash != null)
                {
                    existing = mappingSession.hashDic[objHash];
                    if (existing != null)
                    {
                        for (var x = 0; x < existing.numBindings; x++)
                        {
                            var curUnprocessed = existing.bindings[x];
                            if (curUnprocessed.processed === true) continue;
                            if (curUnprocessed.binding.currentState.source === curObj)
                            {
                                curUnprocessed.processed = true;
                                unprocessed = curUnprocessed.binding;
                                found = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        else if (unprocessed == null || (unprocessed.binding.currentState.source !== curObj && session.bindingHandle.currentState.source !== session.bindingHandle.oldState.source)) //different source objects, but missing binding or different child objects found
        {
            //NOTE: duplicated code, but separating the two cases made debugging easier (and originally they had different logic)

            if (curObj != null)
            {
                var objHash = curObj[_hashMarker];
                if (objHash != null)
                {
                    existing = mappingSession.hashDic[objHash];
                    if (existing != null)
                    {
                        for (var x = 0; x < existing.numBindings; x++)
                        {
                            var curUnprocessed = existing.bindings[x];
                            if (curUnprocessed.processed === true) continue;
                            if (curUnprocessed.binding.currentState.source === curObj)
                            {
                                curUnprocessed.processed = true;
                                unprocessed = curUnprocessed.binding;
                                found = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        else if (unprocessed != null && unprocessed.binding.currentState.source === curObj)
        {
            found = true;
        }

        if (found === true && unprocessed != null && unprocessed.index !== undefined) //we found an unprocessed one and it wasn't from the secondary search
        {
            //delete mappingSession.remainingIndexes[unprocessed.index];
            //mappingSession.makeNewKeys = true;

            unprocessed = unprocessed.binding;            
        }

        if (found === true) //&& unprocessed != null && unprocessed.progressState === EVUI.Modules.Binding.BindingProgressStateFlags.Idle) //we found the match and it's not currently doing anything
        {
            //we set the pending state so when it comes back into swapStates we get a fresh state with the correct information instead of corrupting the current state.
            if (unprocessed.pendingState == null) unprocessed.pendingState = new BindingHandleState();
            unprocessed.pendingState.parentBindingPath = path;
            unprocessed.pendingState.parentBindingKey = path;
            unprocessed.pendingState.parentBindingHandle = unprocessed.currentState.parentBindingHandle;
            unprocessed.pendingState.normalizedPath = unprocessed.pendingState.getNormalizedPath();

            unprocessed.pendingState.htmlContent = (session.bindingHandle.htmlContent != null && session.bindingHandle.htmlContent.content === unprocessed.currentState.htmlContent) ? session.bindingHandle.htmlContent.key : unprocessed.currentState.htmlContent;
            unprocessed.pendingState.htmlContentSet = true;

            unprocessed.pendingState.source = curObj;
            unprocessed.pendingState.sourceSet = true;

            if (ele != null)
            {
                unprocessed.pendingState.element = ele;
                unprocessed.pendingState.elementSet = true;
            }

            //found = true;
            session.bindingHandle.currentState.childBindingHandles.push(unprocessed);
        }

        if (found === false) //we did not find a match, make a new child binding handle
        {
            var partialBinding = new EVUI.Modules.Binding.BindArgs();
            partialBinding.bindingSource = curObj;
            partialBinding.bindingTarget = ele;
            partialBinding.templateName = session.bindingHandle.templateName;

            var bindingHandle = getBindingHandleAmbiguously(partialBinding, session.bindingHandle);
            if (bindingHandle != null)
            {
                //we set both the current state and the pending states so if it gets rebound our old state and new state are correctly populated so that the child diffing function works properly
                bindingHandle.currentState.parentBindingKey = path;
                bindingHandle.currentState.parentBindingPath = path;
                bindingHandle.currentState.parentBindingHandle = session.bindingHandle;
                bindingHandle.currentState.normalizedPath = bindingHandle.currentState.getNormalizedPath();

                if (bindingHandle.currentState.htmlContent == null)
                {
                    bindingHandle.currentState.htmlContent = (session.bindingHandle.htmlContent != null && session.bindingHandle.htmlContent.content === session.bindingHandle.currentState.htmlContent) ?session.bindingHandle.htmlContent.key : session.bindingHandle.currentState.htmlContent;
                    bindingHandle.currentState.htmlContentSet = true;
                }

                if (bindingHandle.pendingState == null) bindingHandle.pendingState = new BindingHandleState();
                bindingHandle.pendingState.parentBindingPath = path;
                bindingHandle.pendingState.parentBindingKey = path;
                bindingHandle.pendingState.parentBindingHandle = bindingHandle.currentState.parentBindingHandle;
                bindingHandle.pendingState.normalizedPath = bindingHandle.pendingState.getNormalizedPath();

                if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(bindingHandle.currentState.htmlContent) === true)
                {
                    bindingHandle.pendingState.htmlContent = (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(bindingHandle.currentState.htmlContent) === true && session.bindingHandle.htmlContent != null && session.bindingHandle.htmlContent.content === bindingHandle.currentState.htmlContent) ? session.bindingHandle.htmlContent.key : bindingHandle.currentState.htmlContent;
                    bindingHandle.pendingState.htmlContentSet = true;
                }

                bindingHandle.pendingState.source = curObj;
                bindingHandle.pendingState.sourceSet = true;

                if (ele == null || bindingHandle.binding.insertionMode === EVUI.Modules.Binding.BindingInsertionMode.Default)
                {
                    if (bindingHandle.currentState.parentBindingHandle != null && bindingHandle.currentState.parentBindingHandle.binding.insertionMode !== EVUI.Modules.Binding.BindingInsertionMode.Default)
                    {
                        bindingHandle.binding.insertionMode = bindingHandle.currentState.parentBindingHandle.binding.insertionMode;
                    }
                    else
                    {
                        bindingHandle.binding.insertionMode = EVUI.Modules.Binding.BindingInsertionMode.Default;
                    }
                }

                //check to see if there already is a binding with a different object at the same path. If these is, we are technically rebinding that same handle, so we need to carry over some information for things to work properly
                var existingAtPath = getBindingContentList(mappingSession.unfoundPathDic, getNormalizedPath(path));
                if (existingAtPath != null)
                {
                    var nextUnprocessed = existingAtPath.getNextUnprocessedBinding();
                    if (nextUnprocessed != null)
                    {
                        //all of these values get moved into the "oldState" when this bindingHandle goes through its own binding process starting in swapStates()
                        nextUnprocessed.processed = true;
                        bindingHandle.currentState.boundContent = nextUnprocessed.binding.currentState.boundContent.slice(); //we need to remember the content to remove
                        bindingHandle.currentState.source = nextUnprocessed.binding.currentState.source; // we need the source object for diff comparisons
                        bindingHandle.currentState.childBindingHandles = nextUnprocessed.binding.currentState.childBindingHandles.slice(); //we need the child handles so the diffing works correctly                        
                        bindingHandle.newStateBound = nextUnprocessed.binding.newStateBound; //we need to flag it as having been bound
                        disposeBindingDispatchHandles(nextUnprocessed.binding); //clean up the old dispatch handles so we don't get a memory leak
                    }
                }

                session.bindingHandle.currentState.childBindingHandles.push(bindingHandle);
            }
        }
    };

    /**Makes a BindingHandle for each ChildBinding that was pulled out of the merged html content.
    @param {BindingSession} session The BindingSession being executed.
    @param {BoundChild[]} boundChildren The array of BoundChildren pulled out of the merged html content.
    @returns {BindingHandle[]} */
    var makeChildBindings = function (session, boundChildren)
    {
        var bindings = [];
        var numChildren = boundChildren.length;
        var isArray = isArrayMode(session);

        for (var x = 0; x < numChildren; x++)
        {
            var curChild = boundChildren[x];

            var partialBinding = new EVUI.Modules.Binding.BindArgs();
            partialBinding.bindingSource = curChild.source;
            partialBinding.bindingTarget = curChild.element;

            var bindingHandle = getBindingHandleAmbiguously(partialBinding, session.bindingHandle);
            if (bindingHandle == null) continue;

            bindingHandle.currentState.parentBindingHandle = session.bindingHandle;
            bindingHandle.currentState.parentBindingPath = curChild.path;

            var segments = EVUI.Modules.Core.Utils.getValuePathSegments(curChild.path);
            if (segments.length === 0)
            {
                bindingHandle.currentState.parentBindingKey = curChild.path;
            }
            else
            {
                bindingHandle.currentState.parentBindingKey = segments[segments.length - 1];
            }

            if (isArray === true) bindingHandle.currentState.boundProperties = session.bindingHandle.currentState.boundProperties.map(function (prop) { var newProp = new EVUI.Modules.Binding.BoundProperty(prop.path); newProp.value = prop.value; return newProp });
            bindings.push(bindingHandle);
        }

        return bindings;
    };

    /**Takes the list of ChildBindings that have been produced by the internal logic and the ones that could have possibly been added by a user and merges them into a single list of final, validated BindingHandles.
    @param {BindingSession} session The BindingSession being executed.
    @returns {BindingHandle[]}*/
    var validateChildBindings = function (session)
    {
        var newHandles = [];
        var childBindings = session.bindingHandle.binding.getChildBindings(); //session.bindingHandle.binding.childBindings;
        var numBindings = childBindings.length;
        var existingBindings = session.bindingHandle.currentState.childBindingHandles;
        var numExisting = existingBindings.length;

        //make a dictionary keyed by binding handle ID to bindingHandle to serve as a look up of childBindings to existingBindings
        var bindingDic = {};
        for (var x = 0; x < numExisting; x++)
        {
            var curExisting = existingBindings[x];
            bindingDic[curExisting.id] = curExisting;
        }

        for (var x = 0; x < numBindings; x++)
        {
            var curChild = childBindings[x];
            var handle = null;

            var curExisting = bindingDic[curChild.id];
            if (curExisting != null) handle = curExisting;

            if (handle == null)
            {
                var newHandle = getBindingHandleAmbiguously(curChild, session.bindingHandle);
                if (newHandle != null) handle = newHandle;
            }

            if (handle != null) newHandles.push(handle);
        }

        return newHandles;
    };

    /**A somewhat hacky method that checks to see if the events between the creating of the merged html content and the child list calculation have been overridden to anything that isn't an empty function.
    @param {BindingSession} session The BindingSession being executed.
    @returns {Boolean} */
    var areOnHtmlContentBoundEventsOverridden = function (session)
    {
        var local = session.bindingHandle.binding.onBindHtmlContent;
        var global = _self.onBindHtmlContent;

        var localType = typeof local;
        var globalType = typeof global;

        //if neither is a function, they were not overridden
        if (localType !== "function" && globalType !== "function") return false;

        //if suppressing child events, neither will fire
        if (session.parentSession != null && session.parentSession.bindingHandle.options.suppressChildEvents === true) return false;
        
        return (localType === "function" || globalType === "function");
    };

    /**Gets all of the changed or new child Bindings of the current Binding in the event of an update rebind. Also does DOM manipulation based on certain kinds of changes that are detected in the child list (removals, swaps, and shifts). 
    @param {BindingSession} session The BindingSession being executed.
    @returns {BindingHandle[]}*/
    var getChangedChildBindings = function (session)
    {
        var reBind = session.shouldReBind;
        if (reBind === false && session.bindingHandle.currentState.childBindingHandles.length === 0/*isArrayMode(session) === false*/) return []; //if it's an array, we calculate the Bindings of its children even if the parent array isn't being rebound
        if (session.bindingHandle.oldState == null) return session.bindingHandle.currentState.childBindingHandles; //we have no old state there is no way to figure out what changed, so just assume they all have

        //calculate all the changes that have been made to all the children
        var childDifferences = makeChildDifferencePackage(session);
        
        var changedKeys = Object.keys(childDifferences.modifiedPaths);
        var numChanges = changedKeys.length;
        if (numChanges === 0) return [];

        var orderedChanges = [];
        for (var x = 0; x < numChanges; x++)
        {
            var curChange = childDifferences.modifiedPaths[changedKeys[x]];
            var numCurChanges = curChange.length;
            for (var y = 0; y < numCurChanges; y++)
            {
                orderedChanges.push(curChange[y]);
            }
        }

        var toDispose = [];

        //put all the changes in order based on their index in the childBiningHandles array so that the changes are not processed out of order
        orderedChanges.sort(function (a, b) { return a.index - b.index });
        var numTotalChanges = orderedChanges.length;
        var changedBindings = [];

        for (var x = 0; x < numTotalChanges; x++)
        {
            var curChange = orderedChanges[x];
            if (curChange.applied === true) continue;

            if (curChange.bindingStructureChangeType === BindingStructureChangeType.Added) //item was added to the list of bindingChildren, add it to the process list. The processing will add it like normal.
            {
                changedBindings.push(curChange.binding);
                curChange.applied = true;
                continue;
            }
            else if (curChange.bindingStructureChangeType === BindingStructureChangeType.Moved) //item was moved from one key to another. Pick up and move the DOM nodes from their current location to the location of the key that it was moved to
            {
                var matchingChange = childDifferences.modifiedPaths[curChange.binding.oldState.normalizedPath][0]; //the matching change is the binding where this binding was moved to

                var ele = matchingChange.binding.currentState.element;
                var target = matchingChange.binding.currentState.boundContent[0];

                if (matchingChange.bindingStructureChangeType === BindingStructureChangeType.Removed)
                {
                    matchingChange.binding.currentState.element = document.createElement("div"); //put a dummy in the old element's place so that when it gets disposed it doesn't remove the current binding's element.
                    matchingChange.applied = true;

                    toDispose.push(matchingChange);
                }

                //put a placeholder where the first piece of content in the destination is
                var placeholder = document.createElement("div");
                target.after(placeholder);

                //load the content from the binding to move into a document fragment
                var tempContent = document.createDocumentFragment();
                var numContent = curChange.binding.currentState.boundContent.length;
                for (var y = 0; y < numContent; y++)
                {
                    var curContent = curChange.binding.currentState.boundContent[y];
                    if (y === 0) curContent.before(placeholder);

                    tempContent.append(curContent);
                }

                //replace the placeholder with the document fragment to move all the content into its new location
                placeholder.replaceWith(tempContent);

                //re-assign the current content to be relative to the target's element
                curChange.binding.currentState.element = ele;
                curChange.applied = true;

                //add it to the process list
                changedBindings.push(curChange.binding);
            }
            else if (curChange.bindingStructureChangeType === BindingStructureChangeType.Removed) //item was removed, add it to the list of items to dispose (if we dispose of it now it can upset the current state of the child binding list, we wait until the end to get rid of it)
            {
                toDispose.push(curChange);
                curChange.applied = true;
                continue;
            }
            else if (curChange.bindingStructureChangeType === BindingStructureChangeType.Shifted) //don't actually do anything for a shift if there was no update
            {
                if (curChange.contentsModified === true) changedBindings.push(curChange.binding);
                curChange.applied = true;
                continue;
            }
            else if (curChange.bindingStructureChangeType === BindingStructureChangeType.Swapped) //swap means that two bindings changed places within their parent binding
            {
                var matchingState = curChange.moveSwapTarget.currentState;

                var matchingChange = childDifferences.modifiedPaths[matchingState.normalizedPath][0]; //the other change that was swapped with the current state

                var placeholder = document.createElement("div");
                var placeholder2 = document.createElement("div");

                var tempContent = document.createDocumentFragment();
                var tempContent2 = document.createDocumentFragment();

                //if we have any content, load it into the document fragment after putting one of the placeholders in the place of the first piece of content
                if (curChange.binding.currentState.boundContent != null)
                {
                    var numContent = curChange.binding.currentState.boundContent.length;
                    for (var y = 0; y < numContent; y++)
                    {
                        var curContent = curChange.binding.currentState.boundContent[y];
                        if (y === 0) curContent.before(placeholder);

                        tempContent.append(curContent);
                    }
                }

                //if the matching change has any content, load it into the other document fragment after putting the other placeholder in the place of the first piece of the other binding's content
                if (matchingChange != null && matchingChange.binding.currentState.boundContent != null)
                {
                    numContent = curChange.moveSwapTarget.currentState.boundContent.length;
                    for (var y = 0; y < numContent; y++)
                    {
                        var curContent = matchingChange.binding.currentState.boundContent[y];
                        if (y === 0) curContent.before(placeholder2);

                        tempContent2.append(curContent);
                    }
                }

                //replace the placeholders with the opposite set of content
                placeholder.replaceWith(tempContent2);
                placeholder2.replaceWith(tempContent);

                if (matchingChange != null)
                {
                    matchingChange.applied = true;
                    changedBindings.push(matchingChange.binding);
                }

                changedBindings.push(curChange.binding);
                curChange.applied = true;

                continue;
            }
            else
            {
                if (curChange.contentsModified === true) changedBindings.push(curChange.binding);
                curChange.applied = true;
            }
        }

        //we need to "swap" the states of every unchanged binding to synthesize the swapStates step that occurs when doing a re-bind evaluation since this method serves to filter out which bindings get re evaluated
        //if we don't swap the states things start getting out of sync and more special handing is required, so this treats the unchanged bindings as if they had been though the initial stages of rebinding.
        var numToSwapStates = childDifferences.unchangedBindings.length;
        for (var x = 0; x < numToSwapStates; x++)
        {
            var curUnchangedBinding = childDifferences.unchangedBindings[x];//.binding;
            var newState = new BindingHandleState();

            newState.boundContent = curUnchangedBinding.currentState.boundContent;
            newState.boundProperties = curUnchangedBinding.currentState.boundProperties;
            newState.boundContentFragment = curUnchangedBinding.currentState.boundContentFragment;
            newState.boundTemplateContentClone = curUnchangedBinding.currentState.boundTemplateContentClone;
            newState.boundContentTree = curUnchangedBinding.currentState.boundContentTree;
            newState.childBindingHandles = curUnchangedBinding.currentState.childBindingHandles;

            var tempState = curUnchangedBinding.pendingState;
            //if (tempState == null) tempState = curUnchangedBinding.currentState;

            newState.element = tempState.element;
            newState.normalizedPath = tempState.normalizedPath;
            newState.htmlContent = tempState.htmlContent;
            newState.mergedHtmlContent = curUnchangedBinding.currentState.mergedHtmlContent;
            newState.parentBindingHandle = tempState.parentBindingHandle;
            newState.parentBindingKey = tempState.parentBindingKey;
            newState.parentBindingPath = tempState.parentBindingPath;
            newState.source = tempState.source;

            newState.sourceObserver = curUnchangedBinding.currentState.sourceObserver;
           
            curUnchangedBinding.oldState = session.bindingHandle.currentState;
            curUnchangedBinding.currentState = newState;
            curUnchangedBinding.pendingState = null;
            curUnchangedBinding.oldStateBound = session.bindingHandle.oldStateBound;
            curUnchangedBinding.newStateBound = true; //session.bindingHandle.newStateBound;
        }

        //now that all the changes have been processed in sequence, we can safely dispose of all the bindings that are flagged to be removed.
        var numToDispose = toDispose.length;
        for (var x = 0; x < numToDispose; x++)
        {
            triggerDispose(toDispose[x].binding);
        }

        return changedBindings;       
    };

    /**
     * 
     * @param {any} dictionary
     * @param {any} objectPath
     * @returns {BindingContentList}
     */
    var getBindingContentList = function (dictionary, objectPath)
    {
        var contentList = dictionary[objectPath];
        while (contentList == null)
        {
            var lastSeg = objectPath.lastIndexOf(".");
            if (lastSeg !== -1)
            {
                objectPath = objectPath.substring(0, lastSeg);
            }
            else
            {
                break;
            }

            contentList = dictionary[objectPath];
        }

        return contentList;
    };

    /**
     * 
     * @param {any} session
     * @param {any} childBindingHandles
     */
    var makeChangeDictionary = function (session, childBindingHandles)
    {
        var dic = {};

        var numChildren = childBindingHandles.length;
        for (var x = 0; x < numChildren; x++)
        {
            var curChild = childBindingHandles[x];
            var stateToCheck = curChild.currentState;

            if (stateToCheck.normalizedPath == null) stateToCheck.normalizedPath = stateToCheck.getNormalizedPath();

            var bindingContentList = dic[stateToCheck.normalizedPath];
            if (bindingContentList == null)
            {
                bindingContentList = new BindingContentList(stateToCheck.normalizedPath);
                dic[stateToCheck.normalizedPath] = bindingContentList;
            }

            var listItem = bindingContentList.addBinding(curChild, x);
            listItem.stateToCheck = stateToCheck;
        }

        return dic;
    };

    /**
 * 
 * @param {any} session
 * @param {any} childBindingHandles
 */
    var makeChangeHashDictionary = function (session, childBindingHandles)
    {
        var dic = {};

        var numChildren = childBindingHandles.length;
        for (var x = 0; x < numChildren; x++)
        {
            var curChild = childBindingHandles[x];
            var hash = (curChild.currentState.source != null) ? curChild.currentState.source[_hashMarker] : null;

            if (hash == null)
            {
                hash = Math.random(); //_services.diffController.getValueHashCode(curChild.currentState.source);
                if (curChild.currentState.source != null) curChild.currentState.source[_hashMarker] = hash;
            }

            var bindingContentList = dic[hash];
            if (bindingContentList == null)
            {
                bindingContentList = new BindingContentList(hash);
                dic[hash] = bindingContentList;
            }

            var listItem = bindingContentList.addBinding(curChild, x);
            listItem.stateToCheck = curChild.currentState;
        }

        return dic;
    };

    var removeObjectHashes = function (session, childBindingHandles)
    {
        var numChildren = childBindingHandles.length;
        for (var x = 0; x < numChildren; x++)
        {
            var curChild = childBindingHandles[x];
            if (curChild.currentState.source != null) delete curChild.currentState.source[_hashMarker];
        }
    }

    /**Creates a digest package describing the changes to make to all the new and existing children of the Binding.
    @param {BindingSession} session The BindingSession being executed.
    @returns {ChildDifferencePackage} */
    var makeChildDifferencePackage = function (session)
    {
        var childDiffs = new ChildDifferencePackage();
        childDiffs.isArray = session.isArray;

        var modifiedPaths = childDiffs.modifiedPaths;
        var allBindings = makeChangeDictionary(session, session.bindingHandle.currentState.childBindingHandles);
        var allOldBindings = makeChangeDictionary(session, session.bindingHandle.oldState.childBindingHandles);

        //process any diff that may have occurred since the last run or during this session.
        var sessionDiffs = (areOnHtmlContentBoundEventsOverridden(session) === true) ? session.bindingHandle.currentState.sourceObserver.getChanges() : [];
        var diffs = (EVUI.Modules.Core.Utils.isArray(session.observedDifferences) === true) ? session.observedDifferences.concat(sessionDiffs) : sessionDiffs;

        var numDiffs = diffs.length;
        for (var x = 0; x < numDiffs; x++)
        {
            var curDiff = diffs[x];

            if (curDiff.type === EVUI.Modules.Observers.ObservedObjectChangeType.Added || curDiff.type === EVUI.Modules.Observers.ObservedObjectChangeType.Changed || curDiff.type === EVUI.Modules.Observers.ObservedObjectChangeType.Removed)
            {
                var objectPath = curDiff.path;
                if (objectPath == null) continue;

                //first see if the unmodified path is a match
                var curBinding = getBindingContentList(allBindings, objectPath);
                if (curDiff.type === EVUI.Modules.Observers.ObservedObjectChangeType.Added) //object was added
                {
                    //if we still don't have a match the changed object, continue on to the next change
                    if (curBinding == null) continue;

                    if (modifiedPaths[curBinding.normalizedPath] == null) //if the binding isn't in our change dictionary, add it
                    {
                        modifiedPaths[curBinding.normalizedPath] = curBinding.makeChangeArray(BindingStructureChangeType.Added);
                    }
                }
                else if (curDiff.type === EVUI.Modules.Observers.ObservedObjectChangeType.Changed || curDiff.type === EVUI.Modules.Observers.ObservedObjectChangeType.Removed) //the binding was changed. This could mean a content change, a swap, or a shift, or a change in addition or any one of those types of changes
                {
                    var lookInOld = false;
                    if (curBinding == null)
                    {
                        lookInOld = true;
                        curBinding = getBindingContentList(allOldBindings, objectPath);
                    }

                    //if it was in the old one, but not the new one, and it no longer has a value, it was removed.
                    if (curBinding != null && lookInOld === true && modifiedPaths[curBinding.normalizedPath] == null)
                    {
                        modifiedPaths[curBinding.normalizedPath] = curBinding.makeChangeArray(BindingStructureChangeType.Removed);
                        continue;
                    }

                    //if we still don't have a match the changed object, continue on to the next change
                    if (curBinding == null) continue;

                    var existingChange = modifiedPaths[curBinding.normalizedPath];
                    if (existingChange != null) //we already processed this binding, but it may not have been flagged as a change yet, so make sure it's changed.
                    {
                        var numExisting = existingChange.length;
                        for (var y = 0; y < numExisting; y++)
                        {
                            var curExisting = existingChange[y];

                            if (curExisting.contentsModified === false &&
                               (curExisting.bindingStructureChangeType !== BindingStructureChangeType.Shifted &&
                                curExisting.bindingStructureChangeType !== BindingStructureChangeType.Removed &&
                                curExisting.bindingStructureChangeType !== BindingStructureChangeType.Swapped)) curExisting.contentsModified = true;
                        }

                        continue;
                    }

                    //if (curDiff.type === EVUI.Modules.Observers.ObservedObjectChangeType.Removed)
                    //{
                    //    modifiedPaths[curBinding.normalizedPath] = curBinding.makeChangeArray(BindingStructureChangeType.Removed);
                    //}
                    //else
                    //{
                        modifiedPaths[curBinding.normalizedPath] = curBinding.makeChangeArray(function (change)
                        {
                            getSpecialChangeType(session, change, allBindings, allOldBindings);
                            return change.bindingStructureChangeType;
                        });
                    //}
                }
            }
        }

        //if the object changed, process the difference between the new and the old and add it to the current dictionary of changes.
        if (session.bindingHandle.oldState != null && session.bindingHandle.currentState.source != session.bindingHandle.oldState.source)
        {
            if (session.observedDifferences == null)
            {
                session.observedDifferences = _services.diffController.compare(session.bindingHandle.currentState.source, session.bindingHandle.oldState.source);
            }

            /**
            @type {EVUI.Modules.Diff.Comparison[]}*/
            var allChanges = session.observedDifferences.rootComparison.differences; 
            var numChanges = allChanges.length;

            for (var x = 0; x < numChanges; x++)
            {
                var curChange = allChanges[x];
                var objectPath = curChange.getPath();
                if (objectPath == null) continue;

                //first see if the unmodified path is a match
                var curBinding = getBindingContentList(allBindings, objectPath);

                //if we don't have a match the changed object, continue on to the next change
                if (curBinding == null)
                {
                    curBinding = getBindingContentList(allOldBindings, objectPath);
                    if (curBinding == null) continue;
                }

                var aType = (curChange.a == null) ? "object" : typeof curChange.a;
                var bType = (curChange.b == null) ? "object" : typeof curChange.b;

                if (curChange.a != null && curChange.b != null && aType === "object" && bType === "object") //changed
                {
                    var existingChange = modifiedPaths[objectPath];
                    if (existingChange != null) //we already processed this binding, but it may not have been flagged as a change yet, so make sure it's changed.
                    {
                        var numChanges = existingChange.length;
                        for (var y = 0; y < numChanges; y++)
                        {
                            existingChange[y].contentsModified = true;
                        }
                        continue;
                    }

                    modifiedPaths[objectPath] = curBinding.makeChangeArray(function (change)
                    {
                        getSpecialChangeType(session, change, allBindings, allOldBindings);
                        return change.bindingStructureChangeType;
                    });
                }
                else if (bType === "object" && curChange.a == null && curChange.b != null) //removed
                {
                    //if we don't have a match the changed object, continue on to the next change
                    if (curBinding == null) continue;

                    if (modifiedPaths[objectPath] == null) //if the binding isn't in our change dictionary, add it
                    {
                        modifiedPaths[objectPath] = curBinding.makeChangeArray(BindingStructureChangeType.Removed);
                    }
                }
                else if (aType === "object" && curChange.a != null && curChange.b == null) //added
                {
                    //if we still don't have a match the changed object, continue on to the next change
                    if (curBinding == null) continue;

                    if (modifiedPaths[objectPath] == null) //if the binding isn't in our change dictionary, add it
                    {
                        modifiedPaths[objectPath] = curBinding.makeChangeArray(BindingStructureChangeType.Added);
                    }
                }
            }
        }

        //finally, create a list of all the bindings that were not changed so that can have their states swapped as if they were changed 
        var newBindingKeys = Object.keys(allBindings);
        var numKeys = newBindingKeys.length;
        for (var x = 0; x < numKeys; x++)
        {
            var curKey = newBindingKeys[x];
            var modified = modifiedPaths[curKey];

            if (modified === undefined)
            {
                var curBindings = getBindingContentList(allBindings, curKey);                
                for (var y = 0; y < curBindings.numBindings; y++)
                {
                    childDiffs.unchangedBindings.push(curBindings.bindings[y].binding);
                }
            }
            else
            {
                var numModified = modified.length;
                for (var y = 0; y < numModified; y++)
                {
                    var curModified = modified[y];
                    if (curModified.contentsModified === false && curModified.bindingStructureChangeType === BindingStructureChangeType.Shifted)
                    {
                        childDiffs.unchangedBindings.push(curModified.binding);

                        //remove it from our modified paths array
                        modified.splice(y, 1);
                        y--;
                        numModified--;

                        if (numModified === 0) delete modifiedPaths[curKey];
                    }
                }
            }
        }

        return childDiffs;
    };

    /**Gets a special change type for a ChildDifference object.
    @param {BindingSession} session The BindingSession being executed.
    @param {ChildDifference} change The change being checked for a special case.
    @param {Object} allBindings A dictionary containing the keys of all current bindings paired to the corresponding binding.
    @param {Object} allOldBindings  A dictionary containing the keys of all old bindings paired to the corresponding old binding.*/
    var getSpecialChangeType = function (session, change, allBindings, allOldBindings)
    {
        var otherState = change.binding.pendingState != null ? change.binding.pendingState : change.binding.oldState;
        if (otherState == null || otherState.parentBindingKey === change.binding.currentState.parentBindingKey) //if there was no old state or the keys match, the object was changed in place.
        {
            change.contentsModified = true;
            return;
        }

        if (otherState.parentBindingKey !== change.binding.currentState.parentBindingKey) //the key of the binding changed
        {
            if (otherState.source !== change.binding.currentState.source) //..and the object did too. It's a normal change.
            {
                change.contentsModified = true;
                return;
            }

            //the objects match and the keys are different. It's either a swap or a shift.
            var otherBinding = getBindingContentList(allBindings, otherState.normalizedPath);
            if (otherBinding == null) otherBinding = getBindingContentList(allOldBindings, otherState.normalizedPath);
            if (otherBinding != null)
            {
                var unprocessedOtherBinding = otherBinding.getNextUnprocessedBinding();
                if (unprocessedOtherBinding == null)
                {
                    if (change.contentsModified === false)
                    {
                        var childChange = session.oldStateDictionary.getChild(change.binding.currentState.parentBindingKey);
                        change.contentsModified = childChange.haveChildrenChanged();
                    }

                    return;
                }

                unprocessedOtherBinding.processed = true;

                change.moveSwapTarget = unprocessedOtherBinding.binding;
                var otherBindingState = unprocessedOtherBinding.binding.pendingState != null ? unprocessedOtherBinding.binding.pendingState : unprocessedOtherBinding.binding.oldState;
                if (otherBindingState == null) otherBindingState = unprocessedOtherBinding.stateToCheck;
                if (unprocessedOtherBinding.stateToCheck.parentBindingKey === otherState.parentBindingKey && change.binding.currentState.parentBindingKey === otherBindingState.parentBindingKey) //new key of the old binding is the old key of the new binding. It's a swap.
                {
                    change.bindingStructureChangeType = BindingStructureChangeType.Swapped;
                }
                else
                {
                    if (session.isArray === false) //if we're not dealing with an array, the change is a move.
                    {
                        change.bindingStructureChangeType = BindingStructureChangeType.Moved;
                    }
                    else
                    {
                        change.bindingStructureChangeType = BindingStructureChangeType.Shifted;
                    }

                    if (change.contentsModified === false)
                    {
                        var childChange = session.oldStateDictionary.getChild(change.binding.currentState.parentBindingKey);
                        change.contentsModified = childChange.haveChildrenChanged();
                    }
                }

                return;
            }
        }

        //something other than a special case happened, just flag it as changed.
        change.contentsModified = true;
    };


    /**Makes sure that any child Binding's element is a child node of it's parent Binding's element. Having child bindings outside the hierarchy of nodes can lead to unpredictable results.
    @param {BindingSession} session The BindingSession being executed.
    @returns {Boolean}*/
    var isChildElementUnderParent = function (session)
    {
        if (session.parentSession != null)
        {
            if (session.parentSession.isArray === false && session.bindingHandle.currentState.element != null)
            {
                return session.parentSession.bindingHandle.currentState.boundContentFragment.contains(session.bindingHandle.currentState.element); //the bound content fragment should always be there if this is a non-array child
            }
        }

        return true;
    };

    /**Makes sure that a child Binding's source element is not a child of itself. A circular binding will freeze the browser.
    @param {BindingSession} bindingSession The BindingSession being executed.
    @returns {Boolean} */
    var isCircularChildReference = function (bindingSession)
    {
        var curParent = bindingSession.bindingHandle.currentState.parentBindingHandle;
        var parentSources = [];

        while (curParent != null)
        {
            if (parentSources.indexOf(curParent.currentState.source) !== -1) return true;

            parentSources.push(curParent.currentState.source);
            curParent = curParent.currentState.parentBindingHandle;
        }

        if (parentSources.indexOf(bindingSession.bindingHandle.currentState.source) !== -1)
        {
            return true;
        }

        return false;
    };

    /*******************************************************************************BINDING HTML CONTENT MANAGEMENT**************************************************************************/

    /**Gets htmlContent via HTTP if the content entry had a URL but no actual content. All other sessions using the same contentEntry wait for the first one to go get it, then they all continue.
    @param {BindingSession} session The BindingSession being executed.
    @param {BindingHtmlContentEntry} contentEntry The htmlContent container that has the URL to request the content from.
    @param {Function} callback A callback function that takes the string of HTML as a parameter that is called once the request completes. */
    var getHtmlContentViaHttp = function (session, contentEntry, callback)
    {
        if (contentEntry.failed === true) return callback(null); //request was ran and failed. just return null
        if (contentEntry.pending === false) //request is NOT in progress
        {
            var commonCallback = function (result)
            {
                contentEntry.pending = false;
                if (contentEntry.failed === false && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(result) === false)
                {
                    contentEntry.content = result;
                }
                else
                {
                    contentEntry.failed = true;
                }

                //call all the callbacks that were queued for this piece of html content in order of arrival
                callback(result);
                while (contentEntry.pendingCallbacks.length > 0)
                {
                    var curCallback = contentEntry.pendingCallbacks.shift();
                    curCallback(result);
                }
            };

            EVUI.Modules.Core.Utils.require("Http", EVUI.Modules.Binding.Dependencies.Http.version);

            var httpOptions = null;
            if (session.bindingHandle.binding.contentLoadSettings != null)
            {
                httpOptions = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Http.HttpRequestArgs(), session.bindingHandle.binding.contentLoadSettings.httpRequestArgs);
                httpOptions.url = contentEntry.url;
                if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(httpOptions.method) === true) httpOptions.method = "GET";
            }
            else
            {
                httpOptions = new EVUI.Modules.Http.HttpRequestArgs();
                httpOptions.url = contentEntry.url;
                httpOptions.method = "GET";
            }

            contentEntry.pending = true;

            //run the request and return the response into a string.
            _services.httpManager.executeRequest(httpOptions, function (completedRequest)
            {
                contentEntry.pending = false;
                if (completedRequest == null)
                {
                    contentEntry.failed = true;
                    return commonCallback(null);
                }
                else
                {
                    if (completedRequest.success === true) //turn whatever the server returned into a string if possible
                    {
                        var result = completedRequest.response;

                        if (result == null) return commonCallback(null);
                        if (typeof result === "string" && completedRequest.xmlHttpRequest.responseType !== "json") return commonCallback(result);

                        if (completedRequest.xmlHttpRequest.responseType === "json") //must be a JSON encoded string, not an object.
                        {
                            try
                            {
                                result = JSON.parse(result);
                            }
                            catch (ex)
                            {
                                result = null;
                                EVUI.Modules.Core.Utils.log(ex);
                            }

                            if (typeof result === "string") return commonCallback(result);
                            return commonCallback(null);
                        }
                        else if (EVUI.Modules.Core.Utils.instanceOf(result, Blob) === true)
                        {
                            contentEntry.pending = true;
                            EVUI.Modules.Core.Utils.blobToTextAsync(result).then(function (strContent)
                            {
                                contentEntry.pending = false;
                                commonCallback(strContent);

                            }).catch(function (ex)
                            {
                                contentEntry.pending = false;
                                EVUI.Modules.Core.Utils.log(ex);
                                commonCallback(null);
                            });
                        }
                        else if (EVUI.Modules.Core.Utils.instanceOf(result, ArrayBuffer) === true)
                        {
                            var str = null;
                            try
                            {
                                str = new TextDecoder().decode(result);
                            }
                            catch (ex)
                            {
                                EVUI.Modules.Core.Utils.log(ex);
                            }

                            commonCallback(str);
                        }
                        else if (EVUI.Modules.Core.Utils.instanceOf(result, Node) === true)
                        {
                            if (EVUI.Modules.Core.Utils.isElement(result) === true)
                            {
                                return commonCallback(result.outerHTML);
                            }
                            else if (EVUI.Modules.Core.Utils.instanceOf(result, Document) === true)
                            {
                                return commonCallback(result.body.innerHtml);
                            }
                            else
                            {
                                return commonCallback(result.textContent);
                            }
                        }
                        else
                        {
                            return commonCallback(null);
                        }
                    }
                    else
                    {
                        if (completedRequest.error != null && completedRequest.error.exception != null) EVUI.Modules.Core.Utils.log(completedRequest.error.exception);
                        return commonCallback(null);
                    }
                }
            });
        }
        else //if the request is pending, add the callback to the entry's list of callbacks to execute once the request completes.
        {
            contentEntry.pendingCallbacks.push(callback);
        }
    };

    /**Adds a BindingHtmlContentEntry to the cache of stored htmlContents to reference later.
    @param {String|EVUI.Modules.Binding.BindingHtmlContent} key Either the full entry or the string key to store a new entry by.
    @param {String} content The raw html to use.
    @param {String} url The URL where the raw html can be found.
    @returns {BindingHtmlContentEntry} */
    var addCachedHtmlContent = function (key, content, url)
    {
        var tempEntry = {};
        if (key != null && typeof key === "object")
        {
            tempEntry = key;
        }
        else
        {
            tempEntry.key = key;
            tempEntry.content = content;
            tempEntry.url = url;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(tempEntry.key) === true) throw Error("BindingHtmlContent must have a non-whitespace string key.");
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(tempEntry.content) === true && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(tempEntry.url) === true) throw Error("BindingHtmlContent must have either content or a url.");

        var existing = getHtmlContentEntry(tempEntry.key);
        if (existing != null)
        {
            throw Error("BindingHtmlContent entry with the key \"" + tempEntry.key + "\" already exists.");
        }
        else
        {
            var entry = new BindingHtmlContentEntry();
            entry.key = tempEntry.key;
            entry.content = tempEntry.content;
            entry.url = tempEntry.url;
            entry.item = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Binding.BindingHtmlContent(entry), tempEntry, ["key", "content", "url"]);

            _bindingHtmlContentEntries.push(entry);

            return entry;
        }
    };

    /**Removes a BindingHtmlContentEntry from the cache.
    @param {String} key The key of the BindingHtmlContentEntry to remove.
    @returns {Boolean} */
    var removeCachedHtmlContent = function (key)
    {
        var numEntries = _bindingHtmlContentEntries.length;
        for (var x = 0; x < numEntries; x++)
        {
            var curEntry = _bindingHtmlContentEntries[x];
            if (curEntry.item.key === key)
            {
                _bindingHtmlContentEntries.splice(x, 1);
                return true;
            }
        }

        return false;
    };

    /**Gets a BindingHtmlContentEntry by its key.
    @param {String} key The Key of the entry to get.
    @returns {BindingHtmlContentEntry}*/
    var getHtmlContentEntry = function (key)
    {
        var numEntries = _bindingHtmlContentEntries.length;
        for (var x = 0; x < numEntries; x++)
        {
            var curEntry = _bindingHtmlContentEntries[x];
            if (curEntry.item.key === key)
            {                
                return curEntry;
            }
        }

        return null;
    };

    /********************************************************************************BINDING TEMPLATE MANAGEMENT*************************************************************************** */

    /**Gets a BindingTemplate based on its name.
    @param {String} name The name of the BindingTemplate to get.
    @returns {EVUI.Modules.Binding.BindingTemplate} */
    var getBindingTemplate = function (name)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(name) === true) return null;
        var numNamed = _bindingTemplates.length;
        for (var x = 0; x < numNamed; x++)
        {
            var curNamed = _bindingTemplates[x];
            if (curNamed.templateName === name) return curNamed;
        }

        return null;
    };

    /**Makes a BindingTemplate given ambiguous input.
    @param {EVUI.Modules.Binding.Binding} bindingorArgs Either a full binding or parts of a full binding to turn into a BindingTemplate.
    @param {BindingHandle} parentHandle The parent BindingHandle if this Binding is the child of another Binding.
    @returns {EVUI.Modules.Binding.BindingTemplate} */
    var makeBindingTemplate = function (bindingorArgs, parentHandle, bindingEntry)
    {
        var useSameOptions = parentHandle != null && bindingorArgs.options == null && parentHandle.options.shareOptions !== false;
        var useSameLoadSettings = parentHandle != null && bindingorArgs.contentLoadSettings == null && parentHandle.options.shareContentLoadSettings !== false;
        var addTemplateArgs = null;
        var copyTemplateFilter = [
            "id", "source", "context", "bindProgressState", "bindingSource", "bindingTarget", "bindingPath", "element",
            "getBoundProperties", "boundContentFragment", "parentBinding", "parentBindingKey", "getChildBindings",
            "bind", "bindAsync", "dispose", "getBoundContent", "removeChildBinding", "changeBoundPropertyValue"
        ];

        if (bindingEntry == null)
        {
            addTemplateArgs = new EVUI.Modules.Binding.BindingTemplate();
        }
        else
        {
            addTemplateArgs = new EVUI.Modules.Binding.BindingTemplate(bindingEntry);
            copyTemplateFilter.push("templateName");
        }

        addTemplateArgs = EVUI.Modules.Core.Utils.shallowExtend(addTemplateArgs, bindingorArgs, copyTemplateFilter);

        if (useSameOptions === true)
        {
            addTemplateArgs.options = parentHandle.options;
        }
        else
        {
            addTemplateArgs.options = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Binding.BindOptions(), addTemplateArgs.options);
        }

        if (useSameLoadSettings === true)
        {
            addTemplateArgs.contentLoadSettings = parentHandle.binding.contentLoadSettings;
        }
        else
        {
            addTemplateArgs.contentLoadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Binding.BindingContentLoadSettings(), addTemplateArgs.contentLoadSettings);
            if (addTemplateArgs.contentLoadSettings.httpRequestArgs != null)
            {
                addTemplateArgs.contentLoadSettings.httpRequestArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Http.HttpRequestArgs(), addTemplateArgs.contentLoadSettings.httpRequestArgs);
                if (addTemplateArgs.contentLoadSettings.httpRequestArgs.headers != null) addTemplateArgs.contentLoadSettings.httpRequestArgs.headers = addTemplateArgs.contentLoadSettings.httpRequestArgs.headers.map(function (header)
                {
                    return new EVUI.Modules.Http.HttpRequestHeader(header.key, header.value);
                });
            }
        }

        return addTemplateArgs;
    };

    /**Makes a BindingTemplate mock object based on the attribute values of an element.
    @param {Element} ele The element to base the template properties off of.
    @param {BindingHandle} parentHandle The parent BindingHandle if this Binding is the child of another Binding.*/
    var makeTemplateFromElement = function (ele, parentHandle)
    {
        if (EVUI.Modules.Core.Utils.isElement(ele) === false) return null;
        var attributes = getBindingAttributes(ele);
        var attributeTemplate = {};

        var path = attributes.sourcePath;
        var mode = attributes.mode;
        var key = attributes.key;
        var name = attributes.templateName;
        var src = attributes.src;

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(path) === false)
        {
            attributeTemplate.bindingPath = path;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(mode) === false)
        {
            var mode = mode.toLowerCase();
            var insertionModes = EVUI.Modules.Binding.BindingInsertionMode;

            var validModes = [
                insertionModes.Append, insertionModes.Fragment, insertionModes.InsertAfter,
                insertionModes.InsertBefore, insertionModes.Prepend,
                insertionModes.ReplaceChildren, insertionModes.Shadow];

            var numModes = validModes.length;
            for (var x = 0; x < numModes; x++)
            {
                var curMode = validModes[x];
                if (mode.indexOf(curMode) !== -1)
                {
                    attributeTemplate.insertionMode = curMode;
                    break;
                }
            }

            if (mode.indexOf(EVUI.Modules.Binding.BindingMode.Merge) !== -1)
            {
                attributeTemplate.bindingMode = EVUI.Modules.Binding.BindingMode.Merge;
            }
            else if (mode.indexOf(EVUI.Modules.Binding.BindingMode.Overwrite) !== -1)
            {
                attributeTemplate.bindingMode = EVUI.Modules.Binding.BindingMode.Overwrite;
            }
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(key) === false)
        {
            attributeTemplate.htmlContent = key;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(name) === false)
        {
            attributeTemplate.templateName = name;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(src) === false)
        {
            if (typeof attributeTemplate.htmlContent === "string")
            {
                attributeTemplate.htmlContent = {};
                attributeTemplate.htmlContent.key = key;
            }
            else
            {
                attributeTemplate.htmlContent = {};
            }

            attributeTemplate.htmlContent.url = src;
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(attributeTemplate.htmlContent.key) === true)
            {
                var numHtml = _bindingHtmlContentEntries.length;
                for (var x = 0; x < numHtml; x++)
                {
                    var curHtml = _bindingHtmlContentEntries[x];
                    if (curHtml.url === src)
                    {
                        attributeTemplate.htmlContent = curHtml;
                        break;
                    }
                }
            }
        }

        return attributeTemplate;
    };

    /**Gets all the attribute values needed to make a child binding based off of the markup of an Element's attributes.
    @param {Element} element The element to extract the elements from.
    @returns {BindingElementAttributes} */
    var getBindingAttributes = function (element)
    {
        if (element == null) return null;
        var attrs = EVUI.Modules.Core.Utils.getElementAttributes(element);
        var bindingAttributes = new BindingElementAttributes();
        bindingAttributes.key = attrs.getValue(EVUI.Modules.Binding.Constants.Attr_HtmlContentKey);
        bindingAttributes.mode = attrs.getValue(EVUI.Modules.Binding.Constants.Attr_Mode);
        bindingAttributes.templateName = attrs.getValue(EVUI.Modules.Binding.Constants.Attr_BindingTemplateName);
        bindingAttributes.sourcePath = attrs.getValue(EVUI.Modules.Binding.Constants.Attr_BoundObj);
        bindingAttributes.src = attrs.getValue(EVUI.Modules.Binding.Constants.Attr_HtmlContentUrl);

        return bindingAttributes;
    };

    /*******************************************************************************CONTENT METADATA MANAGEMENT****************************************************************************************** */

    /**
     * 
     * @param {String|BindingHtmlContentEntry} htmlOrEntry
     * @returns {HtmlContentMetadata}
     */
    var getHtmlContentMetadata = function (htmlOrEntry)
    {
        if (typeof htmlOrEntry === "object")
        {
            if (htmlOrEntry.needsRecalcuation === true || htmlOrEntry.contentMetata == null)
            {
                htmlOrEntry.contentMetata = makeHtmlContentMetadata(htmlOrEntry.content);
            }

            return htmlOrEntry.contentMetata;
        }
        else
        {
            var numMetadata = _htmlContentMetadata.length;
            for (var x = 0; x < numMetadata; x++)
            {
                var curMetadata = _htmlContentMetadata[x];
                if (curMetadata.html === htmlOrEntry) return curMetadata;
            }

            var newMetadata = makeHtmlContentMetadata(htmlOrEntry);
            _htmlContentMetadata.push(newMetadata);

            return newMetadata;
        }
    };

    /**
     * 
     * @param {String} html
     * @returns {HtmlContentMetadata}
     */
    var makeHtmlContentMetadata = function (html)
    {
        var metadata = new HtmlContentMetadata();
        metadata.html = html;

        var templateTree = _services.domTreeConverter.htmlToDomTree(html);
        templateTree.search(function (ele)
        {
            if (ele.attrs == null) return;
            
            var numAttrs = ele.attrs.length;
            for (var x = 0; x < numAttrs; x++)
            {
                var curAttr = ele.attrs[x];
                if (curAttr.val.indexOf("{{") === -1) continue;
                
                var tokens = getTokenMappingsFromHtmlContent(curAttr.val);
                var numTokens = tokens.length;
                for (var y = 0; y < numTokens; y++)
                {
                    var curToken = tokens[y];
                    if (metadata.attributePaths[curToken.path] == null)
                    {
                        metadata.attributePaths[curToken.path] =  _hashMarker + curToken.path + _hashMarker;
                    }
                }                
            }            
        });

        return metadata;
    };

    /**
     * 
     * @param {BindingSession} session
     * @param {EVUI.Modules.DomTree.DomTreeElement} domTreeElement
     */
    var buildElementMetadata = function (session, domTreeElement)
    {
        if (typeof domTreeElement.content === "string")
        {
            var cleaned = removeHtmlContentTagMarkers(domTreeElement.content);
            domTreeElement.content = cleaned.content;
        }

        var metadata = new ElementMetadata();

        if (domTreeElement.attrs == null) return metadata;
        var numAttrs = domTreeElement.attrs.length;

        //walk all the attributes on the element and see if they were a data-bound attributes
        for (var x = 0; x < numAttrs; x++)
        {
            var curAttr = domTreeElement.attrs[x];
            var attributeMetadata = new AttributeMetadata();
            attributeMetadata.name = curAttr.key;

            var values = curAttr.val.split(/\s+/);
            var lowerKey = curAttr.key.toLowerCase();

            //if (EVUI.Modules.Core.Utils.stringStartsWith("on", lowerKey) === true && HTMLElement.prototype.hasOwnProperty(lowerKey) === true)
            //{
            //    values.push(curAttr.val);
            //}
            //else
            //{
            //    values = curAttr.val.split(/\s+/);
            //}


            var numValues = values.length;
            var attrString = "";
            var attrTokenizedString = "";

            for (var y = 0; y < numValues; y++)
            {
                var attribtueValueMetadata = new AttributeValueMetadata();
                attributeMetadata.values.push(attribtueValueMetadata);

                //get the list of all the paths that were bound to the attribute value and the cleaned content that no longer includes the hash markers.
                var cleanData = removeHtmlContentTagMarkers(values[y]);

                attrString += " " + cleanData.content;
                attribtueValueMetadata.value = cleanData.content;

                var tokenizedString = cleanData.content;
                var numBound = cleanData.paths.length;
                for (var z = 0; z < numBound; z++)
                {
                    attributeMetadata.containsBoundValues = true;
                    attribtueValueMetadata.wasBound = true;

                    var curBound = cleanData.paths[z];
                    var matchingProp = session.boundPropertyDictionary[curBound];

                    var boundMetadata = new BoundAttributeValueMetadata();
                    boundMetadata.boundContent = (matchingProp == null) ? "" : matchingProp.value;
                    boundMetadata.boundPath = curBound;

                    tokenizedString = tokenizedString.replace(matchingProp.value, "{{" + curBound + "}}");
                    attribtueValueMetadata.boundValues.push(boundMetadata);
                }

                attribtueValueMetadata.tokenizedString = tokenizedString;
                attrTokenizedString += " " + tokenizedString;
            }

            //assign the cleaned attribute value so what gets injected into the DOM is correct and what the user intended to be injected
            attrString = attrString.trim();
            curAttr.val = attrString;
            attributeMetadata.value = attrString;
            attributeMetadata.tokenizedValue = attrTokenizedString.trim(); //tokenizedString.trim();

            metadata.attributes[curAttr.key] = attributeMetadata;
        }

        return metadata;
    };

    /**
     * 
     * @param {String} str
     */
    var removeHtmlContentTagMarkers = function (str)
    {
        if (typeof str !== "string" || str.length === 0) return {paths: [], content: str};

        var tokenPaths = [];

        var hashMarkerIndex = str.indexOf(_hashMarker);
        while (hashMarkerIndex !== -1)
        {
            var nextMarker = str.indexOf(_hashMarker, hashMarkerIndex + 1);
            if (nextMarker === -1) break;

            var token = str.substring(hashMarkerIndex, nextMarker + _hashMarkerLength);

            var existing = _escapedPathCahce[token];
            if (existing == null)
            {
                existing = new RegExp(token.replace(_escapeRegexRegex, function (val) { return "\\" + val; }), "g");
                _escapedPathCahce[token] = existing;
            }

            str = str.replace(existing, "");

            var tokenPath = token.substring(_hashMarkerLength, token.length - _hashMarkerLength);
            if (tokenPath.length > 0) tokenPaths.push(tokenPath);

            hashMarkerIndex = str.indexOf(_hashMarker);
        }

        var cleanedData = { paths: tokenPaths, content: str };
        return cleanedData;
    };

    /**
     * 
     * @param {Node} node
     * @returns {ElementMetadata}
     */
    var getElementMetadata = function (node)
    {
        return node[_hashMarker];
    };

    /*******************************************************************************BINDING HANDLE CREATION****************************************************************************************** */

    /**Creates a BindingHandle object based off of any combination of the properties of the possible inputs that can be used to make a binding handle.
    @param {EVUI.Modules.Binding.Binding|EVUI.Modules.Binding.BindingTemplate|EVUI.Modules.Binding.BindArgs|String} ambiguousInput The input that will be used to make the BindingHandle.
    @param {BindingHandle} parentHandle The parent Binding of this Binding if it is the child of another Binding.
    @returns {BindingHandle}*/
    var getBindingHandleAmbiguously = function (ambiguousInput, parentHandle)
    {
        if (ambiguousInput == null) return null;

        var bindingHandle = new BindingHandle(makeControllerWrapper());
        var bindingArgs = null;
        var bindingTemplateFound = false;

        var inputType = typeof ambiguousInput;
        if (inputType === "string") //first see if we got a string - this can either be the name of a pre-built named binding or the ID of an existing binding
        {
            var bindingTemplate = getBindingTemplate(ambiguousInput); //try getting the named binding first
            if (bindingTemplate != null)
            {
                bindingArgs = makeBindingTemplate(bindingTemplate, parentHandle);
                bindingTemplateFound = true;
            }
            else
            {
                return null; //couldn't resolve the named binding, return nothing.
            }
        }

        if (inputType !== "object" && bindingArgs == null) return null; //if we got something other than an object or a string, also return nothing.

        if (EVUI.Modules.Core.Utils.instanceOf(ambiguousInput, EVUI.Modules.Binding.Binding) === true) //see if we were handed an existing binding
        {
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(ambiguousInput.templateName) === false) //see if it has a name, if it does try and load the named binding
            {
                var bindingTemplate = getBindingTemplate(ambiguousInput.templateName);
                if (bindingTemplate != null) //use the named binding
                {
                    bindingTemplate = EVUI.Modules.Core.Utils.shallowExtend({}, bindingTemplate); //copy the binding onto a blank object
                    bindingTemplate = EVUI.Modules.Core.Utils.shallowExtend(bindingTemplate, ambiguousInput); //copy our input object onto the new clone of the binding template
                    bindingArgs = makeBindingTemplate(bindingTemplate, parentHandle); //then make the final args from the union
                }
                else //no named binding, but a valid name. Add it.
                {
                    bindingArgs = _self.addBindingTemplate(ambiguousInput);
                }

                bindingTemplateFound = true;
            }
            else //no valid name, just make the binding object into a AddBindingArgs object.
            {
                bindingArgs = makeBindingTemplate(ambiguousInput, parentHandle);
            }            
        }

        //see if we were handed a valid element we can extract attributes from
        var ele = null;
        if (EVUI.Modules.Core.Utils.isElement(ambiguousInput.element))
        {
            ele = ambiguousInput.element;
        }
        else if (EVUI.Modules.Core.Utils.isElement(ambiguousInput.bindingTarget))
        {
            ele = ambiguousInput.bindingTarget;
        }

        var bindingAttributeTemplate = makeTemplateFromElement(ele, parentHandle); //pull off the settings from the element that is being used to make the binding
        if (bindingAttributeTemplate != null && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(bindingAttributeTemplate.templateName) === false)
        {
            ambiguousInput.templateName = bindingAttributeTemplate.templateName;
        }

        if (bindingTemplateFound === false && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(ambiguousInput.templateName) === false) //no named binding found, and it was not a Binding object
        {
            var bindingTemplate = getBindingTemplate(ambiguousInput.templateName); //see if we can get a named binding
            if (bindingTemplate == null) //no named binding, go add one
            {
                bindingArgs = _self.addBindingTemplate(ambiguousInput);
            }
            else //use the named binding
            {
                bindingTemplate = EVUI.Modules.Core.Utils.shallowExtend({}, bindingTemplate); //copy the binding onto a blank object
                bindingTemplate = EVUI.Modules.Core.Utils.shallowExtend(bindingTemplate, ambiguousInput); //copy our input object onto the new clone of the binding template
                bindingArgs = makeBindingTemplate(bindingTemplate, parentHandle); //then make the final args from the union

                bindingTemplateFound = true;
            }
        }

        if (bindingAttributeTemplate != null) //if we had element settings, apply them last so that they always override the template's settings (if it was made at all)
        {
            if (bindingArgs != null)
            {
                bindingArgs = EVUI.Modules.Core.Utils.shallowExtend(bindingArgs, bindingAttributeTemplate, function (propName, sourceObj) { if (sourceObj[propName] == null) return true; });
            }
            else
            {
                ambiguousInput = EVUI.Modules.Core.Utils.shallowExtend(ambiguousInput, bindingAttributeTemplate);
            }
        }

        //if we still don't have binding args, make a set of them from the input
        if (bindingArgs == null) bindingArgs = makeBindingTemplate(ambiguousInput, parentHandle);

        //set the recursive events if no template was found and we have a parent binding handle
        if (bindingTemplateFound === false && parentHandle != null)
        {
            var bindingTemplate = getBindingTemplate(parentHandle.templateName); //see if we can get a named binding
            if (bindingTemplate != null) //no named binding, go add one
            {
                bindingTemplate = EVUI.Modules.Core.Utils.shallowExtend({}, bindingTemplate); //copy the binding onto a blank object
                bindingArgs = makeBindingTemplate(bindingTemplate, parentHandle); //then make the final args from the union
            }
            else
            {
                if (parentHandle.htmlContent != null && bindingArgs.htmlContent == null)
                {
                    bindingArgs.htmlContent = parentHandle.htmlContent.item;
                }
            }

            if (parentHandle.options.recursiveEvents === true)
            {
                bindingArgs.onBind = parentHandle.binding.onBind;
                bindingArgs.onBindChildren = parentHandle.binding.onBindChildren;
                bindingArgs.onBindHtmlContent = parentHandle.binding.onBindHtmlContent;
                bindingArgs.onBound = parentHandle.binding.onBound;
                bindingArgs.onChildrenBound = parentHandle.binding.onChildrenBound;
                bindingArgs.onSetBindings = parentHandle.binding.onSetBindings;
                bindingArgs.onSetHtmlContent = parentHandle.binding.onSetHtmlContent;
            }
        }
       
        bindingHandle.id = _bindingIDCounter++;
        bindingHandle.currentState = new BindingHandleState();
        bindingHandle.binding = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Binding.Binding(bindingHandle), bindingArgs, ["templateName"]);
        bindingHandle.progressState = EVUI.Modules.Binding.BindingProgressStateFlags.Idle;
        bindingHandle.templateName = bindingArgs.templateName;
        bindingHandle.htmlContent = (typeof bindingArgs.htmlContent === "object") ? bindingArgs.htmlContent : bindingHandle.htmlContent;

        var ele = (ambiguousInput.bindingTarget == null) ? ambiguousInput.element : ambiguousInput.bindingTarget;
        var source = (ambiguousInput.bindingSource == null) ? ambiguousInput.source : ambiguousInput.bindingSource;

        //if we were handed a BindingArgs (rather than a Binding or AddBindingArgs object)
        if (ele != null && bindingHandle.currentState.element == null) bindingHandle.currentState.element = getValidElement(ele);
        if (source != null && bindingHandle.binding.source == null && typeof source === "object")
        {
            bindingHandle.binding.source = source;
        }
        else if (bindingAttributeTemplate != null && bindingAttributeTemplate.bindingPath != null)
        {
            var value = null;
            if (parentHandle != null)
            {
                value = EVUI.Modules.Core.Utils.getValue(bindingAttributeTemplate.bindingPath, parentHandle.currentState.source);
            }
            else
            {
                value = EVUI.Modules.Core.Utils.getValue(bindingAttributeTemplate.bindingPath, window);
            }

            if (value != null) bindingHandle.binding.source = value;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(bindingArgs.htmlContent) === false) bindingHandle.currentState.htmlContent = bindingArgs.htmlContent;


        return bindingHandle;
    };

    /**Makes the controller wrapper that is injected into a Binding object so that it can access select parts of the controller from outside the controller.
    @returns {BindingControllerWrapper}*/
    var makeControllerWrapper = function ()
    {
        var wrapper = new BindingControllerWrapper();
        wrapper.controller = _self;
        wrapper.triggerDispose = triggerDispose;
        wrapper.triggerBind = triggerBind;
        wrapper.validateElement = validateElement;
        wrapper.getValidElement = getValidElement;
        wrapper.triggerUpdate = triggerUpdate;
        wrapper.toDomNode = toDomNode;

        return wrapper;
    };

    /**********************************************************************************ELEMENT HANDLING*******************************************************************************************/

    /**Validates that there is a theoretically valid value for a Binding's element assigned.
    @param {String|DocumentFragment|Element} value The value to check.
    @returns {Boolean}*/
    var validateElement = function (value)
    {
        if (value == null)
        {
            return true;
        }
        else if (typeof value === "string" && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(value) === false)
        {
            return true;
        }
        else
        {
            if (value instanceof DocumentFragment)
            {
                return true;
            }
            else
            {
                if (EVUI.Modules.Core.Utils.isElement(value) === true)
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }
    };

    /**Gets a valid element value out of the current (potentially invalid) value of an element.
    @param {String|DocumentFragment|Element} value The value to extract the valid value from.
    @param {Boolean} mustBeElement Whether or not the value must already be an element.
    @returns {String|Element} */
    var getValidElement = function (value, mustBeElement)
    {
        if (value instanceof DocumentFragment) return value;
        if (mustBeElement !== true && typeof value === "string" && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(value) === false) return value;
        if (EVUI.Modules.Core.Utils.isElement(value) === true) return value;

        var extracted = EVUI.Modules.Core.Utils.getValidElement(value);
        if (extracted != null) return extracted;

        if (value instanceof EVUI.Modules.Dom.DomHelper) return value.elements[0];

        return null;
    };

    /**********************************************************************************HTML CONTENT DUPLICATION*******************************************************************************************/

    /**Walks the html content and pulls out anything surrounded by {{ and }}.
    @method getTokenMappings
    @param {String} htmlContent The htmlContent to pull token values out of.
    @returns {TokenMapping[]}*/
    var getTokenMappingsFromHtmlContent = function (htmlContent)
    {
        if (typeof htmlContent !== "string") return [];
        

        var props = [];
        var htmlLength = htmlContent.length;
        var curIndex = 0;

        while (curIndex < htmlLength)
        {
            var firstDoubleCurly = htmlContent.indexOf("{{", curIndex);
            if (firstDoubleCurly == -1) break;

            var secondDoubleCurly = htmlContent.indexOf("}}", firstDoubleCurly);
            if (secondDoubleCurly == -1) break;

            curIndex = secondDoubleCurly;

            var boundProp = htmlContent.substring(firstDoubleCurly + 2, secondDoubleCurly);
            if (props.indexOf(boundProp) !== -1) continue; //don't include any properties that already exist in the bound properties list

            props.push(boundProp);
        }

        //make the array of return objects (they're objects in case we need to extend this later, although its unneeded at the moment)
        return props.map(function (prop)
        {
            var mapping = new TokenMapping();
            mapping.path = prop;
            return mapping;
        });
    };

    /**Duplicates a Html content based on the properties of the object passed in along with the Html content.
    @param {Object} obj The object that contains the properties to populate the Html content with.
    @param {String} htmlContent The Html content to populate with values from the object.
    @param {EVUI.Modules.Binding.BoundProperty[]} mappings An array of TokenMapping representing the tokens to replace in the htmlContent.
    @param {HtmlContentMetadata} contentMetadata The metadata describing the special properties of the htmlContent.
    @returns {String}*/
    var duplicateHtmlContent = function (session, htmlContent, mappings, contentMetadata)
    {
        if (mappings == null || mappings.length === 0) return htmlContent;
        if (typeof htmlContent !== "string") return null;

        var result = htmlContent;
        var numMappings = mappings.length;

        for (var x = 0; x < numMappings; x++)
        {
            var curProperty = mappings[x];
            if (curProperty.value === undefined) continue;

            var replacementValue = null;
            if (typeof curProperty.value === "function")
            {
                replacementValue = addInvocationHandle(session, curProperty);
            }
            else
            {
                replacementValue = curProperty.value;
            }

            if (replacementValue == null) replacementValue = "";
            var boundItemMarker = contentMetadata.attributePaths[curProperty.path];

            if (boundItemMarker != null) replacementValue += boundItemMarker;

            try
            {
                var existing = _escapedPathCahce[curProperty.path];
                if (existing == null)
                {
                    existing = new RegExp("{{" + curProperty.path.replace(_escapeRegexRegex, function (val) { return "\\" + val; }) + "}}", "g");;
                    _escapedPathCahce[curProperty.path] = existing;
                }

                result = result.replace(existing, replacementValue);
            }
            catch (ex)
            {
                EVUI.Modules.Core.Utils.log(ex);
            }
        }

        return result;
    };

    var getNormalizedPath = function (path)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(path) === true) return path;
        var path = path.replace(/\.|\[|\]\.|\]/g, ".");

        if (EVUI.Modules.Core.Utils.stringEndsWith(".", path) === true) path = path.substring(0, path.length - 1);
        return path;
    };

    /****************************************************************************EVENT DISPATCH HANDLING******************************************************************************************** */


    var getInvocationHash = function (session, boundProperty)
    {
        return EVUI.Modules.Core.Utils.getHashCode(_salt + session.bindingHandle.id + ":" + boundProperty.path).toString(36);
    }

    /**Makes a public event handler to invoke a function that is being data-bound to html content, the handler is attached to the $evui.dispatch global object by a key based on the hash code of the property name and binding handle ID.
    @param {BindingSession} session The BindingSession being executed.
    @param {EVUI.Modules.Binding.BoundProperty} boundProperty The property that is binding a function to the Html.
    @returns {String} */
    var addInvocationHandle = function (session, boundProperty)
    {
        if (typeof boundProperty.value !== "function") return null;

        var fn = boundProperty.value;
        var hashKey = getInvocationHash(session, boundProperty);
        var replacementValue = "$evui.dispatch(event, '" + hashKey + "')";

        //look to see if we don't have the same handler there already
        var existing = _invocationDictionary[hashKey];
        if (existing != null)
        {
            if (existing.handler === fn)
            {
                return replacementValue;
            }
            else
            {
                session.rollbackDispatchHandles.push(existing);
                existing.dispose();
            }
        }     
        
        //we did not, make a new handler to put there
        var handle = new BindingDispatchHandle();
        handle.handler = fn;
        handle.id = _dispatchIDCounter;
        handle.binding = session.bindingHandle;
        handle.path = boundProperty.path;
        handle.hashKey = hashKey;
        handle.invocationHandle = function (eventArgs)
        {
            var invocationSite = getInvocationSite(handle, eventArgs);
            if (invocationSite == null)
            {
                invocationSite = new BindingDispatchInvocationSite();
                invocationSite.currentTarget = eventArgs.currentTarget;
                invocationSite.eventName = eventArgs.type;

                handle.invocationSites.push(invocationSite);
            }

            if (handle.binding.options.eventContextMode === EVUI.Modules.Binding.BoundEventContextMode.ParentObject)
            {
                //get the parent object to invoke the handler with
                var normalized = getNormalizedPath(handle.path);
                var lastDotIndex = normalized.lastIndexOf(".");
                var owningObject = null;

                if (lastDotIndex === -1)
                {
                    owningObject = handle.binding.currentState.source;
                }
                else
                {
                    var objPath = normalized.substring(0, lastDotIndex);
                    owningObject = EVUI.Modules.Core.Utils.getValue(objPath, handle.binding.currentState.source);
                }

                //couldn't find the object, fall back to the window
                if (owningObject == null) owningObject = window;

                return handle.handler.call(owningObject, eventArgs, handle.binding.binding);
            }
            else if (handle.binding.options.eventContextMode === EVUI.Modules.Binding.BoundEventContextMode.Element)
            {
                return handle.handler.call(eventArgs.currentTarget, eventArgs, handle.binding.binding);
            }
            else
            {
                throw Error("Invalid eventContextMode: " + handle.binding.options.eventContextMode)
            }
        };

        _invocationDictionary[handle.hashKey] = handle;
        session.bindingHandle.dispatchHandles.push(handle);

        return replacementValue;
    };

    /**Gets an BindingDispatchInvocationSite based on the currentTarget of the event args.
    @param {BindingDispatchHandle} dispatchHandle The dispatch handle handling the event.
    @param {Event} eventArgs The event arguments for the event.
    @returns {BindingDispatchInvocationSite}  */
    var getInvocationSite = function (dispatchHandle, eventArgs)
    {
        var numSites = dispatchHandle.invocationSites.length;
        for (var x = 0; x < numSites; x++)
        {
            var curSite = dispatchHandle.invocationSites[x];
            if (curSite.eventName === eventArgs.type)
            {
                if (curSite.currentTarget === eventArgs.currentTarget) return curSite;
            }
        }

        return null;
    };

    /**Invokes the function found in the invocationDictionary based on the hash code of the handle.
    @param {Event} eventArgs The browser's event args for the event.
    @param {String} handleHash The hash code of the handle to invoke.
    @returns {Any}*/
    var invokeHandle = function (eventArgs, handleHash)
    {
        var dispatchHandle = _invocationDictionary[handleHash];
        if (dispatchHandle == null)
        {
            var logMessage = "Dispatch function for event " + eventArgs.type + " element " + getElementMoniker(eventArgs.currentTarget) + " could not be found.";
            EVUI.Modules.Core.Utils.log(logMessage);

            return;
        }

        return dispatchHandle.invocationHandle(eventArgs, dispatchHandle.binding);
    };

    //make a global object for the event handlers to call.
    Object.defineProperty($evui, "dispatch", {
        get: function ()
        {
            return invokeHandle;
        },
        enumerable: false
    });

    /**Gets an identifying name for an element to appear in a log message.
    @param {Element} element
    @returns {String}*/
    var getElementMoniker = function (element)
    {
        var moniker = element.tagName.toLowerCase();

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(element.id) === false)
        {
            moniker += "#" + element.id;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(element.className) === false)
        {
            moniker += "." + element.className.trim().replace(/\s/g, ".");
        }

        moniker;
    };

    var cacheObjectKeys = function ()
    {
        EVUI.Modules.Core.Utils.cacheProperties(new BindingHandleState())
    };

    /****************************************************************************OBJECT DEFINITIONS******************************************************************************************** */

    /**Object for containing the parse results of some Html Content.
    @class*/
    var TokenMapping = function ()
    {
        /**String. The name of the property from the htmlContent that was surrounded with {{ and }}. */
        this.path = null;
    };

    /**A container for a stored HTML content.
    @class*/
    var BindingHtmlContentEntry = function ()
    {
        /**Object. The public facing properties of this object.
        @type {EVUI.Modules.Binding.BindingHtmlContent}*/
        this.item = null;

        /**String. The key used to identify the content.
        @type {String}*/
        this.key = null;

        /**String. The URL where the HTNL content can be loaded from.
        @type {String}*/
        this.url = null;

        /**String. The raw HTML of the content.
        @type {String}*/
        this.content = null;

        /**Whether or not the token mappings need to be recalculated. 
        @type {Boolean}*/
        this.needsRecalcuation = true;

        /**Array. The mappings of properties found in the HTML.
        @type {TokenMapping[]}*/
        this.tokenMappings = null;

        /**Boolean. Whether or not this html content is actively being retrieved from a server.
        @type {Boolean}*/
        this.pending = false;

        /**Boolean. Whether or not the content was loaded via HTTP.
        @type {Boolean}*/
        this.loaded = false;

        /**Boolean. Whether or not the HTTP request to get this content failed.
        @type {Boolean}*/
        this.failed = false;

        /**Boolean. If the HTML was changed after it was loaded, it no longer matches it's URL.
        @type {Boolean}*/
        this.ignoreUrl = false;

        /**Array. All of the callbacks that are waiting on this partial to be loaded.
        @type {Function[]}*/
        this.pendingCallbacks = [];
    
        /**Object. The special metadata about this html content.
        @type {HtmlContentMetadata}*/
        this.contentMetata = null;
    };

    /**The container for the state differences between binding sessions for a given Binding.
    @class*/
    var BindingHandle = function (controllerWrapper)
    {
        if (controllerWrapper instanceof BindingControllerWrapper === false) throw Error("Invalid parameters.");

        /**Object. The wrapper for the controller and a few functions to expose in the binding object.
        @type {BindingControllerWrapper}*/
        this.wrapper = controllerWrapper;

        /**Number. The ID of the binding instance.
        @type {Number}*/
        this.id = null;

        /**String. The current state of the binding operation.
        @type {String}*/
        this.progressState = EVUI.Modules.Binding.BindingProgressStateFlags.Idle;

        /**String. The BindingTemplate that this binding is based off of.
        @type {String}*/
        this.templateName = null;

        /**Object. Options object for the Binding.
        @type {EVUI.Modules.Binding.BindOptions}*/
        this.options = null;

        /**Object. The public Binding object that is exposed to the outside.
        @type {EVUI.Modules.Binding.Binding}*/
        this.binding = null;

        /**Object. The current state of the binding operation.
        @type {BindingHandleState}*/
        this.currentState = null;

        /**Object. The previous state of the binding operation.
        @type {BindingHandleState}*/
        this.oldState = null;

        /**Object. The current in-progress state of the binding operation.
        @type {BindingHandleState}*/
        this.pendingState = null;

        /**Boolean. Whether or not to flush the Binding once it has been bound.
        @type {Boolean}*/
        this.disposing = false;

        /**Boolean. Whether or not the current state of the object has already been bound.
        @type {Boolean}*/
        this.newStateBound = false;

        /**Boolean. Whether or not the old state of the object has already been bound.
        @type {Boolean}*/
        this.oldStateBound = false;

        /**Array. An array of event handlers that are bound to this Binding.
        @type {BindingDispatchHandle[]}*/
        this.dispatchHandles = [];

        /**Boolean. Whether or not this binding was canceled after it's "shouldReBind" flag had been set, which means that any observed differences in the source object have been calculated and the ObjectObserver has had it's state set to the new state, which will prevent those changes from being detected when re-run post cancellation. If this flag is set, a re-bind operation is forced.
        @type {Boolean}*/
        this.canceledDuringReBind = false;

        /**Object. The BindingHtmlContentEntry used for this Binding.
        @type {BindingHtmlContentEntry}*/
        this.htmlContent = null;

        /**String. The state in which the Binding is in after its execution ends.
        @type {String}*/
        this.completionState = EVUI.Modules.Binding.BindingCompletionState.None;
    };

    /**The container for the state of the binding at a moment in time.
    @class*/
    var BindingHandleState = function ()
    {
        /**String. The ID of this state.
        @type {String}*/
        this.stateId = _bindingStateIDCounter++;

        /**String. The htmlContent used to generate the final DOM nodes of the binding.
        @type {String|Element|EVUI.Modules.Binding.BindingHtmlContent}*/
        this.htmlContent = null;

        /**Object. The BindingHandle that triggered the creation of this one.
        @type {BindingHandle}*/
        this.parentBindingHandle = null;

        /**Object|String. The element that the binding will be bound to.
        @type {Element|String}*/
        this.element = null;

        /**String. The property name of the parent binding's source object that triggered the creation of this child binding.
        @type {String}*/
        this.parentBindingKey = null;

        /**String. The "path" from the parent Binding's source object to this Binding's source object.
        @type {String}*/
        this.parentBindingPath = null;

        /**Array. The collection of child bindings that this binding triggered the creation of.
        @type {BindingHandle[]}*/
        this.childBindingHandles = [];

        /**Object. The source object used as the source of the values used to merge into the htmlContent.
        @type {Object}*/
        this.source = null;

        /**String. The value hash code of the source object when it was originally assigned.
        @type {String}*/
        this.sourceHashCode = null;

        /**Object. The ObjectObserver watching the source object to keep track of its changes.
        @type {EVUI.Modules.Observers.ObjectObserver}*/
        this.sourceObserver = null;

        /**Array. All of the bound properties of that were found in the source object.
        @type {EVUI.Modules.Binding.BoundProperty[]}*/
        this.boundProperties = null;

        /**String. The final merged htmlContent before it is turned into a DOM element.
        @type {String}*/
        this.mergedHtmlContent = null;

        /**Object. The DocumentFragment holding the result of the htmlContent merging operation.
        @type {DocumentFragment}*/
        this.boundContentFragment = null;

        /**A DomTreeElement hierarchy parsed from the bound HTML htmlContent that will lazily be turned into actual DOM nodes upon request.
        @type {EVUI.Modules.DomTree.DomTreeElement}*/
        this.boundContentTree = null;

        /**Object. The root elements of the final HTML htmlContent after it has been injected into the DOM.
        @type {Node[]}*/
        this.boundContent = null;

        /**Boolean. Whether or not the element was set.
        @type {Boolean}*/
        this.elementSet = false;

        /**Boolean. Whether or not the element was set.
        @type {Boolean}*/
        this.sourceSet = false;

        /**Boolean. Whether or not the htmlContent was set.
        @type {Boolean}*/
        this.htmlContentSet = false;

        /**Object. A clone of the freshly made boundContentFragment that is used for re-binding the Binding on subsequent runs.
        @type {DocumentFragment}*/
        this.boundTemplateContentClone = null;

        /**String. The full path to the Binding starting at their highest parent's path.
        @type {String}*/
        this.normalizedPath = null;
    };

    /**Gets the full path of a BindingHandle's state given the current parents above it.
    @returns {String}*/
    BindingHandleState.prototype.getNormalizedPath = function ()
    {
        return getNormalizedPath(this.parentBindingPath);

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(this.parentBindingPath) === true) return this.parentBindingPath;
        var path = this.parentBindingPath.replace(/\.|\[|\]\.|\]/g, ".");

        if (EVUI.Modules.Core.Utils.stringEndsWith(".", path) === true) path = path.substring(0, path.length - 1);
        return path;
    }

    /**Wrapper object for injecting into a Binding so that it can use parts of the controller from outside the controller.
    @class*/
    var BindingControllerWrapper = function ()
    {
        /**Reference to the BindingController.
        @type {EVUI.Modules.Binding.BindingController}*/
        this.controller = null;

        /**Reference to the function that kicks off the full bind process.
        @type {triggerBind}*/
        this.triggerBind = null;

        /**Reference to the function that disposes of a Binding.
        @type {triggerDispose}*/
        this.triggerDispose = null;

        /**Reference to the function that kicks off the "smart" update function.
        @type {triggerUpdate}*/
        this.triggerUpdate = null;

        /**Reference to the function that validates element input.
        @type {validateElement}*/
        this.validateElement = null;

        this.toDomNode = null;
    };

    /**Container for all things related to an active Binding in progress.
    @class*/
    var BindingSession = function ()
    {
        /**String. The ID of the binding session.
        @type {Number}*/
        this.sessionId = _sessionIDCounter++;

        /**Object. The binding handle of the binding being bound.
        @type {BindingHandle}*/
        this.bindingHandle = null;

        /**Object. The binding arguments for what will be bound.
        @type {EVUI.Modules.Binding.BindArgs}*/
        this.bindingArgs = null;

        /**Object. The event stream executing the binding operation.
        @type {EVUI.Modules.EventStream.EventStream}*/
        this.eventStream = null;

        /**Array. The array of callbacks to call once this operation completes.
        @type {BindingCallbackEntry[]}*/
        this.callbacks = [];

        /**Whether or not another session came along and canceled this one to prevent a race condition.
        @type {Boolean}*/
        this.cancel = false;

        /**Array. The original set of BoundProperties that was pulled out of the source object.
        @type {EVUI.Modules.Binding.BoundProperty[]} */
        this.originalBoundProps = [];

        /**Array. All of the child BindingSessions that were spawned by this session.
        @type {BindingSession[]}*/
        this.childSessions = [];

        /**Object. Any contextual information to carry around for the binding operation.
        @type {Object}*/
        this.context = {};

        /**Boolean. Whether or not to maintain the currentState of the Binding when the binding process begins.
        @type {Boolean}*/
        this.maintainCurrentState = false;

        /**Object|Array. The differences between the old source object and the new source object.
        @type {EVUI.Modules.Observers.ObservedChangedProperty[]|EVUI.Modules.Diff.CompareResult}*/
        this.observedDifferences = null;

        /**Object. The ObservedProperties that are in the ObjectObserver prior to its new changes being calculated and its state updated.
        @type {EVUI.Modules.Observers.ObservedProperty}*/
        this.oldStateDictionary = null;

        /**Boolean. Whether or not the binding logic should fire again and make a fresh document fragment for this session's Binding.
        @type {Boolean}*/
        this.shouldReBind = true;

        /**Object. The session that spawned this one.
        @type {BindingSession}*/
        this.parentSession = null;

        /**Object. The last inserted node from any child in the session.
        @type {Node}*/
        this.lastInsertedNode = null;

        /**Boolean. Whether or not the source object for this session is an array.
        @type {Boolean}*/
        this.isArray = false;

        /**Number. The ID of the BindingSessionBatch that this BindingSession is being processed in.
        @type {Number}*/
        this.batchId = -1;

        /**Number. The type of action the session is performing. Must be a value from BindingSessionMode.
        @type {Number}*/
        this.sessionMode = BindingSessionMode.None;

        /**Object.The bindingHandle's oldState that is used to roll back to the previous state in the event of a cancel operation.
        @type {BindingHandleState}*/
        this.rollbackState = null;

        /**Object. The pending state that was applied to the current state. Is used in the event of a rollback.
        @type {BinindgHandleState}*/
        this.rollbackPendingState = null;

        /**Array. An array of BindingDispatchHandles to re-attach in the event of a cancellation.
        @type {BindingDispatchHandle[]}*/
        this.rollbackDispatchHandles = [];

        /**Object. A dictionary of all the bound properties and their values that were used in the binding process.
        @type {{}}*/
        this.boundPropertyDictionary = {};
    };

    /**Represents a matching of a binding session as referring to the same Binding, Element, or Source object as another session.
    @class*/
    var BindingSessionMatch = function ()
    {
        /**Object. The binding session that was a match to another session.
        @type {BindingSession}*/
        this.session = null;

        /**Number. The BindingSessionMatchTypeFlags value indicating what matched the other session.
        @type {Number}*/
        this.flags = BindingSessionMatchTypeFlags.None;
    };

    /**Flags for describing what matched in a comparison of two BindingSessions.
    @class*/
    var BindingSessionMatchTypeFlags =
    {
        None: 0,
        SameBinding: 1,
        SameElement: 2,
        SameSource: 4
    };

    /**Entry for associating a callback function passed into the bind or update functions to a given session that is called once the session completes.
    @class*/
    var BindingCallbackEntry = function ()
    {
        /**Number. The sequential ID of the callback, used to ensure that they are called in order when more than one will be called at the end of a binding process (i.e. if one session matched another the callbacks are merged into the newer session). 
        @type {Number}*/
        this.id = -1;

        /**Function. The callback to call.
        @type {EVUI.Modules.Binding.Constants.Fn_BindingCallback}*/
        this.callback = null;

        /**Object. The BindingSession that is tied to the callback.
        @type {BindingSession}*/
        this.session = null;
    };

    /**Object that is populated with the special attribute values that are present on an Element.
    @class*/
    var BindingElementAttributes = function ()
    {
        /**String. The name of the BindingTemplate to use.
        @type {String}*/
        this.templateName = null;

        /**String. The key of any existing htmlContent to use.
        @type {String}*/
        this.key = null;

        /**String. The path from the current parent Binding's source (or from the Window if there is no parent Binding) to the child Binding's source object.
        @type {String}*/
        this.sourcePath = null;

        /**String. The URL of the htmlContent to use.
        @type {String}*/
        this.src = null;

        /**String. A combination of BindingMode and Insertion mode to give the Binding.
        @type {String}*/
        this.mode = null;
    };

    /**Represents the bare minimum amount of information needed to make a child Binding.
    @class*/
    var BoundChild = function ()
    {
        /**Object. The Element the source will be bound relative to.
        @type {Element}*/
        this.element = null;

        /**Object. The source object with the properties to merge into the htmlContent
        @type {Object}*/
        this.source = null;

        /**String. The path from the parent Binding's source object to this child Binding's source object.
        @type {String}*/
        this.path = null;
    };

    /**The various modes that a BindingSession can execute itself in.
    @enum*/
    var BindingSessionMode =
    {
        /**Default.*/
        None: 0,
        /**Full binding procedure, all children will be re-evaluated.*/
        Bind: 1,
        /**Partial binding procedure, only changed children will be re-evaluated. (Changed at the time from when the "update" function is invoked).*/
        Update: 2
    }

    /**Wrapper for an event handler that is bound to a Binding and a function on that Binding's source.
    @class*/
    var BindingDispatchHandle = function ()
    {
        /**String. The hash code key of this dispatch handle. Made from the path of the bound property and the index of the BindingHandle.
        @type {String}*/
        this.hashKey = null;

        /**String. The path from the BoundProperty.
        @type {String}*/
        this.path = null;

        /**Object. The Binding that this handle is associated with. Passed into the handler as a parameter.
        @type {EVUI.Modules.Binding.Binding}*/
        this.binding = null;

        /**Function. The handling function for the event.
        @type {Function}*/
        this.handler = null;

        /**The array of all the locations in the markup where this handle has been invoked from. Used to remove the BindingDispatchHandle from memory at disposal time.
        @type {BindingDispatchInvocationSite[]}*/
        this.invocationSites = [];

        /**Actual invocation function used to invoke the user's function with the browser's event args and the associated Binding as parameters.
        @param {Event} eventArgs The browser's event arguments.
        @returns {Any} */
        this.invocationHandle = function (eventArgs) { };
    };

    /**Disposes of the BindingDispatchHandle, thus removing it from the DOM and from memory.*/
    BindingDispatchHandle.prototype.dispose = function ()
    {
        var numInvocationSites = this.invocationSites.length;
        for (var x = 0; x < numInvocationSites; x++)
        {
            var curInvocationSite = this.invocationSites[x];

            var attrName = "on" + curInvocationSite.eventName;
            var val = curInvocationSite.currentTarget[attrName];
            if (val != null && val.toString().indexOf(this.hashKey) !== -1)
            {
                curInvocationSite.currentTarget[attrName] = null;
                curInvocationSite.currentTarget.removeAttribute(attrName);
            }
        }

        this.invocationSites = [];

        if (_invocationDictionary[this.hashKey] === this) delete _invocationDictionary[this.hashKey];
    };

    /**Represents a location in markup where a BindingDispatchHandle was invoked from.
    @class*/
    var BindingDispatchInvocationSite = function ()
    {
        /**String. The name of the event that dispatched the event.
        @type {String}*/
        this.eventName = null;

        /**Object. The element that dispatched the event.
        @type {Element}*/
        this.currentTarget = null;
    };

    /**The type of structural change a child binding underwent in the list of its parentBinding's childBinding's list.
    @enum*/
    var BindingStructureChangeType =
    {
        /**No structural change - either no change or a content change to the child Binding.*/
        None: 0,
        /**Binding was added to the new set of childBindings.*/
        Added: 1,
        /**Binding was removed from the new set of childBindings. */
        Removed: 2,
        /**Binding was swapped with another binding, meaning their contents should switch places in the DOM.*/
        Swapped: 3,
        /**Binding was a member of an array and has had its index change in response to the source array having elements spliced into or out of it.*/
        Shifted: 4,
        /**Binding was not a member of an array, but had it's content moved to a new key in the source object.*/
        Moved: 5
    };

    /**A container describing all of the changes made between an old set of childBindings and a new set of childBindings.
    @class*/
    var ChildDifferencePackage = function ()
    {
        /**Boolean. Whether or not the session being changed is an array.
        @type {Boolean}*/
        this.isArray = false;

        /**Object. Dictionary of all paths that have been modified when the old and new lists were compared against each other. Object values are ChildDifferences.
        @type {Object}*/
        this.modifiedPaths = {};

        /**Array. The array of all the bindings that were not changed.
        @type {ChildDifference[]}*/
        this.unchangedBindings = [];
    };

    /**Represents a difference in one of the children of a Binding when it is being re-bound. 
    @class*/
    var ChildDifference = function ()
    {
        /**Number. The index of the Binding in the list of parent Bindings.
        @type {Number}*/
        this.index = -1;

        /**Object. The BindingHandle that was processed.
        @type {BindingHandle}*/
        this.binding = null;

        /**Object. Whether or not the contents of the child Binding's source object have been modified.
        @type {Boolean}*/
        this.contentsModified = false;

        /**Number. The type of structural change the difference represents if the change involved changing the assignment of a binding to a new, changed, or removed key.
        @type {Number}*/
        this.bindingStructureChangeType = BindingStructureChangeType.None;

        /**Object. If the Binding is being moved to a new key or swapped with an existing one, this is the other Binding involved in the move or switch.
        @type {BindingHandle}*/
        this.moveSwapTarget = null;

        /**Boolean. Whether or not the change has been applied by the change processor.
        @type {Boolean}*/
        this.applied = false;
    };

    var BindingContentList = function (path)
    {
        this.normalizedPath = path;

        /**
        @type {BindingContentListItem[]}*/
        this.bindings = [];
        this.numBindings = 0;
    };

    BindingContentList.prototype.addBinding = function (bindingHandle, index)
    {
        var listItem = new BindingContentListItem(bindingHandle);
        listItem.index = index;

        this.numBindings = this.bindings.push(listItem);

        return listItem;
    };

    BindingContentList.prototype.getNextUnprocessedBinding = function ()
    {
        for (var x = 0; x < this.numBindings; x++)
        {
            var curBindingItem = this.bindings[x];
            if (curBindingItem.processed === false) return curBindingItem;
        }

        return null;
    };

    BindingContentList.prototype.makeChangeArray = function (changeType)
    {
        var changes = [];
        for (var x = 0; x < this.numBindings; x++)
        {
            var curBinding = this.bindings[x];

            var curChange = new ChildDifference();
            curChange.binding = curBinding.binding;
            curChange.index = curBinding.index;
            curChange.bindingStructureChangeType = (typeof changeType === "function") ? changeType(curChange) : changeType;

            changes.push(curChange);
        }

        return changes;
    }

    var BindingContentListItem = function (bindingHandle)
    {
        /**
        @type {BindingHandle}*/
        this.binding = bindingHandle;
        this.index = -1;
        this.processed = false;

        /**
        @type {BindingHandleState}*/
        this.stateToCheck = null;
    };

    var HtmlContentMetadata = function ()
    {
        this.html = null;
        this.attributePaths = {};
    };

    var ElementMetadata = function ()
    {
        this.attributes = {};
    };

    /**
     * 
     * @param {any} attrName
     * @returns {AttributeMetadata}
     */
    ElementMetadata.prototype.getAttributeMetadata = function (attrName)
    {
        return this.attributes[attrName];
    };

    var AttributeMetadata = function ()
    {
        this.name = null;
        this.containsBoundValues = false;

        this.value = null;

        this.tokenizedValue = null;

        /**
        @type {AttributeValueMetadata[]}*/
        this.values = [];
    };

    var AttributeValueMetadata = function ()
    {
        this.value = null;
        this.wasBound = false;
        this.tokenizedString = null;

        /**
        @type {BoundAttributeValueMetadata[]}*/
        this.boundValues = [];
    };

    var BoundAttributeValueMetadata = function ()
    {
        this.boundContent = null;
        this.boundPath = null;
    };

    var BindingTemplateEntry = function ()
    {
        this.templateName = null;
    };

    /**Represents a batch of peer-bindings to be executed at the same time.
    @class*/
    var BindingSessionBatch = function ()
    {
        /**The unique ID of this batch.
        @type {Number}*/
        this.id = _batchIDCounter++;

        /**The container that holds this batch and its peer batches.
        @type {BindingSessionBatchContainer}*/
        this.batchContainer = null;

        /**The sessions in the batch being executed.
        @type {BindingSession[]}*/
        this.sessions = [];

        /**The number of sessions in the batch.
        @type {Number}*/
        this.numSessions = 0;

        /**The number of completed sessions in the batch.
        @type {Number}*/
        this.numComplete = 0;
    };

    /**Represents a container for BindingSessionBatches.
    @class     */
    var BindingSessionBatchContainer = function ()
    {

        /**The number of batches in this container.
        @type {Number}*/
        this.numBatches = 0;

        /**The batches contained by this container.
        @type {BindingSessionBatch[]}*/
        this.batches = [];

        /**The batch that is currently being loaded with sessions.
        @type {BindingSessionBatch}*/
        this.currentBatch = null;

        /**The batch container that contains this one.
        @type {BindingSessionBatchContainer}*/
        this.parentContainer = null;

        /**The child batches of this batch. Mirrors the hierarchy of the objects being bound.
        @type {BindingSessionBatchContainer[]}*/
        this.childContainers = null;

        /**The number of child containers.
        @type {Number}*/
        this.numChildContainers = 0;

    }


    cacheObjectKeys();
    ensureServices();
};

/**A container for Html content that is stored in the BindingController that can be referenced by its key in Bindings so that the same Html can be re-used and referenced in multiple places.
@class*/
EVUI.Modules.Binding.BindingHtmlContent = function (entry)
{
    if (entry == null || typeof entry.key !== "string") throw Error("Invalid constructor arguments.");
    var _entry = entry;

    /**String. The key used to reference the Html content by.
    @type {String}*/
    this.key = null;
    Object.defineProperty(this, "key", {
        get: function () { return _entry.key; },
        configurable: false,
        enumerable: true
    });

    /**String. The URL of where the Html content can be found if it is being loaded remotely.
    @type {String}*/
    this.url = null;
    Object.defineProperty(this, "url", {
        get: function () { return _entry.url; },
        configurable: false,
        enumerable: true
    });

    /**String. The raw Html to use in the Binding process.
    @type {String}*/
    this.content = null;
    Object.defineProperty(this, "content", {
        get: function () { return _entry.content; },
        set: function (value)
        {
            if (typeof value !== "string" && value != null) throw Error("content must be a string.");
            if (_entry.content !== value)
            {
                _entry.needsRecalcuation = true;
                if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(value) === false && _entry.loaded === true)
                {
                    _entry.ignoreUrl = true; //the htmlContent is now different than what was returned from the server, so if we get just the URL again re-load the result in a new entry.
                }

                if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(value) == true)
                {
                    _entry.ignoreUrl = false;
                    _entry.loaded = false;
                }

                _entry.content = value;
            }
        },
        configurable: false,
        enumerable: true
    });
};

/**The central object of the binding mechanism, contains all the settings and overrides for performing a binding operation and is obtained via invoking the bind or bindAsync commands.
@class*/
EVUI.Modules.Binding.Binding = function (handle)
{
    if (handle == null || handle.wrapper == null) throw Error("Invalid constructor arguments");

    var _handle = handle;
    var _self = this;

    /**String. The ID of the binding.
    @type {Number}*/
    this.id = null;
    Object.defineProperty(this, "id", {
        get: function ()
        {
            return _handle.id;
        },
        configurable: false,
        enumerable: true
    });

    /**String. The name of the BindingTemplate that this Binding was created from.
    @type {String}*/
    this.templateName = null;
    Object.defineProperty(this, "templateName", {
        get: function () { return _handle.templateName; },
        configurable: false,
        enumerable: true
    });

    /**Element. The Element in the DOM that the htmlContent will be inserted relative to. Cannot be changed while a Binding operation is in progress. If this Binding is the child of another Binding, the element must be a child element of the boundContent of the parent Binding.
    @type {Element}*/
    this.element = null;
    Object.defineProperty(this, "element", {
        get: function ()
        {
            return (_handle.pendingState != null && _handle.pendingState.elementSet === true) ? _handle.pendingState.element : _handle.currentState.element;
        },
        set: function (value)
        {
            if (value === _handle.currentState.element) return;
            if (_handle.progressState != EVUI.Modules.Binding.BindingProgressStateFlags.Idle) throw Error("Cannot change the element of a Binding that is queued or in progress.");
            if (_handle.wrapper.validateElement(value) === false) throw Error("Failed to set element - must be null, a non-whitespace string, a DocumentFragment, or an Element.");

            if (_handle.newStateBound === true || _handle.pendingState != null)
            {
                if (_handle.pendingState == null) _handle.pendingState = {};
                _handle.pendingState.elementSet = true;
                _handle.pendingState.element = value;
            }
            else
            {
                _handle.currentState.element = value;
                _handle.currentState.elementSet = true;
            }
        },
        configurable: false,
        enumerable: true
    });

    /**Number. Flags indicating the current state of the bind operation on this Binding.
    @type {Number}*/
    this.bindingProgressState = EVUI.Modules.Binding.BindingProgressStateFlags.Idle;
    Object.defineProperty(this, "bindingProgressState", {
        get: function () { return _handle.progressState; },
        configurable: false,
        enumerable: true
    });

    /**String. Status value indicating whether or not the Binding was bound successfully, or if it ended due to a cancellation or error.
    @type {String}*/
    this.bindingCompletionState = EVUI.Modules.Binding.BindingCompletionState.None;
    Object.defineProperty(this, "bindingCompletionState", {
        get: function () { return _handle.completionState; },
        configurable: false,
        enumerable: true
    });

    /**Object. The source object that the values for the Binding and any child Bindings will be pulled from. Cannot be re-assigned during a binding in progress.
    @type {Object}*/
    this.source = null;
    Object.defineProperty(this, "source", {
        get: function () { return (_handle.pendingState != null && _handle.pendingState.sourceSet === true) ? _handle.pendingState.source : _handle.currentState.source; },
        set: function (value)
        {
            if (value != null && typeof value !== "object") throw Error("source must be an object.");
            if (value === _handle.currentState.source) return;
            if (_handle.progressState != EVUI.Modules.Binding.BindingProgressStateFlags.Idle) throw Error("Cannot change the source object reference of a Binding that is queued or in progress.");

            if (_handle.newStateBound === true || _handle.pendingState != null)
            {
                if (_handle.pendingState == null) _handle.pendingState = {};
                _handle.pendingState.source = value;
                _handle.pendingState.sourceSet = true;
            }
            else
            {
                _handle.currentState.source = value;
                _handle.currentState.sourceSet = true;
            }
        },
        configurable: false,
        enumerable: true
    });

    /**String. The Html content (or Element that the Html will be pulled from) that will be populated with values from the source object. Cannot be changed during a Binding in progress after the onSetBinding events fire.
    @type {String|Element|EVUI.Modules.Binding.BindingHtmlContent}*/
    this.htmlContent = null;
    Object.defineProperty(this, "htmlContent", {
        get: function ()
        {
            return  (_handle.pendingState != null && _handle.pendingState.htmlContentSet === true) ? _handle.pendingState.htmlContent: _handle.currentState.htmlContent;
        },
        set: function (value)
        {
            if (value === _handle.currentState.htmlContent) return;
            if (EVUI.Modules.Core.Utils.hasFlag(_handle.progressState, EVUI.Modules.Binding.BindingProgressStateFlags.GotHtmlContent)) throw Error("Cannot change the htmlContent of a Binding that has already been Bound.");

            var stateToSet = null;

            if (_handle.newStateBound === true || _handle.pendingState != null)
            {
                if (_handle.pendingState == null) _handle.pendingState = {};
                stateToSet = _handle.pendingState;
            }
            else
            {
                stateToSet = _handle.currentState;
            }

            if (value != null && typeof value !== "string")
            {
                if (value instanceof EVUI.Modules.Binding.BindingHtmlContent || (value != null && typeof value === "object"))
                {
                    if (value.item != null) value = value.item;
                    stateToSet.htmlContent = value;
                    stateToSet.htmlContentSet = true;
                }
                else if (EVUI.Modules.Core.Utils.isElement(value) === true)
                {
                    stateToSet.htmlContent= value;
                    stateToSet.htmlContentSet = true;
                }
                else
                {
                    throw Error("template must be a string, Element, or BindingTemplateCaheItem.")
                }
            }
            else
            {
                stateToSet.htmlContent= value;
                stateToSet.htmlContentSet = true;
            }
        }
    });

    /**Object. The options for controlling how the binding is inserted and processed. Cannot be null.
    @type {EVUI.Modules.Binding.BindOptions}*/
    this.options = null;
    Object.defineProperty(this, "options", {
        get: function ()
        {
            return _handle.options;
        },
        set: function (value)
        {
            if (typeof value === "object")
            {
                if (value == null)
                {
                    throw Error("options must be an object.");
                }
                else
                {
                    _handle.options = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Binding.BindOptions(), value);
                }
            }
            else
            {
                throw Error("options must be an object.");
            }
        }
    });

    /**Object. The settings for loading the binding's htmlContent from a remote source.
    @type {EVUI.Modules.Binding.BindingContentLoadSettings}*/
    this.contentLoadSettings = null;

    /**String. The way in which the binding will be inserted into the DOM. Must be a value from the BindingMode enum. BindingMode.Merge by default.
    @type {String}*/
    this.bindingMode = EVUI.Modules.Binding.BindingMode.Merge;

    /**String. The way in which the final product of the binding operation will be inserted relative to the Binding's element. Must be a value from the BindingInsertionMode enum. BindingInsertionMode.Append by default.
    @type {String}*/
    this.insertionMode = EVUI.Modules.Binding.BindingInsertionMode.Default;

    /**Gets a cloned copy of the internal boundProperties list that maps a path to a property in the source object to the value found at that path in the source object.
    @returns {EVUI.Modules.Binding.BoundProperty[]}*/
    this.getBoundProperties = function ()
    {
        var numBound = (_handle.currentState != null && _handle.currentState.boundProperties != null) ? _handle.currentState.boundProperties.length : 0;

        var boundProps = [];

        for (var x = 0; x < numBound; x++)
        {
            var curProp = _handle.currentState.boundProperties[x];
            var newProp = new EVUI.Modules.Binding.BoundProperty(curProp.path);
            newProp.value = curProp.value;

            boundProps.push(newProp);
        }

        return boundProps;
    };

    /**Changes the value of a boundProperty in the Binding. Returns true if successful, false otherwise.
    @param {String} path The path of the boundProperty to change.
    @param {Any} value The value to set the boundProperty to.
    @returns {Boolean}*/
    this.changeBoundPropertyValue = function (path, value)
    {
        if (typeof path !== "string") throw Error("String expected.");

        var numBound = (_handle.currentState != null && _handle.currentState.boundProperties != null) ? _handle.currentState.boundProperties.length : 0;

        for (var x = 0; x < numBound; x++)
        {
            var curProp = _handle.currentState.boundProperties[x];
            if (curProp.path === path)
            {
                curProp.value = value;
                return true;
            }
        }

        return false;
    };

    /**Object. The DocumentFragment containing the DOM Nodes made from the merged Html content.
    @type {DocumentFragment}*/
    this.boundContentFragment = null;
    Object.defineProperty(this, "boundContentFragment", {
        get: function ()
        {
            if (_handle.currentState.boundTemplateFragment != null) return _handle.currentState.boundTemplateFragment;

            if (_handle.currentState.boundContentTree != null && _handle.newStateBound === false)
            {
                _handle.currentState.boundTemplateFragment = _handle.wrapper.toDomNode(_handle.currentState.boundContentTree); //_handle.currentState.boundContentTree.toNode();
            }

            return _handle.currentState.boundTemplateFragment;
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The Binding that triggered the creation of this binding.
    @type {EVUI.Modules.Binding.Binding}*/
    this.parentBinding = null;
    Object.defineProperty(this, "parentBinding", {
        get: function ()
        {
            return (_handle.currentState.parentBindingHandle != null) ? _handle.currentState.parentBindingHandle.binding : null;
        },
        configurable: false,
        enumerable: true
    });

    /**String. The property name in the parent binding that selected the source object for this Binding.
    @type {String}*/
    this.parentBindingKey = null;
    Object.defineProperty(this, "parentBindingKey", {
        get: function ()
        {
            return _handle.currentState.parentBindingKey;
        },
        configurable: false,
        enumerable: true
    });

    /**Gets a copy of the list of childBindings that are direct children to this binding.
    @returns {EVUI.Modules.Binding.Binding[]}*/
    this.getChildBindings = function ()
    {
        var childBindings = [];
        var numChildren = (_handle.currentState != null && _handle.currentState.childBindingHandles != null) ? _handle.currentState.childBindingHandles.length : 0;
        for (var x = 0; x < numChildren; x++)
        {
            childBindings.push(_handle.currentState.childBindingHandles[x].binding);
        }

        return childBindings;
    };

    /**Removes a child Binding from the Binding by invoking its dispose function. Returns true if successful, false otherwise.
    @param {EVUI.Modules.Binding.Binding} childBinding The child Binding to remove from its parent.
    @returns {Boolean} */
    this.removeChildBinding = function (childBinding)
    {
        if (childBinding == null) return false;

        var found = false;

        var numBindings = (_handle.currentState != null && _handle.currentState.childBindingHandles != null) ? _handle.currentState.childBindingHandles.length : 0;
        for (var x = 0; x < numBindings; x++)
        {
            var curChildBinding = _handle.currentState.childBindingHandles[x].binding;
            if (childBinding.id === binding.id && curChildBinding === childBinding)
            {
                found = true;
                break;
            }
        }

        if (found === false) return false;
        childBinding.dispose();

        return true;
    };

    /**Gets a copy of the internal boundContent list that contains all the Nodes produced by binding this Binding to the DOM.
    @returns {Node[]}*/
    this.getBoundContent = function ()
    {
        var boundContent = [];
        var numBoundContent = _handle.currentState.boundContent.length;
        for (var x = 0; x < numBoundContent; x++)
        {
            boundContent.push(_handle.currentState.boundContent[x]);
        }

        return boundContent;
    };

    /**Executes the binding process and recalculates itself and all child bindings.
    @param {EVUI.Modules.Binding.BindArgs} bindArgs Optional. Either a source object reference to base the bind on, or a YOLO BindArgs object to pass into the bind logic.
    @param {EVUI.Modules.Binding.Constants.Fn_BindingCallback} callback A callback function to call once the binding process is complete.*/
    this.bind = function (bindArgs, callback)
    {
        if (typeof bindArgs === "function" && callback == null) callback = bindArgs;

        if (bindArgs == null || typeof bindArgs === "function")
        {
            bindArgs = new EVUI.Modules.Binding.BindArgs();
            bindArgs.bindingTarget = this.element;
            bindArgs.bindingSource = this.source;
        }

        _handle.wrapper.triggerBind(_handle, bindArgs, null, callback);
    };

    /**Awaitable. Executes the binding process and recalculates itself and all child bindings.
    @param {EVUI.Modules.Binding.BindArgs} bindArgs Optional. Either a source object reference to base the bind on, or a YOLO BindArgs object to pass into the bind logic.
    @returns {Promise<EVUI.Modules.Binding.Binding>}*/
    this.bindAsync = function (bindArgs)
    {
        return new Promise(function (resolve)
        {
            _self.bind(bindArgs, function ()
            {
                resolve(_self);
            });
        });
    };

    /**Executes the binding process for itself and any of its children that have changed, unchanged children are not re-evaluated.
    @param {EVUI.Modules.Binding.UpdateArgs} updateArgs Optional. Either a source object reference to base the update on, or a YOLO UpdateArgs object to pass into the update logic.
    @param {EVUI.Modules.Binding.Constants.Fn_BindingCallback} callback A callback function to call once the update is complete.*/
    this.update = function (updateArgs, callback)
    {
        _handle.wrapper.triggerUpdate(_handle, updateArgs, null, callback);
    };

    /**Executes the binding process for itself and any of its children that have changed, unchanged children are not re-evaluated.
    @param {EVUI.Modules.Binding.UpdateArgs} updateArgs Optional. Either a source object reference to base the update on, or a YOLO UpdateArgs object to pass into the update logic.
    @param {EVUI.Modules.Binding.Constants.Fn_BindingCallback} callback A callback function to call once the update is complete.*/
    this.updateAsync = function (updateArgs)
    {
        return new Promise(function (resolve)
        {
            _self.update(updateArgs, function ()
            {
                resolve(_self);
            })
        });
    };

    /**Overwrites all the values on this Binding with those that were set on the given BindingTemplate.
    @param {String} templateName The name of the template to apply.
    @returns {Boolean}*/
    this.applyBindingTemplate = function (templateName)
    {
        if (_handle.progressState !== EVUI.Modules.Binding.BindingProgressStateFlags.Idle) throw Error("Cannot set the BindingTemplate of a Binding in progress.");

        var template = null;

        if (typeof templateName === "string")
        {
            template = EVUI.Modules.Binding.Binder.getBindingTemplate(templateName);
            if (template == null) return false;
        }
        else if (templateName != null && typeof templateName === "object")
        {
            template = templateName;
        }
        else
        {
            throw Error("String or object expected.");
        }

        EVUI.Modules.Core.Utils.shallowExtend(this, template, ["templateName"]);
        _handle.templateName = templateName;

        return true;
    };

    /**Disposes of the Binding and all of its associated resources and removes its DOM Nodes from the DOM.*/
    this.dispose = function ()
    {
        return _handle.wrapper.triggerDispose(_handle);
    };

    /**Event that fires immediately before the binding process begins.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onBind = null;

    /**Event that fires when the htmlContent for the binding has been obtained.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onSetHtmlContent = null;

    /**Event that fires when the htmlContent has been finalized and the bindings in the htmlContent
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onSetBindings = null;

    /**Event that fires when the htmlContent has been populated with the values from the bound object.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onBindHtmlContent = null;

    /**Event that fires when the child bindings of the current binding have been found and are about to be bound.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onBindChildren = null;

    /**Event that fires when the htmlContent has been populated with the values from the bound object and has had all of its child bindings injected into it.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onChildrenBound = null;

    /**Event that fires when the binding operation is complete and the complete content and all its children has been injected.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onBound = null;
};

/**Searches all the children underneath this Binding using the predicate function to find a match.
@param {EVUI.Modules.Binding.Constants.Fn_SearchBindings} selector
@param {Boolean} recursive Whether or not to perform a recursive search.
@param {Boolean} returnFirst Whether or not to return the first match found (or null) instead of an array (or potentially empty array).
@returns {EVUI.Modules.Binding.Binding[]|EVUI.Modules.Binding.Binding} */
EVUI.Modules.Binding.Binding.prototype.search = function (selector, recursive, returnFirst)
{
    if (typeof selector !== "function") throw Error("Function expected.");
    if (typeof recursive !== "boolean") recursive = false;
    if (typeof returnFirst !== "boolean") returnFirst = false;
    var results = [];
    var children = this.getChildBindings();
    var numChildren = children.length;
    for (var x = 0; x < numChildren; x++)
    {
        var curChild = children[x];
        if (selector(curChild) === true)
        {
            if (returnFirst === true) return curChild;
            results.push(curChild);
        }

        if (recursive === true)
        {
            var childSearchResult = curChild.search(selector, recursive, returnFirst);
            if (childSearchResult != null)
            {
                if (returnFirst === true) return childSearchResult;
                if (childSearchResult.length > 0)
                {
                    results = results.concat(childSearchResult);
                }
            }
        }
    }

    if (returnFirst === true) return null;
    return results;
};

/**Gets the root parent binding of this binding that has no parents above it.
@returns {EVUI.Modules.Binding.Binding}*/
EVUI.Modules.Binding.Binding.prototype.getRootBinding = function ()
{
    var parent = this.parentBinding;
    while (parent != null)
    {
        var newParent = parent.parentBinding;
        if (newParent == null) return parent;

        parent = newParent;
    }

    return parent;
};



/**Represents a property that was found in the htmlContent (surrounded by {{double curly braces}}) and its value in the source object.
@class*/
EVUI.Modules.Binding.BoundProperty = function (path)
{
    /**The path from the Binding's source object to the property to inject into the htmlContent.
    @type {String}*/
    this.path = path;

    /**The value found in the Binding's source object at the given path.
    @type {Any}*/
    this.value = null;
};

/**Arguments for adding, updating, or executing a binding operation.
@class*/
EVUI.Modules.Binding.BindingTemplate = function (templateEntry)
{   
    var _templateEntry = templateEntry;

    /**String. Read only. The name of the BindingTemplate.
    @type {String}*/
    this.templateName = null;

    //only add the getters if this was made with a real TemplateEntry object, otherwise it is a throwaway object that doesn't need the overhead of the getters
    if (_templateEntry != null)
    {
        Object.defineProperty(this, "templateName", {
            get: function ()
            {
                return _templateEntry.templateName;
            },
            enumerable: true,
            configurable: false
        });
    }

    /**String. Either the htmlContent that will be populated with values from the source object, or the key of a BindingHtmlContent, or a YOLO BindingHtmlContent object, or an Element to use its outerHTML as a template.
    @type {String|EVUI.Modules.Binding.BindingHtmlContent|Element}*/
    this.htmlContent = null;

    /**Object. The options for controlling how the binding is inserted and processed.
    @type {EVUI.Modules.Binding.BindOptions}*/
    this.options = null;

    /**Object. The settings for loading the binding's htmlContent from a remote source.
    @type {EVUI.Modules.Binding.BindingContentLoadSettings}*/
    this.contentLoadSettings = null;

    /**String. The way in which the binding will be inserted into the DOM. Must be a value from the BindingMode enum. BindingMode.Merge by default.
    @type {String}*/
    this.bindingMode = EVUI.Modules.Binding.BindingMode.Merge;

    /**String. The way in which the final product of the binding operation will be inserted relative to the Binding's element. Must be a value from the BindingInsertionMode enum. BindingInsertionMode.Append by default.
    @type {String}*/
    this.insertionMode = EVUI.Modules.Binding.BindingInsertionMode.Default;

    /**Event that fires immediately before the binding process begins.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onBind = null;

    /**Event that fires when the htmlContent for the binding has been obtained.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onSetHtmlContent = null;

    /**Event that fires when the htmlContent has been finalized and the bindings in the htmlContent
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onSetBindings = null;

    /**Event that fires when the htmlContent has been populated with the values from the bound object.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onBindHtmlContent = null;

    /**Event that fires when the child bindings of the current binding have been found and are about to be bound.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onBindChildren = null;

    /**Event that fires when the htmlContent has been populated with the values from the bound object and has had all of its child bindings injected into it.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onChildrenBound = null;

    /**Event that fires when the binding operation is complete and the complete content and all its children has been injected.
    @type {EVUI.Modules.Binding.Constants.Fn_BindingEventHandler}*/
    this.onBound = null;
};

/**Arguments to feed into the bind and bindAsync functions.
@class*/
EVUI.Modules.Binding.BindArgs = function ()
{
    /**Object. The Element to bind the content relative to.
    @type {Element}*/
    this.bindingTarget = null;

    /**Object. The source object for the Binding to draw values from to populate its htmlContent.
    @type {Object}*/
    this.bindingSource = null;

    /**String. The name of the BindingTemplate to use, if any.
    @type {String}*/
    this.templateName = null;

    /**Any. Any contextual information to pass into the binding.
    @type {Any}*/
    this.bindingContext = null;
};

/**Arguments to feed into the update and updateAsunc functions.
@class*/
EVUI.Modules.Binding.UpdateArgs = function ()
{
    /**Object. The source object for the Binding to draw values from to populate its htmlContent.
    @type {Object}*/
    this.bindingSource = null;

    /**Any. Any contextual information to pass into the Binding.
    @type {Any}*/
    this.bindingContext = null;
};

/**Settings for how to load remote htmlContent for the Binding.
@class*/
EVUI.Modules.Binding.BindingContentLoadSettings = function ()
{
    /**The HttpRequestArgs to use to make the web request to get the htmlContent.
    @type {EVUI.Modules.Http.HttpRequestArgs}*/
    this.httpRequestArgs = null;
};

/**Options for controlling the behavior of the Binding.
@class*/
EVUI.Modules.Binding.BindOptions = function ()
{
    /**Boolean. Whether or not to execute recursive Bindings under the current Binding if any are detected. True by default.
    @type {Boolean}*/
    this.recursive = true;

    /**Boolean. When executing recursive Bindings, this controls whether or not the child Bindings get the same event handlers as their parent if the child Binding is not based on a BindingTemplate that has its own events. True by default.
    @type {Boolean}*/
    this.recursiveEvents = true;

    /**Boolean. When executing recursive Bindings, this controls whether or not the child Bindings raise any events during their Binding process. False by default.
    @type {Boolean}*/
    this.suppressChildEvents = false;

    /**Boolean. When executing recursive Bindings, this controls whether or not the options object reference is shared by all child Bindings of the current Binding if the child Binding is not based on a BindingTemplate that has its own options, otherwise a shallow clone of the options is used instead. True by default.
    @type {Boolean}*/
    this.shareOptions = true;

    /**Boolean. When executing recursive Bindings, this controls whether or not the templateLoadSettings object reference is shared by all child Bindings of the current Binding if the child Binding is not based on a BindingTemplate that has its own templateLoadSettings, otherwise a clone of the templateLoadSettings is used instead. True by default.
    @type {Boolean}*/
    this.shareContentLoadSettings = true;

    /**Boolean. When executing recursive Bindings and using a CSS selector to find the Binding's element, this controls whether or not the parent Binding's element is used as the scope for finding the child Binding's element. True by default.
    @type {Boolean}*/
    this.scopedCSSSelectors = true;

    /**Boolean. When executing a HTTP request for Html, if this Binding does not have an associated BindingHtmlContent, add a BindingHtmlContent when the result is loaded. True by default.
    @type {Boolean}*/
    this.addMissingHtmlContent = true;

    /**Boolean. When Binding a source object that is an Array, this controls whether or not the htmlContent for the Binding will be duplicated for each item in the array. True by default.
    @type {Boolean}*/
    this.enumerateArrays = true;

    /**String. When executing recursive bindings, this controls how the binding operation's context will be shared with its children. Must be a value from ShareContextMode. By default, if the context is an object, the same reference will be used for child Bindings.
    @type {String}*/
    this.shareContextMode = EVUI.Modules.Binding.ShareContextMode.ShareReference;

    /**String. When an event handler is bound to the DOM, this control what is the "this" context for the event handler. Defaults to the calling element. Must be a value from BoundEventContextMode.
    @type {String}*/
    this.eventContextMode = EVUI.Modules.Binding.BoundEventContextMode.Element;
};

/**Event arguments for the Binding process.
@class*/
EVUI.Modules.Binding.BinderEventArgs = function (bindSession)
{
    var _bindSession = bindSession;

    /**Object. The Binding being processed.
    @type {EVUI.Modules.Binding.Binding}*/
    this.binding = _bindSession.bindingHandle.binding;

    /**Boolean. Whether or not the Binding is re-binding itself.
    @type {Boolean}*/
    this.reBinding = _bindSession.bindingHandle.oldStateBound;

    /**Array. If this Binding has been bound more than once, this is the old content that was bound before the current binding operation.
    @type {Node[]}*/
    this.originalContent = (_bindSession.bindingHandle.oldState != null && _bindSession.bindingHandle.oldState.boundContent != null) ? _bindSession.bindingHandle.oldState.boundContent.slice() : null;

    /**Object. The original source object that was bound to the Binding previously.
    @type {Object}*/
    this.originalSource = (_bindSession.bindingHandle.oldState != null) ? _bindSession.bindingHandle.oldState.source : null;

    /**String. The unique key current step in the EventStream.
    @type {String}*/
    this.key = null;

    /**Pauses the EventStream, preventing the next step from executing until resume is called.*/
    this.pause = function () { };

    /**Resumes the EventStream, allowing it to continue to the next step.*/
    this.resume = function () { };

    /**Cancels the EventStream and aborts the execution of the operation.*/
    this.cancel = function () { }

    /**Stops the EventStream from calling any other event handlers with the same name.*/
    this.stopPropagation = function () { };

    /**Object. Any state value to carry between events.
    @type {Object}*/
    this.context = {};
};

/**The way in which the binding will be inserted into the DOM.
@enum*/
EVUI.Modules.Binding.BindingMode =
{
    /**The new or changed content from the Binding will be merged with the existing DOM contents.*/
    Merge: "merge",
    /**The old content from the Binding will be removed and replaced with the new content.*/
    Overwrite: "overwrite"
};

Object.freeze(EVUI.Modules.Binding.BindingMode);

/**The way in which the final product of the binding operation will be inserted relative to the Binding's element.
@enum*/
EVUI.Modules.Binding.BindingInsertionMode =
{
    /**Unset value. Defaults to Append if left unset.*/
    Default: "default",
    /**The content will be appended as a child underneath the Binding's element.*/
    Append: "append",
    /**The content will be prepended as a child underneath the Binding's element.*/
    Prepend: "prepend",
    /**The content will be inserted as a peer before the Binding's element.*/
    InsertBefore: "before",
    /**The content will be inserted as a peer after the Binding's element.*/
    InsertAfter: "after",
    /**The content will be inserted into the Binding's element's shadow.*/
    Shadow: "shadow",
    /**The content will be returned as a DocumentFragment and not be inserted into the DOM.*/
    Fragment: "fragment",
    /**The content will be put in place of the Binding's element's children after removing the existing children from the DOM.*/
    ReplaceChildren: "replace"
};

Object.freeze(EVUI.Modules.Binding.BindingInsertionMode);

/**Enum for describing how the context property of a binding session will be shared with child Bindings.
@enum*/
EVUI.Modules.Binding.ShareContextMode =
{
    /**The context will be a new object reference for each child Binding.*/
    NewContext: "cxt-new",
    /**The context will be the same object reference or value for each child Binding.*/
    ShareReference: "cxt-ref",
    /**The context will be a shallow clone of its parent's context.*/
    Clone: "cxt-clone"
};

Object.freeze(EVUI.Modules.Binding.ShareContextMode);

/**Progress flags indicating how far into the binding process the Binding currently is.
@enum*/
EVUI.Modules.Binding.BindingProgressStateFlags =
{
    /**The Binding is at rest and can freely be modified.*/
    Idle: 0,
    /**The Binding has been queued for a bind operation or an update operation and cannot have its source object reference changed beyond this point.*/
    Queued: 1,
    /**The Binding has resolved its element reference and cannot have its element reference changed beyond this point.*/
    GotElement: 2,
    /**The Binding has resolved its htmlContent and cannot have its htmlContent changed beyond this point.*/
    GotHtmlContent: 4,
    /**The Binding has resolved its boundProperties and cannot have the boundProperty list modified beyond this point.*/
    GotBoundProperties: 8,
    /**The Binding has created its boundContentFragment.*/
    BoundHtmlContent: 16,
    /**The Binding has resolved all of its childBindings. The childBindings array cannot be changed beyond this point.*/
    GotChildren: 32,
    /**The Binding is in the process of binding or updating its childBindings.*/
    BindingChildren: 64,
    /**The Binding has completed binding its children and has finalized its boundContentFragment for injection.*/
    BoundChildren: 128,
    /**The Binding has been injected into the DOM and no further changes to the state of the Binding will be reflected until it is re-bound or updated.*/
    Injected: 256
};

Object.freeze(EVUI.Modules.Binding.BindingProgressStateFlags);

/**An enum for indicating what the "this" context should be for event handlers that are bound to the DOM by the Binder.
@enum*/
EVUI.Modules.Binding.BoundEventContextMode =
{
    /**When a bound event is dispatched, the "this" context for the function will be the Element raising the event.*/
    Element: "element",
    /**When a bound event is dispatched, the "this" context for the function will be the object that owns the function being called.*/
    ParentObject: "parent"
};

Object.freeze(EVUI.Modules.Binding.BoundEventContextMode);

/**Status enum for describing the means by which the Binding completed.
@enum*/
EVUI.Modules.Binding.BindingCompletionState =
{
    /**Default.*/
    None: "none",
    /**Binding is queued for execution.*/
    Queued: "queued",
    /**Binding is in the process of being executed.*/
    Executing: "executing",
    /**Binding process completed successfully.*/
    Success: "success",
    /**Binding process ended due to a cancellation.*/
    Canceled: "canceled",
    /**Binding process ended due to an error.*/
    Failed: "failed",
    /**Binding has been disposed.*/
    Disposed: "disposed"
};

Object.freeze(EVUI.Modules.Binding.BindingCompletionState);

/**Object to inject the standard dependencies used by the BindingController into it via its constructor.
@class*/
EVUI.Modules.Binding.BindingControllerServices = function ()
{
    /**Object. An instance of Http module's HttpManager object.
    @type {EVUI.Modules.Http.HttpManager}*/
    this.httpManager = null;

    /**Object. An instance of the DomTree module's DomTreeConverter object.
    @type {EVUI.Modules.DomTree.DomTreeConverter}*/
    this.domTreeConverter = null;

    /**Object. An instance of the Diff module's DiffController object.
    @type {EVUI.Modules.Diff.DiffController}*/
    this.diffController = null;
};

/**Global instance of the BindingController.
@type {EVUI.Modules.Binding.BindingController}*/
EVUI.Modules.Binding.Binder = null;
(function ()
{
    var binder = null;
    var ctor = EVUI.Modules.Binding.BindingController;

    Object.defineProperty(EVUI.Modules.Binding, "Binder", {
        get: function ()
        {
            if (binder == null) binder = new ctor();
            return binder;
        },
        configurable: false,
        enumerable: true
    });
})();

Object.freeze(EVUI.Modules.Binding)

delete $evui.binder;

/**Global instance of the BindingController.
@type {EVUI.Modules.Binding.BindingController}*/
$evui.binder = null;
Object.defineProperty($evui, "binder", {
    get: function ()
    {
        return EVUI.Modules.Binding.Binder;
    },
    enumerable: true
});

/**Binds an object to the DOM using some Html content that is inserted relative to a target element.
@param {EVUI.Modules.Binding.Binding|EVUI.Modules.Binding.BindArgs|EVUI.Modules.Binding.BindingTemplate|String} bindingOrArgs Either: A YOLO Binding object, a YOLO BindArgs object, a YOLO BindingTemplate object, or the name of the BindingTemplate to use.
@param {EVUI.Modules.Binding.BindArgs} bindArgsOrSource Either a YOLO BindArgs object or the source object to base the Binding off of.
@param {EVUI.Modules.Binding.Constants.Fn_BindingCallback} callback A callback function that is fired when the Binding process completes.*/
$evui.bind = function (bindingOrArgs, bindArgsOrSource, callback)
{
    return $evui.binder.bind(bindingOrArgs, bindArgsOrSource, callback);
};

/**Awaitable. Binds an object to the DOM using some Html content that is inserted relative to a target element.
@param {EVUI.Modules.Binding.Binding|EVUI.Modules.Binding.BindArgs|EVUI.Modules.Binding.BindingTemplate|String} bindingOrArgs Either: A YOLO Binding object, a YOLO BindArgs object, a YOLO BindingTemplate object, or the name of the BindingTemplate to use.
@param {EVUI.Modules.Binding.BindArgs} bindArgsOrSource Either a YOLO BindArgs object or the source object to base the Binding off of.
@returns {Promise<EVUI.Modules.Binding.Binding>}*/
$evui.bindAsync = function (bindingOrArgs, bindArgsOrSource)
{
    return $evui.binder.bindAsync(bindingOrArgs, bindArgsOrSource);
};

/**Adds a set of pre-configured options for Bindings to use that can be referenced by name.
@param {EVUI.Modules.Binding.BindingTemplate} bindingTemplate A YOLO BindingTemplate object.
@returns {EVUI.Modules.Binding.BindingTemplate}*/
$evui.addBindingTemplate = function (bindingTemplate)
{
    return $evui.binder.addBindingTemplate(bindingTemplate);
};

/**Adds Html to the internal store of BindingHtmlContents that can be referenced in Bindings.
@param {String|EVUI.Modules.Binding.BindingHtmlContent} key Either a unique string key of content to add or a YOLO BindingHtmlContent object.
@param {String} content The Html content to associate with the string key.
@param {String} url A URL to get the Html content from if it is going to be loaded remotely.
@returns {EVUI.Modules.Binding.BindingHtmlContent}*/
$evui.addBindingHtmlContent = function (key, content, url)
{
    return $evui.binder.addHtmlContent(key, content, url);
};

/**Removes a BindingTemplate from the controller.
@param {String} templateName The name of the BindingTemplate to remove.
@returns {Boolean} */
$evui.removeBindingTemplate = function (templateName)
{
    return $evui.binder.removeBindingTemplate(templateName);
};

/**Removes a BindingHtmlContent entry from the controller's internal store of BindingHtmlContents.
@param {String} key The key of the BindingHtmlContent entry to remove.
@returns {Boolean}*/
$evui.removeBindingHtmlContent = function (key)
{
    return $evui.binder.removeHtmlContent(key)
};


/*#ENDWRAP(Binding)#*/


/********************************************************Core.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.Core|Core)#*/
/*#REPLACE(EVUI.Modules.Core|Core)#*/

/**Core module containing the Initialization and Utility functionality that is shared by all other modules.
@module*/
EVUI.Modules.Core = {};

/*#MODULEDEF(Core|"1.0"|"Core")#*/
/*#VERSIONCHECK(EVUI.Modules.Core|Core)#*/

/**Property bag for holding various settings that alter the runtime behavior of the library.*/
EVUI.Modules.Core.Settings = {};

/**Property bag for holding various settings that alter the runtime behavior of the library.
@type {EVUI.Modules.Core.Settings}*/
$evui.settings = EVUI.Modules.Core.Settings;
Object.defineProperty($evui, "settings", {
    get: function () { return EVUI.Modules.Core.Settings; },
    enumerable: true
});

/**Gets a value from a settings table.
@param {String} setting The name of the setting to get.
@param {Object} settingsObj The object to get the setting from. If omitted, the $evui.settings object is used by default.
@returns {Any} */
$evui.getSetting = function (setting, settingsObj)
{
    return EVUI.Modules.Core.Utils.getSetting(setting, settingsObj);
};

/**Checks to see if a value is one of the possible values that are commonly used that can mean true (true, 1, "true", or "1") rather than doing JavaScript's implicit typecasting for "truthy" values. 
@param {Any} value The value to check.
@returns {Boolean} */
$evui.isTrue = function (value)
{
    return EVUI.Modules.Core.Utils.isTrue(value);
};

/**Checks to see if one of the constants from a settings table is true.
@param {String} setting The name of the setting to get.
@param {Object} settingsObj The object to get the setting from. If omitted, the $evui.settings object is used by default.
@returns {Boolean} */
$evui.isSettingTrue = function (setting, settingsObj)
{   
    return EVUI.Modules.Core.Utils.isSettingTrue(setting, settingsObj);
};

/**Boolean. Whether or not EventUI can emit any log messages. True by default.
@type {Boolean}*/
EVUI.Modules.Core.Settings.loggingEnabled = true;

/**Function. An alternate logging function to call in the event LoggingEnabled is set to false.
@param {String} message The message to log.*/
EVUI.Modules.Core.Settings.alternateLoggingFunction = function (message) { };

/**Boolean. Whether or not EventUI can emit debug messages. True by default.
@type {Boolean}*/
EVUI.Modules.Core.Settings.debug = true;

/**Boolean. Whether or not to trace events triggered by the EventManager. False by default.
 @type {Boolean}*/
EVUI.Modules.Core.Settings.traceEvents = false;

/**Boolean. Whether or not to trace iframe message sends and responses by the IFrameMessenger. False by default.
 @type {Boolean}*/
EVUI.Modules.Core.Settings.traceIFrames = false;

/**Boolean. If a message comes from an iframe with a white-listed origin, it will automatically be added as a child of the iframeManager. True by default.
@type {Boolean}*/
EVUI.Modules.Core.Settings.autoAddIncomingIFrames = true;

/**Number. When an EventStream is running, this is the number of sequential steps that can be executed by an instance of an EventStream before introducing a shot timeout to free up the thread to allow other processes to continue, otherwise an infinite step loop (which is driven by promises) will lock the thread. Small numbers will slow down the EventStream, high numbers may result in long thread locks. 50 by default.
@type {Number}*/
EVUI.Modules.Core.Settings.stepsBetweenWaits = 250;

/**Number. When positioning a Pane (or Pane-driven) UI component, this is the minimum Z-Index to use to start setting the z-indexes at. 100 by default.
@type {Number}*/
EVUI.Modules.Core.Settings.defaultMinimumZIndex = 100;

/**Boolean. Whether or not to normalize the case of strings when doing string comparisons. False by default. 
@type {Boolean}*/
EVUI.Modules.Core.Settings.normalizeStringCase = false;

/**Boolean. Whether or not to use .toLocaleUpper/LowerCase when normalizing strings. False by default.
@type {Boolean}*/
EVUI.Modules.Core.Settings.localizeStringComparison = false;

/**Constants table for the Core module.*/
EVUI.Modules.Core.Constants = {};

/**A function used to kick start an application.
@param {EVUI.Modules.Core.Settings} settings The $evui.settings object.*/
EVUI.Modules.Core.Constants.Fn_Init = function (settings)
{
        
};

/**A function used to kick start an application.
@param {EVUI.Modules.Core.Settings} settings The $evui.settings object.
@returns {Promise}*/
EVUI.Modules.Core.Constants.Fn_InitAsync = function (settings)
{

};

/**A function that is called once the AsyncSequenceExecutor has completed executing all of its functions. 
@param {Error|Error[]} error Any exception that was thrown while the functions were executing. If foceCompletion was set to true, this will be an array of all errors that occurred during the exection.*/
EVUI.Modules.Core.Constants.Fn_ExecutorCallback = function (error)
{

};

/**A function used to filter the members extended onto a another object.
@param {String} propName The name of the property to extend.
@param {Object} sourceObj The source object being extended onto the target.
@param {Object} testObj The target object or receive properties.
@returns {Boolean}*/
EVUI.Modules.Core.Constants.Fn_ExtendPropertyFilter = function (propName, sourceObj, targetObj) { };

/**If the browser supports Symbols, this is a special Symbol that is used to cache a list of an Object's properties and attach it to that object's prototype so that the property list does not need to be recalculated over and over for objects implementing the same prototype who will always have the same property list.
@type {Symbol}*/
EVUI.Modules.Core.Constants.Symbol_ObjectProperties = "evui-property-list";
(function ()
{
    if (typeof (Symbol) !== "undefined") EVUI.Modules.Core.Constants.Symbol_ObjectProperties = Symbol("evui-property-list");
})()

/**If the browser supports Symbols, this is a special Symbol that is used to indicate that Object.keys can be used to get the object's full properties instead of using a for...in loop.
@type {Symbol}*/
EVUI.Modules.Core.Constants.Symbol_HasPrototypeMembers = "evui-proto-list";
(function ()
{
    if (typeof (Symbol) !== "undefined") EVUI.Modules.Core.Constants.Symbol_HasPrototypeMembers = Symbol("evui-proto-list");
})()

Object.freeze(EVUI.Modules.Core.Constants);

/**Exection arguments to feed into the AsyncSequenceExecutor.
@class*/
EVUI.Modules.Core.AsyncSequenceExecutionArgs = function ()
{
    /**Array. An array of function to execute in the order that they appear in the array, regardless if they are async or not.
    @type {Function[]}*/
    this.functions = null;

    /**Any. The parameter to feed into each function.
    @type {Any}*/
    this.parameter = null;

    /**Boolean. Whether or not, in the event of an error, to continue executing or to stop when the error is thrown. False by default.
    @type {Boolean}*/
    this.forceCompletion = false;
};

/**Utility class used for executing a mixed sequence of async or normal functions in order in that each function is only called once the previous function has returned.
@class*/
EVUI.Modules.Core.AsyncSequenceExecutor = (function ()
{
    var AsyncSequenceExecutor = function() {};

    /**Represents an execution session in progress. */
    var ExecutionSession = function ()
    {
        /**Array. An array of functions to execute.
        @type {Function[]}*/
        this.functions = null;

        /**Object. A parameter to pass into the functions.
        @type {Object}*/
        this.parameter = null;

        /**Number. The index of the currently executing function.
        @type {Number}*/
        this.index = 0;

        /**Function. A callback function to call once all the other functions have executed.
        @type {EVUI.Modules.Core.Constants.Fn_ExecutorCallback}*/
        this.callback = null;

        /**Whether or not executor should continue executing when an error occurs. False by default.
        @type {Boolean}*/
        this.forceCompletion = false;

        /**Array. If forceCompletion is true, this is the array of errors that occurred during the execution of the function stack. */
        this.errors = null;
    };

    /**Executes a sequence of functions in order.
    @param {ExecutionSession} session The currently executing session.*/
    var execute = function (session)
    {
        var curFunction = getNext(session);
        if (curFunction == null) return session.callback(session.errors);

        try
        {
            var result = curFunction(session.parameter);
            if (EVUI.Modules.Core.Utils.isPromise(result) === true)
            {
                result.then(function ()
                {
                    execute(session);

                }).catch(function (ex)
                {
                    if (session.forceCompletion === true)
                    {
                        EVUI.Modules.Core.Utils.log(ex);
                        session.errors.push(ex);

                        execute(session);
                    }
                    else
                    {
                        session.callback(ex)
                    }
                });
            }
            else
            {
                execute(session);
            }
        }
        catch (ex)
        {
            if (session.forceCompletion === true)
            {
                EVUI.Modules.Core.Utils.log(ex);
                session.errors.push(ex);

                execute(session);
            }
            else
            {
                session.callback(ex)
            }
        }
    };

    /**Gets the next function in a sequence of functions.
    @param {ExecutionSession} session The currently executing session.
    @returns {Function}*/
    var getNext = function (session)
    {
        var fn = session.functions[session.index];
        session.index++;

        return fn;
    };

    /**Executes a batch of functions in order based on their indexes in the functions array regardless if they are async or not. Designed to prevent race conditions between competing functions.
    @param {EVUI.Modules.Core.AsyncSequenceExecutionArgs|Function[]} exeArgsOrFns Either a YOLO AsyncSequenceExecutionArgs object or an array of functions.
    @param {EVUI.Modules.Core.Constants.Fn_ExecutorCallback} callback A callback function to call once the last function has completed executing.*/
    AsyncSequenceExecutor.prototype.execute = function (exeArgsOrFns, callback)
    {
        var argsType = typeof exeArgsOrFns;
        if (typeof exeArgsOrFns == null || argsType !== "object") throw Error("Object expected.");

        if (EVUI.Modules.Core.Utils.isArray(exeArgsOrFns) === true)
        {
            var fns = exeArgsOrFns;

            exeArgsOrFns = new EVUI.Modules.Core.AsyncSequenceExecutionArgs();
            exeArgsOrFns.functions = fns;
        }
        else
        {
            if (EVUI.Modules.Core.Utils.isArray(exeArgsOrFns.functions) === false) throw Error("Cannot execute without an array of functions.");
        }

        if (typeof callback !== "function") callback = function () { };

        var session = new ExecutionSession();
        session.functions = exeArgsOrFns.functions.filter(function (func) { return typeof func === "function" });
        session.index = 0;
        session.callback = callback;
        session.parameter = exeArgsOrFns.parameter;
        session.forceCompletion = (exeArgsOrFns.forceCompletion === true) ? true : false;
        session.errors = [];

        execute(session)
    };

    /**Awaitable. Executes a batch of functions in order based on their indexes in the functions array regardless if they are async or not. Designed to prevent race conditions between competing functions.
    @param {EVUI.Modules.Core.AsyncSequenceExecutionArgs|Function[]} exeArgsOrFns Either a YOLO AsyncSequenceExecutionArgs object or an array of functions.
    @returns {Promise<Error>|Promise<Error[]>}*/
    AsyncSequenceExecutor.prototype.executeAsync = function (exeArgsOrFns)
    {
        return new Promise(function (resolve, reject)
        {
            AsyncSequenceExecutor.execute(fns, parameter, function (ex)
            {
                if (ex instanceof Error) return reject(ex);
                if (EVUI.Modules.Core.Utils.isArray(ex) === true && ex.length > 0) return reject(ex);
                resolve();
            });
        });
    };

    return new AsyncSequenceExecutor();
})();

/**Executes a batch of functions in order based on their indexes in the functions array regardless if they are async or not. Designed to prevent race conditions between competing functions.
@param {EVUI.Modules.Core.AsyncSequenceExecutionArgs|Function[]} exeArgsOrFns Either a YOLO AsyncSequenceExecutionArgs object or an array of functions.
@param {EVUI.Modules.Core.Constants.Fn_ExecutorCallback} callback A callback function to call once the last function has completed executing.*/
$evui.executeSequence = function (exeArgsOrFns, callback)
{
    return EVUI.Modules.Core.AsyncSequenceExecutor.execute(exeArgsOrFns, callback);
};

/**Awaitable. Executes a batch of functions in order based on their indexes in the functions array regardless if they are async or not. Designed to prevent race conditions between competing functions.
@param {EVUI.Modules.Core.AsyncSequenceExecutionArgs|Function[]} exeArgsOrFns Either a YOLO AsyncSequenceExecutionArgs object or an array of functions.
@returns {Promise<Error>|Promise<Error[]>}*/
$evui.executeSequenceAsync = function (exeArgsOrFns, callback)
{
    return EVUI.Modules.Core.AsyncSequenceExecutor.executeAsync(exeArgsOrFns, callback);
};

/**Array of all the initialization functions passed into the Initialize function.
@type {EVUI.Modules.Core.Constants.Fn_Init[]|Core.Constants.Fn_InitAsync[]}*/
EVUI.Modules.Core.Initializers =
    EVUI.Modules.Core == null ? [] : EVUI.Modules.Core.Initializers; /*#LOCK#*/

if (EVUI.Modules.Core.Initializers == null) EVUI.Modules.Core.Initializers = [];

(function()
{
    //state variables to pass in via a closure to the Initialize function to keep redundant calls from happening
    var initExecuting = false;
    var initEx = null;
    var initDone = false;
    var initLoadDone = false;

    if (typeof (window) !== "undefined")
    {
        document.addEventListener("DOMContentLoaded", function () { initLoadDone = true; });
        window.addEventListener("load", function () { initLoadDone = true; });
    }
    else
    {
        initLoadDone = true;
    }


    /**Initializes an application. Fires when all DOM content has been loaded, all functions passed into this function are called in FIFO order, even if they are async functions.
    @param {EVUI.Modules.Core.Constants.Fn_Init|EVUI.Modules.Core.Constants.Fn_InitAsync} initFn An initialization function that can optionally be an async function.
    @returns {Promise}*/
    EVUI.Modules.Core.Initialize = function (initFn)
    {
        //add the function to the queue for init functions
        EVUI.Modules.Core.Initializers.push(initFn);

        return new Promise(function (resolve, reject)
        {
            var isDOM = typeof window !== "undefined"; //checking to see if the DOM is available, or if we are running in some environment where there is no document object (web worker, node.js, etc).
            var finish = function (ex)
            {
                initDone = false;
                if (ex == null || (EVUI.Modules.Core.Utils.isArray(ex) === true && ex.length === 0)) return resolve();
                return reject(ex);
            };

            var go = function ()
            {
                if (isDOM === true)
                {
                    //detach event handlers before doing anything
                    document.removeEventListener("DOMContentLoaded", go);
                    window.removeEventListener("load", go);
                }

                initLoadDone = true;

                //set a little timeout in case we're premature with the events slightly, or so that multiple calls to init wind up getting queued properly
                setTimeout(function ()
                {
                    if (initExecuting === false) //if we're not yet executing the function sequence, kick off the execution of the sequence
                    {
                        initExecuting = true;
                        var initFns = EVUI.Modules.Core.Initializers.splice(0, EVUI.Modules.Core.Initializers.length);

                        var exeArgs = new EVUI.Modules.Core.AsyncSequenceExecutionArgs();
                        exeArgs.functions = initFns;
                        exeArgs.parameter = $evui.settings;

                        EVUI.Modules.Core.AsyncSequenceExecutor.execute(exeArgs, function (error)
                        {
                            initDone = true;
                            initEx = error;
                            initExecuting = false;

                            return finish(error);
                        });
                    }
                    else //already executing, wait for the executor to finish
                    {
                        var wait = function ()
                        {
                            setTimeout(function ()
                            {
                                if (initDone === true)
                                {
                                    return finish(initEx);
                                }
                                else
                                {
                                    wait();
                                }
                            });
                        };

                        wait();
                    }
                }, 10);
            };

            //if the loading process is already done (i.e. the DOM is already loaded and ready), execute the functions like normal
            if (initLoadDone === true)
            {
                go();
            }
            else
            {
                if (isDOM === true)
                {
                    document.addEventListener("DOMContentLoaded", go);
                    window.addEventListener("load", go);
                }
                else
                {
                    go();
                }
            }
        });
    };
})();

/**Initializes an application. Fires when all DOM content has been loaded, all functions passed into this function are called in FIFO order, even if they are async functions.
@param {EVUI.Modules.Core.Constants.Fn_Init|EVUI.Modules.Core.Constants.Fn_InitAsync} initFn An initialization function that can optionally be an async function.
@returns {Promise}*/
$evui.init = function (initFn)
{
    return EVUI.Modules.Core.Initialize(initFn);
};

/**Object constructor for an object whose members can be accessed in a case-insensitive manner.
@param {Object} source An object to recursively extend into a case-insensitive object or object hierarchy.
@class*/
EVUI.Modules.Core.CaseInsensitiveObject = function (source)
{
    if (source == null || typeof source !== "object") return;
    if (source instanceof Node) return;

    var keys = EVUI.Modules.Core.Utils.getProperties(source); //Object.keys(source);
    var numKeys = keys.length;

    for (var x = 0; x < numKeys; x++)
    {
        var prop = keys[x];
        this.setValue(prop, source[prop]);
    }
};

/**Gets a value from the object while normalizing the case of the valueName. Note if there are multiple value names differing only in case, this will only return the first one found.
@param {String} valueName The name of the value to get.
@returns {Any}*/
EVUI.Modules.Core.CaseInsensitiveObject.prototype.getValue = function (valueName)
{
    //can only get a property if its key is a string or a number
    if (typeof valueName !== "string" && typeof valueName !== "number") return undefined;

    //check to see if it's already an exact match, if so return the value
    if (this[valueName] !== undefined) return this[valueName];

    //normalize the case if we're dealing with a string
    if (typeof valueName === "string") valueName = valueName.toLowerCase();

    var keys = Object.keys(this);
    var numKeys = keys.length;

    for (var x = 0; x < numKeys; x++) //for (var propName in this)
    {
        var propName = keys[x];

        //normalize the case of the property name
        var lowerPropname = (typeof propName === "string") ? propName.toLowerCase() : lowerPropname;

        //found it, return it
        if (lowerPropname === valueName) return this[propName];
    }

    //didn't find it, return undefined.
    return undefined;
};

/**The most expensive setter ever made. Sets a value in a case-insensitive way, meaning all case-insensitive matches are deleted and replaced with a single property with the given name.
This is to solve the problem of multiple case-insensitive matches on the same object (the first is returned, the others are ignored), this function ensures that the given key will return the provided value, no matter the case.
@param {String|Number} valueName The name of the value to set.
@param {Any} value The value to set.*/
EVUI.Modules.Core.CaseInsensitiveObject.prototype.setValue = function (valueName, value)
{
    if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(valueName) === true && typeof valueName !== "number") return false;
    var lowerValueName = (typeof propName === "string") ? valueName.toLowerCase() : valueName;

    if (typeof valueName === "string")
    {
        var keys = Object.keys(this);
        var numKeys = keys.length;

        for (var x = 0; x < numKeys; x++)
        {
            var propName = keys[x];

            var lowerPropname = (typeof propName === "string") ? propName.toLowerCase() : lowerPropname;
            if (lowerPropname === lowerValueName)
            {
                try
                {
                    delete propName;
                }
                catch (ex)
                {
                    this[popName] = undefined;
                }
            }
        }
    }

    this[valueName] = value;
    return true;
};

/**Utility for doing a simple deep extend on an object hierarchy. All objects created are either plain objects or plain arrays, but will have the same properties as their source object hierarchy.
@class*/
EVUI.Modules.Core.DeepExtender = (function ()
{
    var _hiddenTag = false;
    var _tagID = 0;

    try
    {
        if (typeof (Symbol) !== "undefined") _hiddenTag = Symbol((Math.random() * 10000).toString(36));
    }
    catch (ex)
    {

    }

    /**Dummy object we're using to attach the prototype deepExtend function to.*/
    var DeepExtender = function () { };

    /**Represents a property bag containing all the information about this deep clone operation.
    @class*/
    var DeepExtendSession = function ()
    {
        /**The object receiving properties from the source.
        @type {Object}*/
        this.target = null;

        /**The object whose properties are being copied onto the target.
        @type {Object}*/
        this.source = null;

        /**The options used to configure the deep clone operation.
        @type {EVUI.Modules.Core.DeepExtenderOptions}*/
        this.options = null;

        /**An array of ExistingObjects representing all the objects found in this graph.
        @type {ExistingObject}*/
        this.existingObjects = [];

        /**A lookup table where elements which were tagged are contained.
        @type {{}}*/
        this.existingObjectsLookup = {};

        /**Whether or not to filter by a predicate function.
        @type {Boolean} */
        this.filterViaFn = false;

        /**Whether or not to filter by an array od disallowed property names.
        @type {Boolean} */
        this.filterViaArray = false;

        /**If there was an array of property names, this is a quick-lookup table of them.
        @type {{}} */      
        this.filterLookup = null;
    };

    /**Container for a previously extended object.
    @class*/
    var ExistingObject = function (source, clone)
    {
        /**Object. The raw source object.
        @type {Object}*/
        this.source = source;
        /**Object. The object made from the source object.
        @type {Object}*/
        this.clone = clone;
        /**Array. All of the paths in the object graph that point to this object.
        @type {String}*/
        this.paths = [];
        /**Boolean. Whether or not both the source and the clone are the same object.
        @type {Boolean}*/
        this.sameReference = false;
    };

    /**Extends one object's hierarchy onto another object recursively.
    @param {Object} target The target object to extend properties on to.
    @param {Object} source The source object to extend.
    @param {EVUI.Modules.Core.DeepExtenderOptions} options An optional filter function used to filter out properties from the source to extend onto the target, return true to filter the property. Or an array of property names to not extend onto the target object.
    @returns {Object}*/
    DeepExtender.prototype.deepExtend = function(target, source, options)
    {

        if (typeof source !== "object" || source != null) throw Error("source must be an object.");
        if (typeof target !== "object" || target != null) throw Error("target must be an object.");

        var session = new DeepExtendSession();
        session.target = target;
        session.source = source;
        session.rootObj = target;
        session.options = (typeof options !== "object" || options == null) ? new EVUI.Modules.Core.DeepExtenderOptions() : options;

        return deepExtend(session);
    };


    /**Extends one object's hierarchy onto another object recursively.
    @param {DeepExtendSession} session
    @returns {Object}*/
    var deepExtend = function (session)
    {
        if (session.options.filter != null)
        {
            if (typeof filter === "function")
            {
                session.filterViaFn = true;
            }
            else if (EVUI.Modules.Core.Utils.isArray(filter) === true)
            {
                session.filterViaArray = true;

                session.filterLookup = {};
                var numInFilter = filter.length;
                for (var x = 0; x < numInFilter; x++)
                {
                    var curInFilter = filter[x];
                    session.filterLookup[curInFilter] = true;
                }
            }
        }

        addExistingObject(session, session.source, session.target, ""); //add the top level object to our list of existing objects so if another property points back to it, it will not get into an infinite loop
        
        var extended = extend(session.target, session.source, null, session);

        removeAllTags(session);

        return extended;
    };

    /**Extends one object's hierarchy onto another object recursively.
    @param {DeepExtendSession} session
    @returns {Object}*/
    var extend = function (target, source, path, session)
    {
        if (source == null || typeof source !== "object") return session.target;
        if (target == null || typeof target !== "object") return session.target;

        var keys = EVUI.Modules.Core.Utils.getProperties(source); //Object.keys(session.source);
        var numKeys = keys.length;

        //we recursively create a hierarchy of objects for whatever object was passed in.
        for (var x = 0; x < numKeys; x++)
        {
            var prop = keys[x];
            var val = undefined;

            if (session.filterViaFn === true)
            {
                if (session.filter(prop, session.source, target) === true) continue; //true means don't include
            }
            else if (session.filterViaArray === true)
            {
                if (session.filterLookup[prop] === true) continue; //was in the filter array, do not include
            }
            else
            {
                val = source[prop];
                var valType = typeof val;

                if (val != null && valType === "object") //we have a non-null object, trigger recursive extend
                {
                    var curPath = (path == null) ? prop : path + "." + prop;
                    var targetObj = target[prop];
                    var sameObj = (typeof targetObj === "object" && targetObj === val); //determine if we have the same object reference in both graphs

                    if (val instanceof Node === true) //no deep cloning of nodes.
                    {
                        target[prop] = val;
                        continue;
                    }

                    var existingObject = getExistingObject(session, val); //make sure we haven't already processed this object (without this check circular references cause an error)
                    if (existingObject != null) //already did this one, just pull out the existing object
                    {
                        if (existingObject.sameReference === false) //we already figured out that the existing object appeared in both graphs and assigned the clone to be the same reference as the session.source, so we have no work to do
                        {
                            if (sameObj === true) //both objects are the same, and we have already run into the session.source object before
                            {
                                existingObject.clone = targetObj;

                                //find each location where the clone was stored and switch it with the correct reference
                                var numLocations = existingObject.paths.length;
                                for (var y = 0; y < numLocations; y++)
                                {
                                    EVUI.Modules.Core.Utils.setValue(existingObject.paths[y], session.rootObj, val);
                                }

                                existingObject.paths.splice(0, numLocations);
                                existingObject.sameReference = true;
                            }
                            else //otherwise, record where we put the object
                            {
                                existingObject.paths.push(curPath);
                                existingObject.sameReference = false;
                            }
                        }

                        target[prop] = existingObject.clone;
                    }
                    else //haven't done it yet
                    {
                        if (typeof targetObj !== "object" || targetObj == null)
                        {
                            targetObj = EVUI.Modules.Core.Utils.isArray(val) ? [] : {}; //add it to the list of ones we've done BEFORE processing it (lest it itself be one of its own properties or part of a greater circular reference loop)
                        }

                        addExistingObject(session, val, targetObj, curPath);

                        
                        target[prop] = extend(targetObj, val, curPath, session); //populate our new child recursively
                    }
                }
                else //anything else, just set its value
                {
                    if (val !== undefined) target[prop] = val;
                }
            }
        }

        return target;
    };

    /**Looks through the list of previously extended objects and returns one if found.
    @param {Object} source The object to extend if not found in this list.*/
    var getExistingObject = function (session, source)
    {
        if (_hiddenTag !== false) //if we can tag objects, check that cache first
        {
            var existing = session.existingObjectsLookup[source[_hiddenTag]];
            if (existing != null) return existing;
        }

        //if we didn't find it, loop through the untagged objects
        var numObjs = session.existingObjects.length;
        for (var x = 0; x < numObjs; x++)
        {
            var curObj = session.existingObjects[x];
            if (curObj.source === source) return curObj;
        }

        return null;
    };

    /**Adds an object to the lookup hash table and to the lookup array if the hash table add failed.
    @param {DeepExtendSession} session The session of the extension operation.
    @param {Object} source The source object to map to the cloned object.
    @param {Object} clone The clone of the source object.
    @param {String} path The path at which the clone was made.
    @returns {ExistingObject}*/
    var addExistingObject = function (session, source, clone, path)
    {
        var entry = null;
        if (_hiddenTag !== false) //if we have the hidden tag symbol...
        {
            //see if we have already tagged this object. If so, just add the path to it and return it. Otherwise make a new one and try to add that to the hash lookup.
            var existing = session.existingObjectsLookup[source[_hiddenTag]];
            if (existing == null)
            {
                existing = new ExistingObject(source, clone);
                existing.paths.push(path);

                var tag = _tagID++;
                source[_hiddenTag] = tag;
                var wasAdded = typeof (source[_hiddenTag]) === "number"; //if the object is frozen or sealed this will be false

                if (wasAdded === true) //key added, add it to lookup list
                {
                    session.existingObjectsLookup[tag] = existing;
                    return existing;
                }
                else //key not added, add to the back-up array
                {
                    entry = existing;
                }
            }
            else
            {
                existing.paths.push(path);
                return existing;
            }
        }

        //either no support for Symbols or we have an ExistingObject reference from above.
        if (entry == null) entry = new ExistingObject(source, clone);
        entry.paths.push(path);

        //add it to the objects list
        session.existingObjects.push(entry);

        return entry;
    };

    /**Removes the tags from all the tagged objects.
    @param {DeepExtendSession} session The session with the tagged objects to be removed.*/
    var removeAllTags = function (session)
    {
        var taggedKeys = Object.keys(session.existingObjectsLookup);

        var numKeys = taggedKeys.length;
        for (var x = 0; x < numKeys; x++)
        {
            var tagged = session.existingObjectsLookup[taggedKeys[x]];
            if (tagged != null) delete tagged.source[_hiddenTag];
        }
    }

    return new DeepExtender();
})();

/**Options for configuring the DeepExtender.*/
EVUI.Modules.Core.DeepExtenderOptions = function ()
{
    /**filter An optional filter function used to filter out properties from the source to extend onto the target, return true to filter the property. Or an array of property names to not extend onto the target object.
    @type {EVUI.Modules.Core.Constants.Fn_ExtendPropertyFilter|String[]}*/
    this.filter = null;
};

/**Object for wrapping properties in one object so that manipulating them changes a different object.
@class*/
EVUI.Modules.Core.ObjectPropertyWrapper = function ()
{
    /**Wraps all the properties specified in the property mappings parameter so that they are settable on the source object but are set and read from the target object.
    @param {Object} source The source object to receive the properties.
    @param {Object} target The target object to be manipulated by the getters and setters on the source object.
    @param {EVUI.Modules.Core.ObjectPropertyMapping|EVUI.Modules.Core.ObjectPropertyMapping[]} propertyMappings A single or an array of ObjectPropertyMapping describing the mappings between the two objects.
    @param {EVUI.Modules.Core.ObjectPropertyMappingSettings} settings The settings to apply to each mapping if the mappings do not have their own settings defined.*/
    this.wrap = function (source, target, propertyMappings, settings)
    {
        if (source == null) throw Error("Cannot wrap a property from a null or undefined source object.");
        if (target == null) throw Error("Cannot make a property wrapper on a null or undefined target object.");
        if (propertyMappings == null) return false;

        if (EVUI.Modules.Core.Utils.isArray(propertyMappings) === false) propertyMappings = [propertyMappings];
        var numMappings = propertyMappings.length;

        if (settings == null) settings = new EVUI.Modules.Core.ObjectPropertyMappingSettings();

        for (var x = 0; x < numMappings; x++)
        {
            var curSetting = propertyMappings[x];
            if (curSetting.settings == null) curSetting.settings = settings;

            mapProperty(source, target, curSetting);
        }
    }

    /**Wraps a property so that setting or getting it on the source object actually gets or sets it on the target object.
    @param {Object} source The object to receive the getter and setter.
    @param {Object} target The object having its value get and set.
    @param {EVUI.Modules.Core.ObjectPropertyMapping} objectPropertyMapping The mapping of the source to the target.*/
    var mapProperty = function (source, target, objectPropertyMapping)
    {
        if (objectPropertyMapping == null) return;
        if (typeof objectPropertyMapping.sourcePath !== "string")
        {
            if (typeof objectPropertyMapping.sourcePath === "number")
            {
                objectPropertyMapping.sourcePath = objectPropertyMapping.sourcePath.toString();
            }
            else if (objectPropertyMapping.sourcePath != null)
            {
                return;
            }
        }

        if (typeof objectPropertyMapping.targetPath !== "string")
        {
            if (typeof objectPropertyMapping.targetPath === "number")
            {
                objectPropertyMapping.targetPath = objectPropertyMapping.targetPath.toString();
            }
            else if (objectPropertyMapping.targetPath != null)
            {
                return;
            }
        }

        var sourceObject = source;
        var sourceObjSegments = (objectPropertyMapping.sourcePath == null) ? [] : EVUI.Modules.Core.Utils.getValuePathSegments(objectPropertyMapping.sourcePath);

        var numSourceSegments = sourceObjSegments.length;
        var sourceObjectPath = (numSourceSegments - 1 <= 0) ? null : sourceObjSegments.slice(0, numSourceSegments - 1).join(".");

        sourceObject = EVUI.Modules.Core.Utils.getValue(sourceObjectPath, source);
        if (sourceObject == null) return;

        var settings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Core.ObjectPropertyMappingSettings(), objectPropertyMapping.settings);
        if (settings.autoDetect === true)
        {
            settings = new EVUI.Modules.Core.ObjectPropertyMappingSettings();

            var propertyDescriptor = Object.getOwnPropertyDescriptor(sourceObject, sourceObjSegments[numSourceSegments - 1]);
            if (typeof propertyDescriptor.get === "function" || propertyDescriptor.value !== undefined) settings.get = true;
            if (typeof propertyDescriptor.set === "function" || propertyDescriptor.writable === true) settings.set = true;
            if (propertyDescriptor.configurable === true) settings.configurable = true;
            if (propertyDescriptor.enumerable === false) settings.enumerable = false;
        }

        var targetPath = objectPropertyMapping.targetPath; //severs the link between the definition object and the target path so it can't be changed later

        var propertyDef = {};
        if (settings.get === true) propertyDef.get = function () { return EVUI.Modules.Core.Utils.getValue(targetPath, target); }
        if (settings.set === true) propertyDef.set = function (value) { EVUI.Modules.Core.Utils.setValue(targetPath, target, value); }
        propertyDef.configurable = settings.configurable;
        propertyDef.enumberable = settings.enumerable;

        try
        {
            Object.defineProperty(sourceObject, sourceObjSegments[numSourceSegments - 1], propertyDef);
        }
        catch (ex)
        {
            EVUI.Modules.Core.Utils.debugReturn("ObjectPropertyWrapper", "mapProperty", ex.stack);
        }
    };
};

/**Represents a dynamic property mapping where setting or getting one property in one object will actually get or set a property in another object.
@class*/
EVUI.Modules.Core.ObjectPropertyMapping = function ()
{
    /**String. The path of the property in the source object that wraps the property for the target object.  Paths are "." or "[]" delineated strings from a root object down to a property nested within that root object. I.e. a path of "a.b[2].c" would get/set the value of source.a.b[2].c.
    @type {String}*/
    this.sourcePath = null;

    /**String. The path of the property in the target object that is written to and read from via the source path. Paths are "." or "[]" delineated strings from a root object down to a property nested within that root object. I.e. a path of "a.b[2].c" would get/set the value of target.a.b[2].c.
    @type {String}*/
    this.targetPath = null;

    /**Object. The settings describing how the source and target should be mapped.
    @type {EVUI.Modules.Core.ObjectPropertyMappingSettings}*/
    this.settings = null;
};

/**The settings for describing how a property will be mapped between the source and target objects.
@class*/
EVUI.Modules.Core.ObjectPropertyMappingSettings = function ()
{
    /**Boolean. Whether or not to auto-detect the settings on the target object's property (via Object.getOwnPropertyDescriptor) and use those settings as the basis for the values of this object.
    @type {Boolean}*/
    this.autoDetect = false;

    /**Boolean. Whether or not a getter should be added. True by default.
    @type {Boolean}*/
    this.get = true;

    /**Boolean. Whether or not a setter should be added. True by default.
    @type {Boolean}*/
    this.set = true;

    /**Boolean. Whether or not the property can be deleted or changed once added. False by default.
    @type {Boolean}*/
    this.configurable = false;

    /**Boolean. Whether or not the property can be enumerated. True by default.
    @type {Boolean}*/
    this.enumerable = true;
};


/**Module for containing all common functionality that all the other modules share.
@module*/
EVUI.Modules.Core.Utils = {};

/**Creates an instance of a blank EVUI.Modules.Core.Utils.CaseInsensitiveObject.
@param {Object} source: An object to recursively extend into the case-insensitive object or object hierarchy.
@returns {EVUI.Modules.Core.CaseInsensitiveObject}*/
$evui.cio = function (source)
{
    return new EVUI.Modules.Core.CaseInsensitiveObject(source)
};

/**Extends one object's hierarchy onto another object recursively.
@param {Object} target The target object to extend properties on to.
@param {Object} source The source object to extend.
@param {EVUI.Modules.Core.DeepExtenderOptions} options The configuration options for the deep extender.
@returns {Object}*/
EVUI.Modules.Core.Utils.deepExtend = function (target, source, options)
{
    return new EVUI.Modules.Core.DeepExtender.deepExtend(target, source, options);
};


/**Extends one object's hierarchy onto another object recursively.
@param {Object} target The target object to extend properties on to.
@param {Object} source The source object to extend.
@param {EVUI.Modules.Core.DeepExtenderOptions} options The configuration options for the deep extender.
@returns {Object}*/
$evui.deepExtend = function (target, source, options)
{
    return EVUI.Modules.Core.Utils.deepExtend(target, source, options);
};

/**Returns a CaseInsensitiveObject that contains all the attributes on an element as members of the object.
@param {Object} element The element to get the attributes of.
@returns {EVUI.Modules.Core.CaseInsensitiveObject}*/
EVUI.Modules.Core.Utils.getElementAttributes = function (element)
{
    if (element == null) return null;
    if (EVUI.Modules.Core.Utils.isjQuery(element) === true) element = element[0];
    if (EVUI.Modules.Core.Utils.isDomHelper(element) === true) element = element.elements[0];
    if (EVUI.Modules.Core.Utils.isElement(element) === false) return null;

    var attributeBag = new EVUI.Modules.Core.CaseInsensitiveObject();

    var numAttributes = element.attributes.length;
    for (var x = 0; x < numAttributes; x++)
    {
        var curAttribute = element.attributes[x];
        attributeBag[curAttribute.name] = curAttribute.value;
    }

    return attributeBag;
};

/**Returns a CaseInsensitiveObject that contains all the attributes on an element as members of the object.
@param {Object} element The element to get the attributes of.
@returns {EVUI.Modules.Core.CaseInsensitiveObject}*/
$evui.getAttrs = function (element)
{
    return EVUI.Modules.Core.Utils.getElementAttributes(element);
}

/**Wraps all the properties specified in the property mappings parameter so that they are settable on the source object but are set and read from the target object.
@param {Object} source The source object to receive the properties.
@param {Object} target The target object to be manipulated by the getters and setters on the source object.
@param {EVUI.Modules.Core.ObjectPropertyMapping|EVUI.Modules.Core.ObjectPropertyMapping[]} propertyMappings An array of ObjectPropertyMapping describing the mappings between the two objects.
@param {EVUI.Modules.Core.ObjectPropertyMappingSettings} settings The settings to apply to each mapping if the mappings do not have their own settings defined.*/
EVUI.Modules.Core.Utils.wrapProperties = function (source, target, propertyMappings, settings)
{
    return new EVUI.Modules.Core.ObjectPropertyWrapper().wrap(source, target, propertyMappings, settings);
};

/**Wraps all the properties specified in the property mappings parameter so that they are settable on the source object but are set and read from the target object.
@param {Object} source The source object to receive the properties.
@param {Object} target The target object to be manipulated by the getters and setters on the source object.
@param {EVUI.Modules.Core.ObjectPropertyMapping|EVUI.Modules.Core.ObjectPropertyMapping[]} propertyMappings An array of ObjectPropertyMapping describing the mappings between the two objects.
@param {EVUI.Modules.Core.ObjectPropertyMappingSettings} settings The settings to apply to each mapping if the mappings do not have their own settings defined.*/
$evui.wrap = function (source, target, propertyMappings, settings)
{
    return new EVUI.Modules.Core.Utils.wrapProperties(source, target, propertyMappings, settings);
};

/**Gets a property of an object based on its path starting at the source object.
@param {String} path The dot or bracket delineated path from the source object to the property to get. I.e. a path of "a.b[2].c" would get the value of source.a.b[2].c.
@param {Object} source The starting point of the operation to get the value of the source object.
@returns {Any} */
EVUI.Modules.Core.Utils.getValue = function (path, source)
{
    if (source == null) throw Error("Cannot get a value from a null or undefined source.");

    var pathType = typeof path;
    if (pathType !== "string")
    {
        if (pathType === "number") return source[path];
        if (pathType === "symbol") return source[path];
        if (path == null) return source;

        throw Error("Cannot get value, path must be a string.");
    }

    var segments = EVUI.Modules.Core.Utils.getValuePathSegments(path); //path.replace(/\]/g, "").split(/\.|[\[\]]/g);
    var numSegs = segments.length;
    var curObj = source;

    for (var x = 0; x < numSegs; x++)
    {
        curObj = curObj[segments[x]];
        if (curObj == null) return null;
    }

    return curObj;
};

/**Gets a property of an object based on its path starting at the source object.
@param {String} path The dot or bracket delineated path from the source object to the property to get. I.e. a path of "a.b[2].c" would get the value of source.a.b[2].c.
@param {Object} source The starting point of the operation to get the value of the source object.
@returns {Any} */
$evui.get = function (path, source)
{
    return EVUI.Modules.Core.Utils.getValue(path, source);
};

/**Breaks up a "property path" (a "path" of properties that are separated by dots or braces that leads from a parent object to a child property in it or a child object) into an array of path segments.
@param {String} propertyPath The path to a property.
@returns {String[]} */
EVUI.Modules.Core.Utils.getValuePathSegments = function (propertyPath)
{
    var propType = typeof propertyPath;
    if (propType !== "string") throw Error("Cannot get path segments from a non-string.");

    var segs = propertyPath.split(/\.|\[|\]\.|\]/g); //split based on dots, open braces, close braces followed by a dot, and close braces (in that order so that close braces followed by a dot do not turn into two matches)
    var numSegs = segs.length;
    if (segs[numSegs - 1] === "") segs = segs.slice(0, segs.length - 1);

    return segs;
};

/**Breaks up a "property path" (a "path" of properties that are separated by dots or braces that leads from a parent object to a child property in it or a child object) into an array of path segments.
@param {String} propertyPath The path to a property.
@returns {String[]} */
$evui.getPathSegments = function (propertyPath)
{
    return EVUI.Modules.Core.Utils.getValuePathSegments(propertyPath);
};

/**Sets a property of an object based on its path starting at the target object.
@param {String} path The dot or bracket delineated path from the source object to the property to set. I.e. a path of "a.b[2].c" would set the value of source.a.b[2].c.
@param {Object} target The starting point of the operation to set the value of the source object.
@param {Any} value The value to set the property at the end of the path to.
@param {Boolean} fill Whether or not to fill in any gaps in the object path with plain objects if one is missing.
@returns {Boolean} */
EVUI.Modules.Core.Utils.setValue = function (path, target, value, fill)
{
    if (typeof path !== "string")
    {
        if (EVUI.Modules.Core.Utils.isArray(target) === true && typeof path === "number")
        {
            target[path] = value;
            return true;
        }

        if (path == null)
        {
            target = value;
            return true;
        }

        throw Error("Cannot set value, path must be a string.");
    }

    if (target == null) throw Error("Cannot set value of a null or undefined target.");

    var segments = EVUI.Modules.Core.Utils.getValuePathSegments(path);
    var numSegs = segments.length;
    var curObj = target;

    for (var x = 0; x < numSegs; x++)
    {
        if (x === numSegs - 1)
        {
            curObj[segments[numSegs - 1]] = value;
            return true;
        }

        var curSeg = segments[x];

        var nextObj = curObj[curSeg];
        if (nextObj == null)
        {
            if (fill === true)
            {
                nextObj = {};
                curObj[curSeg] = nextObj;
            }
            else
            {
                throw Error("Failed to set property at path \"" + path + "\", \"" + curSeg + "\"  was null or undefined.");
            }
        }

        curObj = nextObj;
    }

    return false;
};

/**Sets a property of an object based on its path starting at the target object.
@param {String} path The dot or bracket delineated path from the source object to the property to set. I.e. a path of "a.b[2].c" would set the value of source.a.b[2].c.
@param {Object} target The starting point of the operation to set the value of the source object.
@param {Any} value The value to set the property at the end of the path to.
@param {Boolean} fill Whether or not to fill in any gaps in the object path with plain objects if one is missing.
@returns {Boolean} */
$evui.set = function (path, target, value, fill)
{
    return EVUI.Modules.Core.Utils.setValue(path, target, value, fill);
}

/**Gets a value from a settings table.
@param {String} setting The name of the setting to get.
@param {Object} settingsObj The object to get the setting from. If omitted, the $evui.settings object is used by default.
@returns {Any} */
EVUI.Modules.Core.Utils.getSetting = function (setting, settingsObj)
{
    if (setting == null || (typeof setting !== "string" && typeof setting !== "number" && typeof setting !== "symbol")) return null;

    //if for some reason the $evui.settings object is null, we get it from the EVUI.Modules.Core.Settings object, which cannot be set to null.
    if (settingsObj != null && typeof settingsObj === "object") return settingsObj[setting];
    return ($evui.settings == null) ? EVUI.Modules.Core.Settings[setting] : $evui.settings[setting];
};

/**Checks to see if a value is one of the possible values that are commonly used that can mean true (true, 1, "true", or "1") rather than doing JavaScript's implicit typecasting for "truthy" values. 
@param {Any} value The value to check.
@returns {Boolean} */
EVUI.Modules.Core.Utils.isTrue = function (value)
{
    if (value == null) return false;
    if (typeof value === "string") value = value.toLowerCase();
    if (value === "true" || value === 1 || value === "1" || value === true) return true;
    return false;
};

/**Checks to see if one of the constants from a settings table is true.
@param {String} setting The name of the setting to get.
@param {Object} settingsObj The object to get the setting from. If omitted, the $evui.settings object is used by default.
@returns {Boolean} */
EVUI.Modules.Core.Utils.isSettingTrue = function (setting, settingsObj)
{
    return EVUI.Modules.Core.Utils.isTrue(EVUI.Modules.Core.Utils.getSetting(setting, settingsObj));
};

/**Determines if an object can be treated like an array, but not necessarily have the full compliment of Array's prototype functions.
@param {Array} arr The object to test.
@returns {Boolean}*/
EVUI.Modules.Core.Utils.isArray = function (arr)
{
    if (arr == null) return false;

    var arrType = typeof arr;
    if (arrType === "string" || arrType === "function") return false;

    if (Array.isArray(arr) === true) return true;

    if (typeof arr.length === "number")
    {
        return true;
    }
    else
    {    
        return false;
    }
};

/**Determines if an object can be treated like an array, but not necessarily have the full compliment of Array's prototype functions.
@param {Array} arr The object to test.
@returns {Boolean}*/
$evui.isArray = function (arr)
{
    return EVUI.Modules.Core.Utils.isArray(arr);
};

/**Makes a new GUID. Note that this GUID generation function is not intended to create GUIDs to be persisted in any sort of database, shortcuts were taken to simplify the code
that result in having a much higher (but still infinitesimal) odds of collision. It is intended for temporary ID's in a single web app session where the odds of collision are basically zero.
@returns {String}*/
EVUI.Modules.Core.Utils.makeGuid = function ()
{
    return "xxxxxxxx-xxxx-4xxx-8xxx-xxxxxxxxxxxx".replace(/x/g, function ()
    {
        var random = Math.random() * 16;
        random = Math.floor(random);

        return random.toString(16);
    });
};

/**Makes a new GUID. Note that this GUID generation function is not intended to create GUIDs to be persisted in any sort of database, shortcuts were taken to simplify the code
that result in having a much higher (but still infinitesimal) odds of collision. It is intended for temporary ID's in a single web app session where the odds of collision are basically zero.
@returns {String}*/
$evui.guid = function ()
{
    return EVUI.Modules.Core.Utils.makeGuid();
};

/**Makes an empty GUID.
@returns {String}*/
EVUI.Modules.Core.Utils.emptyGuid = function ()
{
    return "00000000-0000-0000-0000-000000000000";
};

/**Makes an empty GUID.
@returns {String}*/
$evui.emptyGuid = function ()
{
    return EVUI.Modules.Core.Utils.emptyGuid();
};

/**Determines whether or not an object can be treated like a Promise.
@param {Promise} promise The object to test.
@returns {Boolean} */
EVUI.Modules.Core.Utils.isPromise = function (promise)
{
    if (promise == null) return false;

    if (typeof (Promise) !== "undefined")
    {
        if (promise instanceof Promise) return true;
    }

    if (typeof promise.then === "function" && typeof promise.catch === "function") return true;
    return false;
};

/**Determines whether or not an object can be treated like a Promise.
@param {Promise} promise The object to test.
@returns {Boolean} */
$evui.isPromise = function (promise)
{
    return EVUI.Modules.Core.Utils.isPromise(promise);
};

/**Normalizes a string by clipping off whitespace and optionally lower casing or locale lower casing it.
@param {String} str The string to normalize.
@param {Boolean} lowerCase Whether or not to normalize case. If omitted the normalizeStringCase setting is used instead.
@param {Boolean} localeCase Whether or not to normalize to localeLowerCase. If omitted the localseStringComparison setting is used instead.
@returns {String} */
EVUI.Modules.Core.Utils.stringNormalize = function (str, lowerCase, localeCase)
{
    if (typeof str !== "string") return null;

    if (typeof lowerCase !== "boolean") lowerCase = EVUI.Modules.Core.Utils.getSetting("normalizeStringCase");
    if (typeof lowerCase !== "boolean") lowerCase = true;

    if (typeof localeCase !== "boolean") localeCase = EVUI.Modules.Core.Utils.getSetting("localizeStringComparison");
    if (typeof localeCase !== "boolean") localeCase = false;

    str = str.trim();

    if (lowerCase === true)
    {
        if (localeCase === true)
        {
            return str.toLocaleLowerCase();
        }
        else
        {
            return str.toLowerCase();
        }
    }
    else
    {
        if (localeCase === true)
        {
            return str.toLocaleLowerCase();
        }

        return str;
    }
};

/**Normalizes a string by clipping off whitespace and optionally lower casing or locale lower casing it.
@param {String} str The string to normalize.
@param {Boolean} lowerCase Whether or not to normalize case. If omitted the normalizeStringCase setting is used instead.
@param {Boolean} localeCase Whether or not to normalize to localeLowerCase. If omitted the localseStringComparison setting is used instead.
@returns {String} */
$evui.strNormalize = function (str, lowerCase, localeCalse)
{
    return EVUI.Modules.Core.Utils.stringNormalize(str, lowerCase, localeCalse);
};

/**Normalizes and compares two strings. Returns 0 if equal, 1 if the first string comes before the second in the sort order, or -1 if the opposite is true.
@param {String} str1 A string to normalize and compare.
@param {String} str2 A string to normalize and compare.
@param {Boolean} lowerCase Whether or not to normalize case. If omitted the normalizeStringCase setting is used instead.
@param {Boolean} useLocale Whether or not to normalize to localeLowerCase. If omitted the localseStringComparison setting is used instead.
@returns {Number} */
EVUI.Modules.Core.Utils.stringCompare = function (str1, str2, lowerCase, useLocale)
{
    if (typeof str1 !== "string" && typeof str2 !== "string") return null;

    if (typeof lowerCase !== "boolean") lowerCase = EVUI.Modules.Core.Utils.getSetting("normalizeStringCase");
    if (typeof lowerCase !== "boolean") lowerCase = true;

    if (typeof useLocale !== "boolean") useLocale = EVUI.Modules.Core.Utils.getSetting("localizeStringComparison");
    if (typeof useLocale !== "boolean") useLocale = false;

    str1 = EVUI.Modules.Core.Utils.stringNormalize(str1, lowerCase, useLocale);
    str2 = EVUI.Modules.Core.Utils.stringNormalize(str2, lowerCase, useLocale);

    var result = 0;

    if (useLocale === true)
    {
        result = str1.trim().localeCompare(str2.trim());
        if (result <= -1) result = -1;
        if (result => 1) result = 1;
    }
    else
    {
        if (str1 < str2) result = -1;
        if (str2 < str1) result = 1;
    }

    return result;
};

/**Normalizes and compares two strings. Returns 0 if equal, 1 if the first string comes before the second in the sort order, or -1 if the opposite is true.
@param {String} str1 A string to normalize and compare.
@param {String} str2 A string to normalize and compare.
@param {Boolean} lowerCase Whether or not to normalize case. If omitted the normalizeStringCase setting is used instead.
@param {Boolean} useLocale Whether or not to normalize to localeLowerCase. If omitted the localseStringComparison setting is used instead.
@returns {Number} */
$evui.strCompare = function (str1, str2, lowerCase, useLocale)
{
    return EVUI.Modules.Core.Utils.stringCompare(str1, str2, lowerCase, useLocale);
};


/**Determines if the parameter passed in is 1) not null, 2) a string, and 3) not composed of only whitespace characters. It is used when we want to make sure a string being used as a key or
name for something is garbage. Returns a boolean.
@param {String} str The string to check.
@returns {Boolean}*/
EVUI.Modules.Core.Utils.stringIsNullOrWhitespace = function (str)
{
    if (str == null || typeof str !== "string") return true;
    var isOnlyWhitespace = (str.trim().length === 0);
    return isOnlyWhitespace;
};

/**Determines if the parameter passed in is 1) not null, 2) a string, and 3) not composed of only whitespace characters. It is used when we want to make sure a string being used as a key or
name for something is garbage. Returns a boolean.
@param {String} str The string to check.
@returns {Boolean}*/
$evui.strIsValid = function (str)
{
    return !EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(str);
};

/**Determines if a string starts with the given phrase.
@param {String} startPhrase The phrase to check for.
@param {String} str The string being checked.
@returns {Boolean}*/
EVUI.Modules.Core.Utils.stringStartsWith = function (startPhrase, str)
{
    if (typeof str !== "string" || typeof startPhrase !== "string") return false;
    if (str.indexOf(startPhrase) !== 0) return false;
    return true;
};

/**Determines if a string starts with the given phrase.
@param {String} startPhrase The phrase to check for.
@param {String} str The string being checked.
@returns {Boolean}*/
$evui.strStartsWith = function (startPhrase, str)
{
    return EVUI.Modules.Core.Utils.stringStartsWith(startPhrase, str);
};

/**Determines if a string ends with the given phrase.
@param {String} endPhrase The phrase to check for.
@param {String} str The string being checked.
@returns {Boolean}*/
EVUI.Modules.Core.Utils.stringEndsWith = function (endPhrase, str)
{
    if (typeof str !== "string" || typeof endPhrase !== "string") return false;

    var endLength = endPhrase.length;
    var strLen = str.length;

    if (endLength > strLen) return false;

    try
    {
        var ending = str.substring(strLen - endLength);
        if (ending === endPhrase) return true;
        return false;
    }
    catch (ex)
    {
        return false;
    }

};

/**Determines if a string ends with the given phrase.
@param {String} endPhrase The phrase to check for.
@param {String} str The string being checked.
@returns {Boolean}*/
$evui.strEndsWith = function (endPhrase, str)
{
    return EVUI.Modules.Core.Utils.stringEndsWith(endPhrase, str);
};

/**Console logging function that can be disabled by setting $evui.settings.loggingEnabled to false. If disabled, it will attempt to fire $evui.settings.alternateLoggingFunction if one was provided.
@param {String} message The message to log.*/
EVUI.Modules.Core.Utils.log = function (message)
{
    try
    {
        if (EVUI.Modules.Core.Utils.isSettingTrue("loggingEnabled"))
        {
            console.log(message);
        }
        else
        {
            var alternateLog = EVUI.Modules.Core.Utils.getSetting("alternateLoggingFunction");
            if (typeof alternateLog === "function") alternateLog(message);
        }
    }
    catch (ex)
    {

    }
};

/**Console logging function that can be disabled by setting $evui.settings.loggingEnabled to false. If disabled, it will attempt to fire $evui.settings.alternateLoggingFunction if one was provided.
@param {String} message The message to log.*/
$evui.log = function (message)
{
    return EVUI.Modules.Core.Utils.log(message);
};

/**Bit flag operator. Checks to see if the flagSet has the given flag set. Returns true if the flag set has the flag, false if it does not.
@param {Number} flagSet The composite value composed of flags.
@param {Number} flagValue The flag to check for.
@returns {Boolean}*/
EVUI.Modules.Core.Utils.hasFlag = function (flagSet, flagValue)
{
    if (typeof flagSet !== "number" || typeof flagValue !== "number") return false;
    var value = flagSet & flagValue;
    return (value === flagValue);
};

/**Bit flag operator. Checks to see if the flagSet has the given flag set.
@param {Number} flagSet The composite value composed of flags.
@param {Number} flagValue The flag to check for.
@returns {Boolean}*/
$evui.hasFlag = function (flagSet, flagValue)
{
    return EVUI.Modules.Core.Utils.hasFlag(flagSet, flagValue);
};

/**Bit flag operator. Sets a flag on the given flag set and returns the new flag set..
@param {Number} flagSet The composite value composed of flags.
@param {Number} flagValue The flag to set.
@returns {Number}*/
EVUI.Modules.Core.Utils.addFlag = function (flagSet, flag)
{
    if (typeof flagSet !== "number" && typeof flag !== "number") return flagSet;
    return flagSet | flag;
};

/**Bit flag operator. Sets a flag on the given flag set and returns the new flag set..
@param {Number} flagSet The composite value composed of flags.
@param {Number} flagValue The flag to set.
@returns {Number}*/
$evui.addFlag = function (flagSet, flag)
{
    return EVUI.Modules.Core.Utils.addFlag(flagSet, flag);
};

/**Bit flag operator. Removes a flag on the given flag set and returns the new flag set..
@param {Number} flagSet The composite value composed of flags.
@param {Number} flagValue The flag to remove.
@returns {Number}*/
EVUI.Modules.Core.Utils.removeFlag = function (flagSet, flag)
{
    if (typeof flagSet !== "number" && typeof flag !== "number") return flagSet;

    flagSet &= ~flag
    return flagSet;
};

/**Bit flag operator. Removes a flag on the given flag set and returns the new flag set.
@param {Number} flagSet The composite value composed of flags.
@param {Number} flagValue The flag to remove.
@returns {Number}*/
$evui.removeFlag = function (flagSet, flag)
{
    return EVUI.Modules.Core.Utils.removeFlag(flagSet, flag);
};

/**Checks to see if an object is an instance of a jQuery object.
@param {Object} object The object to check.
@returns {Boolean}*/
EVUI.Modules.Core.Utils.isjQuery = function (object)
{
    if (object == null) return false; //no object to compare against, always false
    if (typeof (window.jQuery) === "undefined") return false; //jquery was never available
    if (object instanceof jQuery === true) return true; //we have jquery and this object is an instance of the jQuery constructor
    return false;
};

/**Checks to see if an object is an instance of a jQuery object.
@param {Object} object The object to check.
@returns {Boolean}*/
$evui.isjQuery = function (object)
{
    return EVUI.Modules.Core.Utils.isjQuery(object);
};

/**Checks to see if an object is derived from an Element-derived object.
@param {Object} object The object to check.
@returns {Boolean}*/
EVUI.Modules.Core.Utils.isElement = function (object)
{
    return object instanceof Element;
};

/**Checks to see if an object is derived from an Element-derived object.
@param {Object} object The object to check.
@returns {Boolean}*/
$evui.isElement = function (object)
{
    return EVUI.Modules.Core.Utils.isElement(object);
};

/**Utility method for simultaneously logging a debug message and returning a value. Exists for the purpose of returning and logging from a single-line if statement.
This is used to create consistently formatted debug messages for an end user so that they can get some insight into why and where something isn't working. Wherever an unusable input or 
a broken state is detected, this function is used to log it and return safely. Can be silenced via setting $evui.settings.debug to false. Critically important to the guts of EventUI, 
but admittedly of little use to others - use $evui.debug(message, returnValue) for a more generic version. 
@param {String} controller The EventUI controller or object logging the message.
@param {String} method The function that is logging the message.
@param {String} message The message to log.
@param {Any} returnValue Any value to return.
@returns {Any}*/
EVUI.Modules.Core.Utils.debugReturn = function (controller, method, message, returnValue)
{
    if (EVUI.Modules.Core.Utils.isSettingTrue("debug") === false) return returnValue;

    var logStatement = "";
    if (typeof controller === "string")
    {
        logStatement = controller;
    }

    if (typeof method === "string")
    {
        if (logStatement !== "")
        {
            logStatement += "." + method;
        }
        else
        {
            logStatement = method;
        }
    }

    if (typeof message === "string")
    {
        if (logStatement !== "")
        {
            logStatement += ": " + message;
        }
        else
        {
            logStatement = message;
        }
    }

    if (logStatement === "") return returnValue;
    EVUI.Modules.Core.Utils.log(logStatement);

    return returnValue;
};

/**Utility method for simultaneously logging a debug message and returning a value. Exists for the purpose of returning and logging from a single-line if statement.
This is used to create consistently formatted debug messages for an end user so that they can get some insight into why and where something isn't working. Wherever an unusable input or 
a broken state is detected, this function is used to log it and return safely. Can be silenced via setting $evui.settings.debug to false. Critically important to the guts of EventUI, 
but admittedly of little use to others - use $evui.debug(message, returnValue) for a more generic version. 
@param {String} controller The EventUI controller or object logging the message.
@param {String} method The function that is logging the message.
@param {String} message The message to log.
@param {Any} returnValue Any value to return.
@returns {Any}*/
$evui.debugReturn = function (controller, method, message, returnValue)
{
    return EVUI.Modules.Core.Utils.debugReturn(controller, method, message, returnValue);
};

/**Utility method for simultaneously logging a debug message and returning a value. Exists for the purpose of returning and logging from a single-line if statement.
@param {String} message The message to log.
@param {Any} returnValue Any value to return.
@returns {Any}*/
$evui.debug = function (message, returnValue)
{
    return EVUI.Modules.Core.Utils.debugReturn(message, null, null, returnValue);
};

/**Determines whether one element contains another.
@param {Element} childElement The element that is contained by the parent element.
@param {Element} parentElement The element that contains the child element.
@returns {Boolean}*/
EVUI.Modules.Core.Utils.containsElement = function (childElement, parentElement)
{
    if (EVUI.Modules.Core.Utils.isjQuery(childElement) === true) childElement = childElement[0];
    if (EVUI.Modules.Core.Utils.isDomHelper(childElement) === true) childElement = childElement.elements[0];
    if (childElement instanceof Node === false) return false; //not a DOM node, not contained by the parent
    if (childElement.parentElement == null)
    {
        return false;
    }

    if (EVUI.Modules.Core.Utils.isjQuery(parentElement) === true) parentElement = parentElement[0];
    if (EVUI.Modules.Core.Utils.isDomHelper(parentElement) === true) parentElement = parentElement.elements[0];
    if (parentElement instanceof Node === false) return false;

    return parentElement.contains(childElement);
};

/**Determines whether one element contains another.
@param {Object} childElement The element that is contained by the parent element.
@param {Object} parentElement The element that contains the child element.
@returns {Boolean}*/
$evui.containsElement = function (childElement, parentElement)
{
    return EVUI.Modules.Core.Utils.containsElement(childElement, parentElement);
};

/**Determines whether or not a node is an "orphan" and is not connected to the DOM, a DocumentFragment, or a Document.
@param {Node} node The node to test to see if it is part of a Document or DocumentFragment.
@returns {Boolean}*/
EVUI.Modules.Core.Utils.isOrphanedNode = function (node)
{
    if (node == null) return true;
    if (node.isConnected === true) return false;

    var nodeParent = node.parentNode;
    while (nodeParent != null)
    {
        var newParent = nodeParent.parentNode;
        if (newParent == null)
        {
            break;
        }
        else
        {
            nodeParent = newParent;
        }
    }

    if (nodeParent != null && (nodeParent.nodeType === Node.DOCUMENT_FRAGMENT_NODE || nodeParent.nodeType === Node.DOCUMENT_NODE)) return false;
    return true;
};

/**Determines whether or not a node is an "orphan" and is not connected to the DOM, a DocumentFragment, or a Document.
@param {Node} node The node to test to see if it is part of a Document or DocumentFragment.
@returns {Boolean}*/
$evui.isOrphan = function (node)
{
    return EVUI.Modules.Core.Utils.isOrphanedNode(node);
}


/**Shallow extend function.
@param {Object} target The target object to receive properties.
@param {Object} source The source of the properties to extend onto the target.
@param {EVUI.Modules.Core.Constants.Fn_ExtendPropertyFilter|String[]} filter An optional filter function used to filter out properties from the source to extend onto the target, return false to filter the property. Or an array of property names to not extend onto the target object.
@returns {Object}*/
EVUI.Modules.Core.Utils.shallowExtend = function (target, source, filter)
{
    if (target == null || typeof target !== "object") return target;
    if (source == null || typeof source !== "object") return target;
    var filterViaArray = false;
    var filterDictionary = null;
    var filterViaFn = false;

    if (filter != null)
    {
        if (typeof filter === "function")
        {
            filterViaFn = true;
        }
        else if (EVUI.Modules.Core.Utils.isArray(filter) === true)
        {
            filterViaArray = true;

            filterDictionary = {};
            var numInFilter = filter.length;
            for (var x = 0; x < numInFilter; x++)
            {
                filterDictionary[filter[x]] = true;
            }
        }
    }

    var keys = EVUI.Modules.Core.Utils.getProperties(source); //Object.keys(source);
    var numKeys = keys.length;

    for (var x = 0; x < numKeys; x++)
    {
        var prop = keys[x];
        if (filterViaFn === true)
        {
            if (filter(prop, source, target) !== false)
            {
                var sourceValue = source[prop];
                if (sourceValue === undefined) continue;

                target[prop] = sourceValue; //anything other than false means include in target
            }
        }
        else if (filterViaArray === true)
        {
            if (filterDictionary[prop] !== true)
            {
                var sourceValue = source[prop];
                if (sourceValue === undefined) continue;

                target[prop] = sourceValue; //was not in the filter array, include in target
            }           
        }
        else //no filter, include always
        {
            var sourceValue = source[prop];
            if (sourceValue === undefined) continue;

            target[prop] = sourceValue;
        }
    }

    return target;
};

/**Shallow extend function.
@param {Object} target The target object to receive properties.
@param {Object} source The source of the properties to extend onto the target.
@param {EVUI.Constants.Utils.Fn_ExtendPropertyFilter|String[]} filter An optional filter function used to filter out properties from the source to extend onto the target, return false to filter the property. Or an array of property names to not extend onto the target object.
@returns {Object}*/
$evui.extend = function (target, source, filter)
{
    return EVUI.Modules.Core.Utils.shallowExtend(target, source, filter);
};

/**Utility function for returning a new, fresh object or extending the properties of a partial object onto an existing or fresh object.
@param {Object} newObj The freshly constructed object with no modifications.
@param {Object} existingObj The existing object that may need to be modified.
@param {Object} modifiedObj The object or partial object that represents the modifications to apply to the new or existing objects.
@param {EVUI.Constants.Utils.Fn_ExtendPropertyFilter|String[]} filter An optional filter function used to filter out properties from the source to extend onto the target, return false to filter the property. Or an array of property names to not extend onto the target object.
@returns {Object} */
EVUI.Modules.Core.Utils.makeOrExtendObject = function (newObj, existingObj, modifiedObj, filter)
{
    if (existingObj == null)
    {
        if (modifiedObj == null)
        {
            return newObj;
        }
        else
        {
            return EVUI.Modules.Core.Utils.shallowExtend(newObj, modifiedObj, filter);
        }
    }
    else
    {
        if (modifiedObj == null)
        {
            return existingObj;
        }
        else
        {
            if (existingObj instanceof newObj.constructor)
            {
                return EVUI.Modules.Core.Utils.shallowExtend(existingObj, modifiedObj);
            }
            else
            {
                return EVUI.Modules.Core.Utils.shallowExtend(newObj, modifiedObj);
            }
        }
    }
};

/**Combines segments of a URL into a complete url regardless if the segments have leading, lagging, or no slashes at all.
@param {Array} pathSegments An array of strings to concatenate into a slash delineated path.
@returns {String}*/
EVUI.Modules.Core.Utils.combinePaths = function (pathSegments)
{
    if (EVUI.Modules.Core.Utils.isArray(pathSegments) === false) return pathSegments;

    var path = "";

    var numPaths = pathSegments.length;
    for (var x = 0; x < numPaths; x++)
    {
        var curSeg = pathSegments[x];
        if (typeof curSeg !== "string") continue;
        if (x === 0)
        {
            path = curSeg;
            continue;
        }

        var currentPathEndsWithSlash = path[path.length - 1] === "/";
        var currentSegmentStartsWithSlash = curSeg[0] === "/";

        if (currentPathEndsWithSlash === false && currentSegmentStartsWithSlash === true)
        {
            path += curSeg; //we have something like root.com and /folder
        }
        else if (currentPathEndsWithSlash === true && currentSegmentStartsWithSlash === true)
        {
            path += curSeg.substring(1); //we have something like root.com/ and /folder
        }
        else if (currentPathEndsWithSlash === false && currentSegmentStartsWithSlash === false)
        {
            if (curSeg[0] === ".") //we have something like root.com/file and .html
            {
                path += curSeg;
            }
            else
            {
                path += "/" + curSeg; //we have something like root.com/folder and folder2
            }
        }
        else if (currentPathEndsWithSlash === true && currentSegmentStartsWithSlash === false)
        {
            if (curSeg[0] === ".") //we have something like root.com/file/ and .html
            {
                path = path.substring(0, path.length - 1) + curSeg;
            }
            else
            {
                path += curSeg //we have something like root.com/ and file.txt
            }
        }
    }

    return path;
};

/**Combines segments of a URL into a complete url regardless if the segments have leading, lagging, or no slashes at all.
@param {Array} pathSegments An array of strings to concatenate into a slash delineated path.
@returns {String}*/
$evui.combinePaths = function (pathSegments)
{
    return EVUI.Modules.Core.Utils.combinePaths(pathSegments);
};

/**An awaitable function that waits a given amount of time in milliseconds.
@param {Number} duration The number of milliseconds to wait.
@returns {Promise} */
EVUI.Modules.Core.Utils.waitAsync = function (duration)
{
    if (typeof duration != null && typeof duration !== "number") throw new Error("Number expected.");

    return new Promise(function (resolve)
    {
        setTimeout(function ()
        {
            resolve();
        }, duration);
    });
};

/**An awaitable function that waits a given amount of time in milliseconds.
@param {Number} duration The number of milliseconds to wait.
@returns {Promise} */
$evui.waitAsync = function (duration)
{
    return EVUI.Modules.Core.Utils.waitAsync(duration);
};

/**Takes an ambiguous input and returns an Element if one could be extracted from the parameter. 
@param {Element|jQuery|EVUI.Modules.Dom.DomHelper} element Either an Element, a jQuery wrapper for at least one element, or a DomHelper wrapper for at least one element.
@returns {Element} */
EVUI.Modules.Core.Utils.getValidElement = function (element)
{
    if (EVUI.Modules.Core.Utils.isElement(element)) return element;
    if (EVUI.Modules.Core.Utils.isjQuery(element) === true && element.length > 0)
    {
        if (EVUI.Modules.Core.Utils.isElement(element[0]) === true) return element[0];
    }

    if (EVUI.Modules.Dom != null)
    {
        if (element instanceof EVUI.Modules.Dom.DomHelper)
        {
            if (element.elements.length > 0 && EVUI.Modules.Core.Utils.isElement(element.elements[0]) === true) return element.elements[0];
        }
    }

    return null;
};

/**Determines if an object is a DomHelper object.
@param {EVUI.Modules.Dom.DomHelper} domHelper A potential instance of DomHelper.
@returns {Boolean} */
EVUI.Modules.Core.Utils.isDomHelper = function (domHelper)
{
    return (EVUI.Modules.Dom != null && domHelper instanceof EVUI.Modules.Dom.DomHelper);
};

/**Determines if an object is a DomHelper object.
@param {EVUI.Modules.Dom.DomHelper} domHelper A potential instance of DomHelper.
@returns {Boolean} */
$evui.isDomHelper = function (domHelper)
{
    return EVUI.Modules.Core.Utils.isDomHelper(domHelper);
};

/**Takes an ambiguous input and returns an Element if one could be extracted from the parameter.
@param {Element|jQuery|EVUI.Modules.Dom.DomHelper} element Either an Element, a jQuery wrapper for at least one element, or a DomHelper wrapper for at least one element.
@returns {Element} */
$evui.getValidElement = function (element)
{
    return EVUI.Modules.Core.Utils.getValidElement(element);
};

/**Determines if a required dependency is present.
 @param {String} moduleName The name of the required module.
 @param {String} minVersion The minimum version of the module required.*/
EVUI.Modules.Core.Utils.require = function (moduleName, minVersion, message)
{
    if (EVUI.Modules[moduleName] == null) throw Error("Dependency missing: Module EVUI.Modules." + moduleName + " is required." + ((EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(message) === false) ? " " + message : ""));
    if (EVUI.Modules.VersionCheck != null) //if VersionCheck is present, we have a processed file and can check the module's version number.
    {
        if (minVersion !== EVUI.Modules[moduleName].version)
        {
            if (EVUI.Modules.VersionCheck.isNewer(minVersion, EVUI.Modules[moduleName].version) === false) throw Error("Dependency missing: Module EVUI.Modules." + moduleName + " must be at least version " + minVersion + " or higher.");
        }
    }
};

/**Determines if all the required dependencies for a module are present.
@param {Object} dependencies The Dependencies property of a Module.*/
EVUI.Modules.Core.Utils.requireAll = function (dependencies)
{
    if (dependencies == null) throw Error("Dependencies missing.");
    if (dependencies.checked === true) return;

    for (var dependency in dependencies)
    {
        if (dependencies[dependency].required === true)
        {
            EVUI.Modules.Core.Utils.require(dependency, dependencies[dependency].version);
        }
    }

    dependencies.checked = true;
};

/**Determines whether or not an element is in the Shadow Dom.
@param {Element} element The element to check for existence in the Shadow Dom.
@returns {Boolean} */
EVUI.Modules.Core.Utils.isInShadowDom = function (element)
{
    if (EVUI.Modules.Core.Utils.isElement(element) === false) return false;

    if (element instanceof ShadowRoot) return true;

    var curParent = element.parentNode;
    while (curParent != null)
    {
        if (curParent instanceof ShadowRoot) return true;
        curParent = curParent.parentNode;
    }

    return false;
};

/**Determines whether or not an element is in the Shadow Dom.
@param {Element} element The element to check for existence in the Shadow Dom.
@returns {Boolean} */
$evui.isShadow = function (element)
{
    return EVUI.Modules.Core.Utils.isInShadowDom(element);
};

/**Determines if an object was constructed using the given (native) constructor. Performs cross-window constructor checks in addition to simple instanceof checks.
 @param {Any} obj The object to test.
 @param {Function} ctor The constructor to test against.
 @returns {Boolean}*/
EVUI.Modules.Core.Utils.instanceOf = function (obj, ctor)
{
    if (obj == null || typeof ctor !== "function") return false;
    if (obj instanceof ctor) return true;
    if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(ctor.name) === true || ctor.name.toLowerCase() === "object") return false;

    if ("[object " + ctor.name + "]" === Object.prototype.toString.call(obj)) return true;
    return false;
};

/**Determines if an object was constructed using the given (native) constructor. Performs cross-window constructor checks in addition to simple instanceof checks.
 @param {Any} obj The object to test.
 @param {Function} ctor The constructor to test against.
 @returns {Boolean}*/
$evui.instanceOf = function (obj, ctor)
{
    return EVUI.Modules.Core.Utils.instanceOf(obj, ctor);
};

/**Returns a hash that uniquely identifies a string. Intended for identifying strings in a web application.
@param {String} str A string to turn into a hash code.
@returns {Number}*/
EVUI.Modules.Core.Utils.getHashCode = function (str)
{
    if (typeof str !== "string") throw Error("String expected.");
    var strLen = str.length;

    var charRatio = 0;
    var sum = 0;
    var sumMod1 = 0;
    var sumMod2 = 0;
    var sumMod3 = 0;
    var sumMod4 = 0;
    var sumMod5 = 0;
    var curCode = 0;
    var previousCode = 1;

    for (var x = 0; x < strLen; x++)
    {
        curCode = str.charCodeAt(x);
        if (curCode === 0)
        {
            curCode = 10.1667;
        }
        else if (curCode === 1)
        {
            curCode = 26.567;
        }

        charRatio = curCode - (x / previousCode);

        sum -= curCode;
        if (sum < 0) sum *= -8.1373;

        if (curCode % 5 === 0)
        {
            sumMod5 -= charRatio;
            if (sumMod5 < 0) sumMod5 *= -112.69
        }
        else if (curCode % 4 === 0)
        {
            sumMod4 -= charRatio;
            if (sumMod4 < 0) sumMod4 = (sumMod4 * -918.07);
        }
        else if (curCode % 3 === 0)
        {
            sumMod3 -= charRatio;
            if (sumMod3 < 0) sumMod3 *= -213.7;
        }
        else if (curCode % 2 === 0)
        {
            sumMod2 -= charRatio;
            if (sumMod2 < 0) sumMod2 *= -8.1471
        }
        else
        {
            sumMod1 -= charRatio;
            if (sumMod1 < 0) sumMod1 *= -10.912
        }

        previousCode = curCode;
    }

    var final = (sumMod5 - sumMod4 - sumMod3 - sumMod2 - sumMod1 - sum) / (strLen / charRatio);
    if (final < 0) final *= -1;

    if (sum !== 0)
    {
        if (final === sum)
        {
            final *= Math.sqrt(sum);
        }
        else
        {
            final /= sum;
        }
    }

    if (sumMod1 !== 0 && final !== sumMod1) final *= sumMod1;
    if (sumMod2 !== 0 && final !== sumMod2) final /= sumMod2;
    if (sumMod3 !== 0 && final !== sumMod3) final *= sumMod3;
    if (sumMod4 !== 0 && final !== sumMod4) final /= sumMod4;
    if (sumMod5 !== 0 && final !== sumMod5) final *= sumMod5;
    if (curCode !== 0 && final !== curCode) final /= curCode;
    if (final < 1 && final !== 0) final = 1 / final;
    if (final > Number.MAX_SAFE_INTEGER) final = Math.sqrt(final);

    return final;
}

/**Returns a hash that uniquely identifies a string. Not meant to be secure, it is designed for identifying strings in a web application.
@param {String} str A string to turn into a hash code.
@returns {String}*/
$evui.getHashCode = function (str)
{
    return EVUI.Modules.Core.Utils.getHashCode(str);
};

/**Creates a plain object that is keyed based on the key selector function for each item in an array object.
@param {[]} source The source array to iterate over.
@param {Function} keySelector A function that takes each element as a parameter (and its index as a second parameter) and returns a string to identify it by.
@returns {{}}*/
EVUI.Modules.Core.Utils.toDictionary = function (source, keySelector)
{
    if (EVUI.Modules.Core.Utils.isArray(source) === false) throw Error("Array expected.");
    if (typeof keySelector !== "function") throw Error("Function expected.");

    var dic = {};

    var numSource = source.length;
    for (var x = 0; x < numSource; x++)
    {
        var value = source[x];
        var key = keySelector(value, x);
        if (key == null) continue;

        dic[key] = value;
    }

    return dic;
};

/**Creates a plain object that is keyed based on the key selector function for each item in an array object.
@param {[]} source The source array to iterate over.
@param {Function} keySelector A function that takes each element as a parameter (and its index as a second parameter) and returns a string to identify it by.
@returns {{}}*/
$evui.toDictionary = function (source, keySelector)
{
    return EVUI.Modules.Core.Utils.toDictionary(source, keySelector);
}

/**Gets all the property keys that belong to an object.
@param {Object} obj Any object.
@returns {String[]} */
EVUI.Modules.Core.Utils.getProperties = function (obj)
{
    if (typeof obj !== "object" || obj == null) return null;

    //first, check to see if we have explicitly cached the object's properties. If so, just return those.
    var cache = (obj.constructor == null) ? null : obj.constructor[EVUI.Modules.Core.Constants.Symbol_ObjectProperties];
    if (cache != null) return cache;

    //no cache. If the object is a plain object with no constructor or prototypical inheritance, we can use the faster Object.keys to get the object's properties
    if (obj.constructor == Object || (obj.constructor != null && obj.constructor[EVUI.Modules.Core.Constants.Symbol_HasPrototypeMembers] === false))
    {
        return Object.keys(obj);
    }
    else
    {
        if (EVUI.Modules.Core.Utils.isArray(obj) === true) //if its an array, just make a list of all the indexes in the array rather than query the object for its properties
        {
            var len = obj.length;

            var arrayProps = [];
            for (var x = 0; x < len; x++)
            {
                arrayProps.push(x);
            }

            return arrayProps;
        }
        else //some other sort of object that either has a constructor or a prototype that isn't Object.prototype
        {
            //here is the problem we are trying to solve: objects with an explicit constructor function do NOT have a prototype of Object.prototype, they have a different prototype that holds their constructor.
            //HOWEVER, the prototype of that constructor-holding prototype IS Object.prototype, so we need to go two levels down for any constructed object to figure out if we can just use Object.keys on it to get
            //its properties and not a for...in loop (which does account for prototypical inheritance). So, what we do is check for that case where we have a constructor but nothing on the prototype and then cache
            //the result of that check so we don't have to check it every time we run into one of those objects, HOWEVER if someone adds to the prototype AFTER we make this check, we won't ever get those property
            //names from this function since it won't ever look for them in the right way. This is probably an edge case, and has a work-around of simply setting Symbol_HasPrototypeMembers to null to switch off 
            //the entire feature.
            if (EVUI.Modules.Core.Constants.Symbol_HasPrototypeMembers != null) 
            {
                var hasProtoMembers = (obj.constructor == null) ? false : obj.constructor[EVUI.Modules.Core.Constants.Symbol_HasPrototypeMembers]
                if (hasProtoMembers === true) //if we have members in the prototype, we need to use a for...in loop to get them all
                {
                    var props = [];
                    for (var prop in obj)
                    {
                        props.push(prop);
                    }

                    return props;
                }
                else if (hasProtoMembers === false) //if we do NOT have anything on the prototype, we can just use the faster Object.keys
                {
                    return Object.keys(obj)
                }
                else //we haven't checked this "type" of object before
                {
                    //first, get all the properties on it's immediate prototype
                    var immediateProto = Object.getPrototypeOf(obj);
                    var immediateKeys = Object.keys(immediateProto);

                    //if there are none, look one more level down to see if our prototype is Object.prototype.                    
                    if (immediateKeys.length === 0)
                    {
                        var deeperProto = Object.getPrototypeOf(immediateProto);
                        if (deeperProto === Object.prototype || deeperProto == null || Object.getPrototypeOf(deeperProto) == null) //HOWEVER, in a cross - window check, this will fail, so we drill one more level down to get at that deeper prototype and find nothing, we know we were at the base prototype of another window's Object.
                        {
                            if (obj.constructor != null) obj.constructor[EVUI.Modules.Core.Constants.Symbol_HasPrototypeMembers] = false;
                            return Object.keys(obj);
                        }
                    }
                    else //otherwise we know it has properties on at least one level of its prototype, so we flag it as always using a for...in loop to get its properties.
                    {
                        if (obj.constructor != null) obj.constructor[EVUI.Modules.Core.Constants.Symbol_HasPrototypeMembers] = true;
                    }
                }
            }

            //if we haven't returned by now, just do the base behavior
            var props = [];
            for (var prop in obj)
            {
                props.push(prop);
            }

            return props;
        }
    }
};

/**Gets all the property keys that belong to an object.
@param {Object} obj Any object.
@returns {String[]} */
$evui.props = function (obj)
{
    return EVUI.Modules.Core.Utils.getProperties(obj);
}

/**Assigns a Symbol to the object's constructor that contains an array of its property keys so that getProperties does not have to re-query the object for its properties over and over.
@param {Object} obj The object to attach the property list to the constructor.
@param {String[]} props The properties to cache. If omitted, the properties of the object are calculated then cached.
@returns {Boolean} */
EVUI.Modules.Core.Utils.cacheProperties = function (obj, props)
{
    if (EVUI.Modules.Core.Constants.Symbol_ObjectProperties == null) return false;

    if (obj == null || typeof obj !== "object") return false;
    if (Object.getPrototypeOf(obj) == Object.prototype) return false; //NEVER DO THIS FOR PLAIN OBJECTS. All plain objects will report the same list of properties, which will be wrong in 99% of cases.

    if (EVUI.Modules.Core.Utils.isArray(props) === false) props = EVUI.Modules.Core.Utils.getProperties(obj);

    obj.constructor[EVUI.Modules.Core.Constants.Symbol_ObjectProperties] = props;
    return true;
};

/**Assigns a Symbol to the object's constructor that contains an array of its property keys so that $evui.props does not have to re-query the object for its properties over and over.
@param {Object} obj The object to attach the property list to the constructor.
@param {String[]} props The properties to cache. If omitted, the properties of the object are calculated then cached.
@returns {Boolean} */
$evui.cacheProps = function(obj, props)
{
    return EVUI.Modules.Core.Utils.cacheProperties(obj, props);
};

/**Deletes the Symbol from the object's constructor to make it forget its list of cached properties.
@param {Object} obj The object to forget the list of properties from.
@returns {Boolean}*/
EVUI.Modules.Core.Utils.uncacheProperties = function (obj)
{
    if (EVUI.Modules.Core.Constants.Symbol_ObjectProperties == null || obj == null || typeof obj !== "object") return false;

    delete obj.constructor[EVUI.Modules.Core.Constants.Symbol_ObjectProperties];
    delete obj.constructor[EVUI.Modules.Core.Constants.Symbol_HasPrototypeMembers];

    return true;
};

/**Deletes the Symbol from the object's constructor to make it forget its list of cached properties.
@param {Object} obj The object to forget the list of properties from.
@returns {Boolean}*/
$evui.uncacheProps = function (obj)
{
    return EVUI.Modules.Core.Utils.uncacheProperties(obj);
};

Object.freeze(EVUI.Modules.Core);
Object.freeze(EVUI.Modules.Core.Constants);
Object.freeze(EVUI.Modules.Core.Utils);
/*#ENDWRAP(Core)#*/


/********************************************************Dialogs.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.Dialog|Dialog)#*/
/*#REPLACE(EVUI.Modules.Dialog|Dialog)#*/

/**Core module containing the Initialization and Utility functionality that is shared by all other modules.
@module*/
EVUI.Modules.Dialogs = {};

/*#MODULEDEF(Dialog|"1.0";|"Dialog")#*/
/*#VERSIONCHECK(EVUI.Modules.Dialog|Dialog)#*/

EVUI.Modules.Dialogs.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
    Panes: Object.freeze({ version: "1.0", required: true })
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.Dialogs.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();

Object.freeze(EVUI.Modules.Dialogs.Dependencies);

EVUI.Modules.Dialogs.Constants = {};

/**Function for selecting a PaneEntry object. Return true to select the PaneEntry parameter as part of the result set.
@param {EVUI.Modules.Dialogs.Dialog} dialog The PaneEntry providing metadata about a Dialog object.
@returns {Boolean}*/
EVUI.Modules.Dialogs.Constants.Fn_DialogSelector = function (dialog) { return true; }

/**Function for reporting whether or not a Dialog was successfully Loaded.
@param {Boolean} success Whether or not the load operation completed successfully.*/
EVUI.Modules.Dialogs.Constants.Fn_LoadCallback = function (success) { };

/**Function for reporting whether or not an operation Dialog was successful.
@param {Boolean} success Whether or not the operation completed successfully.*/
EVUI.Modules.Dialogs.Constants.Fn_DialogOperationCallback = function (success) { };

EVUI.Modules.Dialogs.Constants.CSS_Position = "evui-position";
EVUI.Modules.Dialogs.Constants.CSS_ClippedX = "evui-clipped-x";
EVUI.Modules.Dialogs.Constants.CSS_ClippedY = "evui-clipped-y";
EVUI.Modules.Dialogs.Constants.CSS_ScrollX = "evui-scroll-x";
EVUI.Modules.Dialogs.Constants.CSS_ScrollY = "evui-scroll-y"
EVUI.Modules.Dialogs.Constants.CSS_Flipped = "evui-flipped";
EVUI.Modules.Dialogs.Constants.CSS_Moved = "evui-moved";
EVUI.Modules.Dialogs.Constants.CSS_Resized = "evui-resized";
EVUI.Modules.Dialogs.Constants.CSS_Transition_Show = "evui-transition-show";
EVUI.Modules.Dialogs.Constants.CSS_Transition_Hide = "evui-transition-hide";

/**String. The name of the ID attribute for the Dialog, used to look up a definition of a Dialog.
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_ID = "evui-dlg-id";

/**String. The name of the attribute that signifies which element should receive initial focus when the Dialog is displayed.
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_Focus = "evui-dlg-focus";

/**String. The name of the attribute that signifies that a click event on the Element should close the Dialog.
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_Close = "evui-dlg-close";

/**String. The name of the attribute on an element that triggers the showing of a Dialog what the URL to get the Dialog's HTML from is (Requires EVUI.Modules.Http).
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_SourceURL = "evui-dlg-src";

/**String. The name of the attribute on an element that triggers the showing of a Dialog of what placeholder to load for the Dialog's HTML (Requires EVUI.Modules.HtmlLoaderController).
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_PlaceholderID = "evui-dlg-placeholder-id";

/**String. The name of the attribute on an element that triggers the showing or hiding of a Dialog whether or not the Dialog should be unloaded when it is hidden.
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_UnloadOnHide = "evui-dlg-unload";

/**String. The name of the attribute on an element that triggers the showing or hiding of a Dialog that is used to indicate special behavior as defined by a consumer of the Dialog.
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_Context = "evui-dlg-cxt";

/**String. The name of the attribute on an element that triggers the showing of a Dialog what CSS selector to use to find the element to show as the Dialog. Only the first result will be used.
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_Selector = "evui-dlg-selector";

/**String. The name of the attribute on an element that triggers the showing of a Dialog whether or not to center the dialog on the screen.
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_Center = "evui-dlg-center";

/**String. The name of the attribute on an element that triggers the showing of a Dialog whether or not to take up the entire screen.
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_Fullscreen = "evui-dlg-fullscreen";

/**String. The name of the attribute that signifies that a drag event on the Element should move the Dialog.
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_Drag = "evui-dlg-drag-handle";

/**String. The name of the attribute that specifies which sides of the Dialog can be used to resize the Dialog. Specify any combination of "left", "right", "top", or "bottom".
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_ResizeHandles = "evui-dlg-resize-handles";

/**String. The name of the attribute which specifies how wide the handle should be on the edges of the Dialog should be to start a resize operation in pixels.
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_ResizeHandleWidth = "evui-dlg-resize-handle-width"

/**String. The name of the attribute that will be used to absolute position the top edge of the Dialog.
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_Top = "evui-dlg-top";

/**String. The name of the attribute that will be used to absolute position the left edge of the Dialog.
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_Left = "evui-dlg-left";

/**String. The name of the attribute that will be used add positioning CSS classes to the dialog.
@type {String}*/
EVUI.Modules.Dialogs.Constants.Attribute_Classes = "evui-dlg-class";

EVUI.Modules.Dialogs.Constants.Default_ObjectName = "Dialog";
EVUI.Modules.Dialogs.Constants.Default_ManagerName = "DialogManager";
EVUI.Modules.Dialogs.Constants.Default_CssPrefix = "evui-dlg";
EVUI.Modules.Dialogs.Constants.Default_EventNamePrefix = "evui.dlg";
EVUI.Modules.Dialogs.Constants.Default_AttributePrefix = "evui-dlg";

Object.freeze(EVUI.Modules.Dialogs.Constants);

/**Class for managing Dialog object.
@class*/
EVUI.Modules.Dialogs.DialogManager = function (services)
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Dialogs.Dependencies);

    var _self = this; //self-reference for closures

    /**The internal PaneManager of the DialogManager.
    @type {EVUI.Modules.Panes.PaneManager}*/
    var _manager = null;

    /**The settings overrides for the DialogManager.
    @type {EVUI.Modules.Panes.PaneManagerSettings}*/
    var _settings = null;

    /**Adds a Dialog to the WidowManager.
    @param {EVUI.Modules.Dialogs.Dialog} dialog A YOLO object representing a Dialog object. This object is copied onto a real Dialog object is then discarded.
    @returns {EVUI.Modules.Dialogs.Dialog}*/
    this.addDialog = function (dialog)
    {
        if (dialog == null) throw Error(_settings.objectName + " cannot be null.");
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(dialog.id) === true) throw Error(_settings.objectName + "must have an id that is a non-whitespace string.");

        var existing = _settings.getPaneEntry(dialog.id);
        if (existing != null) throw Error("A " + _settings.objectName + " with an id of \"" + dialog.id + "\" already exists.");

        _manager.addPane(getDefaultPane(dialog));

        existing = _settings.getPaneEntry(dialog.id);
        return existing.wrapper;
    };

    /**Removes a Dialog from the DialogManager. Does not unload the Dialog's element from the DOM.
    @param {EVUI.Modules.Dialogs.Dialog|String} dialogOrID
    @returns {Boolean}*/
    this.removeDialog = function (dialogOrID)
    {
        return _manager.removePane(dialogOrID);
    };

    /**Gets a DialogEntry object based on its ID or a selector function.
    @param {EVUI.Modules.Dialogs.Constants.Fn_DialogSelector|String} dialogIDOrSelector A selector function to select a Dialog object (or multiple DialogEntry objects) or the ID of the Dialog to get the DialogEntry for.
    @param {Boolean} getAllMatches If a selector function is provided, all the DialogEntries that satisfy the selector are included. Otherwise a single DialogEntry object is returned. False by default.
    @returns {EVUI.Modules.Dialogs.Dialog|EVUI.Modules.Dialogs.Dialog[]} */
    this.getDialog = function (dialogIDOrSelector, getAllMatches)
    {
        var entries = null;

        if (typeof dialogIDOrSelector === "function")
        {
            entries = _settings.getPaneEntry(function () { return true; }, true).map(function (entry) { return entry.wrapper; }).filter(dialogIDOrSelector);
            if (getAllMatches !== true && entries != null) return entries[0];
            return entries;
        }
        else
        {
            entries = _settings.getPaneEntry(dialogIDOrSelector, getAllMatches);
        }

        if (entries == null) return null;

        if (EVUI.Modules.Core.Utils.isArray(entries) === false)
        {
            return entries.wrapper;
        }
        else
        {
            return entries.map(function (entry) { return entry.wrapper; })
        }
    };

    /**Shows (and loads, if necessary or if a reload is requested) a Dialog asynchronously. Provides a callback that is called once the Dialog operation has completed successfully or otherwise.
    @param {EVUI.Modules.Dialogs.Dialog|String} dialogOrID Either a YOLO Dialog object to extend into the existing Dialog, the real Dialog reference, or the string ID of the Dialog to show.
    @param {EVUI.Modules.Dialogs.DialogShowArgs|EVUI.Modules.Dialogs.Constants.Fn_DialogOperationCallback} dialogShowArgs Optional.  The arguments for showing the Dialog, or the callback. If omitted or passed as a function, the Dialog's existing show/load settings are used instead.
    @param {EVUI.Modules.Dialogs.Constants.Fn_DialogOperationCallback} callback Optional. A callback that is called once the operation completes.*/
    this.showDialog = function (dialogOrID, dialogShowArgs, callback)
    {
        var entry = getDialogAmbiguously(dialogOrID, true);

        var paneShowArgs = new EVUI.Modules.Panes.PaneShowArgs();
        paneShowArgs.showSettings = _settings.cloneShowSettings(entry.pane.showSettings);
        paneShowArgs.loadArgs = new EVUI.Modules.Panes.PaneLoadArgs();
        paneShowArgs.loadArgs.loadSettings = _settings.cloneLoadSettings(entry.pane.loadSettings);

        if (typeof dialogShowArgs === "function")
        {
            callback = dialogShowArgs;
            dialogShowArgs = null;
        }
        else if (dialogShowArgs != null && typeof dialogShowArgs === "object")
        {
            dialogShowArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogShowArgs(paneShowArgs), dialogShowArgs, ["type"]);
            if (dialogShowArgs.showSettings != null)
            {
                dialogShowArgs.showSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogShowSettings(paneShowArgs.showSettings), dialogShowArgs.showSettings);
            }
            else
            {
                dialogShowArgs.showSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogShowSettings(paneShowArgs.showSettings), entry.wrapper.showSettings);
            }


            if (dialogShowArgs.loadArgs != null && dialogShowArgs.loadArgs.loadSettings != null)
            {
                dialogShowArgs.loadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogLoadArgs(paneShowArgs.loadArgs), dialogShowArgs.loadArgs, ["type"]);
                dialogShowArgs.loadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogLoadSettings(paneShowArgs.loadArgs.loadSettings), dialogShowArgs.loadArgs.loadSettings);
            }
            else
            {
                dialogShowArgs.loadArgs = new EVUI.Modules.Dialogs.DialogLoadArgs(paneShowArgs.loadArgs);
                dialogShowArgs.loadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogLoadSettings(paneShowArgs.loadArgs.loadSettings), entry.wrapper.loadSettings, ["type"]);;
            }
        }
        else
        {
            dialogShowArgs = null;
        }

        if (dialogShowArgs == null)
        {
            dialogShowArgs = new EVUI.Modules.Dialogs.DialogShowArgs(paneShowArgs);
            dialogShowArgs.showSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogShowSettings(paneShowArgs.showSettings), entry.wrapper.showSettings);
            dialogShowArgs.loadArgs = new EVUI.Modules.Dialogs.DialogLoadArgs(paneShowArgs.loadArgs);
            dialogShowArgs.loadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogLoadSettings(paneShowArgs.loadArgs.loadSettings), entry.wrapper.loadSettings);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(dialogShowArgs);

        _manager.showPane(entry.pane.id, paneShowArgs, callback);
    };

    /**Awaitable. (and loads, if necessary or if a reload is requested) a Dialog asynchronously.
    @param {EVUI.Modules.Dialogs.Dialog|String} dialogOrID Either a YOLO Dialog object to extend into the existing Dialog, the real Dialog reference, or the string ID of the Dialog to show.
    @param {EVUI.Modules.Dialogs.DialogShowArgs} dialogShowArgs Optional.  A YOLO object representing the arguments for showing the Dialog. If omitted, the Dialog's existing show/load settings are used instead.
    @returns {Promise<Boolean>}*/
    this.showDialogAsync = function (dialogOrID, dialogShowArgs)
    {
        return new Promise(function (resolve)
        {
            _self.showDialog(dialogOrID, dialogShowArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Hides (and unloads if requested) a Dialog asynchronously. Provides a callback that is called call once the Dialog operation has completed successfully or otherwise.
    @param {EVUI.Modules.Dialogs.Dialog|String} dialogOrID Either a YOLO Dialog object to extend into the existing Dialog, the real Dialog reference, or the string ID of the Dialog to hide.
    @param {EVUI.Modules.Dialogs.DialogHideArgs|EVUI.Modules.Dialogs.Constants.Fn_DialogOperationCallback} dialogHideArgs Optional. A YOLO object representing arguments for hiding a Dialog or a callback. If omitted or passed as a function, the Dialog's existing hide/unload settings are used instead.
    @param {EVUI.Modules.Dialogs.Constants.Fn_DialogOperationCallback} callback Optional. A callback that is called once the operation completes.*/
    this.hideDialog = function (dialogOrID, dialogHideArgs, callback)
    {
        var entry = getDialogAmbiguously(dialogOrID);

        var paneHideArgs = new EVUI.Modules.Panes.PaneHideArgs();
        paneHideArgs.unloadArgs = new EVUI.Modules.Panes.PaneUnloadArgs();

        if (typeof dialogHideArgs === "function")
        {
            callback = dialogHideArgs;
            dialogHideArgs = null;
        }
        else if (dialogHideArgs != null && typeof dialogHideArgs === "object")
        {
            dialogHideArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogHideArgs(paneHideArgs), dialogHideArgs, ["type"]);
            dialogHideArgs.unloadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogUnloadArgs(paneHideArgs.unloadArgs, dialogHideArgs.unloadArgs));
        }
        else
        {
            dialogHideArgs = null;
        }

        if (dialogHideArgs == null)
        {
            dialogHideArgs = new EVUI.Modules.Dialogs.DialogHideArgs(paneHideArgs);
            dialogHideArgs.unloadArgs = new EVUI.Modules.DialogUnloadArgs(paneHideArgs.unloadArgs);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(dialogHideArgs);
        _manager.hidePane(entry.pane.id, paneHideArgs, callback);
    };

    /**Awaitable. Hides (and unloads if requested) a Dialog asynchronously.
    @param {EVUI.Modules.Dialogs.Dialog|String} dialogOrID Either a YOLO Dialog object to extend into the existing Dialog, the real Dialog reference, or the string ID of the Dialog to hide.
    @param {EVUI.Modules.Dialogs.DialogHideArgs} dialogHideArgs Optional. A YOLO object representing the arguments for hiding a Dialog. If omitted, the Dialog's existing hide/unload settings are used instead.
    @returns {Promise<Boolean>}*/
    this.hideDialogAsync = function (dialogOrID, dialogHideArgs)
    {
        return new Promise(function (resolve)
        {
            _self.hideDialog(dialogOrID, dialogHideArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Hides all visible Dialogs asynchronously. Provides a callback function that is called once all the visible Dialogs have been hidden.
    @param {EVUI.Modules.Panes.DialogHideArgs} dialogHideArgs Optional. A YOLO object representing the arguments for hiding a Dialog. If omitted, the Dialog's existing hide/unload settings are used instead.
    @param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback The callback that is called once all the Dialog's hide operations have completed.*/
    this.hideAllDialogs = function (dialogHideArgs, callback)
    {
        if (typeof callback !== "function") callback = function () { };
        var allVisible = this.getDialog(function (dd) { return dd.isVisible; });
        var numVisible = allVisible.length;
        var numHidden = 0;

        if (numVisible === 0) return callback(true);

        for (var x = 0; x < numVisible; x++)
        {
            this.hideDialog(allVisible[x], dialogHideArgs, function ()
            {
                numHidden++;
                if (numHidden === numVisible)
                {
                    return callback(true);
                }
            });
        }
    };

    /**Awaitable. Hides all Dialogs asynchronously.
    @param {EVUI.Modules.Panes.PaneHideArgs} paneHideArgs Optional. A YOLO object representing the arguments for hiding a Dialog. If omitted, the Dialog's existing hide/unload settings are used instead.
    @returns {Promise<Boolean>} */
    this.hideAllDialogsAsync = function (paneHideArgs)
    {
        return new Promise(function (resolve)
        {
            _self.hideAllDialogs(paneHideArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Asynchronously loads a Dialog. Provides a callback that is called after the operation has completed successfully or otherwise.
    @param {EVUI.Modules.Dialogs.Dialog|String} dialogOrID Either a YOLO Dialog object to extend into the existing Dialog, the real Dialog reference, or the string ID of the Dialog to load.
    @param {EVUI.Modules.Dialogs.DialogLoadArgs|EVUI.Modules.Dialogs.Constants.Fn_DialogOperationCallback} dialogLoadArgs Optional. A YOLO object representing arguments for loading a Dialog or a callback. If omitted or passed as a function, the Dialog's existing load settings are used instead.
    @param {EVUI.Modules.Dialogs.Constants.Fn_DialogOperationCallback} callback Optional. A callback to call once the operation completes.*/
    this.loadDialog = function (dialogOrID, dialogLoadArgs, callback)
    {
        var entry = getDialogAmbiguously(dialogOrID, false);

        var paneLoadArgs = new EVUI.Modules.Panes.PaneLoadArgs();
        paneLoadArgs.loadSettings = _settings.cloneLoadSettings(entry.pane.loadSettings);

        if (typeof dialogLoadArgs === "function")
        {
            callback = dialogLoadArgs;
            dialogLoadArgs = null;
        }
        else if (dialogLoadArgs != null && typeof dialogLoadArgs === "object")
        {
            dialogLoadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogLoadArgs(paneLoadArgs), dialogLoadArgs, ["type"]);
            if (dialogLoadArgs.loadSettings != null)
            {
                dialogLoadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogLoadSettings(paneLoadArgs.loadSettings), dialogLoadArgs.loadSettings);
            }
            else
            {
                dialogLoadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogLoadSettings(paneLoadArgs.loadSettings), entry.wrapper.loadSettings);
            }
        }
        else
        {
            dialogLoadArgs = null;
        }

        if (dialogLoadArgs == null)
        {
            dialogLoadArgs = new EVUI.Modules.Dialogs.DialogLoadArgs(paneLoadArgs);
            dialogLoadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogLoadSettings(paneLoadArgs.loadSettings), entry.wrapper.loadSettings);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(dialogLoadArgs);
        _manager.loadPane(entry.pane.id, paneLoadArgs, callback);
    };

    /**Awaitable. Asynchronously loads a Dialog.
    @param {EVUI.Modules.Dialogs.Dialog|String} dialogOrID Either a YOLO Dialog object to extend into the existing Dialog, the real Dialog reference, or the string ID of the Dialog to load.
    @param {EVUI.Modules.Dialogs.DialogLoadArgs} dialogLoadArgs Optional. A YOLO object representing arguments for loading a Dialog.
    @returns {Promise<Boolean>}*/
    this.loadDialogAsync = function (dialogOrID, dialogLoadArgs)
    {
        return new Promise(function (resolve)
        {
            _self.loadDialog(dialogOrID, dialogLoadArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Asynchronously unloads a Dialog, which disconnects the Dialog's element and removes it from the DOM if it was loaded remotely. Provides a callback that is called after the operation has completed successfully or otherwise.
    @param {EVUI.Modules.Dialogs.Dialog|String} dialogOrID Either a YOLO Dialog object to extend into the existing Dialog, the real Dialog reference, or the string ID of the Dialog to unload.
    @param {EVUI.Modules.Dialogs.DialogUnloadArgs|EVUI.Modules.Dialogs.Constants.Fn_DialogOperationCallback} dialogUnloadArgs Optional. A YOLO object representing arguments for unloading a Dialog or a callback. If omitted or passed as a function, the Dialog's existing unload settings are used instead.
    @param {EVUI.Modules.Dialogs.Constants.Fn_DialogOperationCallback} callback Optional. A callback to call once the operation completes.*/
    this.unloadDialog = function (dialogOrID, dialogUnloadArgs, callback)
    {
        var entry = getDialogAmbiguously(dialogOrID);
        var paneUnloadArgs = new EVUI.Modules.Panes.PaneUnloadArgs();

        if (typeof dialogUnloadArgs === "function")
        {
            callback = dialogUnloadArgs;
            dialogUnloadArgs = null;
        }
        else if (dialogUnloadArgs != null && typeof dialogUnloadArgs === "object")
        {
            dialogUnloadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dialogs.DialogUnloadArgs(paneUnloadArgs), dialogUnloadArgs);
        }
        else
        {
            dialogUnloadArgs = null;
        }

        if (dialogUnloadArgs == null)
        {
            dialogUnloadArgs = new EVUI.Modules.Dialogs.DialogUnloadArgs(paneUnloadArgs);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(dialogUnloadArgs);
        _manager.unloadPane(entry.pane.id, paneUnloadArgs, callback);
    };

    /**Awaitable. Asynchronously unloads a Dialog, which disconnects the Dialog's element and removes it from the DOM if it was loaded remotely.
    @param {EVUI.Modules.Dialogs.Dialog|String} dialogOrID Either a YOLO Dialog object to extend into the existing Dialog, the real Dialog reference, or the string ID of the Dialog to unload.
    @param {EVUI.Modules.Dialogs.DialogUnloadArgs} dialogUnloadArgs Optional. A YOLO object representing arguments for unloading a Dialog. If omitted the Dialog's existing unload settings are used instead.
    @returns {Promise<Boolean>}*/
    this.unloadDialogAsync = function (dialogOrID, dialogUnloadArgs)
    {
        return new Promise(function (resolve)
        {
            _self.unloadDialog(dialogOrID, dialogUnloadArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Makes or extends an object at the end of the PaneManager's function for applying the changes made to the Pane.
   @param {PaneCreationResult} paneCreateResult The result of creating the pane.
   @returns {EVUI.Modules.Panes.Pane}*/
    var makeOrExtendObject = function (createResult)
    {
        var dialog = createResult.pane.dialog;
        delete createResult.pane.dialog;

        return makeOrExtendDialog(dialog, createResult.pane, createResult.exists);
    };

    /**Builds the DialogEventArgs to use in the EventStream.
    @param {EVUI.Modules.Panes.PaneArgsPackage} argsPackage The argument data from the PaneManager about the current state of the Dialog.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The PaneEventArgs that were created for the event.
    @returns {EVUI.Modules.Dialogs.DialogEventArgs} */
    var buildEventArgs = function (argsPackage, paneEventArgs)
    {
        if (argsPackage.foreignArgs == null)
        {
            argsPackage.foreignArgs = createForeignArgs(argsPackage);
        }

        var args = null;
        if (paneEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Hide)
        {
            args = argsPackage.foreignArgs.hideArgs;
        }
        else if (paneEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Load)
        {
            args = argsPackage.foreignArgs.loadArgs;
        }
        else if (paneEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Show)
        {
            args = argsPackage.foreignArgs.showArgs;
        }
        else if (paneEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Unload)
        {
            args = argsPackage.foreignArgs.unloadArgs;
        }

        var dialogEventArgs = new EVUI.Modules.Dialogs.DialogEventArgs(argsPackage, args);
        dialogEventArgs.cancel = paneEventArgs.cancel;
        dialogEventArgs.key = paneEventArgs.key;
        dialogEventArgs.pause = paneEventArgs.pause;
        dialogEventArgs.resume = paneEventArgs.resume;
        dialogEventArgs.stopPropagation = paneEventArgs.stopPropagation;
        dialogEventArgs.context = paneEventArgs.context;

        return dialogEventArgs;
    };

    /**Makes the foreign arguments for injecting into a DialogEventArgs object from the PaneManager.
    @param {EVUI.Modules.Dialogs.DialogShowArgs|EVUI.Modules.Dialogs.DialogHideArgs|EVUI.Modules.Dialogs.DialogLoadArgs|EVUI.Modules.Dialogs.DialogUnloadArgs} dialogArgs
    @returns {EVUI.Modules.Panes.PaneArgsPackage}.*/
    var makeCurrentActionArgs = function (dialogArgs)
    {
        var currentActionArgs = new EVUI.Modules.Panes.PaneArgsPackage();
        if (dialogArgs.type === EVUI.Modules.Dialogs.DialogArgumentType.Hide)
        {
            currentActionArgs.hideArgs = dialogArgs;
            currentActionArgs.unloadArgs = dialogArgs.unloadArgs;
        }
        else if (dialogArgs.type === EVUI.Modules.Dialogs.DialogArgumentType.Show)
        {
            currentActionArgs.showArgs = dialogArgs;
            currentActionArgs.loadArgs = dialogArgs.loadArgs;
        }
        else if (dialogArgs.type === EVUI.Modules.Dialogs.DialogArgumentType.Load)
        {
            currentActionArgs.loadArgs = dialogArgs;
        }
        else if (dialogArgs.type === EVUI.Modules.Dialogs.DialogArgumentType.Unload)
        {
            currentActionArgs.unloadArgs = dialogArgs;
        }

        return currentActionArgs;
    };

    /**Makes the "foreign" arguments for the PaneManager if it does not have them already.
    @param {EVUI.Modules.Panes.PaneArgsPackage} argsPackage The state of the Dialog as reported by the Panemanager.
    @returns {EVUI.Modules.Panes.WidowArgsPackage}*/
    var createForeignArgs = function (argsPackage)
    {
        var foreignArgs = new EVUI.Modules.Panes.PaneArgsPackage();
        if (argsPackage.hideArgs != null)
        {
            foreignArgs.hideArgs = new EVUI.Modules.Dialogs.DialogHideArgs(argsPackage.hideArgs);
            foreignArgs.hideArgs.unloadArgs = new EVUI.Modules.Dialogs.DialogUnloadArgs(argsPackage.hideArgs.unloadArgs);
        }

        if (argsPackage.showArgs != null)
        {
            foreignArgs.showArgs = new EVUI.Modules.Dialogs.DialogShowArgs(argsPackage.showArgs);
            foreignArgs.showArgs.showSettings = new EVUI.Modules.Dialogs.DialogShowSettings(argsPackage.showArgs.showSettings);
            foreignArgs.showArgs.loadArgs = new EVUI.Modules.Dialogs.DialogLoadArgs(argsPackage.showArgs.loadArgs);
            foreignArgs.showArgs.loadArgs.loadSettings = new EVUI.Modules.Dialogs.DialogLoadSettings(argsPackage.showArgs.loadArgs.loadSettings);
        }

        if (argsPackage.loadArgs != null)
        {
            foreignArgs.loadArgs = new EVUI.Modules.Dialogs.DialogLoadArgs(argsPackage.loadArgs);
            foreignArgs.loadArgs.loadSettings = new EVUI.Modules.Dialogs.DialogLoadSettings(argsPackage.loadArgs.loadSettings);
        }

        if (argsPackage.unloadArgs != null)
        {
            foreignArgs.unloadArgs = new EVUI.Modules.Dialogs.DialogUnloadArgs(argsPackage.unloadArgs);
        }

        return foreignArgs;
    };

    /**Makes or extends a Dialog object. Preserves all object references between runs and extends new properties onto the existing objects if they exist. 
    @param {EVUI.Modules.Dialogs.Dialog} yoloDialog A YOLO object representing a Dialog.
    @returns {EVUI.Modules.Dialogs.Dialog} */
    var makeOrExtendDialog = function (yoloDialog, pane, exists)
    {
        var dialogToExtend = null;
        if (exists === true)
        {
            var preExisting = _settings.getPaneEntry(yoloDialog.id);
            dialogToExtend = preExisting.wrapper;
        }
        else
        {
            dialogToExtend = new EVUI.Modules.Dialogs.Dialog(pane);
        }

        var safeCopy = EVUI.Modules.Core.Utils.shallowExtend({}, yoloDialog);
        delete safeCopy.id;
        if (exists === true && yoloDialog.element === pane.element) delete safeCopy.element; //if the dialog already exists and this is the same reference, don't set it again. Otherwise, let it blow up.
        delete safeCopy.currentPosition;
        delete safeCopy.currentZIndex;
        delete safeCopy.isVisible;
        delete safeCopy.isInitialized;
        delete safeCopy.isLoaded;

        EVUI.Modules.Core.Utils.shallowExtend(dialogToExtend, safeCopy, ["showSettings", "loadSettings", "autoCloseSettings", "resizeMoveSettings"]);
        dialogToExtend.showSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Dialogs.DialogShowSettings(pane.showSettings), dialogToExtend.showSettings, yoloDialog.showSettings);
        dialogToExtend.loadSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Dialogs.DialogLoadSettings(pane.loadSettings), dialogToExtend.loadSettings, yoloDialog.loadSettings);
        dialogToExtend.autoCloseSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Dialogs.DialogAutoCloseSettings(pane.autoCloseSettings), dialogToExtend.autoCloseSettings, yoloDialog.autoCloseSettings);
        dialogToExtend.resizeMoveSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Dialogs.DialogResizeMoveSettings(pane.resizeMoveSettings), dialogToExtend.resizeMoveSettings, yoloDialog.resizeMoveSettings)
        return dialogToExtend;
    };

    /**Gets a Dialog object from ambiguous input.
    @param {EVUI.Modules.Dialogs.Dialog|String|Event} dialogOrID Either a YOLO object representing a Dialog object, a string ID of a Dialog, or browser Event args triggering a Dialog action.
    @param {Boolean} addIfMissing Whether or not to add the Dialog record if it is not already present.
    @returns {EVUI.Modules.Panes.PaneEntry} */
    var getDialogAmbiguously = function (dialogOrID, addIfMissing)
    {
        if (dialogOrID == null || (typeof dialogOrID !== "string" && typeof dialogOrID !== "object")) throw Error("Invalid input: " + _settings.objectName + " or string id expected.");

        if (dialogOrID instanceof Event)
        {
            var entry = _settings.getPaneEntryAmbiguously(dialogOrID, addIfMissing);
            return entry;
        }

        var fakePane = {};
        if (typeof dialogOrID === "string")
        {
            fakePane = getDefaultPane({ id: dialogOrID });
        }
        else
        {
            fakePane.id = dialogOrID.id;
            fakePane.dialog = dialogOrID;
        }

        return _settings.getPaneEntryAmbiguously(fakePane, addIfMissing);
    };

    /**Gets a YOLO Pane object with all the default properties for a Dialog's backing Pane.
    @param {EVUI.Modules.Dialogs.Dialog} dialog The dialog to use as a wrapper for the Pane.
    @returns {EVUI.Modules.Panes.Pane}*/
    var getDefaultPane = function (dialog)
    {
        if (typeof dialog.id === "string")
        {
            var existing = _settings.getPaneEntry(dialog.id);
            if (existing != null && existing.pane != null)
            {
                var fake = EVUI.Modules.Core.Utils.shallowExtend({}, existing.pane);

                fake.dialog = dialog;
                return fake;
            }
        }

        var pane =
        {
            id: dialog.id,
            autoCloseSettings:
            {
                closeMode: EVUI.Modules.Panes.PaneCloseMode.Explicit,
                autoCloseKeys: ["Escape", "Enter"],
            },
            showSettings:
            {
                center: true,
            },
            clipSettings:
            {
                clipMode: EVUI.Modules.Dialogs.DialogClipMode.Shift,
                clipBounds: document.documentElement
            },
            resizeMoveSettings:
            {
                canDragMove: true,
                canResizeBottom: true,
                canResizeLeft: true,
                canResizeRight: true,
                canResizeTop: true,
                dragHanldeMargin: 20
            },
            
            dialog: dialog
        };

        return pane;
    };

    /**Interprets a browser event for a Dialog operation.
    @param {EVUI.Modules.Panes.Pane} pane The YOLO Pane being created to extend onto a real record.
    @param {Event} browserEvent The event from the browser.
    @returns {EVUI.Modules.Panes.Pane}*/
    var interpretBrowserEvent = function (pane, browserEvent)
    {
        EVUI.Modules.Core.Utils.shallowExtend(pane, getDefaultPane({ id: pane.id }));
        if (pane.showSettings == null) pane.showSettings = {};
        if (pane.resizeMoveSettings == null) pane.resizeMoveSettings = {};

        var attributes = EVUI.Modules.Core.Utils.getElementAttributes(browserEvent.currentTarget);

        var center = attributes.getValue(EVUI.Modules.Dialogs.Constants.Attribute_Center);
        var fullscreen = attributes.getValue(EVUI.Modules.Dialogs.Constants.Attribute_Fullscreen);
        var drag = attributes.getValue(EVUI.Modules.Dialogs.Constants.Attribute_Drag);
        var resizeHandles = attributes.getValue(EVUI.Modules.Dialogs.Constants.Attribute_ResizeHandles);
        var resizeHadleWidth = attributes.getValue(EVUI.Modules.Dialogs.Constants.Attribute_ResizeHandleWidth);
        var top = attributes.getValue(EVUI.Modules.Dialogs.Constants.Attribute_Top);
        var left = attributes.getValue(EVUI.Modules.Dialogs.Constants.Attribute_Left);
        var classes = attributes.getValue(EVUI.Modules.Dialogs.Constants.Attribute_Classes);

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(fullscreen) === false)
        {
            fullscreen = fullscreen.toLowerCase();

            if (fullscreen === "false")
            {
                pane.showSettings.fullscreen = false;
            }
            else if (fullscreen === "true")
            {
                pane.showSettings.fullscreen = true;
            }
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(center) === false)
        {
            center = center.toLowerCase();

            if (center === "false")
            {
                pane.showSettings.center = false;
            }
            else if (center === "true")
            {
                pane.showSettings.center = true;
            }
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(left) === false)
        {
            if (pane.showSettings.absolutePosition == null) pane.showSettings.absolutePosition = {};
            left = parseFloat(left, left.toLowerCase().replace("px", ""));
            if (isNaN(left) === false) pane.showSettings.absolutePosition.left = left;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(top) === false)
        {
            if (pane.showSettings.absolutePosition == null) pane.showSettings.absolutePosition = {};
            top = parseFloat(top, top.toLowerCase().replace("px", ""));
            if (isNaN(left) === false) pane.showSettings.absolutePosition.top = top;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(classes) === false)
        {
            pane.showSettings.positionClass = classes;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(drag) === false)
        {
            drag = drag.toLowerCase();

            if (drag === "true")
            {
                pane.resizeMoveSettings.canDragMove = true;
            }
            else if (drag === "false")
            {
                pane.resizeMoveSettings.canDragMove = false;
            }
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(resizeHandles) === false)
        {
            resizeHandles = resizeHandles.toLowerCase();

            pane.resizeMoveSettings.canResizeLeft = false;
            pane.resizeMoveSettings.canResizeRight = false;
            pane.resizeMoveSettings.canResizeTop = false;
            pane.resizeMoveSettings.canResizeBottom = false;

            if (resizeHandles.indexOf("left") !== -1) pane.resizeMoveSettings.canResizeLeft = true;
            if (resizeHandles.indexOf("right") !== -1) pane.resizeMoveSettings.canResizeRight = true;
            if (resizeHandles.indexOf("top") !== -1) pane.resizeMoveSettings.canResizeTop = true;
            if (resizeHandles.indexOf("bottom") !== -1) pane.resizeMoveSettings.canResizeBottom = true;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(resizeHadleWidth) === false)
        {
            resizeHadleWidth = parseFloat(resizeHadleWidth, resizeHadleWidth.toLowerCase().replace("px", ""));
            if (isNaN(resizeHadleWidth) === false && resizeHadleWidth >= 0) pane.resizeMoveSettings.resizeHadleWidth = resizeHadleWidth;
        }

        return true;
    };

    /**Adds additional event handlers to the Dialog.
    @param {EVUI.Modules.Panes.PaneEntry} paneEntry The pane to add the event to.*/
    var hookUpEventHandlers = function (paneEntry)
    {
        setHighestZOrder(paneEntry);
    };

    /**Adds additional event handlers to the Dialog.
    @param {EVUI.Modules.Panes.PaneEntry} paneEntry The pane to add the event to.*/
    var setHighestZOrder = function (paneEntry)
    {
        paneEntry.pane.addEventBinding(paneEntry.pane.element, "mousedown", function (eventArgs)
        {
            var curZIndex = paneEntry.pane.currentZIndex;
            if (curZIndex >= EVUI.Modules.Panes.Constants.GlobalZIndex) return;

            EVUI.Modules.Panes.Constants.GlobalZIndex++;

            curZIndex = EVUI.Modules.Panes.Constants.GlobalZIndex;
            var selector = "." + paneEntry.paneCSSName + "." + EVUI.Modules.Dialogs.Constants.CSS_Position;

            EVUI.Modules.Styles.Manager.ensureSheet(_settings.cssSheetName, { lock: true });
            EVUI.Modules.Styles.Manager.setRules(_settings.cssSheetName, selector, { zIndex: curZIndex });
        });
    };

    _settings = new EVUI.Modules.Panes.PaneManagerSettings();
    _settings.attributePrefix = EVUI.Modules.Dialogs.Constants.Default_AttributePrefix;
    _settings.cssPrefix = EVUI.Modules.Dialogs.Constants.Default_CssPrefix;
    _settings.cssSheetName = EVUI.Modules.Styles.Constants.DefaultStyleSheetName;
    _settings.eventNamePrefix = EVUI.Modules.Dialogs.Constants.Default_EventNamePrefix;
    _settings.managerName = EVUI.Modules.Dialogs.Constants.Default_ManagerName;
    _settings.objectName = EVUI.Modules.Dialogs.Constants.Default_ObjectName;
    _settings.makeOrExtendObject = makeOrExtendObject;
    _settings.buildEventArgs = buildEventArgs;
    _settings.interpretBrowserEvent = interpretBrowserEvent;
    _settings.hookUpEventHandlers = hookUpEventHandlers
    _settings.manager = _self;

    if (services == null || typeof services !== "object") services = new EVUI.Modules.Dialogs.DialogControllerServices();
    if (services.paneManager == null || typeof services.paneManager !== "object")
    {
        services.paneManager = EVUI.Modules.Panes.Manager;
    }

    _settings.httpManager = services.httpManager;
    _settings.stylesheetManager = services.stylesheetManager;
    _settings.htmlLoader = services.htmlLoader;

    _manager = new services.paneManager.createNewPaneManager(_settings);

    /**Global event that fires before the load operation begins for any Dialog and is not yet in the DOM and cannot be manipulated in this stage, however the currentActionArgs.loadSettings can be manipulated to change the way the Dialog's root element will be loaded.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogLoadArgs.*/
    this.onLoad = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onLoad", targetPath: "onLoad" });

    /**Global even that fires after the load operation has completed for any Dialog and is now in the DOM and can be manipulated in this stage. From this point on the Dialog's element property cannot be reset..
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogLoadArgs.*/
    this.onLoaded = function (paneEventArgs) { };;
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onLoaded", targetPath: "onLoaded" });

    /**Global event that fires the first time any Dialog is shown after being loaded into the DOM, but is not yet visible. After it has fired once, it will not fire again unless the DialogShowArgs.reInitialize property is set to true.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogShowArgs.*/
    this.onInitialize = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onInitialize", targetPath: "onInitialize" });

    /**Global event that fires at the beginning of the show process and before the calculations for any Dialog's location are made. The Dialog is still hidden, but is present in the DOM and can be manipulated. In order for the positioning calculations in the next step to be accurate, all HTML manipulation should occur in this event.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogShowArgs.*/
    this.onShow = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onShow", targetPath: "onShow" });

    /**Global event that fires after the position of any Dialog has been calculated and is available to be manipulated through the calculatedPosition property of the DialogEventArgs. If the calculatedPosition or the showSettings are manipulated, the position will be recalculated (the changes made directly to the position take priority over changes made to the showSettings).
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogShowArgs.*/
    this.onPosition = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onPosition", targetPath: "onPosition" });

    /**Global event that fires once any Dialog has been positioned, shown, and had its optional show transition applied and completed. Marks the end of the show process.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogShowArgs.*/
    this.onShown = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onShown", targetPath: "onShown" });

    /**Global event that fires before any Dialog has been moved from its current location and hidden. Gives the opportunity to change the hideTransition property of the DialogHideArgs and optionally trigger an unload once the Dialog has been hidden.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogHideArgs.*/
    this.onHide = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onHide", targetPath: "onHide" });

    /**Global event that fires after any Dialog has been moved from its current location and is now hidden and the hide transition has completed.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogHideArgs.*/
    this.onHidden = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onHidden", targetPath: "onHidden" });

    /**Global event that fires before any Dialog has been (potentially) removed from the DOM and had its element property reset to null.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogUnloadArgs.*/
    this.onUnload = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onUnload", targetPath: "onUnload" });

    /**Global event that fires after any Dialog has been (potentially) removed from the DOM and had its element property reset to null. From this point on the Dialog's element property is now settable to a new Element.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogUnloadArgs.*/
    this.onUnloaded = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onUnloaded", targetPath: "onUnloaded" });
}

/**Represents a UI component that behaves like a standard, centered dialog dialog with an optional backdrop by default.
 @class*/
EVUI.Modules.Dialogs.Dialog = function (pane)
{
    if (pane == null) throw Error("Invalid input. Must wrap a Pane.");

    /**Object. The Dialog being wrapped by the Dialog.
    @type {EVUI.Modules.Panes.Pane}*/
    var _pane = pane;

    /**String. The unique ID of this Dialog. ID's are case-insensitive.
    @type {String}*/
    this.id = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "id", targetPath: "id", settings: { set: false } });

    /**Object. The root Element of the Dialog. Cannot be reset once it has been assigned to via initialization or a load operation, unload the Dialog to reset it.
    @type {Element}*/
    this.element = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "element", targetPath: "element" });

    /**Boolean. Whether or not to unload the Dialog from the DOM when it is hidden (only applies to elements that were loaded via HTTP). False by default.
    @type {Boolean}*/
    this.unloadOnHide = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "unloadOnHide", targetPath: "unloadOnHide" });

    /**Object. Calculates and gets the absolute position of the Dialog.
    @type {EVUI.Modules.Dom.ElementBounds}*/
    this.currentPosition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "currentPosition", targetPath: "currentPosition", settings: { set: false } });

    /**Number. Calculates and gets the Z-Index of the Dialog.
    @type {Number}*/
    this.currentZIndex = -1;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "currentZIndex", targetPath: "currentZIndex", settings: { set: false } });

    /**Boolean. Whether or not the internal state of the Dialog thinks it is visible or not. This will be true after the show process has completed and false after an unload or hide operation has been completed.
    @type {Boolean}*/
    this.isVisible = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "isVisible", targetPath: "isVisible", settings: { set: false } });

    /**Boolean. Whether or not the internal state of the Dialog thinks it is visible or not. This will be true after the load process has completed, even if the element was set directly before the first load operation.
    @type {Boolean}*/
    this.isLoaded = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "isLoaded", targetPath: "isLoaded", settings: { set: false } });

    /**Boolean. Whether or not the internal state of the Dialog thinks it has been initialized or not. This will be true after the onInitialized events fire. */
    this.isInitialized = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "isInitialized", targetPath: "isInitialized", settings: { set: false } });

    /**Object. Show settings for the Dialog.
    @type {EVUI.Modules.Dialogs.DialogShowSettings}*/
    this.showSettings = null;

    /**Object. Settings for loading the Dialog.
    @type {EVUI.Modules.Dialogs.DialogLoadSettings}*/
    this.loadSettings = null;

    /**Object. Settings for controlling what should automatically close the Dialog.
    @type {EVUI.Modules.Dialogs.DialogAutoCloseSettings}*/
    this.autoCloseSettings = null;

    /**Object. Settings for controller how the Dialog should resize and move itself.
    @type {EVUI.Modules.Dialogs.DialogResizeMoveSettings}*/
    this.resizeMoveSettings = null;

    /**Any. Any contextual information to attach to the Dialog object.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "context", targetPath: "context" });

    /**Event that fires before the load operation begins for the Dialog and is not yet in the DOM and cannot be manipulated in this stage, however the currentActionArgs.loadSettings can be manipulated to change the way the Dialog's root element will be loaded.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogLoadArgs.*/
    this.onLoad = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onLoad", targetPath: "onLoad" });

    /**Event that fires after the load operation has completed for the Dialog and is now in the DOM and can be manipulated in this stage. From this point on the Dialog's element property cannot be reset..
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogLoadArgs.*/
    this.onLoaded = function (paneEventArgs) { };;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onLoaded", targetPath: "onLoaded" });

    /**Event that fires the first time the Dialog is shown after being loaded into the DOM, but is not yet visible. After it has fired once, it will not fire again unless the DialogShowArgs.reInitialize property is set to true.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogShowArgs.*/
    this.onInitialize = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onInitialize", targetPath: "onInitialize" });

    /**Event that fires at the beginning of the show process and before the calculations for the Dialog's location are made. The Dialog is still hidden, but is present in the DOM and can be manipulated. In order for the positioning calculations in the next step to be accurate, all HTML manipulation should occur in this event.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogShowArgs.*/
    this.onShow = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onShow", targetPath: "onShow" });

    /**Event that fires after the position of the Dialog has been calculated and is available to be manipulated through the calculatedPosition property of the DialogEventArgs. If the calculatedPosition or the showSettings are manipulated, the position will be recalculated (the changes made directly to the position take priority over changes made to the showSettings).
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogShowArgs.*/
    this.onPosition = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onPosition", targetPath: "onPosition" });

    /**Event that fires once the Dialog has been positioned, shown, and had its optional show transition applied and completed. Marks the end of the show process.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogShowArgs.*/
    this.onShown = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onShown", targetPath: "onShown" });

    /**Event that fires before the Dialog has been moved from its current location and hidden. Gives the opportunity to change the hideTransition property of the DialogHideArgs and optionally trigger an unload once the Dialog has been hidden.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogHideArgs.*/
    this.onHide = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onHide", targetPath: "onHide" });

    /**Event that fires after the Dialog has been moved from its current location and is now hidden and the hide transition has completed.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogHideArgs.*/
    this.onHidden = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onHidden", targetPath: "onHidden" });

    /**Event that fires before the Dialog has been (potentially) removed from the DOM and had its element property reset to null.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogUnloadArgs.*/
    this.onUnload = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onUnload", targetPath: "onUnload" });

    /**Event that fires after the Dialog has been (potentially) removed from the DOM and had its element property reset to null. From this point on the Dialog's element property is now settable to a new Element.
    @param {EVUI.Modules.Dialogs.DialogEventArgs} paneEventArgs The event arguments for the Dialog operation. The currentActionArgs property will be an instance of DialogUnloadArgs.*/
    this.onUnloaded = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onUnloaded", targetPath: "onUnloaded" });

    /**Returns a copy of the internal eventBindings array.
    @returns {EVUI.Modules.Panes.PaneEventBinding[]}*/
    this.getEventBindings = function ()
    {
        return _pane.getEventBindings();
    };

    /**Adds an event response to a standard browser event to a child element of the Dialog element.
    @param {Element} element The child element of the root pane element to attach an event handler to.
    @param {EVUI.Modules.Dom.Constants.Fn_BrowserEventHandler} handler An event handler to be called when the specified events are triggered.
    @param {String|String[]} event Either a single event name, or an array of event names, or a space delineated string of event names to add.*/
    this.addEventBinding = function (element, event, handler)
    {
        return _pane.addEventBinding(element, event, handler);
    };
};

/**The settings and options for showing a Dialog.
@class*/
EVUI.Modules.Dialogs.DialogShowSettings = function (showSettings)
{
    /**The show settings being set by the DialogShowSettings.
    @type {EVUI.Modules.Panes.PaneShowSettings}*/
    var _showSettings = (showSettings == null || typeof showSettings !== "object") ? new EVUI.Modules.Panes.PaneShowSettings() : showSettings;
    if (_showSettings.clipSettings == null) _showSettings.clipSettings = new EVUI.Modules.Panes.PaneClipSettings();
    if (_showSettings.absolutePosition == null) _showSettings.absolutePosition = new EVUI.Modules.Panes.PaneAbsolutePosition();

    /**Boolean. Whether or not to full screen the Dialog to cover the entire current view port. False by default.
    @type {Boolean}*/
    this.fullscreen = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "fullscreen", targetPath: "fullscreen" });

    /**Whether or not to explicitly position the Dialog so that it is centered on the screen's current view port. True by default.
    @type {Boolean}*/
    this.center = true;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "center", targetPath: "center" });

    /**If positioning the Dialog absolutely, this is the top coordinate of the Dialog.
    @type {Number}*/
    this.top = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "top", targetPath: "absolutePosition.top" });

    /**If positioning the Dialog absolutely, this is the left coordinate of the Dialog.
    @type {Number}*/
    this.left = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "left", targetPath: "absolutePosition.left" });

    /**String. The name of a CSS class (or an array of CSS classes, or a space-separated CSS classes) that are used to position the Dialog.
    @type {String|String[]}*/
    this.positionClass = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "positionClass", targetPath: "positionClass" });

    /**Object. Contains the details of the CSS transition to use to show the Dialog (if a transition is desired). If omitted, the Dialog is positioned then shown by manipulating the display property directly.
    @type {EVUI.Modules.Dialogs.DialogTransition}*/
    this.showTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "showTransition", targetPath: "showTransition" })

    /**Object. Contains the details of the CSS transition to use to hide the Dialog (if a transition is desired). If omitted, the Dialog is positioned then shown by manipulating the display property directly.
    @type {EVUI.Modules.Dialogs.DialogTransition}*/
    this.hideTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "hideTransition", targetPath: "hideTransition" })

    /**Object. An Element (or CSS selector of an Element) or an ElementBounds object describing the bounds to which the Dialog will attempt to fit inside. If omitted, the Dialog's current view port is used.
    @type {Element|EVUI.Modules.Dom.ElementBounds|String}*/
    this.clipBounds = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "clipBounds", targetPath: "clipSettings.clipBounds" })

    /**String. A value from the EVUI.Modules.Dialog.DialogClipMode enum indicating the behavior when the Pane spills outside of the clipBounds. Defaults to "overflow".
    @type {String}*/
    this.clipMode = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "clipMode", targetPath: "clipSettings.mode" })

    /**Boolean. Whether or not to include the height and width when positioning the element (when it is not clipped).
    @type {Boolean}*/
    this.setExplicitDimensions = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "setExplicitDimensions", targetPath: "setExplicitDimensions" })
};

/**Event arguments for the events exposed when hiding, showing, loading, or unloading a Dialog.
@class*/
EVUI.Modules.Dialogs.DialogEventArgs = function (argsPackage, currentArgs)
{
    if (argsPackage == null || currentArgs == null) throw Error("Invalid arguments.")

    /**Object. The metadata about the state of the Dialog.
    @type {EVUI.Modules.Panes.PaneArgsPackage}*/
    var _argsPackage = argsPackage;

    /**The current event args for the operation.
    @type {Any}*/
    var _currentArgs = currentArgs;

    /**The Dialog that is having an action performed on it.
    @type {EVUI.Modules.Panes.Dialog}*/
    this.dialog = null;
    Object.defineProperty(this, "dialog",
    {
        get: function () { return _argsPackage.wrapper; },
        configurable: false,
        enumerable: true
    });

    /**String. The unique key current step in the EventStream.
    @type {String}*/
    this.key = null;

    /**Function. Pauses the EventStream, preventing the next step from executing until resume is called.*/
    this.pause = function () { };

    /**Function. Resumes the EventStream, allowing it to continue to the next step.*/
    this.resume = function () { };

    /**Function. Cancels the EventStream and aborts the execution of the Dialog operation.*/
    this.cancel = function () { }

    /**Function. Stops the EventStream from calling any other event handlers with the same key.*/
    this.stopPropagation = function () { };

    /**Object. The position of the Dialog that has been calculated in using the currentShowSettings.
    @type {EVUI.Modules.Panes.PanePosition}*/
    this.calculatedPosition = null;
    Object.defineProperty(this, "calculatedPosition",
        {
            get: function () { return _argsPackage.lastCalculatedPosition; },
            configurable: false,
            enumerable: true
        });

    /**Object. The PaneHide/Show/Load/Unload Arguments being used for the operation.
    @type {EVUI.Modules.Dialogs.DialogShowArgs|EVUI.Modules.Dialogs.DialogHideArgs|EVUI.Modules.Dialogs.DialogLoadArgs|EVUI.Modules.Dialogs.DialogUnloadArgs}*/
    this.currentActionArgs = null;
    Object.defineProperty(this, "currentActionArgs", {
        get: function () { return _currentArgs },
        configurable: false,
        enumerable: true
    });

    /**Object. Any state value to carry between events.
    @type {Object}*/
    this.context = {};
};

/**Arguments for loading a Dialog.
 @class*/
EVUI.Modules.Dialogs.DialogLoadArgs = function (paneLoadArgs)
{
    /**The internal PaneLoadArgs being manipulated.
    @type {EVUI.Modules.Panes.PaneLoadArgs}*/
    var _loadArgs = (paneLoadArgs == null || typeof paneLoadArgs !== "object") ? new EVUI.Modules.Panes.PaneLoadArgs() : paneLoadArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _loadArgs, [{ sourcePath: "type", targetPath: "type" }]);

    /**Any. Any contextual information to pass into the Dialog load logic.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _loadArgs, [{ sourcePath: "context", targetPath: "context" }]);

    /**Object. The PaneLoadSettings to use if the Dialog has not already been loaded.
    @type {EVUI.Modules.Dialogs.DialogLoadSettings}*/
    this.loadSettings = null;

    /**Boolean. Whether or not to re-load the Dialog.
    @type {Boolean}*/
    this.reload = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _loadArgs, [{ sourcePath: "reload", targetPath: "reload" }]);
};

/**Arguments for showing a Dialog.
@class*/
EVUI.Modules.Dialogs.DialogShowArgs = function (paneShowArgs)
{
    /**The internal settings being set by the wrapper object.
    @type {EVUI.Modules.Panes.PaneShowArgs}*/
    var _paneShowArgs = (paneShowArgs == null || typeof paneShowArgs !== "object") ? new EVUI.Modules.Panes.PaneShowArgs() : paneShowArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneShowArgs, { sourcePath: "type", targetPath: "type", settings: { set: false } });

    /**Any. Any contextual information to pass into the Dialog show logic.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneShowArgs, { sourcePath: "context", targetPath: "context" });

    /**Object. The show settings for the Dialog.
    @type {EVUI.Modules.Dialogs.DialogShowSettings}*/
    this.showSettings = null;

    /**Object. The load arguments for loading the Dialog if it has not already been loaded.
    @type {EVUI.Modules.Dialogs.DialogLoadArgs}*/
    this.loadArgs = null;

    /**Whether or not to re-initialize the Dialog upon showing it.
    @type {Boolean}*/
    this.reInitialize = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneShowArgs, { sourcePath: "reInitialize", targetPath: "reInitialize" });
};

/**Arguments for hiding a Dialog.
@class*/
EVUI.Modules.Dialogs.DialogHideArgs = function (paneHideArgs)
{
    /**The internal settings being set by the wrapper object.
    @type {EVUI.Modules.Panes.PaneHideArgs}*/
    var _paneHideArgs = (paneHideArgs == null || typeof paneHideArgs !== "object") ? new EVUI.Modules.Panes.PaneHideArgs() : paneHideArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneHideArgs, { sourcePath: "type", targetPath: "type", settings: { set: false } });

    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneHideArgs, { sourcePath: "context", targetPath: "context" });

    /** */
    this.dialogHideTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneHideArgs, { sourcePath: "dialogHideTransition", targetPath: "paneHideTransition" });

    this.unloadArgs = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneHideArgs, { sourcePath: "unloadArgs", targetPath: "unloadArgs" });
};

/**Arguments for unloading a Dialog.
@class*/
EVUI.Modules.Dialogs.DialogUnloadArgs = function (paneUnloadArgs)
{
    /**The internal settings being set by the wrapper object.
    @type {EVUI.Modules.Panes.PaneUnloadArgs}*/
    var _paneUnloadArgs = (paneUnloadArgs == null || typeof paneUnloadArgs !== "object") ? new EVUI.Modules.Panes.PaneUnloadArgs() : paneUnloadArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneUnloadArgs, { sourcePath: "type", targetPath: "type", settings: { set: false } });

    /**Any. Any contextual information to pass into the Dialog hide logic.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneUnloadArgs, { sourcePath: "context", targetPath: "context" });

    /**Boolean. Whether or not to remove the Dialog from the DOM once it has been unloaded.
    @type {Boolean}*/
    this.remove = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneUnloadArgs, { sourcePath: "remove", targetPath: "remove" });
};

/**Represents a transition effect that can be applied to a Dialog when its position or size changes.
@class*/
EVUI.Modules.Dialogs.DialogTransition = function ()
{
    /**Object or String. Either class names, a string of CSS rules (without a selector), or an object of key-value pairs of CSS properties to generate a runtime CSS class for.
    @type {Object|String}*/
    this.css = null;

    /**String. CSS definition for a keyframe animation to apply. Note that the keyframe animation's name must appear in the PaneTransition.css property in order to be applied.
    @type {String|Object}*/
    this.keyframes = null;

    /**The duration (in milliseconds) of the transition so that the OnShown/OnHidden events are only fired once the transition is complete.
    @type {Number}*/
    this.duration = 0;
};

/**Settings and options for loading a Dialog.
@class */
EVUI.Modules.Dialogs.DialogLoadSettings = function (paneLoadSettings)
{
    var _paneLoadSettings = (paneLoadSettings == null || typeof paneLoadSettings !== "object") ? new EVUI.Modules.Panes.PaneLoadSettings() : paneLoadSettings;

    /**Object. The Element to show as the Dialog.
    @type {Element}*/
    this.element = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "element", targetPath: "element" });

    /**String. A CSS selector that is used to go find the Element to show as the Dialog. Only the first result is used.
    @type {String}*/
    this.selector = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "selector", targetPath: "selector" });

    /**Object. If using a CSS selector to find the root element of a Dialog, this is the context limiting element to search inside of.
    @type {Element}*/
    this.contextElement = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "contextElement", targetPath: "contextElement" });

    /**Object. HttpRequestArgs for making a Http request to go get the Dialog's HTML.
    @type {EVUI.Modules.Http.HttpRequestArgs}*/
    this.httpLoadArgs = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "httpLoadArgs", targetPath: "httpLoadArgs" });

    /**Object. PlaceholderLoadArgs for making a series of Http requests to load the Dialog as an existing placeholder.
    @type {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs}*/
    this.placeholderLoadArgs = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "placeholderLoadArgs", targetPath: "placeholderLoadArgs" });
};

/**Settings for controlling how the Dialog will automatically close itself in response to user events.
@class*/
EVUI.Modules.Dialogs.DialogAutoCloseSettings = function (autoCloseSettings)
{
    var _autoCloseSettings = (autoCloseSettings == null || typeof autoCloseSettings !== "object") ? EVUI.Modules.Panes.PaneAutoCloseSettings() : autoCloseSettings;

    /**Array. An array of characters/key names ("a", "b", "Escape", "Enter" etc) that will automatically trigger the Dialog to be hidden when pressed. Corresponds to the KeyboardEvent.key property.
    @type {String[]}*/
    this.autoCloseKeys = [];
    EVUI.Modules.Core.Utils.wrapProperties(this, _autoCloseSettings, { sourcePath: "autoCloseKeys", targetPath: "autoCloseKeys" });

    /**An optional function to use to determine if an auto-close event should hide the Dialog. Return false to prevent the Dialog from being hidden.
    @param {EVUI.Modules.Panes.PaneAutoTriggerContext} autoTriggerContext The context object generated by the event handler.
    @returns {Boolean}*/
    this.autoCloseFilter = function (autoTriggerContext)
    {
        return true;
    };
    EVUI.Modules.Core.Utils.wrapProperties(this, _autoCloseSettings, { sourcePath: "autoCloseFilter", targetPath: "autoCloseFilter" });
};

/**Object for containing information about how the Pane can be resized in response to user action.
@class*/
EVUI.Modules.Dialogs.DialogResizeMoveSettings = function (resizeMoveSettings)
{
    var _resizeMoveSettings = (resizeMoveSettings == null || typeof resizeMoveSettings !== "object") ? new EVUI.Modules.Panes.PaneResizeMoveSettings() : resizeMoveSettings;

    /**Boolean. Whether or not the Pane can be moved around via a click and drag operation after the addition of the evui-dlg-drag-handle attribute to an element on or inside the root element of the Pane. True by default. */
    this.canDragMove = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _resizeMoveSettings, { sourcePath: "canDragMove", targetPath: "canDragMove" });

    /**Boolean. Whether or not the top portion of the Y axis can be resized. True by default.
    @type {Boolean}*/
    this.canResizeTop = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _resizeMoveSettings, { sourcePath: "canResizeTop", targetPath: "canResizeTop" });

    /**Boolean. Whether or not the bottom portion of the Y axis can be resized. True by default.
    @type {Boolean}*/
    this.canResizeBottom = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _resizeMoveSettings, { sourcePath: "canResizeBottom", targetPath: "canResizeBottom" });

    /**Boolean. Whether or not the left portion of the X axis can be resized. True by default.
    @type {Boolean}*/
    this.canResizeLeft = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _resizeMoveSettings, { sourcePath: "canResizeLeft", targetPath: "canResizeLeft" });

    /**Boolean. Whether or not the right portion of the X axis can be resized. True by default.
    @type {Boolean}*/
    this.canResizeRight = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _resizeMoveSettings, { sourcePath: "canResizeRight", targetPath: "canResizeRight" });

    /**Number. The width in pixels of the margin around the edges of the Pane's root element that will be the clickable zone for triggering a resize operation (in pixels). 15 by default.
    @type {Numner}*/
    this.dragHanldeMargin = 15;
    EVUI.Modules.Core.Utils.wrapProperties(this, _resizeMoveSettings, { sourcePath: "dragHanldeMargin", targetPath: "dragHanldeMargin" });

    /**Boolean. Whether or not the dimensions of any resized elements in a Pane will be restored to their original size when the Pane is hidden. True by default.
    @type {Boolean}*/
    this.restoreDefaultOnHide = true;
    EVUI.Modules.Core.Utils.wrapProperties(this, _resizeMoveSettings, { sourcePath: "restoreDefaultOnHide", targetPath: "restoreDefaultOnHide" });
};

/**Object to inject the standard dependencies used by the DialogController into it via its constructor.
@class*/
EVUI.Modules.Dialogs.DialogControllerServices = function ()
{
    /**Object. An instance of Http module's HttpManager object.
    @type {EVUI.Modules.Http.HttpManager}*/
    this.httpManager = null;

    /**Object. An instance of the HtmlLoaderController module's HtmlLoaderController object.
    @type {EVUI.Modules.HtmlLoader.HtmlLoaderController}*/
    this.htmlLoader = null;

    /**Object. An instance of the Styles module's StylesheetManager object.
    @type {EVUI.Modules.Styles.StyleSheetManager}*/
    this.stylesheetManager = null;

    /**Object. An instance of the Panes module's PaneManager object.
    @type {EVUI.Modules.Panes.PaneManager}*/
    this.panesManager = null;
};

/**Enum for indicating what type of arguments object the DialogEventArgs.currentArguments property is.
@enum*/
EVUI.Modules.Dialogs.DialogArgumentType =
{
    /**Arguments are DialogShowArgs.*/
    Show: "show",
    /**Arguments are DialogHideArgs.*/
    Hide: "hide",
    /**Arguments are DialogLoadArgs.*/
    Load: "load",
    /**Arguments are DialogUnloadArgs.*/
    Unload: "unload",
    /**Arguments are DialogMoveResizeArgs.*/
    MoveResize: "moveResize"
};
Object.freeze(EVUI.Modules.Dialogs.DialogArgumentType);

/**Enum for indicating the behavior of the Dialog when it overflows its clipBounds.
@enum*/
EVUI.Modules.Dialogs.DialogClipMode =
{
    /**When the calculated position of the Dialog overflows the clipBounds, it will not be cropped to stay within the clipBounds and will overflow to the outside of the clip bounds.*/
    Overflow: "overflow",
    /**When the calculated position of the Dialog overflows the clipBounds, it will be clipped to the maximum dimensions of the clipBounds on the overflowing axes.*/
    Clip: "clip",
    /**When the calculated position of the Dialog overflows the clipBounds, it will be shifted in the opposite directions as the overflow to fit within the clipBounds.*/
    Shift: "shift",
};
Object.freeze(EVUI.Modules.Dialogs.DialogClipMode);

/**Global instance of the DialogManager, used for creating and using simple dialogs that are positioned relative to a point or another element.
@type {EVUI.Modules.Dialogs.DialogManager}*/
EVUI.Modules.Dialogs.Manager = null;
(function ()
{
    var manager = null;
    var ctor = EVUI.Modules.Dialogs.DialogManager;  

    Object.defineProperty(EVUI.Modules.Dialogs, "Manager", {
        get: function ()
        {
            if (manager == null) manager = new ctor();
            return manager;
        },
        enumerable: true,
        configurable: false
    });
})();

Object.freeze(EVUI.Modules.Dialogs);

delete $evui.dialogs;

/**Global instance of the DialogManager, used for creating and using simple dialogs that are positioned relative to a point or another element.
@type {EVUI.Modules.Dialogs.DialogManager}*/
$evui.dialogs = null;
Object.defineProperty($evui, "dialogs", {
    get: function () { return EVUI.Modules.Dialogs.Manager; },
    enumerable: true
});

/**Adds a Dialog to the WidowManager.
@param {EVUI.Modules.Dialogs.Dialog} yoloDialog A YOLO object representing a Dialog object. This object is copied onto a real Dialog object is then discarded.
@returns {EVUI.Modules.Dialogs.Dialog}*/
$evui.addDialog = function (yoloDialog)
{
    return $evui.dialogs.addDialog(yoloDialog);
};

/**Shows (and loads, if necessary or if a reload is requested) a Dialog asynchronously. Provides a callback that is called call once the Dialog operation has completed successfully or otherwise.
@param {EVUI.Modules.Dialogs.Dialog|String} dialogOrID Either a YOLO Dialog object to extend into the existing Dialog, the real Dialog reference, or the string ID of the Dialog to show.
@param {EVUI.Modules.Dialogs.DialogShowArgs|EVUI.Modules.Dialogs.Constants.Fn_DialogOperationCallback} dialogShowArgs Optional. A YOLO object representing the arguments for showing the Dialog, or the callback. If omitted or passed as a function, the Dialog's existing show/load settings are used instead.
@param {EVUI.Modules.Dialogs.Constants.Fn_DialogOperationCallback} callback Optional. A callback that is called once the operation completes.*/
$evui.showDialog = function (dialogOrID, dialogShowArgs, callback)
{
    return $evui.dialogs.showDialog(dialogOrID, dialogShowArgs, callback);
};

/**Awaitable. (and loads, if necessary or if a reload is requested) a Dialog asynchronously.
@param {EVUI.Modules.Dialogs.Dialog|String} dialogOrID Either a YOLO Dialog object to extend into the existing Dialog, the real Dialog reference, or the string ID of the Dialog to show.
@param {EVUI.Modules.Dialogs.DialogShowArgs} dialogShowArgs Optional.  A YOLO object representing the arguments for showing the Dialog. If omitted, the Dialog's existing show/load settings are used instead.
@returns {Promise<Boolean>}*/
$evui.showDialogAsync = function (dialogOrID, dialogShowArgs)
{
    return $evui.dialogs.showDialogAsync(dialogOrID, dialogShowArgs);
};

/**Hides (and unloads if requested) a Dialog asynchronously. Provides a callback that is called call once the Dialog operation has completed successfully or otherwise.
@param {EVUI.Modules.Dialogs.Dialog|String} dialogOrID Either a YOLO Dialog object to extend into the existing Dialog, the real Dialog reference, or the string ID of the Dialog to hide.
@param {EVUI.Modules.Dialogs.DialogHideArgs|EVUI.Modules.Dialogs.Constants.Fn_DialogOperationCallback} dialogHideArgs Optional.  A YOLO object representing the arguments for hiding a Dialog or the callback. If omitted or passed as a function, the Dialog's existing hide/unload settings are used instead.
@param {EVUI.Modules.Dialogs.Constants.Fn_DialogOperationCallback} callback Optional. A callback that is called once the operation completes.*/
$evui.hideDialog = function (dialogOrID, dialogHideArgs, callback)
{
    return $evui.dialogs.hideDialog(dialogOrID, dialogHideArgs, callback);
};

/**Awaitable. Hides (and unloads if requested) a Dialog asynchronously. Provides a callback that is called call once the Dialog operation has completed successfully or otherwise.
@param {EVUI.Modules.Dialogs.Dialog|String} dialogOrID Either a YOLO Dialog object to extend into the existing Dialog, the real Dialog reference, or the string ID of the Dialog to hide.
@param {EVUI.Modules.Dialogs.DialogHideArgs} dialogHideArgs Optional.  A YOLO object representing the arguments for hiding a Dialog. If omitted, the Dialog's existing hide/unload settings are used instead.
@returns {Promise<Boolean>}*/
$evui.hideDialogAsync = function (dialogOrID, dialogHideArgs)
{
    return $evui.dialogs.hideDialogAsync(dialogOrID, dialogHideArgs);
};

/*#ENDWRAP(Dialog)#*/


/********************************************************Diff.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.Diff|Diff)#*/
/*#REPLACE(EVUI.Modules.Diff|Diff)#*/

/**Module for doing diff comparisons on strings and objects.
@module*/
EVUI.Modules.Diff = {};

/*#MODULEDEF(Diff|"1.0"|"Diff")#*/
/*#VERSIONCHECK(EVUI.Modules.Diff|Diff)#*/

/**Dependency list for the Diff module.*/
EVUI.Modules.Diff.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.Diff.Dependencies, "checked", {
        get: function () { return checked; },
        set: function (value)
        {
            if (typeof value === "boolean") checked = value;
        },
        configurable: false,
        enumberable: true
    });
})();

Object.freeze(EVUI.Modules.Diff.Dependencies);

/**Constants table for the Diff module.*/
EVUI.Modules.Diff.Constants = {};

/**Synchronous function definition for a custom decider that decides if an object should be included in the comparison graph or hash code calculation. Return false to cancel the comparison or inclusion in hash code calculation.
@param {Any} obj The object do decide to compare or not.
@param {String} propName The name of the value being compared in its parent object. Note that the root comparison will not have a property name.
@returns {Boolean}*/
EVUI.Modules.Diff.Constants.Fn_ShouldComparePredicate = function (obj, propName) { return true; }

Object.freeze(EVUI.Modules.Diff.Constants);

/**Global cache of Symbols that appear when calculating value hash codes in the DiffContoller.*/
EVUI.Modules.Diff.SymbolCache = null;
(function ()
{
    var cache = {};
    Object.defineProperty(EVUI.Modules.Diff, "SymbolCache", {
        get: function ()
        {
            return cache;
        },
        enumerable: true,
        configurable: false
    });
})();

/**Class for doing generic comparisons between objects, values, and strings.
@class*/
EVUI.Modules.Diff.DiffController = function ()
{
    /**Object for keeping track of all the data that is collected and used when comparing two objects or values.
    @class*/
    var CompareSession = function ()
    {
        /**Array. The current "stack" of objects representing the hierarchy of objects the hash calculator is in when it is digging into an object hierarchy while generating hash codes. Is used to prevent circular loops in object graphs that would otherwise result in a stack overflow.
        @type {Object[]}*/
        this.objectParentage = [];

        /**Number. A counter that keeps track of the number of conversions in an object graph and ensures a unique ID for each.
        @type {Number}*/
        this.counter = 0;

        /**Array. A list of all the objects who have had their hash codes calculated already.
        @type {ObjectHashCode[]}*/
        this.objectHashCodes = [];

        /**Object. The final result of the comparison operation.
        @type {EVUI.Modules.Diff.CompareResult}*/
        this.compareResult = new EVUI.Modules.Diff.CompareResult();

        /**Number. The type of operation being performed. Must be a value from the SessionMode enum.
        @type {Number}*/
        this.mode = SessionMode.Diff;

        /**Object. Lookup object for storing commonly cached values rather than re-hashing them over and over.
        @type {Object}*/
        this.hashCache = {};

        /**Handle to look up object hash codes on-the-fly.
        @param {Any} value THe value to get the hash code of.
        @returns {Number} */
        this.getValueHashCode = function (value)
        {
            return getHashCode(this, value);
        };
    };

    /**Enum for indicating the ownership of a property relative to its owning object.
    @enum*/
    var PropertyOwnershipState =
    {
        /**Property ownership status unknown.*/
        Unknown: -1,
        /**Property is in both objects.*/
        Common: 0,
        /**Property is only in A.*/
        AOnly: 1,
        /**Property is only in B.*/
        BOnly: 2,
    };

    /**Details about which object(s) own a given property when they are being compared.
    @class*/
    var PropertyDetails = function ()
    {
        /**String. The property key.
        @type {String}*/
        this.key = null;

        /**Number. Indicates which object(s) own the property with the given key. Must be a value from PropertyOwnershipState.
        @type {Number}*/
        this.flags = PropertyOwnershipState.Unknown;
    };

    /**Record that records an object and it's calculated hash code.
    @class*/
    var ObjectHashCode = function ()
    {
        /**Object. The object that has had it's hash code calculated.
        @type {Object}*/
        this.obj = null;

        /**String. The hash code of the object.
        @type {String}*/
        this.hash = null;
    };

    /**The type of mode the CompareSession object is running as.
    @enum*/
    var SessionMode =
    {
        /**Comparing two objects or values.*/
        Diff: 0,
        /**Getting the hash code of an object or value.*/
        GetValueHash: 1,
        /**Getting the difference between two strings.*/
        StringDiff: 2
    };

    //common hash codes to reuse so we don't have to calculate them over and over again.
    var _nullHash = EVUI.Modules.Core.Utils.getHashCode("##evui.null##");
    var _undefinedHash = EVUI.Modules.Core.Utils.getHashCode("##evui.undefined##");
    var _trueHash = EVUI.Modules.Core.Utils.getHashCode("##evui.true##");
    var _falseHash = EVUI.Modules.Core.Utils.getHashCode("##evui.false##");

    /**Performs a deep compare on two objects and returns data on what is different and the same between the two values.
    @param {Any} a A value to compare.
    @param {Any} b A value to compare.
    @param {EVUI.Modules.Diff.CompareOptions} options A YOLO CompareOptions object for controlling various aspects of the comparison. 
    @returns {EVUI.Modules.Diff.CompareResult}*/
    this.compare = function (a, b, options)
    {
        var session = makeSession(options, SessionMode.Diff);

        session.compareResult.rootComparison = compareItems(session, a, b, null, null);

        return session.compareResult;
    };

    /**Gets a value equality hash code of an arbitrary value or object. The hash code is calculated based on the value or values of the object (and its children) and can be used for value equality comparisons. Note that circular object graphs have a much higher chance of hash collisions than non-circular ones.
    @param {Any} value The value to get the value equality hash code of.
    @param {EVUI.Modules.Diff.CompareOptions} options A YOLO CompareOptions object for controlling various aspects of the hash generation.
    @returns {Number}*/
    this.getValueHashCode = function (value, options)
    {
        var session = makeSession(options, SessionMode.GetValueHash);

        if (shouldInclude(session, null, value, null, typeof value, null, true) === false) return null;

        return getHashCode(session, value);
    };

    /**Performs a string compare on two string and returns data on what is different and the same between the two strings.
    @param {Any} a A string to compare.
    @param {Any} b A string to compare.
    @param {EVUI.Modules.Diff.StringCompareOptions} options A YOLO StringCompareOptions object for controlling various aspects of the string diff.
    @returns {EVUI.Modules.Diff.StringCompareResult}*/
    this.compareStrings = function (a, b, options)
    {
        if (typeof a !== "string" || typeof b !== "string") throw Error("Invalid parameters: cannot compare non-string values.");

        var sessionOptions = new EVUI.Modules.Diff.CompareOptions();
        sessionOptions.diffStrings = true;
        sessionOptions.stringCompareOptions = options;

        var session = makeSession(sessionOptions, SessionMode.StringDiff);
        var comparison = compareItems(session, a, b);

        var stringDiff = new EVUI.Modules.Diff.StringCompareResult();
        stringDiff.a = a;
        stringDiff.b = b;
        stringDiff.options = session.compareResult.options;
        stringDiff.stringDiffs = comparison.differences;

        return stringDiff;
    };

    /**Makes the ComparisonSession object used in the comparison 
    @param {EVUI.Modules.Diff.CompareOptions} options
    @returns {CompareSession}*/
    var makeSession = function (options, mode)
    {
        options = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Diff.CompareOptions(), options);
        if (options.exclusionFilters != null && EVUI.Modules.Core.Utils.isArray(options.exclusionFilters) === true) options.exclusionFilters = options.exclusionFilters.slice();
        options.stringCompareOptions = (options.stringCompareOptions == null) ? new EVUI.Modules.Diff.StringCompareOptions() : EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Diff.StringCompareOptions(), options.stringCompareOptions);

        var session = new CompareSession();
        session.compareResult.options = options;

        if (mode == null) mode = SessionMode.Diff;

        return session;
    }

    /**Determines if either of the two values should be compared.
    @param {CompareSession} session Data about the compare operation in progress.
    @param {String} propName The name of the property being evaluated.
    @param {Any} a Any value.
    @param {Any} b Any value.
    @param {String} aType The value of the typeof operator on a.
    @param {String} bType The value of the typeof operator on b.
    @param {Boolean} hashing Whether or not this function is being called 
    @returns {Boolean}*/
    var shouldInclude = function (session, propName, a, b, aType, bType, hashing)
    {
        if (session.compareResult.options.excludeFunctions === true)
        {
            if (aType === "function" || bType === "function")
            {
                return false;
            }
        }

        //not comparing anything having to do with nodes, they are massive recursive objects that will either crash or choke the converter
        if ((aType === "object" && a instanceof Node) || (bType === "object" && b instanceof Node))
        {
            return false;
        }

        //apply any custom exclusions to the object graph
        if (session.compareResult.options.exclusionFilters != null)
        {
            if (typeof session.compareResult.options.exclusionFilters === "function")
            {
                if (session.compareResult.options.exclusionFilters(a, propName) === false || (hashing === false && session.compareResult.options.exclusionFilters(b, propName) === false))
                {
                    return false;
                }
            }
            else if (EVUI.Modules.Core.Utils.isArray(session.compareResult.options.exclusionFilters) === true)
            {
                var numFuncs = session.compareResult.options.exclusionFilters.length;;
                for (var x = 0; x < numFuncs; x++)
                {
                    var curFilter = session.compareResult.options.exclusionFilters[x];
                    if (typeof curFilter === "function")
                    {
                        if (curFilter(a, propName) === false) return false;
                        if (hashing === false && curFilter(b, propName) === false) return false;
                    }
                }
            }
        }

        return true;
    };

    /**Starting point of a deep recursive compare operation for any two values.
    @param {CompareSession} session Data about the compare operation in progress.
    @param {Any} a Any value.
    @param {Any} b Any value.
    @param {String} propName The name of the property in the parent object that is being compared.
    @param {EVUI.Modules.Diff.Comparison} parent The parent comparison that this comparison is a child of.
    @returns {EVUI.Modules.Diff.Comparison} */
    var compareItems = function (session, a, b, propName, parent)
    {
        var aType = typeof a;
        var bType = typeof b;

        if (shouldInclude(session, propName, a, b, aType, bType, false) === false) return null;

        var comparison = new EVUI.Modules.Diff.Comparison(session);
        comparison.id = session.counter++;
        comparison.a = a;
        comparison.b = b;
        comparison.parentComparison = parent;
        comparison.propName = propName;

        //add to the flat list of all comparisons that will be returned as part of the result
        session.compareResult.allComparisons.push(comparison);

        if (aType === "object" && bType === "object") //if both are objects
        {
            comparison.diffType = EVUI.Modules.Diff.DiffType.Object;

            if (a != null && b != null) //and neither is null, do a recursive object comparison
            {
                comparison = compareObjects(session, comparison);
                if (a.prototype !== b.prototype) comparison.flags |= EVUI.Modules.Diff.DiffFlags.Prototype;
            }
            else //otherwise, if one is null, don't bother doing a comparison.
            {
                if (a != null || b != null)
                {
                    comparison.flags |= (a != null) ? EVUI.Modules.Diff.DiffFlags.AOnly : EVUI.Modules.Diff.DiffFlags.BOnly;

                    //if (session.compareResult.options.compareValuesOnly === false) comparison.flags |= EVUI.Modules.Diff.DiffFlags.Reference;
                    comparison.flags |= EVUI.Modules.Diff.DiffFlags.Reference;
                }

                //do the comparison with one null value anyways just so that the missing properties show up as differences
                comparison = compareObjects(session, comparison);
            }
        }
        else
        {
            if (a !== b) //values different
            {
                comparison.flags |= EVUI.Modules.Diff.DiffFlags.Value;
            }

            if (aType === "string" && bType === "string") //both are strings, do the special string compare mode
            {
                comparison.diffType = EVUI.Modules.Diff.DiffType.String;
                if (session.compareResult.options.diffStrings === true)
                {
                    comparison.differences = getStringDiffs(a, b);
                }                
            }
            else //otherwise we have two random values to compare
            {
                comparison.diffType = EVUI.Modules.Diff.DiffType.Property;
                if (aType !== bType) comparison.flags |= EVUI.Modules.Diff.DiffFlags.Prototype; //if the types differ, we have different prototypes
            }
        }

        var finalFlags = (session.compareResult.options.compareValuesOnly === true) ? EVUI.Modules.Core.Utils.removeFlag(comparison.flags, EVUI.Modules.Diff.DiffFlags.Reference) : comparison.flags;

        if (parent != null) //register the comparison with the parent if we have one
        {
            parent.childComparisons.push(comparison);
            if (finalFlags !== EVUI.Modules.Diff.DiffFlags.None) //if the child comparison had any differences at all, mark the parent as having a child difference. This will propagate all the way to the top of the hierarchy
            {
                parent.differences.push(comparison);
                parent.flags |= EVUI.Modules.Diff.DiffFlags.Children;
            }
        }       

        //if anything had any difference, add it to the differences list
        if (finalFlags !== EVUI.Modules.Diff.DiffFlags.None)
        {
            session.compareResult.allDifferences.push(comparison);
        }
        else //otherwise it goes in the "in common" list
        {
            session.compareResult.allInCommon.push(comparison);
        }


        return comparison;
    };

    /**Special logic for comparing strings to come up with a list of the segments that belong to a, b, or both.
    @param {String} strA A string to compare.
    @param {String} strB Another string to compare.
    @param {EVUI.Modules.Diff.StringCompareOptions} stringDiffOptions Options for controlling the diffing of the strings.
    @returns {EVUI.Modules.Diff.StringDifference[]} */
    var getStringDiffs = function (strA, strB, stringDiffOptions)
    {
        if (strA === strB) return [];
        var diffs = [];

        var curDiff = null;

        var aLen = strA.length;
        var bLen = strB.length;
        var len = (aLen >= bLen) ? aLen : bLen;

        var aIndex = 0;
        var bIndex = 0;
        var commonSeg = "";

        while (aIndex < len || bIndex < len) //while we have not walked off the end of both strings
        {
            var aChar = strA[aIndex];
            var bChar = strB[bIndex];

            if (aChar !== bChar && aChar !== undefined && bChar !== undefined) //if the characters are different and not undefined, we need to find the nearest common character in both strings.
            {
                if (curDiff != null) //if we had an existing difference object, it was being built from common characters. Finish it off and reset it to null.
                {
                    curDiff.text = commonSeg;
                    commonSeg = "";

                    diffs.push(curDiff);
                    curDiff = null;
                }

                var foundInA = false;
                var foundInB = false;

                if (aChar !== undefined && bChar !== undefined) //if we have two valid characters, begin walking the strings
                {
                    //start looking beginning at the current indexes in both strings
                    var sameCharAIndex = aIndex;
                    var sameCharBIndex = bIndex;

                    //walk the A string and find the nearest character in common in the B string
                    var maxB = bLen; //maxB is the furthest point in B to where there is a common character, it's moved closer with every iteration of the inner loops successful completion
                    for (var x = aIndex; x < aLen; x++)
                    {
                        var curIndex = aIndex + (x - aIndex);
                        aChar = strA[curIndex]; //get the next character in the A string

                        if (curIndex < maxB) //if the current index in A still hasn't passed the next closest index in B, keep going (effectively, "have the strings overlapped yet" check)
                        {
                            for (var y = bIndex; y < maxB; y++) //walk the B string looking for A's character
                            {
                                if (strB[y] === aChar) //found a match, walk maxB back and remember the location of the same character in both A and B strings
                                {
                                    foundInA = true;
                                    maxB = y;
                                    sameCharAIndex = curIndex;
                                    sameCharBIndex = y;
                                    break;
                                }
                            }
                        }
                        else //stings now overlapping, we're done searching
                        {
                            break;
                        }
                    }

                    //now walk the B string looking for the closes character in the A string. We need whichever is closer.
                    var maxA = (foundInA === true) ? sameCharAIndex : aLen; //maxA is the furthest point in A to where there is a common character, it's moved closer with every iteration of the inner loops successful completion
                    for (var x = bIndex; x < bLen; x++)
                    {
                        var curIndex = bIndex + (x - bIndex);
                        bChar = strB[curIndex]; //get the next character in the b string

                        if (curIndex < maxA) //if the current index in B still hasn't passed the next closest index in A, keep going (effectively, "have the strings overlapped yet" check)
                        {
                            for (var y = aIndex; y < maxA; y++) //walk the A string looking for B's character
                            {
                                if (bChar === strA[y]) //found a match, walk maxA back
                                {
                                    foundInB = true;
                                    maxA = y;
                                    if (curIndex <= sameCharBIndex || y <= sameCharAIndex) //only if this character came earlier than the result of the A loop, remember the location of the same character in both A and B strings
                                    {
                                        sameCharBIndex = curIndex;
                                        sameCharAIndex = y;
                                    }

                                    break;
                                }
                            }
                        }
                        else //stings now overlapping, we're done searching
                        {
                            break;
                        }
                    }
                }

                aChar = strA[sameCharAIndex]
                bChar = strB[sameCharBIndex]
                if (aChar !== bChar) //check to see if we've gotten out of sync
                {
                    if (foundInA === false && foundInB === false) //if we are out of sync, but never found a match, we are done searching the strings
                    {
                        sameCharAIndex = aLen;
                        sameCharBIndex = bLen;
                    }
                    else //otherwise something failed and we will stop the operation
                    {
                        var aDiff = new EVUI.Modules.Diff.StringDifference();
                        aDiff.aIndex = aIndex;
                        aDiff.text = strA.substring(aIndex, aLen);
                        aDiff.flags |= EVUI.Modules.Diff.DiffFlags.AOnly;
                        diffs.push(aDiff);

                        var bDiff = new EVUI.Modules.Diff.StringDifference();
                        bDiff.bIndex = bIndex;
                        bDiff.text = strB.substring(bIndex, bLen);
                        bDiff.flags |= EVUI.Modules.Diff.DiffFlags.BOnly;
                        diffs.push(bDiff);
                        break;
                    }
                }

                //add the new difference for what was found in A's string (if the index advanced)
                if (sameCharAIndex !== aIndex)
                {
                    var aDiff = new EVUI.Modules.Diff.StringDifference();
                    aDiff.aIndex = aIndex;
                    aDiff.text = strA.substring(aIndex, sameCharAIndex);
                    aDiff.flags |= EVUI.Modules.Diff.DiffFlags.AOnly;
                    diffs.push(aDiff);

                    aIndex = sameCharAIndex;
                }

                //add the new difference for what was found in B's string (if the index advanced)
                if (sameCharBIndex !== bIndex)
                {
                    var bDiff = new EVUI.Modules.Diff.StringDifference();
                    bDiff.bIndex = bIndex;
                    bDiff.text = strB.substring(bIndex, sameCharBIndex);
                    bDiff.flags |= EVUI.Modules.Diff.DiffFlags.BOnly;
                    diffs.push(bDiff);

                    bIndex = sameCharBIndex;
                }
            }
            else if (aChar === undefined && bChar !== undefined) //walked off the end of the A string, take the rest of the A string.
            {
                var bDiff = new EVUI.Modules.Diff.StringDifference();
                bDiff.bIndex = bIndex;
                bDiff.text = strB.substring(bIndex, bLen);
                bDiff.flags |= EVUI.Modules.Diff.DiffFlags.BOnly;
                diffs.push(bDiff);

                break;
            }
            else if (bChar === undefined && aChar !== undefined) //walked off of the end of the B string, take the rest of the A string
            {
                var aDiff = new EVUI.Modules.Diff.StringDifference();
                aDiff.aIndex = aIndex;
                aDiff.text = strA.substring(aIndex, aLen);
                aDiff.flags |= EVUI.Modules.Diff.DiffFlags.AOnly;
                diffs.push(aDiff);

                break;
            }
            else if (aChar === undefined && bChar === undefined) //both are undefined, walked off the end of both string, all done
            {
                break;
            }
            else //characters are the same, add them to a diff span that is the common characters
            {
                if (curDiff == null)
                {
                    curDiff = new EVUI.Modules.Diff.StringDifference();
                    curDiff.aIndex = aIndex;
                    curDiff.bIndex = bIndex;
                }

                commonSeg += aChar;

                aIndex++;
                bIndex++;
            }
        }

        if (curDiff != null) //if we have a dangling diff, add it to the end after the loop has escaped
        {
            curDiff.text = commonSeg;
            diffs.push(curDiff);
        }

        return diffs;
    };

    /**Compares two objects recursively.
    @param {CompareSession} session  Data about the compare operation in progress.
    @param {EVUI.Modules.Diff.Comparison} comparison The current comparison of the two objects.
    @returns {EVUI.Modules.Diff.Comparison}*/
    var compareObjects = function (session, comparison)
    {
        if (comparison.a === comparison.b) return comparison;

        comparison.flags |= EVUI.Modules.Diff.DiffFlags.Reference;
        var childComparisons = {};
        var aNull = comparison.a == null;
        var bNull = comparison.b == null;

        if (aNull === false)
        {
            var aKeys = EVUI.Modules.Core.Utils.getProperties(comparison.a); //Object.keys(comparison.a);
            var numAKeys = aKeys.length;

            for (var x = 0; x < numAKeys; x++)
            {
                var key = aKeys[x];
                var aValue = comparison.a[key];
                var bValue = (bNull === false) ? comparison.b[key] : undefined;

                var childComparison = compareItems(session, aValue, bValue, key, comparison);
                if (childComparison == null) continue;

                if (bNull === false) childComparisons[key] = childComparison;
                childComparison.flags |= EVUI.Modules.Diff.DiffFlags.AOnly;
            }
        }

        if (bNull === false)
        {
            var bKeys = EVUI.Modules.Core.Utils.getProperties(comparison.b); //Object.keys(comparison.b);
            var numBKeys = bKeys.length;

            for (var x = 0; x < numBKeys; x++)
            {
                var key = bKeys[x];
                if (aNull === false)
                {
                    var existing = childComparisons[key];
                    if (existing != null)
                    {
                        existing.flags = EVUI.Modules.Core.Utils.removeFlag(existing.flags, EVUI.Modules.Diff.DiffFlags.AOnly);
                        continue;
                    }
                }

                var aValue = (aNull === false) ? comparison.a[key] : undefined;
                var bValue = comparison.b[key];

                var childComparison = compareItems(session, aValue, bValue, key, comparison);
                if (childComparison == null) continue;

                childComparison.flags |= EVUI.Modules.Diff.DiffFlags.BOnly;
            }
        }

        return comparison;
    }

    /**Gets the value equality hash code of a value by salting it based on its type (except when its a string) then getting the value of it's .toString value. If it is an object it will recursively calculate its hash code based on the hash codes of its children.
    @param {CompareSession} session  Data about the compare operation in progress.
    @param {Any} value The value to get the hash code of.
    @returns {Number}*/
    var getHashCode = function (session, value)
    { 
        if (value === null)
        {
            return _nullHash;
        }
        else if (value === undefined)
        {
            return _undefinedHash;
        }
        else
        {
            var valueType = typeof value;
            switch (valueType)
            {
                case "string":

                    if (value.length <= 36)
                    {
                        var existingHash = session.hashCache[value];
                        if (existingHash == null)
                        {
                            var hash = EVUI.Modules.Core.Utils.getHashCode(value);
                            session.hashCache[value] = hash;

                            return hash;
                        }
                        else
                        {
                            return existingHash;
                        }
                    }
                    else
                    {
                        return EVUI.Modules.Core.Utils.getHashCode(value);
                    }
   
                case "boolean":
                    return (value === true) ? _trueHash : _falseHash;
                case "bigint":
                case "number":

                    var hashKey = value.toString() + "##evui." + valueType + "##";
                    var existingHash = session.hashCache[hashKey]; //salting the hash so we don't get collisions between strings and values converted to strings
                    if (existingHash == null)
                    {
                        var hash = EVUI.Modules.Core.Utils.getHashCode(hashKey);
                        session.hashCache[hashKey] = hash;

                        return hash;
                    }
                    else
                    {
                        return existingHash;
                    }
                   
                case "function":
                    return (session.options.excludeFunctions === true) ? "" : EVUI.Modules.Core.Utils.getHashCode(value.toString() + "##evui." + valueType + "##"); //salting the hash so we don't get collisions between strings and values converted to strings
                case "symbol":
                    var cached = EVUI.Modules.Diff.SymbolCache[value]; //because symbols with the same description are not the same, we just hash a GUID to identify the symbol with so it keeps its uniqueness
                    if (cached == null)
                    {
                        cached = EVUI.Modules.Core.Utils.getHashCode(EVUI.Modules.Core.Utils.makeGuid());
                        EVUI.Modules.Diff.SymbolCache[value] = cached;
                    }

                    return cached;
                case "object":
                    return getObjectHashCode(session, value);
                default:
                    return "";
            }
        }
    }

    /**Gets the hash code of an object based on its properties hash codes and the hash codes of its children. Note that collisions are much more likely in graphs with circular references due to the "chicken and egg" problem of getting its hash based on its own hash when referenced in a circular loop.
    @param {CompareSession} session Data about the compare operation in progress.
    @param {Object} obj An object to get the hash code of.
    @returns {String} */
    var getObjectHashCode = function (session, obj)
    {
        var curHashEntry = getExistingObjectHashCode(session, obj);

        //make a hash entry if we don't have one already and add it to the registry 
        if (curHashEntry == null)
        {
            curHashEntry = new ObjectHashCode();
            curHashEntry.obj = obj;

            session.objectHashCodes.push(curHashEntry);
        }
        else
        {
            if (curHashEntry.hash != null)
            {
                return curHashEntry.hash;
            }
        }

        //add the current object to the "parentage" of the current hash operation. This is to detect circular references
        session.objectParentage.push(obj);

        var preHash = "##evui.object##@"; //salting the hash
        var keys = EVUI.Modules.Core.Utils.getProperties(obj);
        var numKeys = keys.length;

        for (var x = 0; x < numKeys; x++) //for (var prop in obj)
        {
            var prop = keys[x];
            var value = obj[prop];

            //filter out any properties that should NOT be included in the final graph
            if (shouldInclude(session, prop, value, null, typeof value, null, true) === false) continue;

            preHash += "##evui.prop##" + prop + ":\"" //yet more salt

            var hash = null;

            if (session.objectParentage.indexOf(value) !== -1) //this is where collisions can come from. Basically, if we hit this block it means we're in a circular loop and we need to make a hash for the object that is not based on its value.
            {
                var existingRef = getExistingObjectHashCode(session, value);
                if (existingRef != null && existingRef.hash != null)
                {
                    hash = existingRef.hash;
                }
                else
                {                   
                    if (session.compareResult.options.compareValuesOnly === true) //if we're only comparing values, we just substitute the same "object" reference for a circular reference 
                    {
                        hash = EVUI.Modules.Core.Utils.getHashCode("##evui.circular##{}");
                    }
                    else
                    {
                        hash = EVUI.Modules.Core.Utils.getHashCode("##evui.circular##" + Object.prototype.toString.call(value) + value.constructor.toString()); //the safest thing we can do here is salt the constructor's text combined with its prototype's name so that we get a unique hash code for the "type" of object
                    }    
                }
            }
            else //otherwise, get the hash code of the child object
            {
                hash = getHashCode(session, value);
            }

            preHash += hash + "\"";
        }

        //finally, get the hash of all the hashes
        var finalHash = EVUI.Modules.Core.Utils.getHashCode(preHash);
        curHashEntry.hash = finalHash;

        //remove the object from the parentage list
        session.objectParentage.pop();

        return finalHash;
    };

    /**Searches the existing list of hash code object pairs to find an object who has already had their hash code calculated.
    @param {CompareSession} session Data about the compare operation in progress.
    @param {Object} obj The object to find the hash code of.  
    @returns {ObjectHashCode}*/
    var getExistingObjectHashCode = function (session, obj)
    {
        var numObjHash = session.objectHashCodes.length; //then check the global registry of hash codes for this session to see if it was already hashed (mostly for use when in a deep graph or when getting a hash code but not as part of a comparison operation)
        for (var x = 0; x < numObjHash; x++)
        {
            var curHash = session.objectHashCodes[x];
            if (curHash.obj === obj)
            {
                return curHash;
            }
        }

        return null;
    }
};

/**Object that contains the result of comparing two arbitrary values.
@class*/
EVUI.Modules.Diff.CompareResult = function ()
{
    /**Object. The "root" comparison between the two parameter values.
    @type {EVUI.Modules.Diff.Comparison}*/
    this.rootComparison = null;

    /**Array. All the differences found between the two graphs.
    @type {EVUI.Modules.Diff.Comparison[]}*/
    this.allDifferences = [];

    /**Array. A flat list of every comparison made when comparing the two values.
    @type {EVUI.Modules.Diff.Comparison[]}*/
    this.allComparisons = [];

    /**Array. A flat list of every comparison that was equal when comparing the two values.
    @type {EVUI.Modules.Diff.Comparison[]}*/
    this.allInCommon = [];

    /**The CompareOptions object used to compare the two values.
    @type {EVUI.Modules.Diff.CompareOptions}*/
    this.options = null;
};

/**Gets all the Comparisons where one (or both) of the two compared values matches the hash code provided as the parameter. Note that this hash code must be made using the same CompareOptions as the ComparisonResult in order for the hashes to match for objects.
@param {String} hash The equality value hash used to find comparisons with the matching value.
@returns {EVUI.Modules.Diff.CompareMatch[]}*/
EVUI.Modules.Diff.CompareResult.prototype.getAllValueMatches = function (hash)
{
    if (typeof hash !== "number") throw Error("Number expected.");

    var matches = [];
    var numComparisons = this.allComparisons.length;
    for (var x = 0; x < numComparisons; x++)
    {
        var curComparison = this.allComparisons[x];
        var matchingComparison = null;
        var matchingObject = null;
        if (curComparison.getAHashCode() === hash)
        {
            matchingComparison = curComparison;
            matchingObject = curComparison.a;
        }
        else if (curComparison.getBHashCode() === hash)
        {
            matchingComparison = curComparison;
            matchingObject = curComparison.b;
        }

        if (matchingComparison != null)
        {
            var match = new EVUI.Modules.Diff.CompareMatch();
            match.comparison = matchingComparison;
            match.matchingObject = matchingObject;
            match.name = matchingComparison.propName;
            match.path = matchingComparison.getPath();
            match.source = hash;

            matches.push(match);
        }
    }

    return matches;
};

/**Gets all the Comparisons where one (or both) of the two compared values matches the object reference provided as the parameter.
@param {String} reference The object reference to find.
@returns {EVUI.Modules.Diff.CompareMatch[]}*/
EVUI.Modules.Diff.CompareResult.prototype.getAllReferenceMatches = function (reference)
{
    if (reference == null || typeof reference !== "object") throw Error("Object expected.");

    var matches = [];
    var numComparisons = this.allComparisons.length;
    for (var x = 0; x < numComparisons; x++)
    {
        var curComparison = this.allComparisons[x];
        var matchingComparison = null;
        if (curComparison.a === reference)
        {
            matchingComparison = curComparison;
        }
        else if (curComparison.b === reference)
        {
            matchingComparison = curComparison;
        }

        if (matchingComparison != null)
        {
            var match = new EVUI.Modules.Diff.CompareMatch();
            match.comparison = matchingComparison;
            match.matchingObject = reference;
            match.name = matchingComparison.propName;
            match.path = matchingComparison.getPath();
            match.source = reference;

            matches.push(match);
        }
    }

    return matches;
};

/**Represents a comparison between two values or objects.
@class*/
EVUI.Modules.Diff.Comparison = function (session)
{
    var _self = this;
    var _session = session;
    var _aHash = null;
    var _bHash = null;
    

    /**Number. The ID of the comparison in the group of related comparisons for an object graph.
    @type {Number}*/
    this.id = -1;

    /**String. The name of the property of the containing objects being compared.
    @type {String}*/
    this.propName = null;

    /**Any. A value being compared.
    @type {Any}*/
    this.a = null;

    /**Any. The other value being compared.
    @type {Any}*/
    this.b = null;

    /**The type of comparison that was made. Must be a value from the DiffType enum.
    @type {String}*/
    this.diffType = EVUI.Modules.Diff.DiffType.None;

    /**Number. Bit flags indicating the type of differences between "a" and "b". Composed of values from the DiffFlags flag set.
    @type {Number}*/
    this.flags = EVUI.Modules.Diff.DiffFlags.None;

    /**Object. The Comparison that contained this Comparison as a childComparison.
    @type {EVUI.Modules.Diff.Comparison}*/
    this.parentComparison = null;

    /**Array. All of the child Comparisons that were made if this comparison was between two objects.
    @type {EVUI.Modules.Diff.Comparison[]}*/
    this.childComparisons = [];

    /**Array. Either an array of Comparisons representing all the differences between two objects, or an array of StringDifferences if the values were both strings.
    @type {EVUI.Modules.Diff.Comparison[]|EVUI.Modules.Diff.StringDifference[]}*/
    this.differences = [];

    /**The value-equality hash code of the "a" object or value. Note that this hash is lazily evaluated and mutating the properties of a will result in an incorrect hash code.
    @returns {Number}*/
    this.getAHashCode = function ()
    {
        if (_aHash != null) return _aHash;
        _aHash = _session.getValueHashCode(_self.a);
        if (_self.a === _self.b) _bHash = _aHash;
        return _aHash;
    };

    /**Gets he value-equality hash code of the "b" object or value. Note that this hash is lazily evaluated and mutating the properties of b will result in an incorrect hash code.
    @returns {Number}*/
    this.getBHashCode = function ()
    {
        if (_bHash != null) return _bHash;
        _bHash = _session.getValueHashCode(_self.b);
        if (_self.a === _self.b) _aHash = _bHash;
        return _bHash;
    };
};



/**Object representing a match in a ComparisonResult based on reference or hash code.
@class*/
EVUI.Modules.Diff.CompareMatch = function ()
{
    /**Object or String. Either the object to find references of or the hash code of the values to find.
    @type {Object|String}*/
    this.source = null;

    /**Any. Any objects or values that either have the same reference as the source or the same hash code as the source.
    @type {Any}*/
    this.matchingObject = null;

    /**String. The "path" from the root object to the matching value in an object graph. Note that for circular references this may be incorrect or truncated.
    @type {String}*/
    this.path = null;

    /**String. The  name of the property with the matching reference or value.
    @type {String}*/
    this.name = null;

    /**Object. The comparison that contains the matching object or hash code.
    @type {EVUI.Modules.Diff.Comparison}*/
    this.comparison = null;
};

/**Gets the "path" from the root object to the comparison's property. Note that for objects with circular references this value may be incorrect.
@returns {String}*/
EVUI.Modules.Diff.Comparison.prototype.getPath = function ()
{
    if (this.propName == null) return null;

    var path = this.propName;
    var parent = this.parentComparison;

    while (parent != null && parent.propName != null)
    {
        path = parent.propName + "." + path;
        parent = parent.parentComparison;
    }

    return path;
};

/**Object that contains the result of a comparison between two segments of different strings.
@class*/
EVUI.Modules.Diff.StringDifference = function ()
{
    /**Number. The index of the difference in the A string. If the text is a commonality, both aIndex and bIndex will be populated.
    @type {Number}*/
    this.aIndex = -1;

    /**Number. The index of the difference in the B string. If the text is a commonality, both aIndex and bIndex will be populated.
    @type {Number}*/
    this.bIndex = -1;

    /**String. The text that was in either or both strings.
    @type {String}*/
    this.text = null;

    /**Number. Flags indicating which string owned the text. Must be a value from the DiffFlags enum.
    @type {Number}*/
    this.flags = EVUI.Modules.Diff.DiffFlags.None;
};


/**The result of doing a top-level string comparison explicitly and not using the generic comparison function.
@class*/
EVUI.Modules.Diff.StringCompareResult = function ()
{
    /**String. The A string.
    @type {String}*/
    this.a = null;

    /**String. The B string.
    @type {String}*/
    this.b = null;

    /**Object. Options for controlling various aspects about the comparison.
    @type {EVUI.Modules.Diff.CompareOptions}*/
    this.options = null;

    /**Array. An array of text spans that were found to belong to either or both strings in order of occurrence.
    @type {EVUI.Modules.Diff.StringDifference[]}*/
    this.stringDiffs = [];
};

/**Enum indicating that, when merging two objects or strings together based on their differences, which value or object should "win" when there is a direct conflict between the two.
@enum*/
EVUI.Modules.Diff.MergeWinner =
{
    /**Indicates that the "A" object should win in the event of a conflict.*/
    A: "a",
    /**Indicates that the "B" object should win in the event of a conflict.*/
    B: "b"
};
Object.freeze(EVUI.Modules.Diff.MergeWinner);

/**Enum indicating what type of Comparison a Comparison object is.
@enum*/
EVUI.Modules.Diff.DiffType =
{
    /**Default.*/
    None: "none",
    /**Comparison was a string comparison and the differences array will be an array of StringDifference.*/
    String: "string",
    /**Comparison was an object comparison and the differences array will be an array of Comparisons.*/
    Object: "object",
    /**Comparison was of a primitive value and will have no differences in the differences array.*/
    Property: "prop"
};
Object.freeze(EVUI.Modules.Diff.DiffType);

/**Flag set for communicating all the ways in which two Comparisons differ.
@enum*/
EVUI.Modules.Diff.DiffFlags =
{
    /**No differences, the values are the same.*/
    None: 0,
    /**The difference included a different object reference.*/
    Reference: 1,
    /**The difference included a difference in value.*/
    Value: 2,
    /**The difference involved comparing A's value against a property key that did not exist in B.*/
    AOnly: 4,
    /**The difference involved comparing B's value against a property key that did not exist in A.*/
    BOnly: 8,
    /**The difference involved a difference in this object's children (or grandchildren, etc).*/
    Children: 16,
    /**The difference involved a difference in prototype between two values or objects.*/
    Prototype: 32
};
Object.freeze(EVUI.Modules.Diff.DiffFlags);

/**Options for controlling the behavior of the comparison.
@class*/
EVUI.Modules.Diff.CompareOptions = function ()
{
    /**Boolean. Whether or not to exclude functions from the comparison. True by default.
    @type {Boolean}*/
    this.excludeFunctions = true;

    /**Boolean. Whether or not to compare values and objects based on their values only and ignore differences in object references. Useful for comparing two different object graphs that are very similar but have totally different object references. Flase by default.
    @type {Boolean}*/
    this.compareValuesOnly = false;

    /**Array. An array of functions to determine if an object should be compared or not. Return false to not compare the object. Note that this may have a detrimental performance impact on the comparison or hash operation, increases the chance of hash code collisions, and can crash the comparison or hash code generation outright. Use with caution.
    @type {EVUI.Modules.Diff.Constants.Fn_ShouldComparePredicate[]}*/
    this.exclusionFilters = null;

    /**Boolean. Whether or not to generate an array of difference metadata about the differences between strings.
    @type {Boolean}*/
    this.diffStrings = false;

    /**Object. Settings for performing diffs on strings.
    @type {EVUI.Modules.Diff.StringDiffOptions}*/
    this.stringCompareOptions = null;
};

EVUI.Modules.Diff.StringCompareOptions = function ()
{
    this.mode = EVUI.Modules.Diff.StringDiffMode.Character;
    this.whitespaceWordBreaks = true;
    this.wordBreaks = [];
};

EVUI.Modules.Diff.StringDiffMode =
{
    Character: "character",
    Word: "word"
};
Object.freeze(EVUI.Modules.Diff.StringDiffMode);

/**Global instance of the DiffController.
@type {EVUI.Modules.Diff.DiffController}*/
EVUI.Modules.Diff.Comparer = null;
(function ()
{
    var diff = null;
    Object.defineProperty(EVUI.Modules.Diff, "Comparer", {
        get: function ()
        {
            if (diff == null) diff = new EVUI.Modules.Diff.DiffController();
            return diff;
        },
        enumerable: true,
        configurable: false
    })
})();

/**Performs a deep compare on two objects and returns data on what is different and the same between the two values.
@param {Any} a A value to compare.
@param {Any} b A value to compare.
@param {EVUI.Modules.Diff.CompareOptions} options Options for controlling various aspects of the comparison.
@returns {EVUI.Modules.Diff.CompareResult}*/
$evui.diff = function (a, b, options)
{
    return EVUI.Modules.Diff.Comparer.compare(a, b, options);
};

/**Performs a string compare on two string and returns data on what is different and the same between the two strings.
@param {Any} a A string to compare.
@param {Any} b A string to compare.
@returns {EVUI.Modules.Diff.StringCompareResult}*/
$evui.strDiff = function (a, b)
{
    return EVUI.Modules.Diff.Comparer.compareStrings(a, b);
};

/**Gets a value equality hash code of an arbitrary value or object. The hash code is calculated based on the value or values of the object (and its children) and can be used for value equality comparisons. Note that circular object graphs have a much higher chance of hash collisions than non-circular ones.
@param {Any} value The value to get the value equality hash code of.
@param {EVUI.Modules.Diff.CompareOptions} options Options for controlling various aspects of the hash generation.
@returns {String}*/
$evui.getValueHashCode = function (value, options)
{
    return EVUI.Modules.Diff.Comparer.getValueHashCode(value, options);
};

/*#ENDWRAP(Diff)#*/


/********************************************************Dom.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.Dom|Dom)#*/
/*#REPLACE(EVUI.Modules.Dom|Dom)#*/

/**Module for containing a DOM helper utility for simple DOM manipulation.
@module*/
EVUI.Modules.Dom = {};

/*#MODULEDEF(Dom|"1.0";|"DomHelper")#*/
/*#VERSIONCHECK(EVUI.Modules.Dom|Dom)#*/;

EVUI.Modules.Dom.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
    DomTree: Object.freeze({ version: "1.0", required: false})
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.Dom.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();

Object.freeze(EVUI.Modules.Dom.Dependencies);

/**Constants table for variables related to getting references to UI controls.*/
EVUI.Modules.Dom.Constants = {};

EVUI.Modules.Dom.Constants.PreviousDisplayState = "evuiDisplayState";

/**A function that handles a generic browser event.
@param {Event} browserEvent The browser's Event object, which will be different depending on the type of event that was raised.*/
EVUI.Modules.Dom.Constants.Fn_BrowserEventHandler = function (browserEvent) { };

Object.freeze(EVUI.Modules.Dom.Constants);

/**Utility for lazily getting a reference to a HTMLElement that exists in the DOM by its ID.
@class
@param {String} id The ID of an element to find (without the #).
@param {Object} attributes Any special metadata about the control to associate with it. */
EVUI.Modules.Dom.ControlInfo = function (id, attributes)
{
    if (EVUI.Modules.Dom.Dependencies.checked !== true)
    {
        if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
        EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Dom.Dependencies);
    }

    if (typeof id !== "string") throw Error("ID must be a string.");

    var _id = id;

    /**@type {HTMLElement} */
    var _control = null;
    var _helper = null;

    /**String. The HTML ID of the element being wrapped by the ControlInfo.
    @type {String}*/
    this.id = null;
    Object.defineProperty(this, "id",
        {
            get: function () { return _id; },
            configurable: false,
            enumerable: true
        });

    /**Object. An Element with the given id.
    @type {HTMLElement}*/
    this.control = null;
    Object.defineProperty(this, "control",
        {
            get: function ()
            {
                return _control;
            },
            configurable: false,
            enumerable: true
        });

    /**A special property bag for containing any additional metadata about the control.
    @type {Object}*/
    this.attributes = (attributes == null) ? {} : attributes;

    /**Queries the DOM and gets a reference to the HTML Element with the given ID. If the DOM has already been queried, the query is skipped and the previously returned value is returned instead.
    @param {any} reQuery Whether or not to ignore the previously searched result and to force a new query for the Element.
    @returns {HTMLElement}*/
    this.getControl = function (reQuery)
    {
        if (reQuery !== true && _control != null) return _control;

        if (EVUI.Modules.Core.Utils.stringStartsWith("#", _id) === true)
        {
            _control = document.getElementById(_id.substring(1));
        }
        else
        {
            _control = document.getElementById(_id);
        }

        return _control;
    };

    /**Queries the DOM and gets a reference to the HTML Element with the given ID. If the DOM has already been queried, the query is skipped and the previously returned value is returned instead.
    @param {any} reQuery Whether or not to ignore the previously searched result and to force a new query for the Element.
    @returns {EVUI.Modules.Dom.DomHelper}*/
    this.getHelper = function (reQuery)
    {
        if (reQuery !== true && _helper != null) return _helper;

        var control = this.getControl(reQuery);
        if (control == null) return null;

        _helper = new EVUI.Modules.Dom.DomHelper(control);
        return _helper;
    };
};

/**Utility object for common DOM manipulation.
@param {HTMLElement|HTMLElement[]|String|JQuery} elementsOrCssSelector Either an array of HTMLElements, a single HTMLElement, a jQuery object, a CSS selector, or a string of HTML.
@param {HTMLElement|JQuery} context A context node used to limit the scope of the search.
@class*/
EVUI.Modules.Dom.DomHelper = function ()
{
    var _domMetadataPropName = null;

    /** Utility object for common DOM manipulation.
    @param {HTMLElement|HTMLElement[]|String|JQuery} elementsOrCssSelector Either an array of HTMLElements, a single HTMLElement, a jQuery object, a CSS selector, or a string of HTML.
    @param {HTMLElement|JQuery} context A context node used to limit the scope of the search. */
    var DomHelper = function (elementsOrCssSelector, context)
    {
        if (EVUI.Modules.Dom.Dependencies.checked !== true)
        {
            if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
            EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Dom.Dependencies);
        }

        /**The Elements contained within the DomHelper.
        @type {Node[]}*/
        this.elements = Object.freeze(processElements(elementsOrCssSelector, context));
    };

    /**Contains details about the state of a DOM node.
    @class*/
    var DomMetadata = function ()
    {
        /**String. The previous display property on a DOM node. Used to restore its original display property upon being un-hidden.
        @type {String}*/
        this.previousDisplayState = null;

        /**Boolean. Whether or not the previous display state was inlined on the element and not part of a class.
        @type {Boolean}*/
        this.displayStateWasInlined = false;
    };

    /**Gets a DomMetadata object from a Node.
    @param {Element} element The element to get the metadata from.
    @returns {DomMetadata}*/
    var getDomMetadata = function (element)
    {
        if (_domMetadataPropName == null) _domMetadataPropName = EVUI.Modules.Core.Utils.getHashCode("@BTMDom:" + EVUI.Modules.Core.Utils.makeGuid()).toString(36);

        var metadata = element[_domMetadataPropName];
        if (metadata == null)
        {
            metadata = new DomMetadata();
            element[_domMetadataPropName] = metadata;
        }

        return metadata;
    };

    /**Function definition for iterating over a collection of elements.
     @param {Element} element The element to iterate over.*/
    var Fn_Element_Apply = function (element) { };

    /**Runs a function over an array of Elements.
    @param {Element[]} elements The elements to pass into the function.
    @param {Fn_Element_Apply} fn The function modifying the elements.*/
    var applyToAll = function (elements, fn)
    {
        if (elements == null) return;

        var numElements = elements.length;
        for (var x = 0; x < numElements; x++)
        {
            var ele = elements[x];
            if (ele == null) continue;

            fn(ele);
        }
    };

    /**Returns the first element in the DomHelper's elements array.
    @returns {Element}*/
    DomHelper.prototype.first = function ()
    {
        return this.elements[0];
    }

    /**Hides all the Elements in the DomHelper by setting their style's display property to "none".
    @returns {EVUI.Modules.Dom.DomHelper}*/
    DomHelper.prototype.hide = function ()
    {
        applyToAll(this.elements, function (element)
        {
            var nodeType = element.nodeType;
            if (nodeType !== Node.ELEMENT_NODE) return; //hiding only applies to elements

            var meta = getDomMetadata(element);

            var existingDisplayState = null;
            var hadInlinedDisplay = false;

            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(element.style.display) == false) //get the inlined display style
            {
                existingDisplayState = element.style.display;
                hadInlinedDisplay = true;
            }

            if (existingDisplayState === "none") return; //already has an inlined display none on it, nothing to do

            if (existingDisplayState == null) //get the computed display style
            {
                var computedStyle = getComputedStyle(element);
                existingDisplayState = computedStyle.display;
                hadInlinedDisplay = false;
            }

            //remember the last display state so it can be restored when we show the element again
            meta.displayStateWasInlined = hadInlinedDisplay;
            meta.previousDisplayState = existingDisplayState;

            element.style.display = "none";
        });

        return this;
    };

    /**Shows all the Elements in the DomHelper by either restoring their previous display value or setting their style's display value to "inline-block".
    @returns {EVUI.Modules.Dom.DomHelper}*/
    DomHelper.prototype.show = function ()
    {
        applyToAll(this.elements, function (element)
        {
            var nodeType = element.nodeType;
            if (nodeType !== Node.ELEMENT_NODE) return; //hiding only applies to elements

            var meta = getDomMetadata(element);

            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(meta.previousDisplayState) === false)
            {
                if (meta.displayStateWasInlined === false) //part of the class - just remove the inlined display:none
                {
                    element.style.display = null;
                }
                else
                {
                    element.style.display = meta.previousDisplayState;
                }
            }
            else //had no display state, default to inline-block.
            {
                element.style.display = "inline-block";
            }

            meta.previousDisplayState = null;
            meta.displayStateWasInlined = false;
        });

        return this;
    };

    /**Gets the outerHeight of the first element in the elements array.
    @param {Boolean} includeMargin Whether or not to include the margin for calculating the outerHeight of the element.
    @returns {Numnber}*/
    DomHelper.prototype.outerHeight = function (includeMargin)
    {
        if (this.elements == null) return 0;
        if (this.elements.length > 0)
        {
            return outerHeight(this.elements[0], includeMargin)
        }
        else
        {
            return 0;
        }
    };

    /**Gets the outerWidth of the first element in the elements array.
    @param {Boolean} includeMargin Whether or not to include the margin for calculating the outerWidth of the element.
    @returns {Number}*/
    DomHelper.prototype.outerWidth = function (includeMargin)
    {
        if (this.elements == null) return 0;
        if (this.elements.length > 0)
        {
            return outerWidth(this.elements[0], includeMargin)
        }
        else
        {
            return 0;
        }
    };

    /**Appends content to the elements referenced by the DomHelper. Returns a new DomHelper with the new content.
    @param {String|Element} htmlOrElement Either a string of HTML or an Element to append to each element in the DomHelper.
    @returns {EVUI.Modules.Dom.DomHelper}*/
    DomHelper.prototype.append = function (htmlOrElement)
    {
        return injectHtml(this.elements, htmlOrElement, "append");
    };

    /**Prepends content to the elements referenced by the DomHelper. Returns a new DomHelper with the new content.
    @param {String|Element} htmlOrElement Either a string of HTML or an Element to prepend to each element in the DomHelper.
    @returns {EVUI.Modules.Dom.DomHelper}*/
    DomHelper.prototype.prepend = function (htmlOrElement)
    {
        return injectHtml(this.elements, htmlOrElement, "prepend");
    };

    /**Appends content to the elements referenced by the DomHelper. Returns a new DomHelper with the new content.
    @param {String|Element} htmlOrElement Either a string of HTML or an Element to insert before each element in the DomHelper.
    @returns {EVUI.Modules.Dom.DomHelper}*/
    DomHelper.prototype.insertBefore = function (htmlOrElement)
    {
        return injectHtml(this.elements, htmlOrElement, "before");
    };

    /**Appends content to the elements referenced by the DomHelper. Returns a new DomHelper with the new content.
    @param {String|Element} htmlOrElement Either a string of HTML or an Element to inserrt after each element in the DomHelper.
    @returns {EVUI.Modules.Dom.DomHelper}*/
    DomHelper.prototype.insertAfter = function (htmlOrElement)
    {
        return injectHtml(this.elements, htmlOrElement, "after");
    };

    /**Removes all the elements referenced by the DomHelper.
    @returns {EVUI.Modules.Dom.DomHelper}*/
    DomHelper.prototype.remove = function ()
    {
        applyToAll(this.elements, function (element)
        {
            if (element.nodeType === Node.TEXT_NODE || element.nodeType === Node.ELEMENT_NODE)
            {
                element.remove();
            }
        });

        return this;
    };

    /**Removes all child nodes from the elememnts references by the DomHelper.
    @returns {EVUI.Modules.Dom.DomHelper}*/
    DomHelper.prototype.empty = function ()
    {
        applyToAll(this.elements, function (element)
        {
            if (element.childNodes != null)
            {
                var node = element.childNodes[0];
                while (node != null)
                {
                    node.remove();
                    node = element.childNodes[0];
                }
            }

            if (element.textContent !== undefined) element.textContent = null;
        });

        return this;
    };

    /**Replaces all the content referenced by the DomHelper with the provided content.
    @param {String|Element} htmlOrElement Either a string of HTML, or an Element to replace the elements referenced by the DomHelper with.
    @returns {EVUI.Modules.Dom.DomHelper}*/
    DomHelper.prototype.replace = function (htmlOrElement)
    {
        var newContent = [];

        applyToAll(this.elements, function (element)
        {
            if (element.nodeType !== Node.ELEMENT_NODE && element.nodeType !== Node.TEXT_NODE) return;

            var htmlContent = ambiguousContentToHtmlArray(htmlOrElement);
            var frag = document.createDocumentFragment();

            var numContent = htmlContent.length;
            for (var x = 0; x < numContent; x++)
            {
                var content = htmlContent[x];

                frag.append(content);
                newContent.push(content);
            }

            element.replaceWith(frag);
        });

        return new EVUI.Modules.Dom.DomHelper(newContent);
    };

    /**Gets the offset of the first element in the elements array relative to its position in the window.
    @returns {EVUI.Modules.Dom.ElementBounds}*/
    DomHelper.prototype.offset = function ()
    {
        var offset = new EVUI.Modules.Dom.ElementBounds();

        if (this.elements == null || this.elements.length === 0) return offset;

        var element = this.elements[0];

        if (element === window)
        {
            offset.top = window.scrollY;
            offset.left = window.scrollX;
            offset.bottom = window.scrollY + this.outerHeight();
            offset.right = window.scrollX + this.outerWidth();

            return offset;
        }

        if (element instanceof DocumentFragment) return offset;

        var inlinedDisplay = element.style.display;
        element.style.display = "inline-block"; //this fixes issues with elements with no measurements on them not reflecting their children's dimensions

        var bounds = element.getBoundingClientRect()

        offset.left = bounds.left + window.scrollX;
        offset.top = bounds.top + window.scrollY;
        offset.right = offset.left + bounds.width
        offset.bottom = offset.top + bounds.height;

        element.style.display = inlinedDisplay;

        return offset;
    };

    /**Gets or sets an attribute value on the elements referenced by the DomHelper. Removes the attribute if the value is null, otherwise it returns the first element's attribute value.
    @param {String} key The name of the attribute to get or set.
    @param {String} value The value to set the attribute to.
    @returns {String|EVUI.Modules.Dom.DomHelper}*/
    DomHelper.prototype.attr = function (key, value)
    {
        if (this.elements == null || EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(key) === true) return;

        if (value === undefined)
        {
            return (this.elements.length === 0) ? null : this.elements[0].getAttribute(key);
        }

        applyToAll(this.elements, function (element)
        {
            if (element.nodeType === Node.ELEMENT_NODE)
            {
                if (value === null)
                {
                    element.removeAttribute(key);
                }
                else
                {
                    element.setAttribute(key, value.toString());
                }
            }
        });

        return this;
    };

    /**Adds a class to every element referenced by the DomHelper.
    @param {String|String[]} cssClass Either a single CSS class name, a string of space-separated CSS class names, or an array of CSS class names.
    @returns {EVUI.Modules.Dom.DomHelper} */
    DomHelper.prototype.addClass = function (cssClass)
    {
        classOp(this.elements, cssClass, "add");
        return this;
    };

    /**Removes a class from every element referenced by the DomHelper.
    @param {String|String[]} cssClass Either a single CSS class name, a string of space-separated CSS class names, or an array of CSS class names.
    @returns {EVUI.Modules.Dom.DomHelper} */
    DomHelper.prototype.removeClass = function (cssClass)
    {
        classOp(this.elements, cssClass, "remove");
        return this;
    };

    /**Adds a class to every element referenced by the DomHelper.
    @param {String|String[]} cssClass Either a single CSS class name, a string of space-separated CSS class names, or an array of CSS class names.
    @param {Boolean} force If true, forces the class to be added to the element. If false, forces the class to be removed from the element.
    @returns {EVUI.Modules.Dom.DomHelper} */
    DomHelper.prototype.toggleClass = function (cssClass, force)
    {
        classOp(this.elements, cssClass, "toggle", force);
        return this;
    };

    /**Returns whether or not ANY of the elements referenced by the DomHelper have the given CSS class. If inclusive is set to true, this returns whether or not ALL elements have the given class.
    @param {Strign} cssClass The CSS class to test for the presence of.
    @param {any} inclusive If set to true, ensures that all elements referenced by the DomHelper have the given CSS class.
    @returns {Boolean}*/
    DomHelper.prototype.hasClass = function (cssClass, inclusive)
    {
        if (typeof cssClass !== "string" || this.elements == null) return false;

        var found = false;
        var numEles = this.elements.length;
        for (var x = 0; x < numEles; x++)
        {
            var curEle = this.elements[x];
            if (curEle.nodeType !== Node.ELEMENT_NODE) continue;

            var hasClass = curEle.classList.contains(cssClass);
            if (inclusive === true && hasClass === false) return false;
            if (hasClass === true)
            {
                found = true;
                if (inclusive !== true) break;
            }
        }

        return found;
    };

    /**Sets the innerText of all elements referenced by the DomHelper.
    @param {String} text The value to set the inner text to.
    @returns {EVUI.Modules.Dom.DomHelper} */
    DomHelper.prototype.text = function (text)
    {
        applyToAll(this.elements, function (element)
        {
            if (element.innerText === undefined) return;
           
            element.innerText = text;
        });

        return this;
    };

    /**Adds an event listener to each matched element with the given handler for the provided events.
    @param {String|String[]} event Either a single event name, or an array of event names, or a space delineated string of event names to add.
    @param {EVUI.Modules.Dom.Constants.Fn_BrowserEventHandler} handler The event handling function to listen for the events. */
    DomHelper.prototype.on = function (event, handler)
    {
        if (event == null || typeof handler !== "function" || this.elements == null) return;

        if (typeof event === "string") event = event.split(/\s+/);
        if (EVUI.Modules.Core.Utils.isArray(event) === false) event = [event];
        var numEvents = event.length;

        if (numEvents == 0) return;

        applyToAll(this.elements, function (element)
        {
            if (element instanceof DocumentFragment === true) return;
            for (var x = 0; x < numEvents; x++)
            {
                var curEvent = event[x];
                if (typeof curEvent !== "string") continue;

                element.addEventListener(curEvent, handler);
            }
        });
    };

    /**Removes an event listener from each matched element with the given handler for the provided events. Requires that both the name and the handling function reference match those that were originally added to the element.
    @param {String|String[]} event Either a single event name, or an array of event names, or a space delineated string of event names to remove.
    @param {EVUI.Modules.Dom.Constants.Fn_BrowserEventHandler} handler The event handling function to remove from the elements's event listeners. */
    DomHelper.prototype.off = function (event, handler)
    {
        if (event == null || typeof handler !== "function" || this.elements == null) return;

        if (typeof event === "string") event = event.split(/\s+/);
        if (EVUI.Modules.Core.Utils.isArray(event) === false) event = [event];
        var numEvents = event.length;

        if (numEvents == 0) return;

        applyToAll(this.elements, function (element)
        {
            if (element instanceof DocumentFragment) return;
            for (var x = 0; x < numEvents; x++)
            {
                var curEvent = event[x];
                if (typeof curEvent !== "string") continue;

                element.removeEventListener(curEvent, handler);
            }
        });
    };

    /**Either gets the value of the first element referenced by the DomHelper or sets the value of the first element referenced by the DomHelper.
    @param {Any} value The value to set. If omitted, returns the value instead.
    @returns {Any|EVUI.Modules.Dom.DomHelper} */
    DomHelper.prototype.val = function (value)
    {
        if (this.elements.length === 0) return;
        if (typeof value !== "undefined")
        {
            this.elements[0].value = value;
            return this;
        }
        else
        {
            return this.elements[0].value;
        }
    };

    /**Performs an operation on the set of elements pertaining to a CSS class.
    @param {Element[]} elements The elements that are the target of the class operation.
    @param {String|String[]} cssClasses The CSS classes that are the subject of the operation.
    @param {String} op The operation to perform. Can be one of the following: add, remove, or toggle.
    @param {Boolean} force In a "toggle" conext, and is true, forces the class to be added to the element. If false, forces the class to be removed from the element.*/
    var classOp = function (elements, cssClasses, op, force)
    {
        if (cssClasses == null || elements == null) return;

        if (typeof cssClasses === "string") cssClasses = cssClasses.split(/\s+/);
        if (EVUI.Modules.Core.Utils.isArray(cssClasses) === false) cssClasses = [cssClasses];
        var numClasses = cssClasses.length;

        if (numClasses == 0) return;

        applyToAll(elements, function (element)
        {
            if (element.nodeType !== Node.ELEMENT_NODE) return;

            for (var x = 0; x < numClasses; x++)
            {
                var curClass = cssClasses[x];
                if (typeof curClass !== "string") continue;

                switch (op)
                {
                    case "add":
                        element.classList.add(curClass);
                        break;

                    case "remove":
                        element.classList.remove(curClass);
                        break;

                    case "toggle":
                        if (typeof force === "boolean")
                        {
                            element.classList.toggle(curClass, force);
                        }
                        else
                        {
                            element.classList.toggle(curClass);
                        }

                        break;
                }
            }
        });
    }

    /**Gets the outerHeight of an element.
    @param {Element|Document|Window} element The element to get the outer hight of.
    @param {Bololean} includeMargin Whether or not to include the element's margins in the calcuation.
    @returns {Number}*/
    var outerHeight = function (element, includeMargin)
    {
        if (element === window)
        {
            return document.documentElement.clientHeight;
        }
        else if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
        {
            return 0;
        }
        else if (element.nodeType === Node.DOCUMENT_NODE)
        {
            return Math.max(document.documentElement.scrollHeight, document.documentElement.offsetHeight, document.documentElement.clientHeight);
        }
        else
        {
            var style = getComputedStyle(element);
            var rawHeight = parsePx(style.height);
            var borderTop = parsePx(style.borderTop);
            var borderBottom = parsePx(style.borderBottom);
            var border = borderTop + borderBottom;

            var marginTop = parsePx(style.marginTop);
            var marginBottom = parsePx(style.marginBottom);
            var margin = marginTop + marginBottom;

            var height = rawHeight + ((border > 0) ? border : 0);
            if (includeMargin === true && margin > 0) height += margin;

            return height;
        }
    };

    /**Gets the outerWidth of an element.
    @param {Element|Document|Window} element The element to get the outer width of.
    @param {Bololean} includeMargin Whether or not to include the element's margins in the calcuation.
    @returns {Number}*/
    var outerWidth = function (element, includeMargin, style)
    {
        if (element === window)
        {
            return document.documentElement.clientWidth;
        }
        else if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
        {
            return 0;
        }
        else if (element.nodeType === Node.DOCUMENT_NODE)
        {
            return Math.max(document.documentElement.scrollWidth, document.documentElement.offsetWidth, document.documentElement.clientWidth);
        }
        else
        {
            var style = getComputedStyle(element);
            var rawWidth = parsePx(style.width);
            var borderLeft = parsePx(style.borderLeft);
            var borderRight = parsePx(style.borderRight);
            var border = borderLeft + borderRight;

            var marginLeft = parsePx(style.marginLeft);
            var marginRight = parsePx(style.marginRight);
            var margin = marginLeft + marginRight;

            var width = rawWidth + ((border > 0) ? border : 0);
            if (includeMargin === true && margin > 0) width += margin;

            return width;
        }
    };

    /**Takes a value in pixels (i.e. "5px") and turns it into a number.
    @param {String} pxValue The value as a string in pixels.
    @returns {Number} */
    var parsePx = function (pxValue)
    {
        var pxIndex = pxValue.indexOf("px");
        if (pxIndex > 0) pxValue = pxValue.substring(0, pxIndex);

        var value = parseFloat(pxValue);

        if (isNaN(value) === true) return 0;
        return value;
    };

    /**Takes a string of HTML and turns it into an array of nodes.
    @param {String} html The HTML to turn into Nodes.
    @returns {Node[]} */
    var htmlToElements = function (html)
    {
        if (EVUI.Modules.DomTree != null)
        {
            var frag = EVUI.Modules.DomTree.Converter.htmlToDocumentFragment(html);
            if (frag == null) return [];

            var eles = [];
            var numEles = frag.childNodes.length;
            for (var x = 0; x < numEles; x++)
            {
                eles.push(frag.childNodes[x]);
            }

            return eles;
        }

        var docFrag = document.createDocumentFragment();
        var element = document.createElement("div");
        element.innerHTML = html;

        var elements = [];
        var numChildren = element.childNodes.length;
        for (var x = 0; x < numChildren; x++)
        {
            var curEle = element.childNodes[0];
            docFrag.appendChild(curEle);
            elements.push(curEle);
        }

        return elements;
    };

    /**Turns ambiguous content into an array of Elements.
    @param {Any} htmlOrElement Can be any valid form of HTML string, document, window, node list, jQuery, DomHelper.
    @returns {HTMLElement[]}*/
    var ambiguousContentToHtmlArray = function (htmlOrElement)
    {
        var content = null;

        if (EVUI.Modules.Core.Utils.isElement(htmlOrElement) === true)
        {
            content = [htmlOrElement];
        }
        else if (htmlOrElement instanceof Document || htmlOrElement === window)
        {
            content = [htmlOrElement];
        }
        else if (htmlOrElement instanceof DocumentFragment)
        {
            content = [htmlOrElement];
        }
        else if (typeof htmlOrElement === "string")
        {
            content = htmlToElements(htmlOrElement);
        }
        else if (EVUI.Modules.Core.Utils.isjQuery(htmlOrElement) === true)
        {
            var jqEles = htmlOrElement;
            content = [];

            jqEles.each(function (index, element) { content.push(element) });
        }
        else if (htmlOrElement instanceof NodeList)
        {
            content = [];
            var numContent = htmlOrElement.length;
            for (var x = 0; x < numContent; x++)
            {
                content.push(htmlOrElement[x]);
            }
        }
        else if (EVUI.Modules.Core.Utils.isArray(htmlOrElement) === true)
        {
            content = [];
            var numEles = htmlOrElement.length;
            for (var x = 0; x < numEles; x++)
            {
                var item = htmlOrElement[x];
                if (EVUI.Modules.Core.Utils.isElement(item) || item instanceof DocumentFragment || item instanceof Document || item === window) content.push(item)
            }
        }
        else if (EVUI.Modules.Core.Utils.isDomHelper(htmlOrElement) === true)
        {
            content = htmlOrElement.elements.slice();
        }

        return content;
    };

    /**Injects HTML into the DOM and returns a DomHelper with the new content. 
     * @param {Element[]} elements The elements to have HTML content added to or around them.
     * @param {String|Element} htmlOrElement The conent to add to or around the elements.
     * @param {String} action The action to perform. Can be one of: "append", "prepend", "after", or "before".
     */
    var injectHtml = function (elements, htmlOrElement, action) 
    {
        var newContent = [];

        applyToAll(elements, function (element)
        {
            if (element === window) return; //cant add DOM nodes to window
            if ((element === document || element instanceof DocumentFragment) && (action === "before" || action === "after")) return; //cant insert before/after a documentFragment because it isn't in the DOM

            //turn whatever the user gave us into an Element array
            var content = ambiguousContentToHtmlArray(htmlOrElement)

            //make a document fragment to stick the nodes into so we can add them to the DOM in one operation.
            var docFrag = document.createDocumentFragment();

            var numContent = content.length;
            for (var x = 0; x < numContent; x++)
            {
                //if we're adding DOM nodes that are already in the DOM, clone them so we don't remove them from their current location.
                var curContent = (EVUI.Modules.Core.Utils.isOrphanedNode(content[x]) === false) ? content[x].cloneNode(true) : content[x];

                if (curContent instanceof DocumentFragment)
                {
                    var numDocFragContent = curContent.childNodes.length;
                    for (var y = 0; y < numDocFragContent; y++)
                    {
                        newContent.push(curContent.childNodes[y]);
                    }

                    docFrag.appendChild(curContent);
                }
                else
                {

                    newContent.push(curContent);
                    docFrag.appendChild(curContent);
                }
            }

            switch (action)
            {
                case "append":
                    element.append(docFrag);
                    break;

                case "prepend":
                    element.prepend(docFrag);
                    break;

                case "before":
                    element.before(docFrag);
                    break;

                case "after":
                    element.after(docFrag);
                    break;

            }
        });

        return new EVUI.Modules.Dom.DomHelper(newContent);
    };

    /**If the CSS selector passed into the DomHelper has a context, this alters the selectors to not include elements outside of the context. 
    @param {String} selectorWithContext A CSS selector that has a context node to search inside of.
    @returns {String} */
    var scopeSelectors = function (selectorWithContext)
    {
        var totalSelector = "";
        var segments = selectorWithContext.split(",");
        var numSegments = segments.length;
        var validSelectors = 0;

        for (var x = 0; x < numSegments; x++)
        {
            var curSeg = segments[x].trim();
            if (curSeg.length === 0) continue;

            if (validSelectors > 0) totalSelector += ", ";
            totalSelector += ":scope " + curSeg;
            validSelectors++;
        }

        return totalSelector;
    };

    /**Processes the input to the DomHelper's constructor and builds the element list with the results.
    @param {any} elementsOrSelector The content to turn into a element array.
    @param {Element|DocumentFragment} context A context to narrow the search by.
    @returns {Element[]} */
    var processElements = function (elementsOrSelector, context)
    {
        if (typeof elementsOrSelector === "string" && EVUI.Modules.Core.Utils.stringStartsWith("<", elementsOrSelector.trim()) === false)
        {
            try //this will fail if we were handed a piece of HTML
            {
                var result = null;

                if (context != null)
                {
                    if (EVUI.Modules.Core.Utils.isElement(context))
                    {
                        result = context.querySelectorAll(scopeSelectors(elementsOrSelector));
                    }
                    else if (context instanceof Document || context instanceof DocumentFragment)
                    {
                        result = context.querySelectorAll(elementsOrSelector);
                    }
                    else if (EVUI.Modules.Core.Utils.isjQuery(context) === true && context.length > 0)
                    {
                        context = context[0];
                        result = context.querySelectorAll(scopeSelectors(elementsOrSelector));
                    }
                    else if (EVUI.Modules.Core.Utils.isDomHelper(context) === true && context.elements.length > 0)
                    {
                        context = context.elements[0];
                        result = context.querySelectorAll(scopeSelectors(elementsOrSelector));
                    }
                    else
                    {
                        throw Error("Invalid context.");
                    }
                }
                else
                {
                    result = document.querySelectorAll(elementsOrSelector);
                }
            }
            catch (ex)
            {
            }

            if (result == null) return [];

            elementsOrSelector = [];
            var numResult = result.length;
            for (var x = 0; x < numResult; x++)
            {
                elementsOrSelector.push(result[x]);
            }
        }
        else
        {
            elementsOrSelector = ambiguousContentToHtmlArray(elementsOrSelector);
        }

        if (elementsOrSelector == null) return [];

        elementsOrSelector = elementsOrSelector.filter(function (ele) { return ele instanceof Node || ele === window || ele === document || ele instanceof DocumentFragment });

        return elementsOrSelector;
    }

    return DomHelper;
}();

/**The current bounds of the element relative to the entire document using the curreent style and the outerWidth and outerHeight functions.
@class*/
EVUI.Modules.Dom.ElementBounds = function ()
{
    /**The top edge of the element.
    @type {Number}*/
    this.top = 0;

    /**The left edge of the element.
    @type {Number}*/
    this.left = 0;

    /**The bottom edge of the element.
    @type {Number}*/
    this.bottom = 0;

    /**The right edge of the element.
    @type {Number}*/
    this.right = 0;
};

/**Gets the ElementBounds relative to the current scrolled position of the window.
@returns {EVUI.Modules.Dom.ElementBounds}*/
EVUI.Modules.Dom.ElementBounds.prototype.toWindowRelativeBounds = function ()
{
    var xOffset = window.pageXOffset;
    var yOffset = window.pageYOffset;

    var newBounds = new EVUI.Modules.Dom.ElementBounds();
    newBounds.top = this.top - yOffset;
    newBounds.bottom = this.bottom - yOffset;
    newBounds.left = this.left - xOffset;
    newBounds.right = this.right - xOffset;

    return newBounds;
};

/**Gets a new instance of a ControlInfo.
@param {String} id The ID of the element the ControlInfo object is wrapping.
@returns {EVUI.Modules.Dom.ControlInfo}*/
$evui.control = function (id, attributes)
{
    return new EVUI.Modules.Dom.ControlInfo(id, attributes);
};

/**Gets a new instance of a DomHelper.
@param {HTMLElement|HTMLElement[]|String|JQuery|EVUI.Modules.Dom.DomHelper} elementsOrCssSelector Either an array of HTMLElements, a single HTMLElement, a jQuery object, a CSS selector, another DomHelper, or a string of HTML.
@param {HTMLElement|JQuery} context A context node used to limit the scope of the search.
@returns {EVUI.Modules.Dom.DomHelper} */
$evui.dom = function (elementsOrCssSelector, context)
{
    return new EVUI.Modules.Dom.DomHelper(elementsOrCssSelector, context);
};

/*#ENDWRAP(Dom)#*/


/********************************************************DomEvents.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/
/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.DomEvents|DomEvents)#*/
/*#REPLACE(EVUI.Modules.DomEvents|DomEvents)#*/

/**Module for adding event listeners to EventTargets that are designed to more gracefully handle multiple async-function listeners that go in sequence instead of racing each other.
@module*/
EVUI.Modules.DomEvents = {};

/*#MODULEDEF(DomEvents|"1.0"|"DomEvents")#*/
/*#VERSIONCHECK(EVUI.Modules.DomEvents|DomEvents)#*/

EVUI.Modules.DomEvents.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
    EventStream: Object.freeze({ version: "1.0", required: true }),
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.DomEvents.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();

Object.freeze(EVUI.Modules.DomEvents.Dependencies);

EVUI.Modules.DomEvents.Constants = {};

/**
 * 
 * @param {EVUI.Modules.DomEvents.AsyncDomEventArgs|Event} asyncEventArgs
 */
EVUI.Modules.DomEvents.Constants.Fn_EventHandler = function (asyncEventArgs) { };

EVUI.Modules.DomEvents.Constants.Prop_EvuiArgsName = "evuiArgs";

Object.freeze(EVUI.Modules.DomEvents.Constants);

/**Manager for manipulating asynchronous functions that are added to EventTargets via add/removeAsyncEventListener.
@class*/
EVUI.Modules.DomEvents.AsyncDomEventManager = (function ()
{
    /**The base36 string that is the property name of the AsyncDomEventer that is attached to EventTargets.
    @type {String}*/
    var _eventerKey = EVUI.Modules.Core.Utils.getHashCode(EVUI.Modules.Core.Utils.makeGuid()).toString(36).replace(".", ""); //a hidden hash value that is used to look up information about objects or nodes that will never occur in a user's code.

    /**The base36 string that is the property name of the AsyncEventMetadata attached to the Event object.
    @type {String}*/
    var _eventKey = EVUI.Modules.Core.Utils.getHashCode(EVUI.Modules.Core.Utils.makeGuid()).toString(36).replace(".", ""); //a hidden hash value that is used to look up information about objects or nodes that will never occur in a user's code.

    /**The base36 string that is the property on an artificial event that carries the callback for a manual async event dispatch.
    @type {String}*/
    var _callbackKey = EVUI.Modules.Core.Utils.getHashCode(EVUI.Modules.Core.Utils.makeGuid()).toString(36).replace(".", ""); //a hidden hash value that is used to look up information about objects or nodes that will never occur in a user's code.

    /**The GUID that is used to salt the generation of sessionID's.
    @type {String}*/
    var _sessionSalt = EVUI.Modules.Core.Utils.makeGuid();

    if (typeof (window.Symbol) !== "undefined")
    {
        _eventerKey = Symbol(_eventerKey);
        _eventKey = Symbol(_eventKey);
        _callbackKey = Symbol(_callbackKey);
    }

    /**Unique ID counter that identifies an event handler that has been bound to an EventTarget.
    @type {Number}*/
    var _handlerId = 0;

    /**Unique ID counter that identifies an EventTarget's AsyncDomEventerHandle.
    @type {Number}*/
    var _targetEventerId = 0;

    /**Unique ID counter that identifies an individual event that was triggered by the browser.
    @type {Number}*/
    var _queuedEventId = 0;

    /**Unique ID counter that identifies a bubbling sequence of events that is shared by all members of a composed path.
    @type {Number}*/
    var _eventSequenceId = 0;

    /**All of the active event sessions that are either executing or queued to be executing.
    @type {{}}*/
    var _sessions = {};

    /**Public-facing handle that is attached to an EventTarget as a property with a random name, used as the doorway into the internals of the AsyncDomEventManager.
    @class*/
    var AsyncDomEventer = function (target)
    {
        if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
        EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.DomEvents.Dependencies);

        var _self = this;
        var _target = target;
        var _handle = new AsyncDomEventerHandle(_self, _target);

        /**Adds an event listener to the stack of managed async event handlers.
        @param {String} type The type of event to listen for.
        @param {EVUI.Modules.DomEvents.Constants.Fn_EventHandler} listener The function that will handle the event.
        @param {EVUI.Modules.DomEvents.EventOptions} options The options to change the behavior of the event handler.*/
        this.addAsyncEventListener = function (type, listener, options)
        {
            if (isValidEventType(type) === false) throw Error("String expected.");
            if (typeof listener !== "function") throw Error("Function expected.");

            addEventListener(_handle, type, listener, options);
        };

        /**Removes an event listener from the stack of managed async event handlers. 
        @param {String} type The type of event that the listener is listening for.
        @param {EVUI.Modules.DomEvents.Constants.Fn_EventHandler} listener The function that was listening for the event.
        @param {EVUI.Modules.DomEvents.EventOptions} options Options used to change the behavior of the event listener.
        @returns {Boolean}*/
        this.removeAsyncEventListener = function (type, listener, options)
        {
            if (isValidEventType(type) === false) throw Error("String expected.");
            if (typeof listener !== "function") throw Error("Function expected.");

            return removeEventListener(_handle, type, listener, options);
        };

        /**Awaitable. Dispatches an event to the EventTarget using the normal browser EventTarget dispatching API. The Promise resolves once the last event handler on the last target in the composed path has been executed.
        @param {Event} dispatchArgs The browser Event object of the event to fire.
        @returns {Promise}*/
        this.dispatchAsyncEvent = function (dispatchArgs)
        {
            if (EVUI.Modules.Core.Utils.instanceOf(dispatchArgs, Event) === false) throw Error("Event object expected.");

            return new Promise(function (resolve, reject)
            {
                dispatchEvent(_handle, dispatchArgs, function ()
                {
                    resolve();
                });
            });
        };

        /**Adds this AsyncDomEventer's internal AsyncDomEventerHandle to the session with the given ID's composedPath trace.
        @param {String} sessionId The ID of the session to add the handle to.*/
        this.addToAsyncEventSession = function (sessionId)
        {
            var session = getEventSession(sessionId);
            if (session == null) return;

            var index = session.composedPath.indexOf(_target);
            if (index === -1) return;

            session.composedPathHandles[index] = _handle;
        };
    };

    /**Internal carrier of state information about the EventTarget that it is attached to - instantiated inside of a AsyncDomEventer and is passed into the internal implementation of the AsyncDomEventManager.
    @class*/
    var AsyncDomEventerHandle = function (eventer, target)
    {
        /**Number. The unique ID of the AsyncDomEventer
        @type {Number}*/
        this.eventerId = _targetEventerId++;

        /**Object.The public-facing Eventer associated with this handle.
        @type {AsyncDomEventer}*/
        this.eventer = eventer;

        /**Object. The target of the events.
        @type {EventTarget}*/
        this.target = target;

        /**Array. The array of events that have been triggered naturally but are not ready to be fired off asynchronously yet.
        @type {AsyncEvent[]}*/
        this.eventQueue = [];

        /**Object. A BubblingEventManager that contains all the events attached to this EventTarget.
        @type {EVUI.Modules.EventStream.BubblingEventManager()}*/
        this.bubbler = new EVUI.Modules.EventStream.BubblingEventManager();

        /**Object. Dictionary of all the events attached to the EventTarget that is keyed by the event's type.
        @type {{}}*/
        this.registeredEvents = {};

        /**Boolean. Flag indicating if the EventTarget is in the middle of executing an async event.
        @type {Boolean}*/
        this.executing = false;
    };

    /**Gets a RegisteredEvent with the given type from the AsyncDomEventerHandle.
    @param {String} type The type of event to get the RegisteredEvent for.
    @returns {RegisteredEvent}*/
    AsyncDomEventerHandle.prototype.getRegisteredEvent = function (type)
    {
        return this.registeredEvents[type]
    };

    /**In the event that a browser event was triggered while this event was executing and added itself to the eventQueue, this gets the next-soonest event from the eventQueue.
     * 
     * @param {any} remove
     */
    AsyncDomEventerHandle.prototype.getNextQueuedEvent = function (remove, type)
    {
        var numQueued = this.eventQueue.length;
        var nextEvent = null;
        var indexOfEvent = -1;
        var hasType = typeof type === "string";

        //walk the list of queued AsyncEvents and find the oldest EventSession that has this handle's target as the current target.
        for (var x = 0; x < numQueued; x++)
        {
            var curEvent = this.eventQueue[x];

            if (hasType === true && curEvent.type !== type) continue;
            if (nextEvent == null || curEvent.eventId < nextEvent.eventId) //the current event is older than the current nextEvent
            {
                var session = getEventSession(curEvent.sessionId);
                if (session == null) continue; //if this happens something is wrong, the event's session has already finished but it is still in queue somehow.

                if (session.currentTarget === this.target) //if the session says that it is this handle's turn to execute, set the next handle to execute
                {
                    nextEvent = curEvent;
                    indexOfEvent = x;
                }
            }
        }

        if (remove === true && indexOfEvent > -1)
        {
            this.eventQueue.splice(indexOfEvent, 1);
        }

        return nextEvent;
    };

    /**Represents all the information known about all the events attached to an EventTarget of the same type.
    @class*/
    var RegisteredEvent = function ()
    {
        /**String. The name of the event that this event is registered as.
        @type {String}*/
        this.eventType = null;

        /**Number. The number of boundHandlers associated with this type of event on the EventTarget.
        @type {Number}*/
        this.numHandlers = 0;

        /**Function. The function that was added to the EventTarget via addEventListener as the trigger that will react to actual events and trigger the custom async event behavior.
        @type {Function}*/
        this.triggeringHandler = null;

        /**Boolean. Whether or not this type of event is currently executing.
        @type {Boolean}*/
        this.executing = false;

        /**Object. Lookup dictionary of any handlers which were removed during the execution of the RegisteredEvent's bound handlers. Keyed by the BoundEventHandler's handlerId.
        @type {{}}*/
        this.pendingRemovals = {};

        /**Array. All of the events that have been bound to the EventTarget for an event type.
        @type {BoundEventHandler[]}*/
        this.boundHandlers = [];
    };

    /**Gets a BoundEventHandler based on the user's function or the handler that's been bound to the target of the event. 
    @param {Function} userHandler
    @returns {BoundEventHandler}*/
    RegisteredEvent.prototype.getBoundHandler = function (userHandler)
    {
        for (var x = 0; x < this.numHandlers; x++)
        {
            var boundHandler = this.boundHandlers[x];
            if (boundHandler.userHandler === userHandler || boundHandler.targetBoundHandler === userHandler)
            {
                return boundHandler;
            }
        }

        return null;
    };

    /**Returns whether or not a BoundHandler has been removed by a user during execution.
    @param {BoundEventHandler} boundHandler The bound handler to check against the pendingRemovals dictionary.
    @returns {Boolean}*/
    RegisteredEvent.prototype.isPendingRemoval = function (boundHandler)
    {
        return this.pendingRemovals[boundHandler.handlerId] != null;
    };

    /**Represents a lookup object that ties together the event handler provided by the user, the event handler that was bound to the "this" context of the EventTarget, the function used in the EventStream, and the options for the event handler.
    @class*/
    var BoundEventHandler = function ()
    {
        /**Number. The unique ID of this handler.
        @type {Number}*/
        this.handlerId = _handlerId++;

        /**Function. The event listener handler provided by the user.
        @type {Function}*/
        this.userHandler = null;

        /**Function. The event listener that has had its "this" context bound to its EventTarget.
        @type {Function}*/
        this.targetBoundHandler = null;

        /**Function. The function fed into the event stream.
        @type {Function}*/
        this.eventStreamHandler = null;

        /**Object. The options object passed in when the event was registered.
        @type {EVUI.Modules.DomEvents.EventOptions}*/
        this.options = null;
    };

    /**Represents an instance of an event that was triggered by the browser on an EventTarget.
    @class*/
    var AsyncEvent = function ()
    {
        /**Number. The unique identifier of this event, used to both identify the event and to know the order in which events were triggered.
        @type {Number}*/
        this.eventId = _queuedEventId++;

        /**String. The type of the event that was triggered.
        @type {String}*/
        this.type = null;

        /**Object. A plain object that is a duplicate of the actual Event object created by the browser when this event was triggered.
        @type {Event}*/
        this.clonedEventArgs = null;

        /**String. The ID of the bubbling event session that this event is a part of.
        @type {String}*/
        this.sessionId = null;
    };

    /**Represents a bubbling event session that touches all the EventTargets in the composed path.
    @class*/
    var AsyncEventSession = function ()
    {
        /**Number. The unique sequential ID of the event sequence session.
        @type {Number}*/
        this.eventSequenceId = -1;

        /**String. The unique ID of this session and key of the session in the _sessions object.
        @type {String}*/
        this.sessionId = null;

        /**String. The name of the event being handled.
        @type {String}*/
        this.eventType = null;

        /**Object. The EventTarget that triggered the creation of the event session.
        @type {EventTarget}*/
        this.target = null;

        /**Object. The EventTarget who is current executing in the stack of EventTargets impacted by this event.
        @type {EventTarget}*/
        this.currentTarget = null;

        /**Array. The array of all the AsyncDomEventerHandles associated with the elements in the composedPath.
        @type {AsyncDomEventerHandle[]}*/
        this.composedPathHandles = [];

        /**Array. The result of the composedPath() function on the initial eventArgs triggering the event.
        @type {EventTarget[]}*/
        this.composedPath = [];

        /**Object. The EventStream driving the event operation.
        @type {EVUI.Modules.EventStream.EventStream}*/
        this.eventStream = null;

        /**Boolean. Whether or not the user aborted the event.
        @type {Boolean}*/
        this.aborted = false;

        /**Function. A callback to call once the event has completed firing its last handler on the last member of the composed path.
        @type {Function}*/
        this.callback = null;
    };

    /**Container for metadata about an Event object in regards to the AsyncDomEventManager.
    @class*/
    var AsyncEventMetadata = function ()
    {
        /**Number. The unique sequential ID of the event sequence.
        @type {Number}*/
        this.eventSequenceId = -1;

        /**String. The unique ID of the session this event is associated with ans is the key of the session in the _sessions object.
        @type {String}*/
        this.sessionId = null;
    };

    /**Adds an event listener to the AsyncDomEventerHandle's collection of managed handlers.
    @param {AsyncDomEventerHandle} handle The internal state of the event target's async event stack.
    @param {String} type The type of event being listened for.
    @param {Function} listener The function to fire.
    @param {any} options The configuration options of the handler.*/
    var addEventListener = function (handle, type, listener, options)
    {
        options = getValidOptions(options);

        //get the container for all events of this type
        var existing = handle.getRegisteredEvent(type);
        if (existing == null)
        {
            existing = new RegisteredEvent();
            existing.eventType = type;
            handle.registeredEvents[type] = existing;
        }

        //if it's new or doesn't have a triggering handler, go make one and attach it to the event target.
        if (existing.triggeringHandler == null)
        {
            existing.triggeringHandler = addTriggeringHandler(handle, type, options);
        }

        var boundHandler = new BoundEventHandler();
        boundHandler.userHandler = listener;
        boundHandler.targetBoundHandler = listener.bind(handle.target);
        boundHandler.options = options;
        boundHandler.eventStreamHandler = function (asyncEventArgs)
        {
            if (existing.isPendingRemoval(boundHandler) === true) return;
            if (boundHandler.options.once === true)
            {
                removeEventListener(handle, type, boundHandler.listener, boundHandler.options);
            }

            return boundHandler.targetBoundHandler(asyncEventArgs);
        };

        existing.numHandlers = existing.boundHandlers.push(boundHandler);
        handle.bubbler.addEventListener(type, boundHandler.eventStreamHandler, EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.EventStream.EventStreamEventListenerOptions(), options));
    };

    /**Duck typing method to determine if an object is an EventTarget and can have events attached to it.
    @param {EventTarget} eventTarget The object to check to see if it implements EventTarget.
    @returns {Boolean}*/
    var isEventTarget = function (eventTarget)
    {
        if (typeof eventTarget !== "object" || eventTarget == null) return false;
        if (typeof eventTarget.addEventListener !== "function") return false;
        if (typeof eventTarget.removeEventListener !== "function") return false;
        if (typeof eventTarget.dispatchEvent !== "function") return false;

        return true;
    };

    /**Determines whether or not an event is a valid event type (i.e. a non whitespace string).
    @param {String} type The string to validate.
    @returns {Boolean}*/
    var isValidEventType = function (type)
    {
        return EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(type) === false;
    };

    var getValidOptions = function (userOptions)
    {
        if (userOptions == null || typeof userOptions !== "object")
        {
            return new EVUI.Modules.DomEvents.EventOptions();
        }

        return EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.DomEvents.EventOptions(), userOptions);
    };

    /**Adds the handler to the EventTarget that will kick off the execution of the stack of async events managed by the eventer handle.
    @param {AsyncDomEventerHandle} handle The AsyncDomEventerHandle associated with the EventTarget.
    @param {String} type The type of event being listed for.
    @param {EVUI.Modules.DomEvents.EventOptions} options Configuration options for the listener.
    @returns {Function}*/
    var addTriggeringHandler = function (handle, type, options)
    {
        var handler = function (eventArgs)
        {
            try
            {
                //check and see if any of the handlers attached for this event has autoPreventDefault to true - if one of them does, stop the default action.
                if (hasAutoPreventDefault(handle, type) === true) eventArgs.preventDefault();

                //make a copy of the event args object so we can store its current state (which changes as it bubbles)
                var composedPath = eventArgs.composedPath();
                var argsClone = EVUI.Modules.Core.Utils.shallowExtend({}, eventArgs, function (propName, source) { if (typeof source[propName] === "function") return false; });
                argsClone.composedPath = function ()
                {
                    return composedPath.slice();
                };

                argsClone.preventDefault = function ()
                {
                    eventArgs.preventDefault();
                };

                var truePath = composedPath.slice();

                if (options.capture === true)
                {
                    truePath.reverse();
                }

                var asyncEvent = new AsyncEvent();
                asyncEvent.clonedEventArgs = argsClone;
                asyncEvent.type = type;
                asyncEvent.composedPath = truePath;

                var eventMetadata = eventArgs[_eventKey];
                if (eventMetadata == null) //if the current target IS the originator for the event, we need to store some metadata in the Event object to pass to the other events in the bubbling sequence
                {
                    var sequenceId = _eventSequenceId++;
                    var sessionId = getEventSessionId(handle, sequenceId);

                    //if this was a manually dispatched event, it should have a callback to call that is resolving a promise to make the dispatchAsyncEvent await's finish
                    var callback = eventArgs[_callbackKey];
                    delete eventArgs[_callbackKey];

                    eventMetadata = new AsyncEventMetadata();
                    eventMetadata.eventSequenceId = sequenceId;
                    eventMetadata.sessionId = sessionId;

                    var session = new AsyncEventSession();
                    session.eventSequenceId = sequenceId;
                    session.currentTarget = eventArgs.currentTarget;
                    session.eventType = asyncEvent.type;
                    session.target = eventArgs.target;
                    session.sessionId = sessionId;
                    session.composedPath = truePath;
                    session.callback = callback;

                    //we store the sensitive state data internally in the _states lookup object and only expose the ID of the session to the object attached to the Event metadata.
                    _sessions[sessionId] = session;
                    eventArgs[_eventKey] = eventMetadata;

                    if (eventArgs.bubbles === false) //not bubbling, only one member of the composedPathHandles array
                    {
                        session.composedPathHandles.push(handle);
                    }
                    else //otherwise, add the handles for all the targets in the composedPath to the session.
                    {
                        getComposedPathHandles(session);
                    }
                }

                asyncEvent.sessionId = eventMetadata.sessionId;

                //kick off or queue execution of the event
                triggerExecution(handle, asyncEvent);
            }
            catch (ex)
            {
                EVUI.Modules.Core.Utils.log("DomEvents: Error triggering async handlers for event \"" + eventArgs.type + "\": " + ex.stack);
            }
        };

        handle.target.addEventListener(type, handler, options);

        return handler;
    };

    /**Checks to see if any of the boundHandlers has an options object where autoPreventDefault is true.
    @param {AsyncDomEventerHandle} handle The handle to look in.
    @param {String} type The name of the event to check.*/
    var hasAutoPreventDefault = function (handle, type)
    {
        if (isValidEventType(type) === false) return false;

        var registeredEvent = handle.getRegisteredEvent(type);
        if (registeredEvent == null) return false;

        var numHandlers = registeredEvent.boundHandlers.length;
        for (var x = 0; x < numHandlers; x++)
        {
            var curHandle = registeredEvent.boundHandlers[x];

            if (registeredEvent.isPendingRemoval(curHandle) === true) continue;
            if (curHandle.options.autoPreventDefault === true) return true;
        }

        return false;
    };

    /**Triggers or queues the execution of an event. 
    @param {AsyncDomEventerHandle} handle The handle of the event target having its event executed or queued.
    @param {AsyncEvent} asyncEvent The event to queue or trigger.*/
    var triggerExecution = function (handle, asyncEvent)
    {
        var session = getEventSession(asyncEvent.sessionId);
        if (session == null) return;

        if (handle.executing === true || session.currentTarget !== asyncEvent.clonedEventArgs.currentTarget)
        {
            handle.eventQueue.push(asyncEvent);
        }
        else 
        {
            executeEvent(handle, asyncEvent, session);
        }
    };

    /**Builds the EventStream that will execute the event handlers that belong to the EventTarget for the given event type.
    @param {AsyncDomEventerHandle} handle The handle of the event target being executed.
    @param {AsyncEvent} asyncEvent The event being executed.
    @param {AsyncEventSession} session The execution session of the event.*/
    var executeEvent = function (handle, asyncEvent, session)
    {
        var eventType = handle.getRegisteredEvent(asyncEvent.type);

        handle.executing = true;

        var es = new EVUI.Modules.EventStream.EventStream();
        es.context = asyncEvent.clonedEventArgs.currentTarget;
        es.bubblingEvents = handle.bubbler;

        es.processInjectedEventArgs = function (eventStreamArgs)
        {
            //make the event args object have all the properties of the actual event args object when it was at the same place in its bubbling path.
            var args = new EVUI.Modules.DomEvents.AsyncDomEventArgs();
            EVUI.Modules.Core.Utils.shallowExtend(args, asyncEvent.clonedEventArgs);

            args.eventSequenceId = session.eventSequenceId;
            args.cancel = eventStreamArgs.cancel;
            args.pause = eventStreamArgs.pause;
            args.resume = eventStreamArgs.resume;
            args.state = eventStreamArgs.state;
            args.stopImmediatePropagation = function () //this stops the current targets handlers from firing but does not stop bubbling
            {
                return eventStreamArgs.stopPropagation();
            }
            args.stopPropagation = function () //stops bubbling propagation.
            {
                session.aborted = true;
            };

            return args;
        };

        es.processReturnedEventArgs = function (eventStreamArgs)
        {
            es.eventState = eventStreamArgs.state;
        };

        es.addEvent(asyncEvent.type, function ()
        {

        });

        es.onComplete = function (eventArgs)
        {
            handle.executing = false;

            //remove all the events that were flagged for removal during execution.
            if (eventType != null && eventType.pendingRemovals != null)
            {
                var removals = EVUI.Modules.Core.Utils.getProperties(eventType.pendingRemovals);
                var numRemovals = removals.length;
                for (var x = 0; x < numRemovals; x++)
                {
                    var key = removals[x];
                    var toRemove = eventType.pendingRemovals[key];
                    if (toRemove != null)
                    {
                        removeEventListener(handle, eventType, toRemove);
                    }

                    delete eventType.pendingRemovals[key];
                }
            }

            //if we removed all the handlers, remove the registered event as well.
            if (eventType.numHandlers === 0 && eventType.triggeringHandler == null)
            {
                delete handle.registeredEvents[eventType.eventType];
            }

            //get the index of the current handle so we can get the index of the next highest handle 
            var nextIndex = session.composedPathHandles.indexOf(handle);
            var nextHandle = null;
            if (nextIndex !== -1)
            {
                nextIndex++;
                nextHandle = session.composedPathHandles[nextIndex];
            }

            //if we have another handle above the current one in the composed path
            if (nextHandle != null)
            {
                //set the target so the session knows whose turn it is to execute
                session.currentTarget = nextHandle.target;

                //see if this handle has another handler on itself that is ready to fire (our rule is that an element can only be handling one event at a time, so we always wait for one to finish before beginning another.)
                var nextEvent = nextHandle.getNextQueuedEvent(true, asyncEvent.type);

                //if we didn't find another event on this handle, move up the chain until we do find a handle with an event that matches our target event type and current event target
                while (nextEvent == null)
                {
                    nextIndex++;
                    nextHandle = session.composedPathHandles[nextIndex];
                    if (nextHandle == null) break;

                    session.currentTarget = nextHandle.target;
                    nextEvent = nextHandle.getNextQueuedEvent(true, asyncEvent.type);
                }

                if (nextEvent != null)
                {
                    triggerExecution(nextHandle, nextEvent)
                }
            }

            if (nextHandle == null) //the session is out of handles and is done.
            {
                delete _sessions[session.sessionId];

                if (typeof session.callback === "function")
                {
                    try
                    {
                        session.callback();
                    }
                    catch (ex)
                    {
                        EVUI.Modules.Core.Utils.log("Error invoking dispatchedEvent's callback");
                        EVUI.Modules.Core.Utils.log(ex);
                    }
                }
            }

            //now that this target has finished its event, go see if there another unrelated event on it and trigger that one as well.
            nextEvent = handle.getNextQueuedEvent(true);
            if (nextEvent != null)
            {
                triggerExecution(handle, nextEvent);
            }
        };

        es.execute();
    };

    /**Generates the sessionId for a given event sequence number and handle.
    @param {AsyncDomEventerHandle} handle The handle that is related to the event session.
    @param {Number} eventSequenceId The sequence number of the current event.
    @returns string */
    var getEventSessionId = function (handle, eventSequenceId)
    {
        return EVUI.Modules.Core.Utils.getHashCode(_sessionSalt + ":" + handle.eventerId + "-" + eventSequenceId).toString(36).replace(".", "");
    };

    /**Gets an AsyncEventSession based on its Id.
    @param {String} sessionId The Id of the session to get.
    @returns {AsyncEventSession}*/
    var getEventSession = function (sessionId)
    {
        return _sessions[sessionId];
    }

    /**Builds the session's composedPathHandles array when an event session is starting.
    @param {AsyncEventSession} session The session to populate the composedPathHandles for.*/
    var getComposedPathHandles = function (session)
    {
        if (EVUI.Modules.Core.Utils.isArray(session.composedPath) === false) return;

        var numInPath = session.composedPath.length;
        for (var x = 0; x < numInPath; x++)
        {
            var eventer = ensureEventer(session.composedPath[x]);
            if (eventer == null) continue;

            eventer.addToAsyncEventSession(session.sessionId);
        }
    };

    /**Ensures that an EventTarget has an AsyncDomEventer attached to it.
    @param {EventTarget} eventTarget The EventTarget to get or attach an AsyncDomEventer to.
    @returns {AsyncDomEventer}*/
    var ensureEventer = function (eventTarget)
    {
        if (typeof eventTarget !== "object" || eventTarget == null) return null;

        var eventer = eventTarget[_eventerKey];
        if (eventer == null)
        {
            eventer = new AsyncDomEventer(eventTarget);
            eventTarget[_eventerKey] = eventer;
        }

        return eventer;
    };

    /**Removes an event listener from the managed stack of async events.
    @param {AsyncDomEventerHandle} handle The internal state of the EventTarget
    @param {String|RegisteredEvent} type The type of event being removed.
    @param {Function|BoundEventHandler} listener The function to stop listening with.
    @param {EVUI.Modules.DomEvents.EventOptions} options The options for how the listener was set up. Only here because the signature in the DOM also takes an options object - not sure what for.
    @returns {Boolean} */
    var removeEventListener = function (handle, type, listener, options)
    {
        var eventType = null;
        var handler = null;

        if (EVUI.Modules.Core.Utils.instanceOf(type, RegisteredEvent) === true)
        {
            eventType = type;
        }
        else
        {
            eventType = handle.getRegisteredEvent(type);
        }

        if (eventType == null) return false;

        if (EVUI.Modules.Core.Utils.instanceOf(listener, BoundEventHandler) === true)
        {
            handler = listener;
        }
        else
        {
            handler = eventType.getBoundHandler(listener);
        }

        if (handler == null) return false;

        //remove the event from the event bubbler so it won't fire again
        if (handle.bubbler.removeEventListener(eventType.eventType, handler.eventStreamHandler) === false) return false;

        //if we're executing, don't remove it just yet but rather queue it to be removed when the event finishes.
        if (eventType.executing === true)
        {
            eventType.pendingRemovals[handler.handlerId] = handler;

            return true;
        }
        else //otherwise snip it out of the list
        {
            var index = eventType.boundHandlers.indexOf(handler);
            if (index !== -1)
            {
                eventType.boundHandlers.splice(index, 1);
                eventType.numHandlers--;

                if (eventType.numHandlers === 0) //if we run out of handlers for a given event type, remove that event's record from the handle and the listener thats in the DOM.
                {
                    handle.target.removeEventListener(eventType.eventType, eventType.triggeringHandler, options);
                    eventType.triggeringHandler = null;

                    delete handle.registeredEvents[eventType.eventType];
                }

                return true;
            }
        }

        return false;
    };

    /**Dispatches an event to the event target that fires engages the normal triggering mechanism.
    @param {AsyncDomEventerHandle} handle The internal state of the EventTarget.
    @param {Event} dispatchArgs The event to dispatch.
    @param {Function} callback The callback to call when the dispatched event's last bubbling handler completes.*/
    var dispatchEvent = function (handle, dispatchArgs, callback)
    {
        dispatchArgs[_callbackKey] = callback;
        handle.target.dispatchEvent(dispatchArgs);
    };

    /**Manager for attaching async event listeners to EventTargets.
    @class*/
    var AsyncDomEventManager = function ()
    {
    };

    /**Adds an event listener to the stack of managed async event handlers.
    @param {EventTarget} eventTarget The target to attach the event to.
    @param {String} type The type of event to listen for.
    @param {EVUI.Modules.DomEvents.Constants.Fn_EventHandler} listener The function that will handle the event.
    @param {EVUI.Modules.DomEvents.EventOptions} options The options to change the behavior of the event handler.*/
    AsyncDomEventManager.prototype.addAsyncEventListener = function (eventTarget, type, listener, options)
    {
        if (isEventTarget(eventTarget) === false) throw Error("EventTarget expected.");

        var eventer = ensureEventer(eventTarget);
        return eventer.addAsyncEventListener(type, listener, options);
    };

    /**Removes an event listener from the stack of managed async event handlers.
    @param {EventTarget} eventTarget The target to remove the event from.
    @param {String} type The type of event that the listener is listening for.
    @param {EVUI.Modules.DomEvents.Constants.Fn_EventHandler} listener The function that was listening for the event.
    @param {EVUI.Modules.DomEvents.EventOptions} options Options used to change the behavior of the event listener.
    @returns {Boolean}*/
    AsyncDomEventManager.prototype.removeAsyncEventListener = function (eventTarget, type, listener, options)
    {

        if (isEventTarget(eventTarget) === false) throw Error("EventTarget expected.");

        var eventer = ensureEventer(eventTarget);
        return eventer.removeAsyncEventListener(type, listener, options);
    };

    /**Awaitable. Dispatches an event to the EventTarget using the normal browser EventTarget dispatching API. The Promise resolves once the last event handler on the last target in the composed path has been executed.
    @param {EventTarget} eventTarget The target to dispatch the event from.
    @param {Event} dispatchArgs The browser Event object of the event to fire.
    @returns {Promise}*/
    AsyncDomEventManager.prototype.dispatchAsyncEvent = function (eventTarget, event)
    {

        if (isEventTarget(eventTarget) === false) throw Error("EventTarget expected.");

        var eventer = ensureEventer(eventTarget);
        return eventer.dispatchAsyncEvent(event);
    };

    /**Adds an event listener to the stack of managed async event handlers.
    @param {String} type The type of event to listen for.
    @param {EVUI.Modules.DomEvents.Constants.Fn_EventHandler} listener The function that will handle the event.
    @param {EVUI.Modules.DomEvents.EventOptions} options The options to change the behavior of the event handler.*/
    EventTarget.prototype.addAsyncEventListener = function (type, listener, options)
    {
        return EVUI.Modules.DomEvents.AsyncDomEventManager.addAsyncEventListener(this, type, listener, options);
    };

    /**Removes an event listener from the stack of managed async event handlers.
    @param {String} type The type of event that the listener is listening for.
    @param {EVUI.Modules.DomEvents.Constants.Fn_EventHandler} listener The function that was listening for the event.
    @param {EVUI.Modules.DomEvents.EventOptions} options Options used to change the behavior of the event listener.
    @returns {Boolean}*/
    EventTarget.prototype.removeAsyncEventListener = function (type, listener, options)
    {
        return EVUI.Modules.DomEvents.AsyncDomEventManager.removeAsyncEventListener(this, type, listener, options);
    };

    /**Awaitable. Dispatches an event to the EventTarget using the normal browser EventTarget dispatching API. The Promise resolves once the last event handler on the last target in the composed path has been executed.
    @param {Event} dispatchArgs The browser Event object of the event to fire.
    @returns {Promise}*/
    EventTarget.prototype.dispatchAsyncEvent = function (event)
    {
        return EVUI.Modules.DomEvents.AsyncDomEventManager.dispatchAsyncEvent(this, event);
    };

    return new AsyncDomEventManager();
})();

/**Options object for configuring the behavior of an event listener.
@class*/
EVUI.Modules.DomEvents.EventOptions = function ()
{
    /**Boolean. Whether or not the event listener will fire once and be removed.
    @type {Boolean}*/
    this.once = false;

    /**Boolean. Whether or not the order of execution of EventTargets is reversed - instead of going from the element which triggered the event to the window, this setting says to start with the window and work in to the originating element.
    @type {Boolean}*/
    this.capture = false;

    /**Boolean. Whether or not this event listener will automatically stop the browser's default action by invoking preventDefault() on the browser's Event argument. 
    If any listener for a given event type on the EventTarget has this set to true, the default action will be prevented.
    @type {Boolean}*/
    this.autoPreventDefault = false;
};

/**Event arguments for handlers that have been assigned via addAsyncEventHandler. Is a shallow clone of the browser's Event arguments for the event that was triggered with the standard EventStream functions added on.
@class*/
EVUI.Modules.DomEvents.AsyncDomEventArgs = function ()
{
    /**Number. The sequential counter that identifies this unique event session for an event on its entire composed path.
    @type {Number}*/
    this.eventSequenceId = -1;

    /**Function. Cancels the execution of the EventStream. Returns true if the execution was canceled, or false if it was not cancelable.
    @returns {Boolean}*/
    this.cancel = function () { return false; };

    /**Function. Pauses the execution of the EventStream. Returns true if the execution was paused, or false if it was not pausable.
    @returns {Boolean}*/
    this.pause = function () { return false; };

    /**Function. Resumes a paused execution of the EventStream. Returns true if the execution was resumed, or false if it was not resumable.
    @returns {Boolean}*/
    this.resume = function () { return false; };

    /**Function. Stops the propagation of the event to other handlers on the current element.
    @returns {Boolean}*/
    this.stopImmediatePropagation = function () { return false; }

    /**Function. Stops the propagation of the event to its parent.
    @returns {Boolean}*/
    this.stopPropagation = function () { return false };

    /**Object. The public event state of the EventStream.
    @type {Object}*/
    this.state = null;
};

/**Adds an event listener to the stack of managed async event handlers.
@param {EventTarget} eventTarget The target to attach the event to.
@param {String} type The type of event to listen for.
@param {EVUI.Modules.DomEvents.Constants.Fn_EventHandler} listener The function that will handle the event.
@param {EVUI.Modules.DomEvents.EventOptions} options The options to change the behavior of the event handler.*/
$evui.addAsyncEventListener = function (eventTarget, type, listener, options)
{
    return EVUI.Modules.DomEvents.AsyncDomEventManager.addAsyncEventListener(eventTarget, type, listener, options);
};

/**Removes an event listener from the stack of managed async event handlers.
@param {EventTarget} eventTarget The target to remove the event from.
@param {String} type The type of event that the listener is listening for.
@param {EVUI.Modules.DomEvents.Constants.Fn_EventHandler} listener The function that was listening for the event.
@param {EVUI.Modules.DomEvents.EventOptions} options Options used to change the behavior of the event listener.
@returns {Boolean}*/
$evui.removeAsyncEventListener = function (eventTarget, type, listener, options)
{
    return EVUI.Modules.DomEvents.AsyncDomEventManager.removeAsyncEventListener(eventTarget, type, listener, options);
};

/**Awaitable. Dispatches an event to the EventTarget using the normal browser EventTarget dispatching API. The Promise resolves once the last event handler on the last target in the composed path has been executed.
@param {EventTarget} eventTarget The target to dispatch the event from.
@param {Event} dispatchArgs The browser Event object of the event to fire.
@returns {Promise}*/
$evui.dispatchAsyncEvent = function (eventTarget, event)
{
    return EVUI.Modules.DomEvents.AsyncDomEventManager.dispatchAsyncEvent(eventTarget, event);
};

Object.freeze(EVUI.Modules.DomEvents);
/*#ENDWRAP(DomEvents)#*/


/********************************************************DomTree.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.DomTree|DT)#*/
/*#REPLACE(EVUI.Modules.DomTree|DT)#*/

/**Module for turning an Element, Document, or DocumentFragment into JSON and vice-versa.
@module*/
EVUI.Modules.DomTree = {};

/*#MODULEDEF(DT|"1.0"|"DomTree")#*/
/*#VERSIONCHECK(EVUI.Modules.DomTree|DT)#*/

EVUI.Modules.DomTree.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.DomTree.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();

Object.freeze(EVUI.Modules.DomTree.Dependencies);

EVUI.Modules.DomTree.Constants = {};

/**A selector function used to locate DomTreeElements in a hierarchy of DomTreeElements.
@param {EVUI.Modules.DomTree.DomTreeElement} domTree The DomTreeElement to test for a positive search result.
@returns {Boolean}*/
EVUI.Modules.DomTree.Constants.Fn_Selector = function (domTree) { };

/**Fiter function used for determining exception cases as to when to filter out in-line event handler attributes. Return true to NOT exclude the attribute.
@param {String} attributeName The name of the attribute.
@param {String} attributeValue The value of the attribute.
@returns {Boolean}*/
EVUI.Modules.DomTree.Constants.Fn_AttributeFilter = function (attributeName, attributeValue) { };

Object.freeze(EVUI.Modules.DomTree.Constants);

/**Utility serializer for turning HTML or XML into a JSON-serializable object structure and visa-versa.
@class*/
EVUI.Modules.DomTree.DomTreeConverter = function ()
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.DomTree.Dependencies);

    var _elementTypes = EVUI.Modules.DomTree.DomTreeElementType;
    var _externalResourceTags = ["a", "img", "svg", "link", "script", "audio", "embed", "object", "source", "video"];
    var _selfClosingTags = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "link", "menuitem", "meta", "keygen", "param", "source", "track", "wbr"];
    var _unescapeHtml = /\&gt;|\&lt;/ig
    var _escapeCharacters = /\<!--|--\>|\<!\CDATA\[\[|\]\]\>/ig
    var _literalTextTags = /\<script|\<\/\s*script\s*\>|\<textarea|\<\/\s*textarea\s*\>|\<style|\<\/\s*style\s*\>|\<pre|\<\/\s*pre\s*\>|\<code|\<\/\s*code\s*\>/ig
    var _quotesAndComments = /\'|\"|\/\*|\*\/|\/\/"|`/g; //match any: ', ", //, /*, */
    var _tagOpenCloses = /\<\/|\/\>|<|\>/g; //match: </, />, <, >
    var _tagNameEnd = /\s|\>|\//; //match: whitespace, >, /
    var _tagNameStart = /\<|\<\/\s*/; //match: <, or </(whitespace)    
    var _attributeComponents = /\\"|\\'|"|'|=/g //match: escaped quote, escaped double quote, quote, double quote, and equals signs
    var _eventHandlerAttributeStart = /^on/i;
    var _canMatchAll = typeof String.prototype.matchAll !== "undefined";
    var _tagCache = {};

    /**Object for containing the data about a serialization in progress.
    @class*/
    var DomTreeConversionSession = function ()
    {
        /**Object. The Document, HTMLElement, or DocumentFragment to get the DomTreeElement model from, or the DomTreeElement to turn into a Document, HTMLElement, or DocumentFragment.
        @type {Document|Element|DocumentFragment|DomTreeElement}*/
        this.source = null;

        /**Object. The options for the DomTree element conversion job.
        @type {EVUI.Modules.DomTree.DomTreeElementOptions}*/
        this.options = new EVUI.Modules.DomTree.DomTreeElementOptions();

        /**Boolean. Whether or not the output of turning a DomTreeElement into HTML should output the raw string and not try and parse it first.
        @type {Boolean}*/
        this.outputToString = false;

        /**Options for determing what content to filter out when converting a DomTreeElement into a Node.
        @type {DomTreeParseOptions}*/
        this.parseOptions = null;
    };

    /**Converts a HTMLElement, Document (XML or HTML), or DocumentFragment into a JSON structure representing the input.
    @param {HTMLElement|Document|DocumentFragment} source Any HTMLElement, Document (XML or HTML), or DocumentFragment to turn into a DomTreeElement hierarchy.
    @param {EVUI.Modules.DomTree.DomTreeElementOptions} options The options for creating the DomTreeElement hierarchy.
    @returns {EVUI.Modules.DomTree.DomTreeElement} */
    this.toDomTreeElement = function (source, options)
    {
        if (source == null) return null;

        var session = makeSession(source, options);
        return convertToDomTreeElements(session);
    };

    /**Converts a DomTree Object graph into a Document, HTMLElment, or DocumentFragment.
    @param {EVUI.Modules.DomTree.DomTreeElement} domTreeElement The Root element to convertFromString.
    @param {EVUI.Modules.DomTree.DomTreeElementOptions} options The options for reading the DomTreeElement hierarchy.
    @returns {HTMLElement|Document|DocumentFragment}*/
    this.fromDomTreeElement = function (domTreeElement, options)
    {
        if (domTreeElement == null) return null;

        var session = makeSession(domTreeElement, options);
        return convertFromDomTreeElement(session, false);
    };

    /**Converts a DomTree Object graph into a string of HTML.
    @param {EVUI.Modules.DomTree.DomTreeElement} domTreeElement The Root element to convertFromString.
    @param {EVUI.Modules.DomTree.DomTreeElementOptions} options
    @returns {String}*/
    this.fromDomTreeElementToString = function (domTreeElement, options)
    {
        if (domTreeElement == null) return null;

        var session = makeSession(domTreeElement, options);
        return convertFromDomTreeElement(session, true);
    };

    /**Converts a HTML string into a DocumentFragment containing the parsed HTML.
    @param {String} htmlString A string of HTML to turn into a DocumentFragment.
    @param {EVUI.Modules.DomTree.DomTreeElementOptions} options Options for controlling the turning of the HTML string into Nodes.
    @returns {DocumentFragment} */
    this.htmlToDocumentFragment = function (htmlString, options)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(htmlString) === true) return null;
        var result = convertFromString(htmlString);
        return result.toNode(null, ensureParseOptions(options));
    };

    /**Converts a HTML string into a hierarchy of DomTreeElements representing a DocumentFragment containing the parsed HTML.
    @param {String} htmlString A string of HTML to turn into a hierarchy of DomTreeElements.
    @param {EVUI.Modules.DomTree.DomTreeElementOptions} options Options for controlling the turning of the HTML string into Nodes.
    @returns {EVUI.Modules.DomTree.DomTreeElement}*/
    this.htmlToDomTree = function (htmlString, options)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(htmlString) === true) return null;
        var result = convertFromString(htmlString);
        return result.toDomTree(null, ensureParseOptions(options));
    };

    /**Makes a DomTreeConversionSession.
    @param {Any} input The Root element to convertFromString.
    @param {EVUI.Modules.DomTree.DomTreeElementOptions} options The Converter.Options passed into the main convertFromString function.*
    @returns {DomTreeConversionSession}*/
    var makeSession = function (input, options)
    {
        var session = new DomTreeConversionSession();
        session.source = input;
        if (options != null)
        {
            session.options = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.DomTree.DomTreeElementOptions(), options);
        }
        else
        {
            session.options = new EVUI.Modules.DomTree.DomTreeElementOptions();
        }

        if (EVUI.Modules.Core.Utils.isArray(session.options.omittedElements) === false)
        {
            session.options.omittedElements = [];
        }
        else
        {
            var omissions = [];
            var numOmissions = session.options.omittedElements.length;
            for (var x = 0; x < numOmissions; x++)
            {
                var curOmission = session.options.omittedElements[x];
                if (typeof curOmission !== "string") continue;

                omissions.push(curOmission.toLowerCase());
            }

            session.options.omittedElements = omissions;
        }

        session.parseOptions = buildDomTreeParseOptions(session.options);

        return session;
    };


    /**
    @param {EVUI.Modules.DomTree.DomTreeElementOptions} options The Converter.Options passed into the main convertFromString function.**/
    var buildDomTreeParseOptions = function (options)
    {
        var parseOptions = new DomTreeParseOptions();
        parseOptions.elementOptions = options;

        if (EVUI.Modules.Core.Utils.isArray(options.omittedElements) === true)
        {
            var numOmitted = options.omittedElements.length;
            for (var x = 0; x < numOmitted; x++)
            {
                parseOptions.omittedElementsDic[options.omittedElements[x]] = true;
            }
        }

        return parseOptions;
    }

    /**Translates a Document, DocumentFragment, or HTMLElment into a JSDONRXElement.
    @param {DomTreeConversionSession} session The conversion session that contains all the data relevant to the current conversion.
    @returns {EVUI.Modules.DomTree.DomTreeElement}*/
    var convertToDomTreeElements = function (session)
    {
        var isDocument = false;
        if (EVUI.Modules.Core.Utils.instanceOf(session.source, Document) === true)
        {
            isDocument = true;
            session.source = session.source.documentElement;
        }

        //do the recursive translation process
        var element = toDomTreeElement(session, session.source);
        if (element == null) return null;

        //set the mime-type of the converted top level element so we know what type of document to round-trip it into.
        if (isDocument === true)
        {
            element.type = _elementTypes.Document;
        }

        return element;
    };

    /**Converts an Element (either XML or HTML) into a DomTreeElement.
    @param {Element} element The element to convertFromString.
    @param {DomTreeConversionSession} session  The conversion session that contains all the data relevant to the current conversion.
    @param {EVUI.Modules.DomTree.DomTreeElement} parentElement The element that is the parent to this element.
    @param {Boolean} inShadowDom Whether or not the element is in the shadow DOM.*/
    var toDomTreeElement = function (session, element, parentElement, inShadowDom)
    {
        if (element == null) return null; //no element, no conversion
        
        var eleType = getDomTreeNodeType(element.nodeType);
        if (eleType === _elementTypes.Unknown) return null;  //unsupported node type, don't try and do anything

        var tagName = element.nodeName.toLowerCase(); //normalize tag name to lower case so we can check it against our list of excluded tags.

        //see if it is one of our omitted elements. If it is and we're not including the outer tag, just skip the whole element. Otherwise continue and the getContents function will skip over its contents.
        if (session.parseOptions.isOmittedTag(tagName) === true && session.options.includeOmittedElementOuterTag === false) return null;

        var domTreeEle = new EVUI.Modules.DomTree.DomTreeElement();
        domTreeEle.flags = getElementFlags(element);
        domTreeEle.type = eleType;
        domTreeEle.attrs = getAttrs(element); //make the attributes array
        domTreeEle.tagName = element.nodeName;
        domTreeEle.content = getContents(session, element, eleType); //get either a string of child content, null content (a self-closing tag), or an array of child elements.
        domTreeEle.shadowContent = (element.shadowRoot != null) ? getContents(session, element, eleType, true) : undefined;
        if (session.options.includeNodeReferences === true) domTreeEle.node = element;

        if (checkForExternalResources(session, element, domTreeEle, parentElement) == true)
        {
            domTreeEle.flags |= EVUI.Modules.DomTree.DomTreeElementFlags.HasForiegnResource;
        }

        if (inShadowDom === true || (parentElement != null && EVUI.Modules.Core.Utils.hasFlag(parentElement.flags, EVUI.Modules.DomTree.DomTreeElementFlags.IsInShadowDom)))
        {
            domTreeEle.flags |= EVUI.Modules.DomTree.DomTreeElementFlags.IsInShadowDom;
        }

        return domTreeEle;
    };

    /**Gets the flags for a given element.
    @param {Element} element The element to get flags for.
    @returns {Number}*/
    var getElementFlags = function (element)
    {
        if (element == null) return EVUI.Modules.DomTree.DomTreeElementFlags.Unknown;

        if (element instanceof HTMLElement) //its a HTML element
        {
            return EVUI.Modules.DomTree.DomTreeElementFlags.HTML;
        }
        else if (element instanceof CharacterData) //its character data, see what it's parent is
        {
            return getElementFlags(element.parentElement); //if this text node has no parent, the parse will fail.
        }
        else if (element instanceof Document) //its a document, check to see if it's a HTML or XML doc
        {
            if (element.documentElement instanceof HTMLElement) //the documentElement of a HTML doc is always a HTMLElement object
            {
                return EVUI.Modules.DomTree.DomTreeElementFlags.HTML;
            }
            else
            {
                return EVUI.Modules.DomTree.DomTreeElementFlags.XML;
            }
        }
        else if (element instanceof DocumentFragment) //the ownerdocument of a document fragment is going to be an HTMLElement if it belongs to an HTML tree, otherwise its XML
        {
            if (element.ownerDocument.body instanceof HTMLElement)
            {
                return EVUI.Modules.DomTree.DomTreeElementFlags.HTML
            }
            else
            {
                return EVUI.Modules.DomTree.DomTreeElementFlags.XML;
            }
        }
        else //not a doc, not a fragment, not explicitly an element. probably xml.
        {
            return EVUI.Modules.DomTree.DomTreeElementFlags.XML
        }
    };

    /**Checks to see if a element has an external resource that should be downloaded and stored as a dataURL.
    @param {DomTreeConversionSession} session The conversion session that contains all the data relevant to the current conversion.
    @param {Element} element The HTMLElement to check for external resources.
    @param {EVUI.Modules.DomTree.DomTreeElement} domTreeEle The converted DomTree element that is going to be injected with the result of media request (eventually).
    @param {EVUI.Modules.DomTree.DomTreeElement} parentElement The element that is the parent to this element, used to check for <source> tags's parents.*/
    var checkForExternalResources = function (session, element, domTreeEle, parentElement)
    {
        var externalResourceAttribute = getExternalResourceAttributeForTag(domTreeEle.tagName); //get the name of the attribute that contains the URL of the content to go get
        if (externalResourceAttribute == null) return false; //no attribute, no url, no content

        //set the URL of the attribute so it can be opened stand-alone and not on the host server the page is being serialized from if it was a relative link
        if (session.options.absoluteUrls === true && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(url) === false)
        {
            //use a somewhat hacky way of getting the complete resource URL in case it's a partial URL (anchor tag manipulation)
            var url = getFullURL(getAttributeValue(domTreeEle, externalResourceAttribute));
            setAttributeValue(domTreeEle, externalResourceAttribute, url);
        }

        var parentTagName = (parentElement == null) ? null : parentElement.tagName.toLowerCase();

        if (domTreeEle.tagName === "link") //excluding link elements (CSS, Fonts, etc)
        {
            return true;
        }
        else if (domTreeEle.tagName === "video") //excluding video elements 
        {
            return true;
        }
        else if (domTreeEle.tagName === "script") //excluding script references
        {
            return true;
        }
        else if (domTreeEle.tagName === "source") //a source tag, make sure we obey the type of content we don't want to download
        {
            if (parentTagName === "video")
            {
                return true;
            }
        }

        return false;
    };

    /**Gets the attribute name for the tag that could contain external media.
    @param {String} tagName The tag name to get the usual external reference attribute for.
    @returns {String} */
    var getExternalResourceAttributeForTag = function (tagName)
    {
        if (typeof tagName !== "string") return null;
        tagName = tagName.toLowerCase();

        if (_externalResourceTags.indexOf(tagName) === -1) return null; //not one of our external media types, bail

        if (tagName === "link" || tagName === "a") //link tags use "href" for their resources
        {
            return "href";
        }
        else //all the others use "src"
        {
            return "src";
        }
    };

    /**A somewhat hacky way of getting the full URL, but it works.
    @param {any} partialURL A URL that may not be a complete URL.
    @returns {String} */
    var getFullURL = function (partialURL)
    {
        if (partialURL == null) return null;
        var aTag = document.createElement("a");
        aTag.href = partialURL;

        var fullURL = aTag.protocol + "//" + aTag.host + aTag.pathname;

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(aTag.search) === false)
        {
            fullURL += ((EVUI.Modules.Core.Utils.stringStartsWith("?", aTag.search) === false) ? "?" + aTag.search : aTag.search);
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(aTag.hash) === false)
        {
            fullURL += ((EVUI.Modules.Core.Utils.stringStartsWith("#", aTag.hash) === false) ? "#" + aTag.hash : aTag.hash);
        }

        return fullURL;
    };

    /**Gets the value of an attribute. 
    @param {EVUI.Modules.DomTree.DomTreeElement} domTreeEle The element that contains the attribute.
    @param {String} attributeName The name of the attribute to get.
    @returns {String}*/
    var getAttributeValue = function (domTreeEle, attributeName)
    {
        if (domTreeEle.attrs == null || typeof attributeName !== "string") return null;
        attributeName = attributeName.toLowerCase();

        var numAttrs = domTreeEle.attrs.length;
        for (var x = 0; x < numAttrs; x++)
        {
            var curAttr = domTreeEle.attrs[x];
            var lowerKey = curAttr.key.toLowerCase();
            if (lowerKey === attributeName) return curAttr.val;
        }

        return null;
    };

    /**Gets the value of an attribute.
    @param {EVUI.Modules.DomTree.DomTreeElement} domTreeEle The element that contains the attribute.
    @param {String} attributeName The name of the attribute to set.
    @param {String} value The value to set the attribute to.
    @returns {String}*/
    var setAttributeValue = function (domTreeEle, attributeName, value)
    {
        if (domTreeEle.attrs == null || typeof attributeName !== "string" || value == null) return;
        attributeName = attributeName.toLowerCase();

        var numAttrs = domTreeEle.attrs.length;
        for (var x = 0; x < numAttrs; x++)
        {
            var curAttr = domTreeEle.attrs[x];
            var lowerKey = curAttr.key.toLowerCase();
            if (lowerKey === attributeName)
            {
                curAttr.val = value.toString();
                return;
            }
        }
    };

    /**Gets the DomTree node type based on the Element's nodeType property.
    @param {Number} nodeType The nodeType from an Element object.
    @returns {Number} */
    var getDomTreeNodeType = function (nodeType)
    {
        switch (nodeType)
        {
            case 1: //ELEMENT_NODE
                return _elementTypes.Element;
            case 3: //TEXT_NODE
                return _elementTypes.Text;
            case 4: //CDATA_SECTION_NODE
                return _elementTypes.CDATA;
            case 8: //COMMENT_NODE
                return _elementTypes.Comment;
            case 9: //DOCUMENT_NODE
                return _elementTypes.Document;
            case 11: //DOCUMENT_FRAGMENT_NODE
                return _elementTypes.DocumentFragment;
            default:
                return _elementTypes.Unknown;
        }
    };

    /** Gets an array of DomTreeElementAttribute objects representing all the attributes on the Element.
    @param {Element} element The Element to get the attributes of.
    @returns {EVUI.Modules.DomTree.DomTreeElementAttribute[]}*/
    var getAttrs = function (element)
    {
        var numAttrs = (element.attributes != null) ? element.attributes.length : 0;
        if (numAttrs === 0) return undefined;

        var domTreeAttrs = [];
        for (var x = 0; x < numAttrs; x++)
        {
            var curAttr = element.attributes[x];
            var domTreeAttr = new EVUI.Modules.DomTree.DomTreeElementAttribute();
            domTreeAttr.key = curAttr.name;
            domTreeAttr.val = curAttr.value;

            domTreeAttrs.push(domTreeAttr);
        }

        return domTreeAttrs;
    };

    /**Gets the inner contents of an DomTreeElement. Can be one of 4 things: null for a self-closing tag, an empty array for a tag with no children, an array of child DomTreeElements for child elements, or a string of text for a text node.
    @param {DomTreeConversionSession} session All the data relating to the
    @param {Element} element The element to get the contents of.
    @param {Number} elementType The EVUI.Modules.DomTree.DomTreeElementType enum value indicating the type of element.
    @param {Boolean} getShadowChildren Whether or not to get the shadow DOM children for the element.
    @returns {Null|[]|String|EVUI.Modules.DomTree.DomTreeElement[]}*/
    var getContents = function (session, element, elementType, getShadowChildren)
    {
        if (getShadowChildren === true && element.shadowRoot == null) return [];

        var tagName = element.nodeName.toLowerCase();
        if (tagName === "iframe") return [];
        if (session.parseOptions.isOmittedTag(tagName) === true && session.options.includeOmittedElementOuterTag === true) //its an omitted tag, but we're keeping the outer tag. Don't get its contents or leave it as a self-closing tag if it was one to start with.
        {
            var numChildren = element.children.length;
            if (numChildren === 0 && isSelfClosing(element, element.outerHTML) === true) return null;
            return [];
        }

        if (elementType === _elementTypes.Text || elementType === _elementTypes.CDATA || elementType === _elementTypes.Comment) //all text node types, just return the text
        {
            return (element.textContent == null) ? "" : element.textContent;
        }
        else if (elementType === _elementTypes.Document || elementType === _elementTypes.DocumentFragment || elementType === _elementTypes.Element) //all of the element types that can have children
        {
            var numChildren = (getShadowChildren === true) ? element.shadowRoot.childNodes.length : element.childNodes.length;
            if (numChildren === 0)
            {
                if (elementType === _elementTypes.Element)
                {
                    if (isSelfClosing(element, element.outerHTML) === true) return null; //null is our special value for self-closing tags
                    if (element.textContent != null && element.textContent.length > 0) return element.textContent; //if it is not self-closing, return the text content.
                    return []; //otherwise it has to children or no text content.
                }
                else
                {
                    return []; //otherwise it has to children or no text content.
                }
            }
            else //has children, recursively get the contents of each one
            {
                var children = [];
                var elementChildren = (getShadowChildren === true) ?  element.shadowRoot.childNodes : element.childNodes;
                for (var x = 0; x < numChildren; x++)
                {
                    var childEle = elementChildren[x];
                    var domTreeEle = toDomTreeElement(session, childEle, element, getShadowChildren);
                    if (domTreeEle != null) children.push(domTreeEle);
                }

                return children;
            }
        }
        else //don't know how to handle the node, crash.
        {
            throw new Error("Unknown node type: " + element.nodeType);
        }
    };

    /** Determines whether or not a node is self-closing.
    @param {Element} element Any Element.
    @param {String} outerHTML THe element's outerHTML.
    @returns {Boolean} */
    var isSelfClosing = function (element, outerHTML)
    {
        if (_selfClosingTags.indexOf(element.nodeName.toLowerCase()) !== -1) return true;
        return false;
    };

    /** Turns a DomTreeElement into a string, Document, HTMLElement, or DocumentFragment.
    @param {DomTreeConversionSession} session  The conversion session that contains all the data relevant to the current conversion.
    @param {EVUI.Modules.DomTree.DomTreeElement} element The DomTreeElement to turn into the output format.
    @returns {String|Document|DocumentFragment|Element[]}*/
    var convertFromDomTreeElement = function (session, toString)
    {
        var frag = domTreeToNodes(session, session.source);
        if (toString === true)
        {
            var div = document.createElement("div");
            div.appendChild(frag);

            return div.innerHTML;
        }
        else
        {
            return frag;
        }
    };

    /**Converts a DomTreeElement to a string.
    @param {DomTreeConversionSession} session The conversion session that contains all the data relevant to the current conversion.
    @param {EVUI.Modules.DomTree.DomTreeElement} element The element to turn into a string.
    @returns {String}*/
    var domTreeToElementString = function (session, element)
    {
        var outerHTML = "<" + element.tagName + "";
        var attributes = getAttributeString(session, element);

        if (element.content == null) //content is null, it's a self closing element
        {
            var closingTag = "/>";

            if (attributes != null)
            {
                return outerHTML + " " + attributes + closingTag;
            }
            else
            {
                return outerHTML + " " + closingTag;
            }
        }
        else //content is not null, regular closing tag having element
        {
            var closingTag = "</" + element.tagName + ">";
            var contents = contentsToString(session, element.content);

            if (attributes != null)
            {
                return outerHTML + " " + attributes + ">" + contents + closingTag;
            }
            else
            {
                return outerHTML + ">" + contents + closingTag;
            }
        }
    };

    /**Gets a string that contains all of an element's attributes.
    @param {DomTreeConversionSession} session  The conversion session that contains all the data relevant to the current conversion.
    @param {EVUI.Modules.DomTree.DomTreeElement} element The element to get the attribute string of. 
    @returns {String}*/
    var getAttributeString = function (session, element)
    {
        if (element.attrs == null) return null; //no attributes, no string
        var dataURLAttr = null;

        if (element.DataUrl != null && element.DataUrl.Data != null) //we have a data URL, prepare to inject it into the appropriate element
        {
            dataURLAttr = element.DataUrl.AttributeName.toLowerCase();
        }

        var attrString = "";
        var numAttrs = element.attrs.length;
        for (var x = 0; x < numAttrs; x++)
        {
            var curAttr = element.attrs[x];
            if (curAttr.key.toLowerCase() === dataURLAttr) //matches our dataRL attribute, inject the data URL string
            {
                attrString += curAttr.key + "\=\"" + element.DataUrl.Data + ((x === numAttrs - 1) ? "\"" : "\" ");
            }
            else //otherwise put the value in as normal
            {
                attrString += curAttr.key + "\=\"" + curAttr.val + ((x === numAttrs - 1) ? "\"" : "\" ");
            }
        }

        return attrString;
    };

    /**Turns the inner contents of a DomTreeElement into a string.
    @param {DomTreeConversionSession} session The conversion session that contains all the data relevant to the current conversion.
    @param {EVUI.Modules.DomTree.DomTreeElement[]} elementContents The array of child elements to turn into content.
    @returns {String}*/
    var contentsToString = function (session, elementContents)
    {
        if (typeof elementContents === "string") return elementContents;

        var contents = "";
        if (EVUI.Modules.Core.Utils.isArray(elementContents) == false) return contents;

        var numContents = elementContents.length;
        for (var x = 0; x < numContents; x++)
        {
            contents += domTreeToElementString(session, elementContents[x]);
        }

        return contents;
    }

    /**Turns a DomTreeElement into the HTML or XML content it represents.
    @param {DomTreeConversionSession} session  The conversion session that contains all the data relevant to the current conversion.
    @param {EVUI.Modules.DomTree.DomTreeElement} domTreeEle The DomTreeElement to turn into a DOM object.
    @param {Node} parentNode The parent node of the node being created.
    @returns {Document|DcumentFragment} */
    var domTreeToNodes = function (session, domTreeEle, parentNode)
    {
        if (parentNode == null) parentNode = document.createDocumentFragment();
        var node = null;

        if (domTreeEle.type === EVUI.Modules.DomTree.DomTreeElementType.CDATA)
        {
            node = document.createCDATASection(domTreeEle.content);
        }
        else if (domTreeEle.type === EVUI.Modules.DomTree.DomTreeElementType.Comment)
        {
            node = document.createComment(unescapeText(domTreeEle.content));            
        }
        else if (domTreeEle.type === EVUI.Modules.DomTree.DomTreeElementType.Document)
        {
            return domTreeToDocument(session, domTreeEle);
        }
        else if (domTreeEle.type === EVUI.Modules.DomTree.DomTreeElementType.Element)
        {
            node = domTreeToElements(session, domTreeEle, parentNode);
        }
        else if (domTreeEle.type === EVUI.Modules.DomTree.DomTreeElementType.Text)
        {
            node = document.createTextNode(unescapeText(domTreeEle.content));
        }
        else if (domTreeEle.type === EVUI.Modules.DomTree.DomTreeElementType.DocumentFragment)
        {
            return domTreeToDocumentFragment(session, domTreeEle);
        }
        else
        {
            throw Error("Invalid element type.");
        }

        parentNode.appendChild(node);
        return parentNode;
    };

    /**Removes any special escaped characters from a HTML string.
    @param {String} str The string to unescape.
    @returns {String} */
    var unescapeText = function (str)
    {
        if (typeof str !== "string") return str;
        if (_unescapeHtml.test(str) === true)
        {
            return str.replace(_unescapeHtml, function (val)
            {
                if (val === "&gt;")
                {
                    return ">";
                }
                else if (val === "&lt;")
                {
                    return "<";
                }
                else
                {
                    return val;
                }
            });
        }
        else
        {
            return str;
        }
    };

    /**Turns a DomTreeElement into a Document object.
    @param {DomTreeConversionSession} session  The conversion session that contains all the data relevant to the current conversion.
    @param {EVUI.Modules.DomTree.DomTreeElement} domTreeEle The DomTree element to turn into a Document.
    @returns {Document}*/
    var domTreeToDocument = function (session, domTreeEle)
    {
        var isXML = EVUI.Modules.Core.Utils.hasFlag(domTreeEle.flags, EVUI.Modules.DomTree.DomTreeElementFlags.XML);

        if (typeof domTreeEle.content === "string" || domTreeEle.content == null)
        {
            var content = (domTreeEle.content == null) ? domTreeToElementString(session, domTreeToElementString) : domTreeEle.content;

            var parser = new DOMParser();
            return parser.parseFromString(content, (isXML === true) ? "text/xml" : "text/html");
        }
        else if (EVUI.Modules.Core.Utils.isArray(domTreeEle.content) === true)
        {
            var frags = [];
            var numChildren = domTreeEle.content.length;

            var html = null;
            var head = null;
            var body = null;
            var rootsFound = false;

            for (var x = 0; x < numChildren; x++)
            {
                var curContent = domTreeEle.content[x];
                var curFrag = domTreeToNodes(session, curContent);

                if (isXML === false && rootsFound === false)
                {
                    var lowerTagName = curContent.tagName.toLowerCase();
                    if (lowerTagName === "html")
                    {
                        html = curFrag;
                        rootsFound = true;
                    }
                    else if (lowerTagName === "head")
                    {
                        head = curFrag;
                    }
                    else if (lowerTagName === "body")
                    {
                        body = curFrag;
                    }

                    if (body != null && head != null) rootsFound = true;
                }

                frags.push(curFrag);
            }

            var parser = new DOMParser();
            var doc = parser.parseFromString("", (isXML === true) ? "text/xml" : "text/html");

            if (isXML === true)
            {
                doc.documentElement.childNodes.forEach(function (node) { node.remove(); });
                doc.documentElement.appendChild(frags[0].childNodes[0]);
            }
            else
            {
                if (html != null)
                {
                    doc.documentElement.replaceWith(html.childNodes[0]);
                }
                else
                {
                    if (head != null || body != null)
                    {
                        if (head != null) doc.head.replaceWith(head.childNodes[0]);
                        if (body != null) doc.body.replaceWith(body.childNodes[0]);
                    }
                    else
                    {
                        var numFrags = frags.length;
                        for (var x = 0; x < numFrags; x++)
                        {
                            doc.append(frags[x].childNodes);
                        }
                    }
                }
            }

            return doc;
        }

        return null;
    };

    /**Turns a DomTreeElement into a hierarchy of Element objects.
    @param {DomTreeConversionSession} session  The conversion session that contains all the data relevant to the current conversion.
    @param {EVUI.Modules.DomTree.DomTreeElement} domTreeEle The DomTreeElement to turn into a hierarchy of elements.
    @returns {Element} */
    var domTreeToElements = function (session, domTreeEle)
    {
        var node = null;

        if (domTreeEle.content == null)
        {
            var eleStr = domTreeToElementString(session, domTreeEle);
            var temp = document.createElement("div");
            temp.innerHTML = eleStr;

            node = temp.childNodes[0];
            node.remove();
        }
        else
        {
            node = document.createElement(domTreeEle.tagName);
            if (domTreeEle.attrs != null)
            {
                var numAttrs = domTreeEle.attrs.length;
                for (var x = 0; x < numAttrs; x++)
                {
                    var curAttr = domTreeEle.attrs[x];
                    node.setAttribute(curAttr.key, curAttr.val)
                }
            }

            if (typeof domTreeEle.content === "string")
            {
                node.textContent = domTreeEle.content;
                node.textContent = domTreeEle.content;
            }
            else if (EVUI.Modules.Core.Utils.isArray(domTreeEle.content) === true)
            {
                var numChildren = domTreeEle.content.length;
                for (var x = 0; x < numChildren; x++)
                {
                    domTreeToNodes(session, domTreeEle.content[x], node);
                }
            }
        }

        if (EVUI.Modules.Core.Utils.isArray(domTreeEle.shadowContent) === true)
        {
            var shadowParent = node.attachShadow({ mode: "open" });
            var numChildren = domTreeEle.shadowContent.length;
            for (var x = 0; x < numChildren; x++)
            {
                domTreeToNodes(session, domTreeEle.shadowContent[x], shadowParent);
            }
        }

        return node;
    };

    /**Turns a DomTreeElemenmt into a document fragment.
    @param {DomTreeConversionSession} session  The conversion session that contains all the data relevant to the current conversion.
    @param {EVUI.Modules.DomTree.DomTreeElement} domTreeEle The DomTreeElement to turn into a document fragment.
    @returns {DocumentFragment} */
    var domTreeToDocumentFragment = function (session, domTreeEle)
    {
        var docFrag = document.createDocumentFragment();
        if (typeof domTreeEle.content === "string")
        {
            docFrag.appendChild(domTreeEle.content);
        }
        else if (EVUI.Modules.Core.Utils.isArray(domTreeEle.content) === true)
        {
            var numContent = domTreeEle.content.length;
            for (var x = 0; x < numContent; x++)
            {
                domTreeToNodes(session, domTreeEle.content[x], docFrag);
            }
        }

        return docFrag;
    };

    /**Ensures that there is a valid DomTreeParseOptions object.
    @param {EVUI.Modules.DomTree.DomTreeElementOptions} options The user's options object.
    @returns {DomTreeParseOptions}*/
    var ensureParseOptions = function (options)
    {
        var newOptions = (options == null || typeof options !== "object") ? new EVUI.Modules.DomTree.DomTreeElementOptions() : EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.DomTree.DomTreeElementOptions(), options);
        return buildDomTreeParseOptions(newOptions);
    };

    /**Entry point into the conversion process where a string is turned into an object model that can be converted into actual DOM Nodes or DomTreeElements.
    @param {String} htmlString A string of HTML to parse.
    @returns {HtmlParseNode} */
    var convertFromString = function (htmlString)
    {
        //make a new session to hold the details of the conversion
        var session = new HtmlParseSession();
        session.rawHtml = htmlString;
        session.rawHtmlLength = htmlString.length;

        //get all the literal text spans - text that is not escaped because it is in quotes, graves, comments, literal html tags, etc
        session.literalTextSpans = getLiteralTextSpansFromQuotesAndComments(session);
        session.literalTextSpans = session.literalTextSpans.concat(getLiteralTextSpansFromTags(session));
        session.literalTextSpans.sort(function (a, b) { return a.start - b.start });

        //make the root block representing a document fragment
        var rootBlock = new HtmlParseNode();
        rootBlock.htmlContent = session.rawHtml;
        rootBlock.index = 0;
        rootBlock.length = session.rawHtml.length;
        rootBlock.blockType = EVUI.Modules.DomTree.DomTreeElementType.DocumentFragment;

        //get all the tag opens and closes that were NOT contained in any of the literal text spans.
        getTagOpensAndCloses(session);
        session.currentTagClose = session.tagCloses[0];
        session.currentTagOpen = session.tagOpens[0];

        //set the index of where we are in the literal text span array back to zero.
        session.lastTextSpanIndex = 0;

        //parse the HTML.
        return parseBlock(session, rootBlock);
    };

    /**Gets all the text that is inside of quotes, comments, graves, script tags, etc and keeps it around in an array so that we can double-check if any text later on in the parsing process is part of some non-escaped non-html text so that we know to skip it.
    @param {HtmlParseSession} session The parse session with all the details about the conversion.
    @returns {LiteralTextSpan[]} */
    var getLiteralTextSpansFromQuotesAndComments = function (session)
    {
        var allNonHtml = [];

        matchAll(session, _quotesAndComments, allNonHtml);
        matchAll(session, _escapeCharacters, allNonHtml);

        //get a complete array of all our matches and then sort it so that they are all in order.
        //var allNonHtml = allQuotesAndComments.concat(allEscaped);
        allNonHtml.sort(function (a, b) { return a.index - b.index; });

        var numMatches = allNonHtml.length;
        var inDoubleQuotes = false;
        var inSingleQuotes = false;
        var inMultiLineComment = false;
        var inGrave = false;
        var inComment = false;
        var inCData = false;
        var inHtmlOrCode = true;
        var spans = [];
        var startIndex = 0;

        //walk through each match and make little spans for the non-interpreted text. Once one type of block opens, the others are ignored until the block finishes because they can all contain each other.
        for (var x = 0; x < numMatches; x++)
        {
            var match = allNonHtml[x];

            if (match[0] === "/*") //start of a multi-line comment
            {
                if (inHtmlOrCode === true) //we're in the code, signal the start of a multi-line comment
                {
                    inMultiLineComment = true;
                    startIndex = match.index;
                    inHtmlOrCode = false;
                }
            }
            else if (match[0] === "*/") //end of a multi-line comment
            {
                if (inMultiLineComment === true) //ONLY if we had started a multi-line comment do we complete the span
                {
                    var span = new LiteralTextSpan();
                    span.start = startIndex;
                    span.end = match.index + match[0].length;
                    span.text = session.rawHtml.substr(span.start, span.end - span.start);

                    spans.push(span);

                    inMultiLineComment = false;
                    inHtmlOrCode = true;
                    startIndex = 0;
                }
            }
            else if (match[0] === "//") //single-line comment
            {
                if (inHtmlOrCode === true)
                {
                    var span = new LiteralTextSpan();
                    span.start = match.index;

                    var endMatch = session.rawHtml.indexOf("\n", match.index); //walk to the end of the line
                    if (endMatch === -1) session.rawHtml.indexOf("\r", match.index);
                    if (endMatch !== -1) //did we find the end of the line?
                    {
                        span.end = endMatch; //yes, capture everything up to the end
                    }
                    else //no, get the rest of the string
                    {
                        span.end = session.rawHtml.length;
                    }

                    span.text = session.rawHtml.substr(span.start, span.end - span.start);
                    spans.push(span);

                    //it is possible for there to be other comment/quote characters inside the sinlge-line comment, so we skip over all of them until we are onto the next line.
                    while (allMatches[x + 1].index < span.end)
                    {
                        x++;
                    }
                }
            }
            else if (match[0] === "\"") //either a start or end double-quote
            {
                var isEscaped = (match.index > 1 && session.rawHtml[match.index - 1] === '\\' && session.rawHtml[match.index - 2] != '\\'); //MAKE SURE IT IS NOT ESCAPED, THEY RUIN EVERYTHING
                if (isEscaped === true) continue;

                if (inHtmlOrCode === true) //start the double quotes session
                {
                    inHtmlOrCode = false;
                    inDoubleQuotes = true;
                    startIndex = match.index;
                }
                else //not in code text, see if we're in a double quote span
                {
                    if (inDoubleQuotes === true) //we are in a quote span, finish it off
                    {
                        var span = new LiteralTextSpan();
                        span.start = startIndex;
                        span.end = match.index + match[0].length;
                        span.text = session.rawHtml.substr(span.start, span.end - span.start);

                        spans.push(span);

                        inDoubleQuotes = false;
                        inHtmlOrCode = true;
                    }
                }
            }
            else if (match[0] === "\'") //either start or end of a single-quote span
            {
                var isEscaped = (match.index > 1 && session.rawHtml[match.index - 1] === '\\' && session.rawHtml[match.index - 2] != '\\'); //once again, make sure it's not escaped
                if (isEscaped === true) continue;

                if (inHtmlOrCode === true) //start the single quote span
                {
                    inHtmlOrCode = false;
                    inSingleQuotes = true;
                    startIndex = match.index;
                }
                else
                {
                    if (inSingleQuotes === true) //end the single quote span
                    {
                        var span = new LiteralTextSpan();
                        span.start = startIndex;
                        span.end = match.index + match[0].length;
                        span.text = session.rawHtml.substr(span.start, span.end - span.start);

                        spans.push(span);

                        inSingleQuotes = false;
                        inHtmlOrCode = true;
                    }
                }
            }
            else if (match[0] === "`")
            {
                var isEscaped = (match.index > 1 && session.rawHtml[match.index - 1] === '\\' && session.rawHtml[match.index - 2] != '\\'); //once again, make sure it's not escaped
                if (isEscaped === true) continue;

                if (inHtmlOrCode === true) //start the single quote span
                {
                    inHtmlOrCode = false;
                    inGrave = true;
                    startIndex = match.index;
                }
                else
                {
                    if (inGrave === true) //end the single quote span
                    {
                        var span = new LiteralTextSpan();
                        span.start = startIndex;
                        span.end = match.index + match[0].length;
                        span.text = session.rawHtml.substr(span.start, span.end - span.start);

                        spans.push(span);

                        inGrave = false;
                        inHtmlOrCode = true;
                    }
                }
            }
            else if (match[0] === "<!--") //starting a HTML comment
            {
                if (inHtmlOrCode === true)
                {
                    inHtmlOrCode = false;
                    startIndex = match.index + match[0].length;
                    inComment = true;
                }
            }
            else if (match[0] === "-->") //ending a HTML content
            {
                if (inHtmlOrCode === false && inComment === true)
                {
                    var span = new LiteralTextSpan();
                    span.start = startIndex;
                    span.end = match.index;
                    span.text = session.rawHtml.substr(span.start, match.index);

                    spans.push(span);
                    inHtmlOrCode = true;
                    inComment = false;
                }
            }
            else if (match[0].toLowerCase() === "<!cdata[[") //in a CDATA section (even though those aren't in HTML, didn't know that when I wrote this)
            {
                if (inHtmlOrCode === true)
                {
                    inHtmlOrCode = false;
                    startIndex = match.index + match[0].length;
                    inCData = true;
                }
            }
            else if (match[0] === "]]>") //end of CDATA section
            {
                if (inHtmlOrCode === false && inCData === true)
                {
                    var span = new LiteralTextSpan();
                    span.start = startIndex;
                    span.end = match.index;
                    span.text = session.rawHtml.substr(span.start, match.index);

                    spans.push(span);
                    inHtmlOrCode = true;
                    inCData = true;
                }
            }
        }

        return spans;
    };

    /**Walks all the tags that can contain literal text (namely, '<' and '>') and add them to our text spans array. We do this after we get all the literal text spans in quotes and comments so that if we find a tag that's actually in a string we know to ignore it.
    @param {HtmlParseSession} session The parse session with all the details about the conversion.
    @returns {LiteralTextSpan[]}*/
    var getLiteralTextSpansFromTags = function (session)
    {
        var allFullText = matchAll(session, _literalTextTags);        

        //gets the end of the tag that contains the literal text. Not the closing tag, but the end of the opening tag.
        var getTagClosingBracket = function (index, endIndex)
        {
            var nextIndex = session.rawHtml.indexOf(">", index);
            while (nextIndex !== -1 && nextIndex < endIndex)
            {
                if (inLiteralString(session, nextIndex) === false) return nextIndex;
                nextIndex = session.rawHtml.indexof(">", nextIndex);
            }

            return -1;
        };

        var spans = [];
        var inScript = false;
        var inStyle = false;
        var inTextArea = false;
        var inPre = false;
        var inHtml = true;
        var numAll = allFullText.length;
        var startIndex = 0;

        //reset the span index so we start looking at the beginning
        session.lastTextSpanIndex = 0;

        for (var x = 0; x < numAll; x++)
        {
            var match = allFullText[x];
            var lastIndex = session.lastTextSpanIndex;

            if (inLiteralString(session, match.index) === true) continue; //our match was in a literal string, ignore it.

            var lowerMatch = match[0].toLowerCase();

            if (lowerMatch.indexOf("<script") !== -1) //start of a script tag
            {
                if (inHtml === true)
                {
                    inScript = true;
                    inHtml = false;
                    startIndex = match.index;
                }
            }
            else if (match[0].match(/\<\/\s*script/i) != null) //start of a script closing tag.
            {
                if (inScript === true)
                {
                    var span = new LiteralTextSpan();
                    var contentStartIndex = getTagClosingBracket(startIndex, match.index);
                    if (contentStartIndex === -1)
                    {
                        span.start = startIndex;
                    }
                    else
                    {
                        span.start = contentStartIndex + 1;
                    }

                    span.end = match.index;
                    span.text = session.rawHtml.substr(span.start, span.end - span.start);
                    spans.push(span);
                    session.lastTextSpanIndex = lastIndex;

                    inScript = false;
                    inHtml = true;
                }
            }
            else if (lowerMatch.indexOf("<textarea") !== -1) //start of a textarea input
            {
                if (inHtml === true)
                {
                    inTextArea = true;
                    inHtml = false;
                    startIndex = match.index;
                }
            }
            else if (match[0].match(/\<\/\s*textarea/i) != null) //end of a textarea input
            {
                if (inTextArea === true)
                {
                    var span = new LiteralTextSpan();
                    var contentStartIndex = getTagClosingBracket(startIndex, match.index);
                    if (contentStartIndex === -1)
                    {
                        span.start = startIndex;
                    }
                    else
                    {
                        span.start = contentStartIndex + 1;
                    }

                    span.end = match.index;
                    span.text = session.rawHtml.substr(span.start, span.end - span.start);
                    spans.push(span);
                    session.lastTextSpanIndex = lastIndex;

                    inTextArea = false;
                    inHtml = true;
                }
            }
            else if (lowerMatch.indexOf("<style") !== -1) //beginning of a style tag
            {
                if (inHtml === true)
                {
                    inStyle = true;
                    inHtml = false;
                    startIndex = match.index;
                }
            }
            else if (match[0].match(/\<\/\s*style/i) != null) //end of a style tag
            {
                if (inStyle === true)
                {
                    var span = new LiteralTextSpan();
                    var contentStartIndex = getTagClosingBracket(startIndex, match.index);
                    if (contentStartIndex === -1)
                    {
                        span.start = startIndex;
                    }
                    else
                    {
                        span.start = contentStartIndex + 1;
                    }

                    span.end = match.index;
                    span.text = session.rawHtml.substr(span.start, span.end - span.start);
                    spans.push(span);
                    session.lastTextSpanIndex = lastIndex;

                    inStyle = false;
                    inHtml = true;
                }
            }
            else if (lowerMatch.indexOf("<pre") !== -1) //start of a "pre" tag
            {
                if (inHtml === true)
                {
                    inPre = true;
                    inHtml = false;
                    startIndex = match.index;
                }
            }
            else if (match[0].match(/\<\/\s*pre/i) != null) //end of a "pre" tag
            {
                if (inPre === true)
                {
                    var span = new LiteralTextSpan();
                    var contentStartIndex = getTagClosingBracket(startIndex, match.index);
                    if (contentStartIndex === -1)
                    {
                        span.start = startIndex;
                    }
                    else
                    {
                        span.start = contentStartIndex + 1;
                    }

                    span.end = match.index;
                    span.text = session.rawHtml.substr(span.start, span.end - span.start);
                    spans.push(span);
                    session.lastTextSpanIndex = lastIndex;

                    inPre = false;
                    inHtml = true;
                }
            }
        }

        return spans;
    };

    /**Determines whether or not a given index is inside of a literal text span or not.
    @param {HtmlParseSession} session The parse session with all the details about the conversion.
    @param {Number} index The index to check.
    @returns {Boolean}*/
    var inLiteralString = function (session, index)
    {
        var numLiterals = session.literalTextSpans.length;
        var startIndex = (session.lastTextSpanIndex >= 0) ? session.lastTextSpanIndex : 0;

        for (var x = startIndex; x < numLiterals; x++)
        {
            var literal = session.literalTextSpans[x];
            if (index >= literal.start && index < literal.end) //in a string
            {
                session.lastTextSpanIndex = x; //set the start index so we don't start looking from zero again
                return true;
            }

            if (literal.start > index) //the text span's start is beyond the index, we are done.
            {
                session.lastTextSpanIndex = x;
                return false;
            }
        }

        return false;
    };

    /**Gets all the tag opens and closes that are not in literal strings or special tags. This gives us all the opens and closes of HTML elements in the string (and some badly formatted text content occasionally).
    @param {HtmlParseSession} session The parse session with all the details about the conversion.*/
    var getTagOpensAndCloses = function (session)
    {
        var allOpensAndCloses =  matchAll(session, _tagOpenCloses);

        session.lastTextSpanIndex = 0;
        var numOpenCloses = allOpensAndCloses.length;
        for (var x = 0; x < numOpenCloses; x++)
        {
            var curMatch = allOpensAndCloses[x];
            if (inLiteralString(session, curMatch.index) === true) continue;

            if (curMatch[0] === ">" || curMatch[0] === "/>") session.tagCloses.push(curMatch);
            if (curMatch[0] === "<" || curMatch[0] === "</") session.tagOpens.push(curMatch);
        }

        return;
    };

    /**Gets all the matches of a RegExp in a string.
    @param {HtmlParseSession|String} session The parse session with all the details about the conversion.
    @param {RegExp} regex The regular expression to iterate over again and again.
    @param {[]} matches An array to push the matches into.
    @returns {RegExpExecArray[]} */
    var matchAll = function (session, regex, matches)
    {
        if (matches == null) matches = [];
        if (typeof session === "string")
        {
            var tempSession =
            {
                rawHtml: session
            };

            session = tempSession;
        }

        if (_canMatchAll === true)
        {
            var allMatches = session.rawHtml.matchAll(regex);

            var match = allMatches.next();
            while (match != null && match.done !== true)
            {
                matches.push(match.value);
                match = allMatches.next();
            }
        }
        else
        {
            var match = regex.exec(session.rawHtml);
            while (match != null)
            {
                matches.push(match);
                match = regex.exec(session.rawHtml);
            }
        }

        return matches;
    };

    /**Parsing function for turning a HTML string into an object hierarchy that can be translated into Nodes or DomTreeElements.
    @param {HtmlParseSession} session The parse session with all the details about the conversion.
    @param {HtmlParseNode} parentNode The HTmlParseNode that is the parent of the current function context's parse.
    @returns {HtmlParseNode} */
    var parseBlock = function (session, parentNode)
    {
        var originalIndex = session.index;
        var blockEnd = parentNode.index + parentNode.length;
        var nextBlock = null;
        var previousToken = null;
        var previousTokenValue = null;
        var lastClose = null;
        var parentStack = [parentNode]; //the "stack" of parent elements are we drill deeper into a hierarchy of HTML. Parents are added when we go deeper and are popped off when we reach their closing tag.
        var parentStackLength = 0;
        var curParent = parentNode;

        while (session.index < session.rawHtmlLength && session.index < blockEnd) //while we have not gone outside the bounds of the block or the raw html string, keep looking for elements.
        {
            var curToken = getNextToken(session);
            if (curToken == null)  //no more tokens, we are done.
            {
                //make a text block out of whatever is left.
                var textBlock = getTextNode(session, session.rawHtmlLength);
                if (textBlock == null) return parentNode;

                if (parentNode.content == null) parentNode.content = [];
                parentNode.content.push(textBlock);
                return parentNode;
            }

            var tokenValue = curToken[0];

            if (tokenValue === "<" || tokenValue === "</") //token is a tag open of an opening tag or the open of a closing tag
            {
                session.currentTagOpen = curToken;
                if (lastClose == null || lastClose.index < curToken.index - 1 || previousTokenValue === ">") //if the last token was a tag close, check and see what content is between the two tags
                {
                    var textBlock = getTextNode(session, curToken.index); //the gap should always be a text block unless the gap space is zero characters long
                    if (textBlock != null)
                    {
                        if (curParent.content == null) curParent.content = [];
                        var childrenLength = curParent.content.length;
                        if (childrenLength > 0 && curParent.content[childrenLength - 1].tagName === "#text") //merge together two adjacent text nodes (which shouldn't ever happen, but dumb html with too many < or > that are outside of tags causes this sometimes)
                        {
                            curParent.content[childrenLength - 1].content += textBlock.content;
                        }
                        else
                        {
                            curParent.content.push(textBlock);
                        }
                    }
                }
                else if (previousTokenValue === "<" || previousTokenValue === "</") //bad html, keep going to the next tag
                {
                    session.tagOpenIndex++;
                    session.currentTagOpen = session.tagOpens[session.tagOpenIndex];

                    continue;
                }

                session.tagOpenIndex++;
                session.index = curToken.index;
                session.currentTagOpen = session.tagOpens[session.tagOpenIndex];

                previousToken = curToken;
                previousTokenValue = tokenValue;
            }            
            else if (tokenValue === ">" || tokenValue === "/>") //token is the close of an open tag or the close of a self-closing tag
            {
                session.currentTagClose = curToken;

                if (previousTokenValue === "<") //previous token was an open tag, we are in a tag body
                {
                    var newNode = new HtmlParseNode();
                    if (populateTagDetails(session, newNode, previousToken.index, curToken.index + 1) === true)
                    {
                        newNode.index = previousToken.index;
                        if (tokenValue === "/>") //self closing tag, no children possible
                        {
                            newNode.isSelfClosing = true;
                            if (curParent.content == null) curParent.content = [];
                            curParent.content.push(newNode);
                        }
                        else //not a self closing tag, it could have children so push it on to the bottom of the parent stack
                        {
                            if (newNode.blockType === EVUI.Modules.DomTree.DomTreeElementType.Comment)
                            {
                                if (curParent.content == null) curParent.content = [];
                                curParent.content.push(newNode);
                            }
                            else if (newNode.blockType === EVUI.Modules.DomTree.DomTreeElementType.CDATA)
                            {
                                if (curParent.content == null) curParent.content = [];
                                curParent.content.push(newNode);
                            }
                            else
                            {
                                parentStackLength = parentStack.push(curParent);
                                if (curParent.content == null) curParent.content = [];
                                curParent.content.push(newNode);
                                curParent = newNode;
                            }
                        }
                    }
                    else //failed to get tag details, usually due to malformed html. Keep going.
                    {
                        session.tagCloseIndex++;
                        session.currentTagClose = session.tagCloses[session.tagCloseIndex];

                        continue;
                    }
                }
                else if (previousTokenValue === "</" && tokenValue === ">") //we arrived at a closing tag. See if the tag name is the same as the current parent's tag name so we know we have reached a complete tag.
                {
                    var tag = session.rawHtml.substring(previousToken.index + 2, curToken.index + 1)
                    var tagName = getTagName(session, tag, tag.length, true);
                    if (curParent.tagName === tagName)
                    {
                        curParent.length = (curToken.index + tokenValue.length) - curParent.index;;
                        curParent = parentStack.pop();
                        parentStackLength--;
                    }
                }
                else if (previousTokenValue === ">" || previousTokenValue === "/>") //bad html, keep going to the next tag
                {
                    session.tagCloseIndex++;
                    session.currentTagClose = session.tagCloses[session.tagCloseIndex];

                    continue;
                }

                session.tagCloseIndex++;
                session.index = curToken.index + tokenValue.length;
                session.currentTagClose = session.tagCloses[session.tagCloseIndex];

                previousToken = curToken;
                previousTokenValue = tokenValue;
                lastClose = curToken;
            }
        }

        return parentNode;
    };

    /**Gets the next token (open or close bracket) in the HTML parse session. 
    @param {HtmlParseSession} session The parse session with all the details about the conversion.
    @returns {RegExpMatchArray}*/
    var getNextToken = function (session)
    {
        var tagCloseIndex = session.currentTagClose == null ? Number.MAX_VALUE : session.currentTagClose.index;
        var tagOpenIndex = session.currentTagOpen == null ? Number.MAX_VALUE : session.currentTagOpen.index;
        var earliestMatch = Math.min(tagOpenIndex, tagCloseIndex);

        if (earliestMatch === Number.MAX_VALUE) return null;
        if (earliestMatch === tagCloseIndex) return session.currentTagClose;
        if (earliestMatch === tagOpenIndex) return session.currentTagOpen;

        return null;
    };

    /**Makes a HtmlParseNode representing a text node.
    @param {HtmlParseSession} session  The parse session with all the details about the conversion.
    @param {Number} endIndex The ending index of the string of raw text in the rawHtml string.
    @returns {HtmlParseNode} */
    var getTextNode = function (session, endIndex)
    {
        if (session.index === endIndex) return null; //no string to return

        var rawContent = session.rawHtml.substring(session.index, endIndex);
        if (rawContent !== "")
        {
            var textBlock = new HtmlParseNode();
            textBlock.blockType = EVUI.Modules.DomTree.DomTreeElementType.Text;
            textBlock.index = session.index;
            textBlock.length = rawContent.length;
            textBlock.tagName = "#text";
            textBlock.content = rawContent;

            return textBlock;
        }

        return null;
    };

    /**Populates the tag details for a HtmlParseNode that is not a text node.
    @param {HtmlParseSession} session The parse session with all the details about the conversion.
    @param {HtmlParseNode} block The block being populated.
    @param {Number} openIndex The start index of the block's opening tag.
    @param {Number} closeIndex The end index of the block's opening tag.
    @returns {Boolean}*/
    var populateTagDetails = function (session, block, openIndex, closeIndex)
    {
        //get the full open tag for the content
        var tag = session.rawHtml.substring(openIndex, closeIndex);
        var tagLength = tag.length;

        //get the tag's name
        block.tagName = getTagName(session, tag, tagLength, false);
        if (block.tagName === "") //no tag name means invalid HTML
        {
            return false;
        }
        else if (block.tagName === "#comment")
        {
            block.blockType = EVUI.Modules.DomTree.DomTreeElementType.Comment;
            block.content = tag.substring(4, tagLength - 3);
        }
        else if (block.tagName === "#cdata")
        {
            block.blockType = EVUI.Modules.DomTree.DomTreeElementType.CDATA;
            block.content = tag.substring(9, tagLength - 3);
        }
        else //it wasn't a comment or CDATA, so it's a vanilla element. Go get it's attributes if it has any,
        {
            block.blockType = EVUI.Modules.DomTree.DomTreeElementType.Element;
            block.attributes = getTagAttributes(session, tag.substring(block.tagName.length + 1, tagLength - 1).trim());
        }

        return true;
    };

    /**Gets the name of a tag.
    @param {HtmlParseSession} session The parse session with all the details about the conversion.
    @param {String} tagContent The raw string of tag HTML.
    @param {Number} contentLength THe length of the raw string of tag HTML.
    @param {Boolean} getClosing Whether or not we are getting a closing tag.
    @returns {String}*/
    var getTagName = function (session, tagContent, contentLength, getClosing)
    {
        var hasAttributes = (getClosing === false) ? true : false;
        if (hasAttributes === true) hasAttributes = /\'|\"|\s/.test(tagContent);
            
        if (hasAttributes === false)
        {
            var existing = _tagCache[tagContent];
            if (existing != null) return existing;
        }

        var tagEnd = 0;
        var tagStart = 0;

        var startMatch = tagContent.match(_tagNameStart);
        if (startMatch != null)
        {
            tagStart = startMatch[0].length;
        }

        if (tagContent[tagStart] === "!") //special cases for comments and CDATA
        {
            if (contentLength > tagStart + 3 && tagContent.substr(tagStart + 1, 2) === "--") return "#comment";
            if (contentLength > tagStart + 9 && tagContent.substr(tagStart + 1, 7).toLowerCase() === "![cdata[") return "#cdata";
        }

        if (contentLength > 4 && getClosing === true) //special cases for getting a normalized tag name for comments and CDATA
        {
            if (tagContent[contentLength - 4] === "-" && tagContent[contentLength - 3] === "-") return "#comment";
            if (tagContent[contentLength - 4] === "]-" && tagContent[contentLength - 3] === "]") return "#cdata";
        }        

        //walk the string and stop at the first character that signals the end of the first word in the tag. This will be the tag name.
        for (var x = tagStart; x < contentLength; x++)
        {
            var curChar = tagContent[x];
            if (_tagNameEnd.test(curChar) === false)
            {
                tagEnd = x;
            }
            else
            {
                break;
            }
        }

        //return the substring from the tag content that is the tag name.
        var tagName = tagContent.substring(tagStart, tagEnd + 1).toUpperCase();

        if (hasAttributes === false)
        {
            _tagCache[tagContent] = tagName;
        }

        return tagName;
    };


    /**Walks the contents of a tag and pulls out all the attribute key-value pairs (or sometimes, just keys).
    @param {HtmlParseSession} session The parse session with all the details about the conversion.
    @param {String} tagContent The raw contents of the opening HTML tag.
    @returns {EVUI.Modules.DomTree.DomTreeElementAttribute[]}*/
    var getTagAttributes = function (session, tagContent)
    {
        if (tagContent === "") return [];
        //if (/\'|\"|\s/.test(tagContent) === false) return []; //if it has no quotes or whitespace it has no attributes

        var tempSession =
        {
            rawHtml: tagContent,
            attributes: []
        }

        //get all the characters that can mark the start or stop of an attribute in the tag
        var components = tagContent; //(_canMatchAll === true) ? Array.from(tagContent.matchAll(_attributeComponents)) : matchAll(tempSession, _attributeComponents);
        var numComponents = components.length;

        var lastIndex = 0;
        var lastEqualsIndex = 0;
        var quoteOpenIndex = 0;
        var inMarkup = true;
        var inSingleQuote = false;
        var inDoubleQuote = false;
        var inParens = false;

        for (var x = 0; x < numComponents; x++) //walk each component and figure out what is a key and what is a value.
        {
            //var curComponent = components[x];
            //var value = curComponent[0];

            var value = components[x];

            if (value === "=")
            {
                if (inMarkup === true)
                {
                    lastEqualsIndex = x; //curComponent.index;
                }
            }
            else if (value === "'")
            {
                //if (curComponent.index > 0 && tagContent[curComponent.index - 1] === "\\") continue;
                if (x > 0 && tagContent[x - 1] === "\\") continue;

                if (inDoubleQuote === true || inParens === true) continue;
                if (inSingleQuote === false)
                {
                    quoteOpenIndex = x;//curComponent.index;
                    inSingleQuote = true;
                    inMarkup = false;
                }
                else
                {
                    getAttribute(tempSession, lastIndex, lastEqualsIndex, quoteOpenIndex, x/*curComponent.index*/);
                    lastIndex = x + 1; //curComponent.index + 1;
                    inSingleQuote = false;
                    inMarkup = true;
                }
            }
            else if (value === "\"")
            {
                //if (curComponent.index > 0 && tagContent[curComponent.index - 1] === "\\") continue;
                if (x > 0 && tagContent[x - 1] === "\\") continue;

                if (inSingleQuote === true || inParens === true) continue;
                if (inDoubleQuote === false)
                {
                    quoteOpenIndex = x; //curComponent.index;
                    inDoubleQuote = true;
                    inMarkup = false;
                }
                else
                {
                    getAttribute(tempSession, lastIndex, lastEqualsIndex, quoteOpenIndex, x/*curComponent.index*/);
                    lastIndex = x + 1; //curComponent.index + 1;
                    inDoubleQuote = false;
                    inMarkup = true;
                }
            }
            else if (value === "(") //we mark parenthesis so that if we have a parameter list inside of an attribute value that has a literal string in it, we don't accidentally chop apart the attribute.
            {
                if (inSingleQuote === true || inDoubleQuote === true)
                {
                    inParens = true;
                }
            }
            else if (value === ")") //we mark parenthesis so that if we have a parameter list inside of an attribute value that has a literal string in it, we don't accidentally chop apart the attribute.
            {
                if (inSingleQuote === true || inDoubleQuote === true)
                {
                    inParens = false;
                }
            }
        }

        if (tempSession.attributes.length === 0 || lastIndex != tempSession.rawHtml.length)
        {
            var multipleAttributes = tagContent.substring(lastIndex, tempSession.rawHtml.length).trim().split(/\s+/g); //sometimes we have attributes with no "=" after them, but they are always separated by some whitespace. Grab any between the last attribute close and the next open.
            var numAttrs = multipleAttributes.length;
            if (numAttrs > 0)
            {
                for (var x = 0; x < numAttrs; x++)
                {
                    var attribute = new EVUI.Modules.DomTree.DomTreeElementAttribute();
                    attribute.key = multipleAttributes[x];
                    attribute.val = "";

                    tempSession.attributes.push(attribute);
                }
            }
        }

        return tempSession.attributes;
    };

    /**Makes an attribute based on the contents of a tag.
    @param {HtmlParseSession} tempSession A dummy session representing the contents of the html tag. Used to pass a reference to the HTML string around rather than passing the whole string for every attribute.
    @param {Number} lastIndex The index of the last attribute processed.
    @param {Number} lastEqualsIndex The index of the last equals sign processed int the string.
    @param {Number} quoteOpenIndex The index of where the quotes around the attribute value open.
    @param {Number} quoteCloseIndex The index where the quotes around the attribute value close.
    @returns {EVUI.Modules.DomTree.DomTreeElementAttribute} */
    var getAttribute = function (tempSession, lastIndex, lastEqualsIndex, quoteOpenIndex, quoteCloseIndex)
    {
        var attributeName = tempSession.rawHtml.substring(lastIndex, lastEqualsIndex).trim();
        if (attributeName.length === 0) return false;

        if (/\s+/.test(attributeName) === true)
        {
            var multipleAttributes = attributeName.split(/\s+/g); //sometimes we have attributes with no "=" after them, but they are always separated by some whitespace. Grab any between the last attribute close and the next open.
            var numAttrs = multipleAttributes.length;
            if (numAttrs > 1)
            {
                for (var x = 0; x < numAttrs - 1; x++)
                {
                    var attribute = new EVUI.Modules.DomTree.DomTreeElementAttribute();
                    attribute.key = multipleAttributes[x].toLowerCase(); //attribute names are ALWAYS lower case
                    attribute.val = "";

                    tempSession.attributes.push(attribute);
                }

                attributeName = multipleAttributes[numAttrs - 1];
            }
        }
        
        var value = tempSession.rawHtml.substring(quoteOpenIndex + 1, quoteCloseIndex);
        var attribute = new EVUI.Modules.DomTree.DomTreeElementAttribute();
        attribute.key = attributeName.toLowerCase();  //attribute names are ALWAYS lower case
        attribute.val = value;

        tempSession.attributes.push(attribute);

        return true;
    }

    /**The parse session with all the details about the conversion.
    @class*/
    var HtmlParseSession = function ()
    {
        /**String. The complete raw HTML string being parsed.
        @type {String}*/
        this.rawHtml = null;

        /**Number. The length of the raw HTML string being parsed.
        @type {String}*/
        this.rawHtmlLength = 0;

        /**Number. The current index of the parse operation in the HTML string.
        @type {Number}*/
        this.index = 0;

        /**Number. The index of the current tag open symbol in the tagOpens array.
        @type {Number}*/
        this.tagOpenIndex = 0;

        /**Number. The index of the current tag close symbol in the tagCloses array.
        @type {Number}*/
        this.tagCloseIndex = 0;

        /**Array. The sequentially ordered array of all the literal text spans in the HTML.
        @type {LiteralTextSpan[]}*/
        this.literalTextSpans = [];

        /**Number. The current index of the parse operation in the literalTextSpans array.*/
        this.lastTextSpanIndex = 0;

        /**Array. The array of every valid HTML tag open symbol in the rawHtml string.
        @type {RegExpMatchArray[]}*/
        this.tagOpens = [];

        /**Array. The array of every valid HTML close tag symbol in the rawHtml string.
        @type {RegExpMatchArray[]}*/
        this.tagCloses = [];

        /**Object. The current tag open token in the parse session.
        @type {RegExpMatchArray}*/
        this.currentTagOpen = null;

        /**Object. The current tag close token in the parse session.
        @type {RegExpMatchArray}*/
        this.currentTagClose = null;
    };

    /**An intermediary object that is created by parsing a HTML string and can be converted into DOM Nodes or DomTreeElements.
    @class*/
    var HtmlParseNode = function ()
    {
        /**Number. The starting index of the HtmlParseNode in the rawHtml string.
        @type {Number}*/
        this.index = -1;

        /**Number. The raw length of the tag's content's length in the rawHtml string.
        @type {Number}*/
        this.length = -1;

        /**Number. The type of block that was being parsed. Must be a value from the DomTreeElementType enum.
        @type {Number}*/
        this.blockType = EVUI.Modules.DomTree.DomTreeElementType.Unknown;

        /**String. The tag name of the HTML Node.
        @type {String}*/
        this.tagName = null;

        /**Array. An array of attribute key-value pairs that are associated with this Node.
        @type {EVUI.Modules.DomTree.DomTreeElementAttribute[]}*/
        this.attributes = [];

        /**String or Array. Either the child HtmlParseNodes of this node, or the raw text content of this Node.
        @type {String|HtmlParseNode[]}*/
        this.content = [];

        /**String. The rawHtml string of this Node.
        @type {String}*/
        this.htmlContent = null;

        /**Boolean. Whether or not this tag is self closing.
        @type {Boolean}*/
        this.isSelfClosing = false;
    };

    /**Recursively translates this HtmlParseNode into a DOM Node hierarchy.
    @param {Node} parent The parent Node of this Node.
    @param {DomTreeParseOptions} options Options for converting the parse node into a Node.
    @returns {Node} */
    HtmlParseNode.prototype.toNode = function (parent, options)
    {
        var node = null;
        if (this.blockType === EVUI.Modules.DomTree.DomTreeElementType.Text)
        {
            node = document.createTextNode(this.content);
        }
        else if (this.blockType === EVUI.Modules.DomTree.DomTreeElementType.DocumentFragment)
        {
            node = document.createDocumentFragment();

            var numChildren = this.content.length
            for (var x = 0; x < numChildren; x++)
            {
                var curChild = this.content[x];
                curChild.toNode(node, options);
            }
        }
        else if (this.blockType === EVUI.Modules.DomTree.DomTreeElementType.CDATA)
        {
            node = document.createCDATASection(this.content);
        }
        else if (this.blockType === EVUI.Modules.DomTree.DomTreeElementType.Comment)
        {
            node = document.createComment(this.content);
        }
        else
        {
            var noSrc = false;
            var noChildren = false;

            if (options.isOmittedTag(this.tagName) === true)
            {
                if (options.elementOptions.includeOmittedElementOuterTag === true)
                {
                    noChildren = true;
                    if (this.tagName === "script") noSrc = true;
                }
                else
                {
                    return null;
                }
            }

            node = document.createElement(this.tagName);

            var numAttrs = this.attributes.length;
            for (var x = 0; x < numAttrs; x++)
            {
                var curAttr = this.attributes[x];
                if (options.isOmittedAttribute(curAttr) === true) continue;
                if (noSrc === true && curAttr.key.toLowerCase() === "src") continue;

                node.setAttribute(curAttr.key, curAttr.val);
            }

            if (noChildren === false)
            {
                var numChildren = this.content.length
                for (var x = 0; x < numChildren; x++)
                {
                    var curChild = this.content[x];
                    curChild.toNode(node, options);
                }
            }
        }

        if (parent != null) parent.append(node);
        return node;
    };

    /**Recursively translates this HtmlParseNode into a DOM Node hierarchy.
    @param {EVUI.Modules.DomTree.DomTreeElement} parent The parent DomTreeElement of this Node.
    @param {DomTreeParseOptions} options Options for converting the parse node into a Node.
    @returns {EVUI.Modules.DomTree.DomTreeElement} */
    HtmlParseNode.prototype.toDomTree = function (parent, options)
    {

        var treeNode = new EVUI.Modules.DomTree.DomTreeElement();
        treeNode.flags = EVUI.Modules.DomTree.DomTreeElementFlags.HTML;
        treeNode.tagName = this.tagName;
        treeNode.type = this.blockType;

        if (this.blockType === EVUI.Modules.DomTree.DomTreeElementType.Text || this.blockType === EVUI.Modules.DomTree.DomTreeElementType.Comment || this.blockType === EVUI.Modules.DomTree.DomTreeElementType.CDATA)
        {
            treeNode.content = this.content;
        }
        else if (this.blockType === EVUI.Modules.DomTree.DomTreeElementType.DocumentFragment)
        {
            treeNode.content = [];
            var numChildren = this.content.length;
            for (var x = 0; x < numChildren; x++)
            {
                this.content[x].toDomTree(treeNode, options);
            }
        }
        else if (this.blockType === EVUI.Modules.DomTree.DomTreeElementType.Element)
        {
            var noSrc = false;
            var noChildren = false;

            if (options.isOmittedTag(this.tagName) === true)
            {
                if (options.elementOptions.includeOmittedElementOuterTag === true)
                {
                    noChildren = true;
                    if (this.tagName.toLowerCase() === "script") noSrc = true;
                }
                else
                {
                    return null;
                }
            }

            if (this.attributes != null)
            {
                var numAttr = this.attributes.length;
                if (numAttr > 0)
                {
                    if (noSrc === true)
                    {
                        treeNode.attrs = [];

                        for (var x = 0; x < numAttr; x++)
                        {
                            var curAttr = this.attributes[x];
                            if (curAttr.key === "src") continue;

                            treeNode.attrs.push(curAttr);
                        }
                    }
                    else
                    {
                        treeNode.attrs = this.attributes;
                    }                    
                }
            }

            if (this.isSelfClosing === true)
            {
                treeNode.content = null;
            }
            else
            {
                
                treeNode.content = [];

                if (noChildren === false)
                {
                    var numChildren = this.content.length;
                    for (var x = 0; x < numChildren; x++)
                    {
                        this.content[x].toDomTree(treeNode, options);
                    }
                }
            }
        }

        if (parent != null && parent.content != null) parent.content.push(treeNode);
        return treeNode;
    };

    /**Represents a span of text that should not be considered when looking for HTML tags.
    @class*/
    var LiteralTextSpan = function ()
    {
        /**Number. The starting index of the text span.
        @type {Number}*/
        this.start = -1;

        /**Number. The ending index of the text span.
        @type {Number}*/
        this.end = -1;

        /**String. The actual text of the span.
        @type {String}*/
        this.text = null;
    };

    /**Options for controlling how a string of HTML is parsed.
    @class*/
    var DomTreeParseOptions = function ()
    {
        /**
        @type {EVUI.Modules.DomTree.DomTreeElementOptions}*/
        this.elementOptions = null;

        /**Object. An object dictionary for all of the elements to be omitted keyed by their tag names.
        @type {{}}*/
        this.omittedElementsDic = {};

        /**Object. An object dictionary for all of the attributes to be omitted keyed by their attribute names.
        @type {{}}*/
        this.omittedAttributesDic = {};
    };

    /**Determins if a tag is an omitted tag or not.
    @param {String} tagName The name of the tag to check.*/
    DomTreeParseOptions.prototype.isOmittedTag = function (tagName)
    {
        if (typeof tagName !== "string") return true;
        if (this.omittedAttributesDic[tagName.toLowerCase()] === true) return true;

        return false;
    };

    /**Determines if an attribute is an omitted attribute or not.
    @param {EVUI.Modules.DomTree.DomTreeElementAttribute} attribute The attribute to test for inclusion.*/
    DomTreeParseOptions.prototype.isOmittedAttribute = function (attribute)
    {
        if (attribute == null || EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(attribute.key) == true) return true;
        var potentialMatch = false;

        var lowerKey = attribute.key.toLowerCase();

        if (this.omittedAttributesDic[lowerKey] === true)
        {
            potentialMatch = true;
        }
        else if (_eventHandlerAttributeStart.test(attribute.key) === true)
        {
            if (window[lowerKey] !== undefined)
            {
                this.omittedAttributesDic[lowerKey] = true;
                potentialMatch = true;
            }
        }

        if (potentialMatch === true)
        {
            if (this.elementOptions.inlineEventHandlerFilter instanceof RegExp)
            {
                if (this.elementOptions.inlineEventHandlerFilter.test(attribute.val) === true) return false;
            }
            else if (typeof this.elementOptions.inlineEventHandlerFilter === "function")
            {
                if (this.elementOptions.inlineEventHandlerFilter(attribute.key, attribute.val) === true) return false;
            }

            return true;
        }

        return false;
    };
};

/**A lightweight, JSON serializeable representation of a HTML or XML node's markup.
@class*/
EVUI.Modules.DomTree.DomTreeElement = function ()
{
    /**Number. Bit flags for describing special states or metadata that an element can have.
    @type {String}*/
    this.flags = EVUI.Modules.DomTree.DomTreeElementFlags.None;

    /**String. The tag name of the element.
    @type {String}*/
    this.tagName = undefined;

    /**Number. A value from the EVUI.Modules.DomTree.DomTreeElementType enum indicating the type of element.
    @type {Number}*/
    this.type = EVUI.Modules.DomTree.DomTreeElementType.Unknown;

    /**An array of EVUI.Modules.DomTree.DomTreeElementAttribute representing the attributes on the element.
    @type {EVUI.Modules.DomTree.DomTreeElementAttribute[]}*/
    this.attrs = undefined;

    /**String or Array. The contents of the Element.
    @type {Null|String|EVUI.Modules.DomTree.DomTreeElement[]}*/
    this.content = undefined;

    /**String or Array. The shadow contents of the Element.
    @type {Null|String|EVUI.Modules.DomTree.DomTreeElement[]}*/
    this.shadowContent = undefined;

    /**Object. The related node that the DomTreeElement was derived from.
    @type {Node}*/
    this.node = undefined;
};

/**Recursively turns this DomTreeElement into a DOM Node hierarchy. Assigns the node reference to this DomTreeElement and all of its children.
@param {EVUI.Modules.DomTree.DomTreeElementOptions} options Options to control how this DomTreeElement is turned into a Node.
@returns {Node}*/
EVUI.Modules.DomTree.DomTreeElement.prototype.toNode = function (options)
{
    if (this.node != null) return this.node;

    if (this.type === EVUI.Modules.DomTree.DomTreeElementType.DocumentFragment || this.type === EVUI.Modules.DomTree.DomTreeElementType.Document)
    {
        this.node = EVUI.Modules.DomTree.Converter.fromDomTreeElement(this, options);
    }
    else
    {
        this.node = EVUI.Modules.DomTree.Converter.fromDomTreeElement(this, options).childNodes[0];
    }

    var assignNodes = function (domTree, node)
    {
        if (typeof domTree.content === "string" || domTree.content == null) return;

        var numChildren = domTree.content.length;
        for (var x = 0; x < numChildren; x++)
        {
            var curChild = domTree.content[x];
            curChild.node = node.childNodes[x];

            assignNodes(curChild, curChild.node);
        }
    };

    assignNodes(this, this.node);
    return this.node;
};

/**Searches the DomTreeElement hierarchy looking for DomTreeElements that meet the predicate.
@param {EVUI.Modules.DomTree.Constants.Fn_Selector} selector The function used to select which DomTreeElements should be in the return set.
@param {Boolean} returnFirstMatch Whether or not to stop the search when the first match is found.
@returns {EVUI.Modules.DomTree.DomTreeElement[]}*/
EVUI.Modules.DomTree.DomTreeElement.prototype.search = function (selector, returnFirstMatch)
{
    var results = [];
    if (typeof selector !== "function") return results;

    if (selector(this) === true)
    {
        results.push(this);
        if (returnFirstMatch === true) return results;
    }

    if (this.content != null && typeof this.content !== "string")
    {
        var contentCopy = this.content.slice();
        var numChildren = contentCopy.length;
        for (var x = 0; x < numChildren; x++)
        {
            var curContent = contentCopy[x];
            var childResults = (curContent == null) ? null : curContent.search(selector);
            if (childResults != null)
            {
                var numResults = childResults.length;
                if (returnFirstMatch === true && numResults > 0) return childResults;

                for (var y = 0; y < numResults; y++)
                {
                    results.push(childResults[y]);
                }
            }
        }
    }

    return results;
};

/**Clones a DomTreeElement and optionally clones all of its children recursively.
@returns {EVUI.Modules.DomTree.DomTreeElement}*/
EVUI.Modules.DomTree.DomTreeElement.prototype.clone = function (recursive)
{
    var newEle = new EVUI.Modules.DomTree.DomTreeElement();
    if (this.attrs != null)
    {
        newEle.attrs = [];
        var numAttrs = this.attrs.length;
        for (var x = 0; x < numAttrs; x++)
        {
            var curAttr = this.attrs[x];
            var newAttr = new EVUI.Modules.DomTree.DomTreeElementAttribute();
            newAttr.key = curAttr.key;
            newAttr.val = curAttr.val;

            newEle.attrs.push(newAttr);
        }
    }

    newEle.flags = this.flags;
    newEle.tagName = this.tagName;
    newEle.type = this.type;

    if (this.content == null) return newEle;
    if (typeof this.content === "string")
    {
        newEle.content = this.content;
    }
    else if (EVUI.Modules.Core.Utils.isArray(this.content) === true)
    {
        newEle.content = [];
        if (recursive === true)
        {
            var numContent = this.content.length;
            for (var x = 0; x < numContent; x++)
            {
                newEle.content.push(this.content[x].clone(true));
            }
        }
    }

    if (EVUI.Modules.Core.Utils.isArray(this.shadowContent) === true)
    {
        newEle.shadowContent = [];
        if (recursive === true)
        {
            var numContent = this.shadowContent.length;
            for (var x = 0; x < numContent; x++)
            {
                newEle.content.push(this.shadowContent[x].clone(true));
            }
        }
    }

    return newEle;
};

/**Flags for describing special states or metadata about an Element.
@enum*/
EVUI.Modules.DomTree.DomTreeElementFlags =
{
    /**Default.*/
    None: 0,
    /**Element is a HTML node.*/
    HTML: 1,
    /**Element is a XML node.*/
    XML: 2,
    /**Element contains a reference to a foreign resource.*/
    HasForiegnResource: 4,
    /**Element exists in the shadow DOM.*/
    IsInShadowDom: 8
};

Object.freeze(EVUI.Modules.DomTree.DomTreeElementFlags);

/**Represents an Element attribute key-value pair.
@class*/
EVUI.Modules.DomTree.DomTreeElementAttribute = function ()
{
    /**String. The attribute name.
    @type {String}*/
    this.key = null;

    /**String. The attribute value.
    @type {String}*/
    this.val = null;
};

/**The type of element a DomTreeElement represents.
@enum*/
EVUI.Modules.DomTree.DomTreeElementType =
{
    /**Default.*/
    Unknown: 0,
    /**The element is a regular element.*/
    Element: 1,
    /**The element is a text node element.*/
    Text: 2,
    /**The element is a comment node element.*/
    Comment: 3,
    /**The element is an entire HTML or XML document.*/
    Document: 4,
    /**The element is a HTML document fragment.*/
    DocumentFragment: 5,
    /**THe element is a CDATA type element.*/
    CDATA: 6
};

Object.freeze(EVUI.Modules.DomTree.DomTreeElementType);

/**Options for converting A HTMLDocument, XMLDocument, Element, or DocumentFragment into an object (a EVUI.Resources.JSONXRElement) or from an object.
@class*/
EVUI.Modules.DomTree.DomTreeElementOptions = function ()
{
    /**Array. When converting an HTMLDOcument, Element, or DocumentFragment into an Object (a EVUI.Modules.DomTree.DomTreeElement), these are the tag names to not capture.
    @type {String[]}*/
    this.omittedElements = [];

    /**Boolean. When converting an HTMLDOcument, Element, or DocumentFragment into an Object (a EVUI.Modules.DomTree.DomTreeElement), and the tag name matches one of the tags in the OmittedDomTreeElements array, this controls whether or not to omit the entire element, or just omits its contents (keeping its outer tag and attributes intact). False by default.
    @type {Boolean}*/
    this.includeOmittedElementOuterTag = false;

    /**Boolean. When converting an HTMLDocument, Element, or DocumentFragment into an Object (a EVUI.Modules.DomTree.DomTreeElement), this controls whether or not to store an external resource or "a" tag's src or href links as absolute URLs or keep them as relative links if they were already relative. False by default.
     @type {Boolean}*/
    this.absoluteUrls = false;

    /**Whether or not to include a reference to the node that a DomTreeElement was derived from. Note that including the node will make the object graph unable to be converted into JSON. False by default. */
    this.includeNodeReferences = false;

    /**Boolean. Whether or not an Element is allowed to have a in-lined event handlers (i.e. "onclick") as attributes on when creating an Element from a DomTreeElement or HTML string.
    @type {Boolean}*/
    this.noInlineEventHandlers = false;

    /**Object. If noInlineEventHandlers is set to true, this is the "exception case" filter where certain inline handlers are allowed, but must satisfy a RegExp or predicate function in order to be included.
    @type {RegExp|EVUI.Modules.DomTree.Constants.Fn_AttributeFilter}*/
    this.inlineEventHandlerFilter = null;
};

/**Global instance of the DomTreeConverter.
@type {EVUI.Modules.DomTree.DomTreeConverter}*/
EVUI.Modules.DomTree.Converter = null;
(function ()
{
    var converter = null;
    Object.defineProperty(EVUI.Modules.DomTree, "Converter", {
        get: function ()
        {
            if (converter == null) converter = new EVUI.Modules.DomTree.DomTreeConverter();
            return converter;
        },
        configurable: false,
        enumerable: true
    });
})();

delete $evui.dromTree;

/**Global instance of the DomTreeConverter.
@type {EVUI.Modules.DomTree.DomTreeConverter}*/
$evui.domTree = null;
(function ()
{
    Object.defineProperty($evui, "domTree", {
        get: function ()
        {
            return EVUI.Modules.DomTree.Converter;
        },
        enumerable: true
    });
})();

/**Converts a HTMLElement, Document (XML or HTML), or DocumentFragment into a JSON structure representing the input.
@param {HTMLElement|Document|DocumentFragment} source Any HTMLElement, Document (XML or HTML), or DocumentFragment to turn into a DomTreeElement hierarchy.
@param {EVUI.Modules.DomTree.DomTreeElementOptions} options The options for creating the DomTreeElement hierarchy.
@returns {EVUI.Modules.DomTree.DomTreeElement} */
$evui.toDomTreeElement = function (source, options)
{
    return $evui.domTree.toDomTreeElement(source, options);
};

/**Converts a DomTreeElement hierarchy into a String, Document, Element, or DocumentFragment.
@param {EVUI.Modules.DomTree.DomTreeElement} domTreeElement The Root element to convert.
@param {EVUI.Modules.DomTree.DomTreeElementOptions} options The options for reading the DomTreeElement hierarchy.
@param {Boolean} toString Whether or not to return a string of html instead of a Node object.
@returns {HTMLElement|Document|DocumentFragment}*/
$evui.fromDomTreeElement = function (domTreeElement, options, toString)
{
    if (toString === true)
    {
        return $evui.domTree.fromDomTreeElementToString(domTreeElement, options);
    }
    else
    {
        return $evui.domTree.fromDomTreeElement(domTreeElement, options);
    }
};

/**Converts a HTML string into a DocumentFragment containing the parsed HTML.
 
 NOTE: This function is significantly slower than the native DOM parser used when setting innerHTML of an element, however there are certain situations where the native DOM parser applies certain rules to the creation of new elements based on the tag name of the element whose innerHTML is being set.
 
 For example, making a <tr> inside of a div via setting the div's innerHTML doesn't work correctly (the tr element is missing in the result in most browsers). There may be other cases where similar rules are applied, and the reason for the existence of this function is to bypass those rules. 
 
 For more performant code, use innerHTML - for code that may fail based on the browser's parsing rules (i.e. having the need to parse any unknown HTML into DOM nodes), this function becomes an option instead.
@param {String} htmlString A string of HTML to turn into a DocumentFragment.
@param {EVUI.Modules.DomTree.DomTreeElementOptions} options Options to control the conversion of the string into Dom Nodes.
@returns {DocumentFragment} */
$evui.parseHtml = function (html, options)
{
    return $evui.domTree.htmlToDocumentFragment(html, options);
};

/**Converts a HTML string into a hierarchy of DomTreeElements representing a DocumentFragment containing the parsed HTML.
@param {String} htmlString A string of HTML to turn into a hierarchy of DomTreeElements.
@param {EVUI.Modules.DomTree.DomTreeElementOptions} options Options to control the conversion of the string into DomTreeElements.
@returns {EVUI.Modules.DomTree.DomTreeElement}*/
$evui.parseHtmlToDomTree = function (html, options)
{
    return $evui.domTree.htmlToDomTree(html, options);
};

Object.freeze(EVUI.Modules.DomTree);

/*#ENDWRAP(DT)#*/


/********************************************************Dropdowns.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.Dropdown|Drop)#*/
/*#REPLACE(EVUI.Modules.Dropdown|Drop)#*/

/**Module that uses the Pane module to create pre-configured drop-down menus.
@module*/
EVUI.Modules.Dropdowns = {};

/*#MODULEDEF(Drop|"1.0";|"Dropdown")#*/
/*#VERSIONCHECK(EVUI.Modules.Dropdown|Drop)#*/

EVUI.Modules.Dropdowns.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
    Panes: Object.freeze({ version: "1.0", required: true })
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.Dropdowns.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();

Object.freeze(EVUI.Modules.Dropdowns.Dependencies);

EVUI.Modules.Dropdowns.Constants = {};

/**Function for selecting a PaneEntry object. Return true to select the PaneEntry parameter as part of the result set.
@param {EVUI.Modules.Dropdowns.Dropdown} dropdown The PaneEntry providing metadata about a Dropdown object.
@returns {Boolean}*/
EVUI.Modules.Dropdowns.Constants.Fn_DropdownSelector = function (dropdown) { return true; }

/**Function for reporting whether or not a Dropdown was successfully Loaded.
@param {Boolean} success Whether or not the load operation completed successfully.*/
EVUI.Modules.Dropdowns.Constants.Fn_LoadCallback = function (success) { };

/**Function for reporting whether or not an operation Dropdown was successful.
@param {Boolean} success Whether or not the operation completed successfully.*/
EVUI.Modules.Dropdowns.Constants.Fn_DropdownOperationCallback = function (success) { };

EVUI.Modules.Dropdowns.Constants.CSS_Position = "evui-position";
EVUI.Modules.Dropdowns.Constants.CSS_ClippedX = "evui-clipped-x";
EVUI.Modules.Dropdowns.Constants.CSS_ClippedY = "evui-clipped-y";
EVUI.Modules.Dropdowns.Constants.CSS_ScrollX = "evui-scroll-x";
EVUI.Modules.Dropdowns.Constants.CSS_ScrollY = "evui-scroll-y"
EVUI.Modules.Dropdowns.Constants.CSS_Flipped = "evui-flipped";
EVUI.Modules.Dropdowns.Constants.CSS_Transition_Show = "evui-transition-show";
EVUI.Modules.Dropdowns.Constants.CSS_Transition_Hide = "evui-transition-hide";

/**String. The name of the ID attribute for the Dropdown, used to look up a definition of a Dropdown.
@type {String}*/
EVUI.Modules.Dropdowns.Constants.Attribute_ID = "evui-dd-id";

/**String. The name of the attribute that signifies which element should receive initial focus when the Dropdown is displayed.
@type {String}*/
EVUI.Modules.Dropdowns.Constants.Attribute_Focus = "evui-dd-focus";

/**String. The name of the attribute that signifies that a click event on the Element should close the Dropdown.
@type {String}*/
EVUI.Modules.Dropdowns.Constants.Attribute_Close = "evui-dd-close";

/**String. The name of the attribute that signifies that a drag event on the Element should move the Dropdown.
@type {String}*/
EVUI.Modules.Dropdowns.Constants.Attribute_Drag = "evui-dd-drag-handle";

/**String. The name of the attribute on an element that triggers the showing of a Dropdown what the URL to get the Dropdown's HTML from is (Requires EVUI.Modules.Http).
@type {String}*/
EVUI.Modules.Dropdowns.Constants.Attribute_SourceURL = "evui-dd-src";

/**String. The name of the attribute on an element that triggers the showing of a Dropdown of what placeholder to load for the Dropdown's HTML (Requires EVUI.Modules.HtmlLoaderController).
@type {String}*/
EVUI.Modules.Dropdowns.Constants.Attribute_PlaceholderID = "evui-dd-placeholder-id";

/**String. The name of the attribute on an element that triggers the showing or hiding of a Dropdown whether or not the Dropdown should be unloaded when it is hidden.
@type {String}*/
EVUI.Modules.Dropdowns.Constants.Attribute_UnloadOnHide = "evui-dd-unload";

/**String. The name of the attribute on an element that triggers the showing or hiding of a Dropdown that is used to indicate special behavior as defined by a consumer of the Dropdown.
@type {String}*/
EVUI.Modules.Dropdowns.Constants.Attribute_Context = "evui-dd-cxt";

/**String. The name of the attribute on an element that triggers the showing of a Dropdown what CSS selector to use to find the element to show as the Dropdown. Only the first result will be used.
@type {String}*/
EVUI.Modules.Dropdowns.Constants.Attribute_Selector = "evui-dd-selector";

/**String. The name of the attribute that controls the orientation of the dropdown. The value must be a combination of values from the DropdownOrientation enum.
@type {String}*/
EVUI.Modules.Dropdowns.Constants.Attribute_Orientation = "evui-dd-orientation";

/**String. The name of the attribute that controls the orientation of the dropdown. The value must be a value from the DopdownAlignment enum.
@type {String}*/
EVUI.Modules.Dropdowns.Constants.Attribute_Alignment = "evui-dd-alignment"

/**String. The name of the attribute that controls what the dropdown will use to orient itself around. Must be a value from the DropdownMode enum.
@type {String}*/
EVUI.Modules.Dropdowns.Constants.Attribute_DropMode = "evui-dd-mode"

EVUI.Modules.Dropdowns.Constants.Default_ObjectName = "Dropdown";
EVUI.Modules.Dropdowns.Constants.Default_ManagerName = "DropdownManager";
EVUI.Modules.Dropdowns.Constants.Default_CssPrefix = "evui-dd";
EVUI.Modules.Dropdowns.Constants.Default_EventNamePrefix = "evui.dd";
EVUI.Modules.Dropdowns.Constants.Default_AttributePrefix = "evui-dd";

Object.freeze(EVUI.Modules.Dropdowns.Constants);

/**Class for managing Dropdown objects.
@class*/
EVUI.Modules.Dropdowns.DropdownManager = function (services)
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Dropdowns.Dependencies);

    var _self = this; //self-reference for closures

    /**The internal PaneManager of the DropdownManager.
    @type {EVUI.Modules.Panes.PaneManager}*/
    var _manager = null;

    /**The settings overrides for the DropdownManager.
    @type {EVUI.Modules.Panes.PaneManagerSettings}*/
    var _settings = null;

    /**Adds a Dropdown to the WidowManager.
    @param {EVUI.Modules.Dropdowns.Dropdown} dropdown A YOLO object representing a Dropdown object. This object is copied onto a real Dropdown object is then discarded.
    @returns {EVUI.Modules.Dropdowns.Dropdown}*/
    this.addDropdown = function (dropdown)
    {
        if (dropdown == null) throw Error(_settings.objectName + " cannot be null.");
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(dropdown.id) === true) throw Error(_settings.objectName + "must have an id that is a non-whitespace string.");

        var existing = _settings.getPaneEntry(dropdown.id);
        if (existing != null) throw Error("A " + _settings.objectName + " with an id of \"" + dropdown.id + "\" already exists.");

        _manager.addPane(getDefaultPane(dropdown));

        existing = _settings.getPaneEntry(dropdown.id);
        return existing.wrapper;       
    };

    /**Removes a Dropdown from the DropdownManager. Does not unload the Dropdown's element from the DOM.
    @param {EVUI.Modules.Dropdowns.Dropdown|String} dropdownOrID
    @returns {Boolean}*/
    this.removeDropdown = function (dropdownOrID)
    {
        return _manager.removePane(dropdownOrID);
    };

    /**Gets a DropdownEntry object based on its ID or a selector function.
    @param {EVUI.Modules.Dropdowns.Constants.Fn_DropdownSelector|String} dropdownIDOrSelector A selector function to select a Dropdown object (or multiple DropdownEntry objects) or the ID of the Dropdown to get the DropdownEntry for.
    @param {Boolean} getAllMatches If a selector function is provided, all the DropdownEntries that satisfy the selector are included. Otherwise a single DropdownEntry object is returned. False by default.
    @returns {EVUI.Modules.Dropdowns.Dropdown|EVUI.Modules.Dropdowns.Dropdown[]} */
    this.getDropdown = function (dropdownIDOrSelector, getAllMatches)
    {
        var entries = null;

        if (typeof dropdownIDOrSelector === "function")
        {
            entries = _settings.getPaneEntry(function () { return true; }, true).map(function (entry) { return entry.wrapper; }).filter(dropdownIDOrSelector);
            if (getAllMatches !== true && entries != null) return entries[0];
            return entries;
        }
        else
        {
            entries = _settings.getPaneEntry(dropdownIDOrSelector, getAllMatches);
        }

        if (entries == null) return null;

        if (EVUI.Modules.Core.Utils.isArray(entries) === false)
        {
            return entries.wrapper;
        }
        else
        {
            return entries.map(function (entry) { return entry.wrapper; })
        }
    };

    /**Shows (and loads, if necessary or if a reload is requested) a Dropdown asynchronously. Provides a callback that is called once the Dropdown operation has completed successfully or otherwise.
    @param {EVUI.Modules.Dropdowns.Dropdown|String} dropdownOrID Either a YOLO Dropdown object to extend into the existing Dropdown, the real Dropdown reference, or the string ID of the Dropdown to show.
    @param {EVUI.Modules.Dropdowns.DropdownShowArgs|EVUI.Modules.Dropdowns.Constants.Fn_DropdownOperationCallback} dropdownShowArgs Optional.  The arguments for showing the Dropdown, or the callback. If omitted or passed as a function, the Dropdown's existing show/load settings are used instead.
    @param {EVUI.Modules.Dropdowns.Constants.Fn_DropdownOperationCallback} callback Optional. A callback that is called once the operation completes.*/
    this.showDropdown = function (dropdownOrID, dropdownShowArgs, callback)
    {
        var entry = getDropdownAmbiguously(dropdownOrID, true);

        var paneShowArgs = new EVUI.Modules.Panes.PaneShowArgs();
        paneShowArgs.showSettings = _settings.cloneShowSettings(entry.pane.showSettings);
        paneShowArgs.loadArgs = new EVUI.Modules.Panes.PaneLoadArgs();
        paneShowArgs.loadArgs.loadSettings = _settings.cloneLoadSettings(entry.pane.loadSettings);

        if (typeof dropdownShowArgs === "function")
        {
            callback = dropdownShowArgs;
            dropdownShowArgs = null;
        }
        else if (dropdownShowArgs != null && typeof dropdownShowArgs === "object")
        {
            dropdownShowArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownShowArgs(paneShowArgs), dropdownShowArgs, ["type"]);
            if (dropdownShowArgs.showSettings != null)
            {
                dropdownShowArgs.showSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownShowSettings(paneShowArgs.showSettings), dropdownShowArgs.showSettings);
            }
            else
            {
                dropdownShowArgs.showSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownShowSettings(paneShowArgs.showSettings), entry.wrapper.showSettings);
            }


            if (dropdownShowArgs.loadArgs != null && dropdownShowArgs.loadArgs.loadSettings != null)
            {
                dropdownShowArgs.loadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownLoadArgs(paneShowArgs.loadArgs), dropdownShowArgs.loadArgs, ["type"]);
                dropdownShowArgs.loadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownLoadSettings(paneShowArgs.loadArgs.loadSettings), dropdownShowArgs.loadArgs.loadSettings);
            }
            else
            {
                dropdownShowArgs.loadArgs = new EVUI.Modules.Dropdowns.DropdownLoadArgs(paneShowArgs.loadArgs);
                dropdownShowArgs.loadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownLoadSettings(paneShowArgs.loadArgs.loadSettings), entry.wrapper.loadSettings, ["type"]); ;
            }
        }
        else
        {
            dropdownShowArgs = null;
        }

        if (dropdownShowArgs == null)
        {
            dropdownShowArgs = new EVUI.Modules.Dropdowns.DropdownShowArgs(paneShowArgs);
            dropdownShowArgs.showSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownShowSettings(paneShowArgs.showSettings), entry.wrapper.showSettings);
            dropdownShowArgs.loadArgs = new EVUI.Modules.Dropdowns.DropdownLoadArgs(paneShowArgs.loadArgs);
            dropdownShowArgs.loadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownLoadSettings(paneShowArgs.loadArgs.loadSettings), entry.wrapper.loadSettings);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(dropdownShowArgs);

        _manager.showPane(entry.pane.id, paneShowArgs, callback);
    };

    /**Awaitable. (and loads, if necessary or if a reload is requested) a Dropdown asynchronously.
    @param {EVUI.Modules.Dropdowns.Dropdown|String} dropdownOrID Either a YOLO Dropdown object to extend into the existing Dropdown, the real Dropdown reference, or the string ID of the Dropdown to show.
    @param {EVUI.Modules.Dropdowns.DropdownShowArgs} dropdownShowArgs Optional.  A YOLO object representing the arguments for showing the Dropdown. If omitted, the Dropdown's existing show/load settings are used instead.
    @returns {Promise<Boolean>}*/
    this.showDropdownAsync = function (dropdownOrID, dropdownShowArgs)
    {
        return new Promise(function (resolve)
        {
            _self.showDropdown(dropdownOrID, dropdownShowArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Hides (and unloads if requested) a Dropdown asynchronously. Provides a callback that is called call once the Dropdown operation has completed successfully or otherwise.
    @param {EVUI.Modules.Dropdowns.Dropdown|String} dropdownOrID Either a YOLO Dropdown object to extend into the existing Dropdown, the real Dropdown reference, or the string ID of the Dropdown to hide.
    @param {EVUI.Modules.Dropdowns.DropdownHideArgs|EVUI.Modules.Dropdowns.Constants.Fn_DropdownOperationCallback} dropdownHideArgs Optional. A YOLO object representing arguments for hiding a Dropdown or a callback. If omitted or passed as a function, the Dropdown's existing hide/unload settings are used instead.
    @param {EVUI.Modules.Dropdowns.Constants.Fn_DropdownOperationCallback} callback Optional. A callback that is called once the operation completes.*/
    this.hideDropdown = function (dropdownOrID, dropdownHideArgs, callback)
    {
        var entry = getDropdownAmbiguously(dropdownOrID);

        var paneHideArgs = new EVUI.Modules.Panes.PaneHideArgs();
        paneHideArgs.unloadArgs = new EVUI.Modules.Panes.PaneUnloadArgs();

        if (typeof dropdownHideArgs === "function")
        {
            callback = dropdownHideArgs;
            dropdownHideArgs = null;
        }
        else if (dropdownHideArgs != null && typeof dropdownHideArgs === "object")
        {
            dropdownHideArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownHideArgs(paneHideArgs), dropdownHideArgs, ["type"]);
            dropdownHideArgs.unloadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownUnloadArgs(paneHideArgs.unloadArgs, dropdownHideArgs.unloadArgs));
        }
        else
        {
            dropdownHideArgs = null;
        }


        if (dropdownHideArgs == null)
        {
            dropdownHideArgs = new EVUI.Modules.Dropdowns.DropdownHideArgs(paneHideArgs);
            dropdownHideArgs.unloadArgs = new EVUI.Modules.DropdownUnloadArgs(paneHideArgs.unloadArgs);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(dropdownHideArgs);
        _manager.hidePane(entry.pane.id, paneHideArgs, callback);
    };

    /**Awaitable. Hides (and unloads if requested) a Dropdown asynchronously.
    @param {EVUI.Modules.Dropdowns.Dropdown|String} dropdownOrID Either a YOLO Dropdown object to extend into the existing Dropdown, the real Dropdown reference, or the string ID of the Dropdown to hide.
    @param {EVUI.Modules.Dropdowns.DropdownHideArgs} dropdownHideArgs Optional. A YOLO object representing the arguments for hiding a Dropdown. If omitted, the Dropdown's existing hide/unload settings are used instead.
    @returns {Promise<Boolean>}*/
    this.hideDropdownAsync = function (dropdownOrID, dropdownHideArgs)
    {
        return new Promise(function (resolve)
        {
            _self.hideDropdown(dropdownOrID, dropdownHideArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Hides all visible Dropdowns asynchronously. Provides a callback function that is called once all the visible Dropdowns have been hidden.
    @param {EVUI.Modules.Panes.DropdownHideArgs} dropdownHideArgs Optional. A YOLO object representing the arguments for hiding a Dropdown. If omitted, the Dropdown's existing hide/unload settings are used instead.
    @param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback The callback that is called once all the Dropdown's hide operations have completed.*/
    this.hideAllDropdowns = function (dropdownHideArgs, callback)
    {
        if (typeof callback !== "function") callback = function () { };
        var allVisible = this.getDropdown(function (dd) { return dd.isVisible; });
        var numVisible = allVisible.length;
        var numHidden = 0;

        if (numVisible === 0) return callback(true);

        for (var x = 0; x < numVisible; x++)
        {
            this.hideDropdown(allVisible[x], dropdownHideArgs, function ()
            {
                numHidden++;
                if (numHidden === numVisible)
                {
                    return callback(true);
                }
            });
        }
    };

    /**Awaitable. Hides all Dropdowns asynchronously.
    @param {EVUI.Modules.Panes.PaneHideArgs} paneHideArgs Optional. A YOLO object representing the arguments for hiding a Dropdown. If omitted, the Dropdown's existing hide/unload settings are used instead.
    @returns {Promise<Boolean>} */
    this.hideAllDropdownsAsync = function (paneHideArgs)
    {
        return new Promise(function (resolve)
        {
            _self.hideAllDropdowns(paneHideArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Asynchronously loads a Dropdown. Provides a callback that is called after the operation has completed successfully or otherwise.
    @param {EVUI.Modules.Dropdowns.Dropdown|String} dropdownOrID Either a YOLO Dropdown object to extend into the existing Dropdown, the real Dropdown reference, or the string ID of the Dropdown to load.
    @param {EVUI.Modules.Dropdowns.DropdownLoadArgs|EVUI.Modules.Dropdowns.Constants.Fn_DropdownOperationCallback} dropdownLoadArgs Optional. A YOLO object representing arguments for loading a Dropdown or a callback. If omitted or passed as a function, the Dropdown's existing load settings are used instead.
    @param {EVUI.Modules.Dropdowns.Constants.Fn_DropdownOperationCallback} callback Optional. A callback to call once the operation completes.*/
    this.loadDropdown = function (dropdownOrID, dropdownLoadArgs, callback)
    {
        var entry = getDropdownAmbiguously(dropdownOrID, false);

        var paneLoadArgs = new EVUI.Modules.Panes.PaneLoadArgs();
        paneLoadArgs.loadSettings = _settings.cloneLoadSettings(entry.pane.loadSettings);

        if (typeof dropdownLoadArgs === "function")
        {
            callback = dropdownLoadArgs;
            dropdownLoadArgs = null;
        }
        else if (dropdownLoadArgs != null && typeof dropdownLoadArgs === "object")
        {
            dropdownLoadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownLoadArgs(paneLoadArgs), dropdownLoadArgs, ["type"]);
            if (dropdownLoadArgs.loadSettings != null)
            {
                dropdownLoadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownLoadSettings(paneLoadArgs.loadSettings), dropdownLoadArgs.loadSettings);
            }
            else
            {
                dropdownLoadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownLoadSettings(paneLoadArgs.loadSettings), entry.wrapper.loadSettings);
            }
        }
        else
        {
            dropdownLoadArgs = null;
        }

        if (dropdownLoadArgs == null)
        {
            dropdownLoadArgs = new EVUI.Modules.Dropdowns.DropdownLoadArgs(paneLoadArgs);
            dropdownLoadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownLoadSettings(paneLoadArgs.loadSettings), entry.wrapper.loadSettings);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(dropdownLoadArgs);
        _manager.loadPane(entry.pane.id, paneLoadArgs, callback);
    };

    /**Awaitable. Asynchronously loads a Dropdown.
    @param {EVUI.Modules.Dropdowns.Dropdown|String} dropdownOrID Either a YOLO Dropdown object to extend into the existing Dropdown, the real Dropdown reference, or the string ID of the Dropdown to load.
    @param {EVUI.Modules.Dropdowns.DropdownLoadArgs} dropdownLoadArgs Optional. A YOLO object representing arguments for loading a Dropdown.
    @returns {Promise<Boolean>}*/
    this.loadDropdownAsync = function (dropdownOrID, dropdownLoadArgs)
    {
        return new Promise(function (resolve)
        {
            _self.loadDropdown(dropdownOrID, dropdownLoadArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Asynchronously unloads a Dropdown, which disconnects the Dropdown's element and removes it from the DOM if it was loaded remotely. Provides a callback that is called after the operation has completed successfully or otherwise.
    @param {EVUI.Modules.Dropdowns.Dropdown|String} dropdownOrID Either a YOLO Dropdown object to extend into the existing Dropdown, the real Dropdown reference, or the string ID of the Dropdown to unload.
    @param {EVUI.Modules.Dropdowns.DropdownUnloadArgs|EVUI.Modules.Dropdowns.Constants.Fn_DropdownOperationCallback} dropdownUnloadArgs Optional. A YOLO object representing arguments for unloading a Dropdown or a callback. If omitted or passed as a function, the Dropdown's existing unload settings are used instead.
    @param {EVUI.Modules.Dropdowns.Constants.Fn_DropdownOperationCallback} callback Optional. A callback to call once the operation completes.*/
    this.unloadDropdown = function (dropdownOrID, dropdownUnloadArgs, callback)
    {
        var entry = getDropdownAmbiguously(dropdownOrID);
        var paneUnloadArgs = new EVUI.Modules.Panes.PaneUnloadArgs();

        if (typeof dropdownUnloadArgs === "function")
        {
            callback = dropdownUnloadArgs;
            dropdownUnloadArgs = null;
        }
        else if (dropdownUnloadArgs != null && typeof dropdownUnloadArgs === "object")
        {
            dropdownUnloadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Dropdowns.DropdownUnloadArgs(paneUnloadArgs), dropdownUnloadArgs);
        }
        else
        {
            dropdownUnloadArgs = null;
        }

        if (dropdownUnloadArgs == null)
        {
            dropdownUnloadArgs = new EVUI.Modules.Dropdowns.DropdownUnloadArgs(paneUnloadArgs);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(dropdownUnloadArgs);
        _manager.unloadPane(entry.pane.id, paneUnloadArgs, callback);
    };

    /**Awaitable. Asynchronously unloads a Dropdown, which disconnects the Dropdown's element and removes it from the DOM if it was loaded remotely.
    @param {EVUI.Modules.Dropdowns.Dropdown|String} dropdownOrID Either a YOLO Dropdown object to extend into the existing Dropdown, the real Dropdown reference, or the string ID of the Dropdown to unload.
    @param {EVUI.Modules.Dropdowns.DropdownUnloadArgs} dropdownUnloadArgs Optional. A YOLO object representing arguments for unloading a Dropdown. If omitted the Dropdown's existing unload settings are used instead.
    @returns {Promise<Boolean>}*/
    this.unloadDropdownAsync = function (dropdownOrID, dropdownUnloadArgs)
    {
        return new Promise(function (resolve)
        {
            _self.unloadDropdown(dropdownOrID, dropdownUnloadArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Makes or extends an object at the end of the PaneManager's function for applying the changes made to the Pane.
    @param {PaneCreationResult} paneCreateResult The result of creating the pane.
    @returns {EVUI.Modules.Panes.Pane}*/
    var makeOrExtendObject = function (createResult)
    {
        var dropdown = createResult.pane.dropdown;
        delete createResult.pane.dropdown;

        return makeOrExtendDropdown(dropdown, createResult.pane, createResult.exists);
    };

    /**Builds the DropdownEventArgs to use in the EventStream.
    @param {EVUI.Modules.Panes.PaneArgsPackage} argsPackage The argument data from the PaneManager about the current state of the Dropdown.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The PaneEventArgs that were created for the event.
    @returns {EVUI.Modules.Dropdowns.DropdownEventArgs} */
    var buildEventArgs = function (argsPackage, paneEventArgs)
    {
        if (argsPackage.foreignArgs == null)
        {
            argsPackage.foreignArgs = createForeignArgs(argsPackage);
        }

        var args = null;
        if (paneEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Hide)
        {
            args = argsPackage.foreignArgs.hideArgs;
        }
        else if (paneEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Load)
        {
            args = argsPackage.foreignArgs.loadArgs;
        }
        else if (paneEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Show)
        {
            args = argsPackage.foreignArgs.showArgs;
        }
        else if (paneEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Unload)
        {
            args = argsPackage.foreignArgs.unloadArgs;
        }

        var dropdownEventArgs = new EVUI.Modules.Dropdowns.DropdownEventArgs(argsPackage, args);
        dropdownEventArgs.cancel = paneEventArgs.cancel;
        dropdownEventArgs.key = paneEventArgs.key;
        dropdownEventArgs.pause = paneEventArgs.pause;
        dropdownEventArgs.resume = paneEventArgs.resume;
        dropdownEventArgs.stopPropagation = paneEventArgs.stopPropagation;
        dropdownEventArgs.context = paneEventArgs.context;

        return dropdownEventArgs;
    };

    /**Makes the foreign arguments for injecting into a DropdownEventArgs object from the PaneManager.
    @param {EVUI.Modules.Dropdowns.DropdownShowArgs|EVUI.Modules.Dropdowns.DropdownHideArgs|EVUI.Modules.Dropdowns.DropdownLoadArgs|EVUI.Modules.Dropdowns.DropdownUnloadArgs} dropdownArgs
    @returns {EVUI.Modules.Panes.PaneArgsPackage}.*/
    var makeCurrentActionArgs = function (dropdownArgs)
    {
        var currentActionArgs = new EVUI.Modules.Panes.PaneArgsPackage();
        if (dropdownArgs.type === EVUI.Modules.Dropdowns.DropdownArgumentType.Hide)
        {
            currentActionArgs.hideArgs = dropdownArgs;
            currentActionArgs.unloadArgs = dropdownArgs.unloadArgs;
        }
        else if (dropdownArgs.type === EVUI.Modules.Dropdowns.DropdownArgumentType.Show)
        {
            currentActionArgs.showArgs = dropdownArgs;
            currentActionArgs.loadArgs = dropdownArgs.loadArgs;
        }
        else if (dropdownArgs.type === EVUI.Modules.Dropdowns.DropdownArgumentType.Load)
        {
            currentActionArgs.loadArgs = dropdownArgs;
        }
        else if (dropdownArgs.type === EVUI.Modules.Dropdowns.DropdownArgumentType.Unload)
        {
            currentActionArgs.unloadArgs = dropdownArgs;
        }

        return currentActionArgs;
    };

    /**Makes the "foreign" arguments for the PaneManager if it does not have them already.
    @param {EVUI.Modules.Panes.PaneArgsPackage} argsPackage The state of the Dropdown as reported by the Panemanager.
    @returns {EVUI.Modules.Panes.WidowArgsPackage}*/
    var createForeignArgs = function (argsPackage)
    {
        var foreignArgs = new EVUI.Modules.Panes.PaneArgsPackage();
        if (argsPackage.hideArgs != null)
        {
            foreignArgs.hideArgs = new EVUI.Modules.Dropdowns.DropdownHideArgs(argsPackage.hideArgs);
            foreignArgs.hideArgs.unloadArgs = new EVUI.Modules.Dropdowns.DropdownUnloadArgs(argsPackage.hideArgs.unloadArgs);
        }

        if (argsPackage.showArgs != null)
        {
            foreignArgs.showArgs = new EVUI.Modules.Dropdowns.DropdownShowArgs(argsPackage.showArgs);
            foreignArgs.showArgs.showSettings = new EVUI.Modules.Dropdowns.DropdownShowSettings(argsPackage.showArgs.showSettings);
            foreignArgs.showArgs.loadArgs = new EVUI.Modules.Dropdowns.DropdownLoadArgs(argsPackage.showArgs.loadArgs);
            foreignArgs.showArgs.loadArgs.loadSettings = new EVUI.Modules.Dropdowns.DropdownLoadSettings(argsPackage.showArgs.loadArgs.loadSettings);
        }

        if (argsPackage.loadArgs != null)
        {
            foreignArgs.loadArgs = new EVUI.Modules.Dropdowns.DropdownLoadArgs(argsPackage.loadArgs);
            foreignArgs.loadArgs.loadSettings = new EVUI.Modules.Dropdowns.DropdownLoadSettings(argsPackage.loadArgs.loadSettings);
        }

        if (argsPackage.unloadArgs != null)
        {
            foreignArgs.unloadArgs = new EVUI.Modules.Dropdowns.DropdownUnloadArgs(argsPackage.unloadArgs);
        }

        return foreignArgs;
    };

    /**Makes or extends a Dropdown object. Preserves all object references between runs and extends new properties onto the existing objects if they exist. 
    @param {EVUI.Modules.Dropdowns.Dropdown} yoloDropdown A YOLO object representing a Dropdown.
    @returns {EVUI.Modules.Dropdowns.Dropdown} */
    var makeOrExtendDropdown = function (yoloDropdown, bantmPane, exists)
    {
        var dropdownToExtend = null;
        if (exists === true)
        {
            var preExisting = _settings.getPaneEntry(yoloDropdown.id);
            dropdownToExtend = preExisting.wrapper;
        }
        else
        {
            dropdownToExtend = new EVUI.Modules.Dropdowns.Dropdown(bantmPane);
        }

        var safeCopy = EVUI.Modules.Core.Utils.shallowExtend({}, yoloDropdown);
        delete safeCopy.id;
        if (exists === true && yoloDropdown.element === bantmPane.element) delete safeCopy.element; //if the dropdown already exists and this is the same reference, don't set it again. Otherwise, let it blow up.
        delete safeCopy.currentPosition;
        delete safeCopy.currentZIndex;
        delete safeCopy.isVisible;
        delete safeCopy.isInitialized;
        delete safeCopy.isLoaded;

        EVUI.Modules.Core.Utils.shallowExtend(dropdownToExtend, safeCopy, ["showSettings", "loadSettings"]);
        dropdownToExtend.showSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Dropdowns.DropdownShowSettings(bantmPane.showSettings), dropdownToExtend.showSettings, yoloDropdown.showSettings);
        dropdownToExtend.loadSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Dropdowns.DropdownLoadSettings(bantmPane.loadSettings), dropdownToExtend.loadSettings, yoloDropdown.loadSettings);
        return dropdownToExtend;
    };

    /**Gets a Dropdown object from ambiguous input.
    @param {EVUI.Modules.Dropdowns.Dropdown|String|Event} dropdownOrID Either a YOLO object representing a Dropdown object, a string ID of a Dropdown, or browser Event args triggering a Dropdown action.
    @param {Boolean} addIfMissing Whether or not to add the Dropdown record if it is not already present.
    @returns {EVUI.Modules.Panes.PaneEntry} */
    var getDropdownAmbiguously = function (dropdownOrID, addIfMissing)
    {
        if (dropdownOrID == null || (typeof dropdownOrID !== "string" && typeof dropdownOrID !== "object")) throw Error("Invalid input: " + _settings.objectName + " or string id expected.");

        if (dropdownOrID instanceof Event)
        {
            var entry = _settings.getPaneEntryAmbiguously(dropdownOrID, addIfMissing);
            return entry;
        }

        var fakePane = {};
        if (typeof dropdownOrID === "string")
        {
            fakePane = getDefaultPane({ id: dropdownOrID });
        }
        else
        {
            fakePane.id = dropdownOrID.id;
            fakePane.dropdown = dropdownOrID;
        }

        return _settings.getPaneEntryAmbiguously(fakePane, addIfMissing);
    };

    /**Determines whether or not any of the AutoClose triggers attached to the Dropdown should trigger a hide operation on the Dropdown. Every dropdown has their own listener, so this function fires once per visible dropdown.
    @param {EVUI.Modules.Panes.PaneAutoTriggerContext} autoCloseArgs The auto-close arguments from the Pane's auto-close handlers.
    @returns {Boolean} */
    var shouldAutoClose = function (autoCloseArgs)
    {
        if (autoCloseArgs == null) return true;
        if (autoCloseArgs.triggerType === EVUI.Modules.Panes.PaneAutoCloseTriggerType.Click)
        {
            return shouldAutoCloseOnClick(autoCloseArgs);
        }
        else if (autoCloseArgs.triggerType === EVUI.Modules.Panes.PaneAutoCloseTriggerType.KeyDown)
        {
            return shouldAutoCloseOnKeydown(autoCloseArgs);
        }

        return true;
    };

    /**Determines if a mouse event should trigger an auto-close of the Dropdown. Every dropdown has their own listener, so this function fires once per visible dropdown.
    @param {EVUI.Modules.Panes.PaneAutoTriggerContext} autoCloseArgs The auto-close arguments generated by the Pane's auto-close handlers.
    @returns {Boolean}*/
    var shouldAutoCloseOnClick = function (autoCloseArgs)
    {
        if (autoCloseArgs.browserEvent.type === "contextmenu") //if someone is showing a right-click menu, make sure the dropdown isn't already showing itself in response to the same click. If it is, don't cancel the show.
        {
            var entry = _settings.getPaneEntry(autoCloseArgs.target.id);
            if (entry.currentPaneAction === EVUI.Modules.Panes.PaneAction.Show) return false;

            autoCloseArgs.browserEvent.preventDefault(); //if it's not being shown actively, close the dropdown. 
            return true;
        }

        var visibleDropdowns = _self.getDropdown(function (dd) { return dd.isVisible }, true);
        if (visibleDropdowns == null) return true; //get any visible dropdowns

        var midShow = _settings.getPaneEntry(function (entry) { return entry.currentPaneAction === EVUI.Modules.Panes.PaneAction.Show }, true);
        var numMidShow = (midShow == null) ? 0 : midShow.length; //get any dropdowns that are in the middle of showing themselves.

        var numDropdowns = visibleDropdowns.length;
        for (var x = 0; x < numDropdowns; x++)
        {
            var curDropdown = visibleDropdowns[x];
            for (var y = 0; y < numMidShow; y++) //see if the relative element of the dropdown being shown is a child of one of the active dropdowns. If it is, don't hide anything.
            {
                var curInMidShow = midShow[y];
                if (curInMidShow.wrapper.showSettings != null && curInMidShow.wrapper.showSettings.relativeElement != null)
                {
                    if (curDropdown.element.contains(curInMidShow.wrapper.showSettings.relativeElement)) return false;
                }
            }            
        }

        return true;
    };

    /**Makes it so Dropdowns close in descending order of Z-Index when the keydown auto-close command is issued. Every dropdown has their own listener, so this function fires once per visible dropdown.
    @param {EVUI.Modules.Panes.PaneAutoTriggerContext} autoCloseArgs The auto-close args generated by the handler.
    @returns {Boolean} */
    var shouldAutoCloseOnKeydown = function (autoCloseArgs)
    {
        var visiblePanes = _settings.getPaneEntry(function (entry) { return entry.pane.isVisible === true }, true);
        if (visiblePanes == null) return true;

        var currentZIndex = autoCloseArgs.target.currentZIndex;

        if (EVUI.Modules.Core.Utils.isArray(visiblePanes) === false) visiblePanes = [visiblePanes];
        var numPanes = visiblePanes.length;
        for (var x = 0; x < numPanes; x++)
        {
            var curPane = visiblePanes[x];
            if (curPane.pane.currentZIndex > currentZIndex)
            {
                return false;
            }
        }

        autoCloseArgs.browserEvent.stopPropagation();
        autoCloseArgs.browserEvent.preventDefault();
        return true;
    };

    /**Gets a YOLO Pane object with all the default properties for a Dropdown's backing Pane.
    @param {EVUI.Modules.Dropdowns.Dropdown} dropdown The dropdown to use as a wrapper for the Pane.
    @returns {EVUI.Modules.Panes.Pane}*/
    var getDefaultPane = function (dropdown)
    {
        if (typeof dropdown.id === "string")
        {
            var existing = _settings.getPaneEntry(dropdown.id);
            if (existing != null && existing.pane != null)
            {
                var fake = EVUI.Modules.Core.Utils.shallowExtend({}, existing.pane);

                fake.dropdown = dropdown;
                return fake;
            }
        }

        var pane =
        {
            id: dropdown.id,
            autoCloseSettings:
            {
                closeMode: EVUI.Modules.Panes.PaneCloseMode.Click,
                autoCloseKeys: ["Escape"],
                autoCloseFilter: function (context)
                {
                    return shouldAutoClose(context);
                }
            },
            showSettings:
            {
                relativePosition:
                {
                    orientation: EVUI.Modules.Dropdowns.DropdownOrientation.Bottom + " " + EVUI.Modules.Dropdowns.DropdownOrientation.Right,
                    alignment: EVUI.Modules.Dropdowns.DropdownAlignment.None,
                },
                clipSettings:
                {
                    mode: EVUI.Modules.Panes.PaneClipMode.Shift
                }
            },
            dropdown: dropdown
        }

        return pane;
    };

    /**Interprets a browser event for a Dropdown operation.
    @param {EVUI.Modules.Panes.Pane} bantmPane The YOLO Pane being created to extend onto a real record.
    @param {Event} browserEvent The event from the browser.
    @returns {EVUI.Modules.Panes.Pane}*/
    var interpretBrowserEvent = function (bantmPane, browserEvent)
    {
        EVUI.Modules.Core.Utils.shallowExtend(bantmPane, getDefaultPane({ id: bantmPane.id }));

        var attributes = EVUI.Modules.Core.Utils.getElementAttributes(browserEvent.currentTarget);
        if (bantmPane.showSettings == null) bantmPane.showSettings = {};
        if (bantmPane.showSettings.relativePosition == null) bantmPane.showSettings.relativePosition = {};

        var orientation = attributes.getValue(EVUI.Modules.Dropdowns.Constants.Attribute_Orientation);
        var alignment = attributes.getValue(EVUI.Modules.Dropdowns.Constants.Attribute_Alignment);
        var mode = attributes.getValue(EVUI.Modules.Dropdowns.Constants.Attribute_DropMode);    

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(orientation) === false)
        {
            bantmPane.showSettings.relativePosition.orientation = orientation;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(alignment) === false)
        {
            bantmPane.showSettings.relativePosition.alignment = alignment;
        }

        if (mode === EVUI.Modules.Dropdowns.DropdownMode.Element)
        {
            bantmPane.showSettings.relativePosition.relativeElement = browserEvent.currentTarget;
        }
        else if (mode === EVUI.Modules.Dropdowns.DropdownMode.Point)
        {
            bantmPane.showSettings.relativePosition.x = browserEvent.clientX;
            bantmPane.showSettings.relativePosition.y = browserEvent.clientY;
        }
        else
        {
            if (browserEvent.type === "contextmenu")
            {
                bantmPane.showSettings.relativePosition.x = browserEvent.clientX;
                bantmPane.showSettings.relativePosition.y = browserEvent.clientY;
            }
            else
            {
                bantmPane.showSettings.relativePosition.relativeElement = browserEvent.currentTarget;
            }
        }

        if (browserEvent.type === "contextmenu") browserEvent.preventDefault();

        return true;
    };

    _settings = new EVUI.Modules.Panes.PaneManagerSettings();
    _settings.attributePrefix = EVUI.Modules.Dropdowns.Constants.Default_AttributePrefix;
    _settings.cssPrefix = EVUI.Modules.Dropdowns.Constants.Default_CssPrefix;
    _settings.cssSheetName = EVUI.Modules.Styles.Constants.DefaultStyleSheetName;
    _settings.eventNamePrefix = EVUI.Modules.Dropdowns.Constants.Default_EventNamePrefix;
    _settings.managerName = EVUI.Modules.Dropdowns.Constants.Default_ManagerName;
    _settings.objectName = EVUI.Modules.Dropdowns.Constants.Default_ObjectName;
    _settings.makeOrExtendObject = makeOrExtendObject;
    _settings.buildEventArgs = buildEventArgs;
    _settings.interpretBrowserEvent = interpretBrowserEvent;

    if (services == null || typeof services !== "object") services = new EVUI.Modules.Dropdowns.DropdownControllerServices();
    if (services.paneManager == null || typeof services.paneManager !== "object")
    {
        services.paneManager = EVUI.Modules.Panes.Manager;
    }

    _settings.httpManager = services.httpManager;
    _settings.stylesheetManager = services.stylesheetManager;
    _settings.htmlLoader = services.htmlLoader;

    _manager = new services.paneManager.createNewPaneManager(_settings);

    /**Global event that fires before the load operation begins for any Dropdown and is not yet in the DOM and cannot be manipulated in this stage, however the currentActionArgs.loadSettings can be manipulated to change the way the Dropdown's root element will be loaded.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownLoadArgs.*/
    this.onLoad = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onLoad", targetPath: "onLoad" });

    /**Global even that fires after the load operation has completed for any Dropdown and is now in the DOM and can be manipulated in this stage. From this point on the Dropdown's element property cannot be reset..
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownLoadArgs.*/
    this.onLoaded = function (paneEventArgs) { };;
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onLoaded", targetPath: "onLoaded" });

    /**Global event that fires the first time any Dropdown is shown after being loaded into the DOM, but is not yet visible. After it has fired once, it will not fire again unless the DropdownShowArgs.reInitialize property is set to true.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownShowArgs.*/
    this.onInitialize = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onInitialize", targetPath: "onInitialize" });

    /**Global event that fires at the beginning of the show process and before the calculations for any Dropdown's location are made. The Dropdown is still hidden, but is present in the DOM and can be manipulated. In order for the positioning calculations in the next step to be accurate, all HTML manipulation should occur in this event.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownShowArgs.*/
    this.onShow = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onShow", targetPath: "onShow" });

    /**Global event that fires after the position of any Dropdown has been calculated and is available to be manipulated through the calculatedPosition property of the DropdownEventArgs. If the calculatedPosition or the showSettings are manipulated, the position will be recalculated (the changes made directly to the position take priority over changes made to the showSettings).
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownShowArgs.*/
    this.onPosition = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onPosition", targetPath: "onPosition" });

    /**Global event that fires once any Dropdown has been positioned, shown, and had its optional show transition applied and completed. Marks the end of the show process.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownShowArgs.*/
    this.onShown = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onShown", targetPath: "onShown" });

    /**Global event that fires before any Dropdown has been moved from its current location and hidden. Gives the opportunity to change the hideTransition property of the DropdownHideArgs and optionally trigger an unload once the Dropdown has been hidden.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownHideArgs.*/
    this.onHide = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onHide", targetPath: "onHide" });

    /**Global event that fires after any Dropdown has been moved from its current location and is now hidden and the hide transition has completed.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownHideArgs.*/
    this.onHidden = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onHidden", targetPath: "onHidden" });

    /**Global event that fires before any Dropdown has been (potentially) removed from the DOM and had its element property reset to null.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownUnloadArgs.*/
    this.onUnload = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onUnload", targetPath: "onUnload" });

    /**Global event that fires after any Dropdown has been (potentially) removed from the DOM and had its element property reset to null. From this point on the Dropdown's element property is now settable to a new Element.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownUnloadArgs.*/
    this.onUnloaded = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onUnloaded", targetPath: "onUnloaded" });
};

/**Represents a UI component that behaves like a standard application dropdown menu that is positioned relative to another element or a point on the screen by default.
 @class*/
EVUI.Modules.Dropdowns.Dropdown = function (bantmPane)
{
    if (bantmPane == null) throw Error("Invalid input. Must wrap a Pane.");

    /**Object. The Dropdown being wrapped by the Dropdown.
    @type {EVUI.Modules.Panes.Pane}*/
    var _pane = bantmPane;

    /**String. The unique ID of this Dropdown. ID's are case-insensitive.
    @type {String}*/
    this.id = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "id", targetPath: "id", settings: { set: false } });

    /**Object. The root Element of the Dropdown. Cannot be reset once it has been assigned to via initialization or a load operation, unload the Dropdown to reset it.
    @type {Element}*/
    this.element = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "element", targetPath: "element" });

    /**Boolean. Whether or not to unload the Dropdown from the DOM when it is hidden (only applies to elements that were loaded via HTTP). False by default.
    @type {Boolean}*/
    this.unloadOnHide = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "unloadOnHide", targetPath: "unloadOnHide" });

    /**Object. Calculates and gets the absolute position of the Dropdown.
    @type {EVUI.Modules.Dom.ElementBounds}*/
    this.currentPosition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "currentPosition", targetPath: "currentPosition", settings: { set: false } });

    /**Number. Calculates and gets the Z-Index of the Dropdown.
    @type {Number}*/
    this.currentZIndex = -1;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "currentZIndex", targetPath: "currentZIndex", settings: { set: false } });

    /**Boolean. Whether or not the internal state of the Dropdown thinks it is visible or not. This will be true after the show process has completed and false after an unload or hide operation has been completed.
    @type {Boolean}*/
    this.isVisible = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "isVisible", targetPath: "isVisible", settings: { set: false } });

    /**Boolean. Whether or not the internal state of the Dropdown thinks it is visible or not. This will be true after the load process has completed, even if the element was set directly before the first load operation.
    @type {Boolean}*/
    this.isLoaded = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "isLoaded", targetPath: "isLoaded", settings: { set: false } });

    /**Boolean. Whether or not the internal state of the Dropdown thinks it has been initialized or not. This will be true after the onInitialized events fire. */
    this.isInitialized = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "isInitialized", targetPath: "isInitialized", settings: { set: false } });

    /**Object. Show settings for the Dropdown.
    @type {EVUI.Modules.Dropdowns.DropdownShowSettings}*/
    this.showSettings = null;    

    /**Object. Settings for loading the Dropdown.
    @type {EVUI.Modules.Dropdowns.DropdownLoadSettings}*/
    this.loadSettings = null;   

    /**Any. Any contextual information to attach to the Dropdown object.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "context", targetPath: "context"});

    /**Event that fires before the load operation begins for the Dropdown and is not yet in the DOM and cannot be manipulated in this stage, however the currentActionArgs.loadSettings can be manipulated to change the way the Dropdown's root element will be loaded.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownLoadArgs.*/
    this.onLoad = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onLoad", targetPath: "onLoad" });

    /**Event that fires after the load operation has completed for the Dropdown and is now in the DOM and can be manipulated in this stage. From this point on the Dropdown's element property cannot be reset..
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownLoadArgs.*/
    this.onLoaded = function (paneEventArgs) { };;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onLoaded", targetPath: "onLoaded" });

    /**Event that fires the first time the Dropdown is shown after being loaded into the DOM, but is not yet visible. After it has fired once, it will not fire again unless the DropdownShowArgs.reInitialize property is set to true.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownShowArgs.*/
    this.onInitialize = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onInitialize", targetPath: "onInitialize" });

    /**Event that fires at the beginning of the show process and before the calculations for the Dropdown's location are made. The Dropdown is still hidden, but is present in the DOM and can be manipulated. In order for the positioning calculations in the next step to be accurate, all HTML manipulation should occur in this event.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownShowArgs.*/
    this.onShow = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onShow", targetPath: "onShow" });

    /**Event that fires after the position of the Dropdown has been calculated and is available to be manipulated through the calculatedPosition property of the DropdownEventArgs. If the calculatedPosition or the showSettings are manipulated, the position will be recalculated (the changes made directly to the position take priority over changes made to the showSettings).
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownShowArgs.*/
    this.onPosition = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onPosition", targetPath: "onPosition" });

    /**Event that fires once the Dropdown has been positioned, shown, and had its optional show transition applied and completed. Marks the end of the show process.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownShowArgs.*/
    this.onShown = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onShown", targetPath: "onShown" });

    /**Event that fires before the Dropdown has been moved from its current location and hidden. Gives the opportunity to change the hideTransition property of the DropdownHideArgs and optionally trigger an unload once the Dropdown has been hidden.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownHideArgs.*/
    this.onHide = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onHide", targetPath: "onHide" });

    /**Event that fires after the Dropdown has been moved from its current location and is now hidden and the hide transition has completed.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownHideArgs.*/
    this.onHidden = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onHidden", targetPath: "onHidden" });

    /**Event that fires before the Dropdown has been (potentially) removed from the DOM and had its element property reset to null.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownUnloadArgs.*/
    this.onUnload = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onUnload", targetPath: "onUnload" });

    /**Event that fires after the Dropdown has been (potentially) removed from the DOM and had its element property reset to null. From this point on the Dropdown's element property is now settable to a new Element.
    @param {EVUI.Modules.Dropdowns.DropdownEventArgs} paneEventArgs The event arguments for the Dropdown operation. The currentActionArgs property will be an instance of DropdownUnloadArgs.*/
    this.onUnloaded = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onUnloaded", targetPath: "onUnloaded" });

    /**Returns a copy of the internal eventBindings array.
    @returns {EVUI.Modules.Panes.PaneEventBinding[]}*/
    this.getEventBindings = function ()
    {
        return _pane.getEventBindings();
    };

    /**Adds an event response to a standard browser event to a child element of the Dropdown element.
    @param {Element} element The child element of the root bantmPane element to attach an event handler to.
    @param {EVUI.Modules.Dom.Constants.Fn_BrowserEventHandler} handler An event handler to be called when the specified events are triggered.
    @param {String|String[]} event Either a single event name, or an array of event names, or a space delineated string of event names to add.*/
    this.addEventBinding = function (element, event, handler)
    {
        return _pane.addEventBinding(element, event, handler);
    };
};

/**The settings and options for showing a Dropdown.
@class*/
EVUI.Modules.Dropdowns.DropdownShowSettings = function (showSettings)
{
    /**The show settings being set by the DropdownShowSettings.
    @type {EVUI.Modules.Panes.PaneShowSettings}*/
    var _showSettings = (showSettings == null || typeof showSettings !== "object") ? new EVUI.Modules.Panes.PaneShowSettings() : showSettings;
    if (_showSettings.relativePosition == null) _showSettings.relativePosition = new EVUI.Modules.Panes.PaneRelativePosition();
    if (_showSettings.clipSettings == null) _showSettings.clipSettings = new EVUI.Modules.Panes.PaneClipSettings();

    /**Number. The X-Coordinate to align the Dropdown to if it is not being aligned with an Element.
    @type {Number}*/
    this.x = 0;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "x", targetPath: "relativePosition.x" })

    /**Number. The Y-Coordinate to align the Dropdown to if it is not being aligned with an Element.
    @type {Number}*/
    this.y = 0;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "y", targetPath: "relativePosition.y" })

    /**String. The orientation of the Dropdown relative to the point or element. "bottom right" by default. If only "left" or "right" is specified, "bottom" is implied; if only "bottom" or "top" is specified, "right" is implied. Must be a value from the DropdownOrientation enum.
    @type {String}*/
    this.orientation = EVUI.Modules.Dropdowns.DropdownOrientation.Right + " " + EVUI.Modules.Dropdowns.DropdownOrientation.Bottom;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "orientation", targetPath: "relativePosition.orientation" })

    /**String. The alignment of the Dropdown relative to the side of the point or element.
    @type {String}*/
    this.alignment = EVUI.Modules.Dropdowns.DropdownAlignment.None;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "alignment", targetPath: "relativePosition.alignment" });

    /**Object. Contains the details of the CSS transition to use to show the Dropdown (if a transition is desired). If omitted, the Dropdown is positioned then shown by manipulating the display property directly.
    @type {EVUI.Modules.Dropdowns.DropdownTransition}*/
    this.showTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "showTransition", targetPath: "showTransition" })

    /**Object. Contains the details of the CSS transition to use to hide the Dropdown (if a transition is desired). If omitted, the Dropdown is positioned then shown by manipulating the display property directly.
    @type {EVUI.Modules.Dropdowns.DropdownTransition}*/
    this.hideTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "hideTransition", targetPath: "hideTransition" })

    /**Object. An Element (or CSS selector of an Element) to be used as a point or reference for the Dropdown to be placed next to. Defers to an x,y point specification.
    @type {Element|String}*/
    this.relativeElement = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "relativeElement", targetPath: "relativePosition.relativeElement" })

    /**Object. An Element (or CSS selector of an Element) or an ElementBounds object describing the bounds to which the Dropdown will attempt to fit inside. If omitted, the Dropdown's current view port is used.
    @type {Element|EVUI.Modules.Dom.ElementBounds|String}*/
    this.clipBounds = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "clipBounds", targetPath: "clipSettings.clipBounds" })

    /**Boolean. Whether or not scrollbars should appear on the X-axis when the Dropdown has been clipped.
    @type {Boolean}*/
    this.scrollXWhenClipped = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "scrollXWhenClipped", targetPath: "clipSettings.scrollXWhenClipped" })

    /**Boolean. Whether or not scrollbars should appear on the Y-axis when the Dropdown has been clipped.
    @type {Boolean}*/
    this.scrollYWhenClipped = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "scrollYWhenClipped", targetPath: "clipSettings.scrollYWhenClipped" })

    /**Boolean. Whether or not to include the height and width when positioning the element (when it is not clipped).
    @type {Boolean}*/
    this.setExplicitDimensions = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "setExplicitDimensions", targetPath: "setExplicitDimensions" })
};

/**Event arguments for the events exposed when hiding, showing, loading, or unloading a Dropdown.
@class*/
EVUI.Modules.Dropdowns.DropdownEventArgs = function (argsPackage, currentArgs)
{
    if (argsPackage == null || currentArgs == null) throw Error("Invalid arguments.")

    /**Object. The metadata about the state of the Dropdown.
    @type {EVUI.Modules.Panes.PaneArgsPackage}*/
    var _argsPackage = argsPackage;

    /**The current event args for the operation.
    @type {Any}*/
    var _currentArgs = currentArgs;

    /**The Dropdown that is having an action performed on it.
    @type {EVUI.Modules.Dropdowns.Dropdown}*/
    this.dropdown = null;
    Object.defineProperty(this, "dropdown",
    {
        get: function () { return _argsPackage.wrapper; },
        configurable: false,
        enumerable: true
    });

    /**String. The unique key current step in the EventStream.
    @type {String}*/
    this.key = null;

    /**Function. Pauses the EventStream, preventing the next step from executing until resume is called.*/
    this.pause = function () { };

    /**Function. Resumes the EventStream, allowing it to continue to the next step.*/
    this.resume = function () { };

    /**Function. Cancels the EventStream and aborts the execution of the Dropdown operation.*/
    this.cancel = function () { }

    /**Function. Stops the EventStream from calling any other event handlers with the same key.*/
    this.stopPropagation = function () { };

    /**Object. The position of the Dropdown that has been calculated in using the currentShowSettings.
    @type {EVUI.Modules.Panes.PanePosition}*/
    this.calculatedPosition = null;
    Object.defineProperty(this, "calculatedPosition",
    {
        get: function () { return _argsPackage.lastCalculatedPosition; },
        configurable: false,
        enumerable: true
    });

    /**Object. The PaneHide/Show/Load/Unload Arguments being used for the operation.
    @type {EVUI.Modules.Dropdowns.DropdownShowArgs|EVUI.Modules.Dropdowns.DropdownHideArgs|EVUI.Modules.Dropdowns.DropdownLoadArgs|EVUI.Modules.Dropdowns.DropdownUnloadArgs}*/
    this.currentActionArgs = null;
    Object.defineProperty(this, "currentActionArgs", {
        get: function () { return _currentArgs },
        configurable: false,
        enumerable: true
    });

    /**Object. Any state value to carry between events.
    @type {Object}*/
    this.context = {};
};

/**Arguments for loading a Dropdown.
 @class*/
EVUI.Modules.Dropdowns.DropdownLoadArgs = function (paneLoadArgs)
{
    /**The internal PaneLoadArgs being manipulated.
    @type {EVUI.Modules.Panes.PaneLoadArgs}*/
    var _loadArgs = (paneLoadArgs == null || typeof paneLoadArgs !== "object") ? new EVUI.Modules.Panes.PaneLoadArgs() : paneLoadArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _loadArgs, [{ sourcePath: "type", targetPath: "type" }]);

    /**Any. Any contextual information to pass into the Dropdown load logic.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _loadArgs, [{ sourcePath: "context", targetPath: "context" }]);

    /**Object. The PaneLoadSettings to use if the Dropdown has not already been loaded.
    @type {EVUI.Modules.Dropdowns.DropdownLoadSettings}*/
    this.loadSettings = null;

    /**Boolean. Whether or not to re-load the Dropdown.
    @type {Boolean}*/
    this.reload = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _loadArgs, [{ sourcePath: "reload", targetPath: "reload" }]);
};

/**Arguments for showing a Dropdown.
@class*/
EVUI.Modules.Dropdowns.DropdownShowArgs = function (paneShowArgs)
{
    /**The internal settings being set by the wrapper object.
    @type {EVUI.Modules.Panes.PaneShowArgs}*/
    var _paneShowArgs = (paneShowArgs == null || typeof paneShowArgs !== "object") ? new EVUI.Modules.Panes.PaneShowArgs() : paneShowArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneShowArgs, { sourcePath: "type", targetPath: "type", settings: { set: false } });

    /**Any. Any contextual information to pass into the Dropdown show logic.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneShowArgs, { sourcePath: "context", targetPath: "context" });

    /**Object. The show settings for the Dropdown.
    @type {EVUI.Modules.Dropdowns.DropdownShowSettings}*/
    this.showSettings = null;

    /**Object. The load arguments for loading the Dropdown if it has not already been loaded.
    @type {EVUI.Modules.Dropdowns.DropdownLoadArgs}*/
    this.loadArgs = null;

    /**Whether or not to re-initialize the Dropdown upon showing it.
    @type {Boolean}*/
    this.reInitialize = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneShowArgs, { sourcePath: "reInitialize", targetPath: "reInitialize" });
};

/**Arguments for hiding a Dropdown.
@class*/
EVUI.Modules.Dropdowns.DropdownHideArgs = function (paneHideArgs)
{
    /**The internal settings being set by the wrapper object.
    @type {EVUI.Modules.Panes.PaneHideArgs}*/
    var _paneHideArgs = (paneHideArgs == null || typeof paneHideArgs !== "object") ? new EVUI.Modules.Panes.PaneHideArgs() : paneHideArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneHideArgs, { sourcePath: "type", targetPath: "type", settings: { set: false } });

    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneHideArgs, { sourcePath: "context", targetPath: "context" });

    /** */
    this.dropdownHideTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneHideArgs, { sourcePath: "dropdownHideTransition", targetPath: "paneHideTransition" });

    this.unloadArgs = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneHideArgs, { sourcePath: "unloadArgs", targetPath: "unloadArgs" });
};

/**Arguments for unloading a Dropdown.
@class*/
EVUI.Modules.Dropdowns.DropdownUnloadArgs = function (paneUnloadArgs)
{
    /**The internal settings being set by the wrapper object.
    @type {EVUI.Modules.Panes.PaneUnloadArgs}*/
    var _paneUnloadArgs = (paneUnloadArgs == null || typeof paneUnloadArgs !== "object") ? new EVUI.Modules.Panes.PaneUnloadArgs() : paneUnloadArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneUnloadArgs, { sourcePath: "type", targetPath: "type", settings: { set: false } });

    /**Any. Any contextual information to pass into the Dropdown hide logic.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneUnloadArgs, { sourcePath: "context", targetPath: "context" });

    /**Boolean. Whether or not to remove the Dropdown from the DOM once it has been unloaded.
    @type {Boolean}*/
    this.remove = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneUnloadArgs, { sourcePath: "remove", targetPath: "remove" });
};

/**Represents a transition effect that can be applied to a Dropdown when its position or size changes.
@class*/
EVUI.Modules.Dropdowns.DropdownTransition = function ()
{
    /**Object or String. Either class names, a string of CSS rules (without a selector), or an object of key-value pairs of CSS properties to generate a runtime CSS class for.
    @type {Object|String}*/
    this.css = null;

    /**String. CSS definition for a keyframe animation to apply. Note that the keyframe animation's name must appear in the DropdownTransition.css property in order to be applied.
    @type {String}*/
    this.keyframes = null;

    /**The duration (in milliseconds) of the transition so that the OnShown/OnHidden events are only fired once the transition is complete.
    @type {Number}*/
    this.duration = 0;
};

/**Settings and options for loading a dropdown.
@class */
EVUI.Modules.Dropdowns.DropdownLoadSettings = function (paneLoadSettings)
{
    var _paneLoadSettings = (paneLoadSettings == null || typeof paneLoadSettings !== "object") ? new EVUI.Modules.Panes.PaneLoadSettings() : paneLoadSettings;

    /**Object. The Element to show as the Dropdown.
    @type {Element}*/
    this.element = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "element", targetPath: "element" });

    /**String. A CSS selector that is used to go find the Element to show as the Dropdown. Only the first result is used.
    @type {String}*/
    this.selector = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "selector", targetPath: "selector" });

    /**Object. If using a CSS selector to find the root element of a Dropdown, this is the context limiting element to search inside of.
    @type {Element}*/
    this.contextElement = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "contextElement", targetPath: "contextElement" });

    /**Object. HttpRequestArgs for making a Http request to go get the Dropdown's HTML.
    @type {EVUI.Modules.Http.HttpRequestArgs}*/
    this.httpLoadArgs = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "httpLoadArgs", targetPath: "httpLoadArgs" });

    /**Object. PlaceholderLoadArgs for making a series of Http requests to load the Dropdown as an existing placeholder.
    @type {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs}*/
    this.placeholderLoadArgs = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "placeholderLoadArgs", targetPath: "placeholderLoadArgs" });
};

/**The mode by which the Dropdown will be positioned in response to a browser event. Only applies to the "evui-dd-mode" attribute. By default all browser events but "contextmenu" are relative to the Element, "contextmenu" defaults to the location of the mouse.
@enum*/
EVUI.Modules.Dropdowns.DropdownMode =
{
    /**Override the default behavior to make the Dropdown appear relative to the location of the mouse cursor.*/
    Point: "point",
    /**Override the default behavior to make the Dropdown appear rleative to the Element with the event handler.*/
    Element: "element"
};
Object.freeze(EVUI.Modules.Dropdowns.DropdownMode);

/**Controls the alignment of the Dropdown along the X or Y axis when it is positioned relative to an Element.
@enum*/
EVUI.Modules.Dropdowns.DropdownAlignment =
{
    /**The axis will not be aligned and will keep its calculated value.*/
    None: "none",
    /**The element will be aligned with the left side of the relative element.*/
    Left: "left",
    /**The element will be aligned with the right side of the relative element.*/
    Right: "right",
    /**The element will be aligned on the center of the x-axis of the relative element.*/
    XCenter: "xcenter",
    /**The element will be aligned on the center of the y-axis of the relative element..*/
    YCenter: "ycenter",
    /**The element will be aligned with the top side of the relative element.*/
    Top: "top",
    /**The element will be aligned with the bottom side of the relative element.*/
    Bottom: "bottom"
};
Object.freeze(EVUI.Modules.Dropdowns.DropdownAlignment);

/**Enum set for orientations of a Dropdown relative to a point or element. Any combination of left/right and top/bottom is valid.
@enum*/
EVUI.Modules.Dropdowns.DropdownOrientation =
{
    /**The Dropdown's right edge will be against the left edge of the relative element or point.*/
    Left: "left",
    /**The Dropdown's left edge will be against the right edge of the relative element or point.*/
    Right: "right",
    /**The Dropdown's bottom edge will be against the top edge of the relative element or point.*/
    Top: "top",
    /**The Dropdown's top edge will be against the bottom edge of the relative element or point.*/
    Bottom: "bottom"
};
Object.freeze(EVUI.Modules.Dropdowns.DropdownOrientation);


/**Enum for indicating what type of arguments object the DropdownEventArgs.currentArguments property is.
@enum*/
EVUI.Modules.Dropdowns.DropdownArgumentType =
{
    /**Arguments are DropdownShowArgs.*/
    Show: "show",
    /**Arguments are DropdownHideArgs.*/
    Hide: "hide",
    /**Arguments are DropdownLoadArgs.*/
    Load: "load",
    /**Arguments are DropdownUnloadArgs.*/
    Unload: "unload",
    /**Arguments are DropdownMoveResizeArgs.*/
    MoveResize: "moveResize"
};
Object.freeze(EVUI.Modules.Dropdowns.DropdownArgumentType);

/**Enum for indicating the behavior of the Dropdown when it overflows its clipBounds.
@enum*/
EVUI.Modules.Dropdowns.DropdownClipMode =
{
    /**When the calculated position of the Dropdown overflows the clipBounds, it will not be cropped to stay within the clipBounds and will overflow to the outside of the clip bounds.*/
    Overflow: "overflow",
    /**When the calculated position of the Dropdown overflows the clipBounds, it will be clipped to the maximum dimensions of the clipBounds on the overflowing axes.*/
    Clip: "clip",
    /**When the calculated position of the Dropdown overflows the clipBounds, it will be shifted in the opposite directions as the overflow to fit within the clipBounds.*/
    Shift: "shift",
};
Object.freeze(EVUI.Modules.Dropdowns.DropdownClipMode);

/**Object to inject the standard dependencies used by the DropdownController into it via its constructor.
@class*/
EVUI.Modules.Dropdowns.DropdownControllerServices = function ()
{
    /**Object. An instance of Http module's HttpManager object.
    @type {EVUI.Modules.Http.HttpManager}*/
    this.httpManager = null;

    /**Object. An instance of the HtmlLoaderController module's HtmlLoaderController object.
    @type {EVUI.Modules.HtmlLoader.HtmlLoaderController}*/
    this.htmlLoader = null;

    /**Object. An instance of the Styles module's StylesheetManager object.
    @type {EVUI.Modules.Styles.StyleSheetManager}*/
    this.stylesheetManager = null;

    /**Object. An instance of the Panes module's PaneManager object.
    @type {EVUI.Modules.Panes.PaneManager}*/
    this.panesManager = null;
};

/**Global instance of the DropdownManager, used for creating and using simple dropdowns that are positioned relative to a point or another element.
@type {EVUI.Modules.Dropdowns.DropdownManager}*/
EVUI.Modules.Dropdowns.Manager = null;
(function ()
{
    var manager = null;
    var ctor = EVUI.Modules.Dropdowns.DropdownManager;

    Object.defineProperty(EVUI.Modules.Dropdowns, "Manager", {
        get: function ()
        {
            if (manager == null) manager = new ctor();
            return manager;
        },
        enumerable: true,
        configurable: false
    });
})();

Object.freeze(EVUI.Modules.Dropdowns);

delete $evui.dropdowns;

/**Global instance of the DropdownManager, used for creating and using simple dropdowns that are positioned relative to a point or another element.
@type {EVUI.Modules.Dropdowns.DropdownManager}*/
$evui.dropdowns = null;
Object.defineProperty($evui, "dropdowns", {
    get: function () { return EVUI.Modules.Dropdowns.Manager; },
    enumerable: true
});

/**Adds a Dropdown to the WidowManager.
@param {EVUI.Modules.Dropdowns.Dropdown} yoloDropdown A YOLO object representing a Dropdown object. This object is copied onto a real Dropdown object is then discarded.
@returns {EVUI.Modules.Dropdowns.Dropdown}*/
$evui.addDropdown = function (yoloDropdown)
{
    return $evui.dropdowns.addDropdown(yoloDropdown);
};

/**Shows (and loads, if necessary or if a reload is requested) a Dropdown asynchronously. Provides a callback that is called call once the Dropdown operation has completed successfully or otherwise.
@param {EVUI.Modules.Dropdowns.Dropdown|String} dropdownOrID Either a YOLO Dropdown object to extend into the existing Dropdown, the real Dropdown reference, or the string ID of the Dropdown to show.
@param {EVUI.Modules.Dropdowns.DropdownShowArgs|EVUI.Modules.Dropdowns.Constants.Fn_DropdownOperationCallback} dropdownShowArgs Optional. A YOLO object representing the arguments for showing the Dropdown, or the callback. If omitted or passed as a function, the Dropdown's existing show/load settings are used instead.
@param {EVUI.Modules.Dropdowns.Constants.Fn_DropdownOperationCallback} callback Optional. A callback that is called once the operation completes.*/
$evui.showDropdown = function (dropdownOrID, dropdownShowArgs, callback)
{
    return $evui.dropdowns.showDropdown(dropdownOrID, dropdownShowArgs, callback);
};

/**Awaitable. (and loads, if necessary or if a reload is requested) a Dropdown asynchronously.
@param {EVUI.Modules.Dropdowns.Dropdown|String} dropdownOrID Either a YOLO Dropdown object to extend into the existing Dropdown, the real Dropdown reference, or the string ID of the Dropdown to show.
@param {EVUI.Modules.Dropdowns.DropdownShowArgs} dropdownShowArgs Optional.  A YOLO object representing the arguments for showing the Dropdown. If omitted, the Dropdown's existing show/load settings are used instead.
@returns {Promise<Boolean>}*/
$evui.showDropdownAsync = function (dropdownOrID, dropdownShowArgs)
{
    return $evui.dropdowns.showDropdownAsync(dropdownOrID, dropdownShowArgs);
};

/**Hides (and unloads if requested) a Dropdown asynchronously. Provides a callback that is called call once the Dropdown operation has completed successfully or otherwise.
@param {EVUI.Modules.Dropdowns.Dropdown|String} dropdownOrID Either a YOLO Dropdown object to extend into the existing Dropdown, the real Dropdown reference, or the string ID of the Dropdown to hide.
@param {EVUI.Modules.Dropdowns.DropdownHideArgs|EVUI.Modules.Dropdowns.Constants.Fn_DropdownOperationCallback} dropdownHideArgs Optional.  A YOLO object representing the arguments for hiding a Dropdown or the callback. If omitted or passed as a function, the Dropdown's existing hide/unload settings are used instead.
@param {EVUI.Modules.Dropdowns.Constants.Fn_DropdownOperationCallback} callback Optional. A callback that is called once the operation completes.*/
$evui.hideDropdown = function (dropdownOrID, dropdownHideArgs, callback)
{
    return $evui.dropdowns.hideDropdown(dropdownOrID, dropdownHideArgs, callback);
};

/**Awaitable. Hides (and unloads if requested) a Dropdown asynchronously. Provides a callback that is called call once the Dropdown operation has completed successfully or otherwise.
@param {EVUI.Modules.Dropdowns.Dropdown|String} dropdownOrID Either a YOLO Dropdown object to extend into the existing Dropdown, the real Dropdown reference, or the string ID of the Dropdown to hide.
@param {EVUI.Modules.Dropdowns.DropdownHideArgs} dropdownHideArgs Optional.  A YOLO object representing the arguments for hiding a Dropdown. If omitted, the Dropdown's existing hide/unload settings are used instead.
@returns {Promise<Boolean>}*/
$evui.hideDropdownAsync = function (dropdownOrID, dropdownHideArgs)
{
    return $evui.dropdowns.hideDropdownAsync(dropdownOrID, dropdownHideArgs);
};

/*#ENDWRAP(Drop)#*/


/********************************************************Enums.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.Enums|Enums)#*/
/*#REPLACE(EVUI.Modules.Enums|Enums)#*/

/**Utility module for a shortcut to getting EventUI's enum values or constant values.
@module*/
EVUI.Modules.Enums = {};

/*#MODULEDEF(Enums|"1.0"|"Enums")#*/
/*#VERSIONCHECK(EVUI.Modules.Enums|Enums)#*/

EVUI.Modules.Enums.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.Enums.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();

Object.freeze(EVUI.Modules.Enums.Dependencies);

/**Utility object for getting enum values based on a variety of possible inputs.
@class*/
EVUI.Modules.Enums.EnumValueGetter = function ()
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Enums.Dependencies);

    var _moduleCache = {};
    var _enumCache = {};

    /**Gets either an enum object or a value from an enum object.
    @param {String|Object} enumNameOrModule Either the path to an enum, an enum's name, a module object, or the name of a module.
    @param {String} enumKeyOrName Optional. Either the name/path of the enum (if the first parameter was a module) object and its value.
    @param {String} enumKey Optional. The key of the value to get from the enum.
    @returns {Any}*/
    this.getEnumValue = function (enumNameOrModule, enumKeyOrName, enumKey)
    {
        if (enumNameOrModule == null) return undefined;

        var parsedPath = null;
        var enumEntry = null;
        var moduleEntry = null;
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(enumNameOrModule) === false)
        {
            parsedPath = resolvePath(enumNameOrModule);
            if (parsedPath.moduleEntry != null)
            {
                moduleEntry = parsedPath.moduleEntry
            }

            if (parsedPath.enumEntry != null)
            {
                enumEntry = parsedPath.enumEntry                
            }
        }
        else if (typeof enumNameOrModule === "object")
        {
            moduleEntry = getModuleEntryByReference(enumNameOrModule);
        }
        else
        {
            return undefined;
        }

        if (enumEntry == null && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(enumKeyOrName) === false)
        {
            parsedPath = resolvePath(enumKeyOrName);
            if (parsedPath.moduleEntry != null)
            {
                moduleEntry = parsedPath.moduleEntry
            }

            if (parsedPath.enumEntry != null)
            {
                enumEntry = parsedPath.enumEntry
            }            
        }

        //if we found an enum entry but don't have a key for it, check the parameters in order of precedence
        if (enumEntry != null && parsedPath.enumValueKey == null)
        {
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(enumKeyOrName) === false)
            {
                var lowerKey = enumKeyOrName.toLowerCase()
                if (parsedPath.enumEntry.values[lowerKey] !== undefined)
                {
                    parsedPath.enumValueKey = enumKeyOrName;
                }
                else
                {
                    if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(enumKey) === false)
                    {
                        var lowerKey = enumKey.toLowerCase()
                        if (parsedPath.enumEntry.values[lowerKey] !== undefined)
                        {
                            parsedPath.enumValueKey = enumKey;
                        }
                    }
                }
            }                          
        }

        if (moduleEntry == null) return undefined;

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(parsedPath.enumValueKey) === false && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(enumKey) === true) enumKey = parsedPath.enumValueKey;
        if (enumKey === undefined) return enumEntry.enumObj;
        if (typeof enumKey !== "string") return undefined;

        var value = enumEntry.enumObj[enumKey];
        if (value !== undefined) return value;

        return enumEntry.values[enumKey.toLowerCase()];
    };

    /**Gets a module object based on its name.
    @param {String} moduleName The name of the module to get.
    @returns {Object} */
    this.getModule = function (moduleName)
    {
        if (typeof moduleName !== "string") return undefined;

        var lowerName = moduleName.toLowerCase();
        var moduleEntry = _moduleCache[lowerName];

        if (moduleEntry == null || EVUI.Modules[moduleEntry.name] !== moduleEntry.module)
        {
            updateModuleCache();

            moduleEntry = _moduleCache[lowerName];
            if (moduleEntry == null) return undefined;
        }

        return moduleEntry.module;
    };

    /**Gets a constant value from a module's Constants table.
    @param {String} moduleName The name of the module to get the constant from.
    @param {String} constValueName The name of the constant value to get.
    @returns {Any} */
    this.getConstant = function (moduleName, constValueName)
    {
        if (moduleName == null) return undefined;

        var moduleEntry = null;
        if (typeof moduleName === "object")
        {
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(constValueName) === true) return undefined;

            moduleEntry = getModuleEntryByReference(moduleName);
        }
        else if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(moduleName) === false)
        {
            var parseResult = resolvePath(moduleName);
            if (parseResult.moduleEntry != null)
            {
                moduleEntry = parseResult.moduleEntry;
                if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(constValueName) === true && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(parseResult.enumValueKey) === false) constValueName = parseResult.enumValueKey;
            }
        }

        if (moduleEntry == null || constValueName == null) return undefined;
        return moduleEntry.constants.values[constValueName.toLowerCase()];
    };

    /**Takes a string path and resolves it into any ModuleEntry or EnumEntry that could be found in part of the path.
    @param {String} path The path of the value to get.
    @returns {ParsedEnumPath}*/
    var resolvePath = function (path)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(path) === true) return null; //not a valid string, nothing we can do

        var parseResult = new ParsedEnumPath();
        var pathSegs = EVUI.Modules.Core.Utils.getValuePathSegments(path);
        var numSegs = pathSegs.length;

        //walk each segment and try and resolve a module or enum entry based on any path segment's case normalized value
        for (var x = 0; x < numSegs; x++)
        {
            var curSeg = pathSegs[x];
            var lowerSeg = curSeg.toLowerCase();

            if (lowerSeg === "evui" || lowerSeg === "modules") continue; //root namespaces, just skip

            if (parseResult.moduleEntry == null) //if we haven't found a module yet, go look for one of those first
            {
                var moduleEntry = getModuleEntry(lowerSeg);
                if (moduleEntry != null)
                {
                    parseResult.moduleEntry = moduleEntry;
                    continue;
                }
            }

            if (parseResult.moduleEntry != null && lowerSeg === "constants") //if we found a module already and the current segment is "constants", we're getting something from the module's Constants table
            {
                parseResult.enumEntry = moduleEntry.constants;
            }
            else if (parseResult.moduleEntry != null && lowerSeg === "dependencies") //if we found a module already and the current segment is "dependencies", we're getting something from the module's Dependencies table
            {
                parseResult.enumEntry = moduleEntry.dependencies;
            }

            //if we don't have a module name match, do a enum name match (all enums should have unique names)
            if (parseResult.enumEntry == null)
            {
                var enumEntry = getEnumEntry(lowerSeg);
                if (enumEntry != null)
                {
                    parseResult.enumEntry = enumEntry
                    parseResult.moduleEntry = enumEntry.module;

                    continue;
                }
            }

            if (parseResult.enumEntry != null && parseResult.moduleEntry != null) //found both an enum and a module - take the last segment of the path as the value key we're looking for
            {
                if (x <= numSegs - 1)
                {
                    parseResult.enumValueKey = pathSegs[numSegs - 1].toLowerCase();
                    break;
                }
            }
        } 

        //if we didn't find an enum by looping through the segments, go update the cache and look again - its possible a module was loaded between the last and current call to get the enum value
        if (parseResult.enumEntry == null)
        {
            if (parseResult.moduleEntry != null && numSegs === 1) return parseResult;

            if (updateModuleCache() === true) //if updateModuleCache is true, we actually updated something. Otherwise we had the latest data and we don't have what the user is looking for
            {
                return resolvePath(path); //look again if we updated something
            }
            else
            {
                return parseResult;
            }
        }
        else
        {
            return parseResult;
        }

    };

    /**Walks the list of modules current loaded as part of EventUI and sees if any of them needs a re-scan of enum members. Returns true if something was updated.
    @returns {Boolean}*/
    var updateModuleCache = function ()
    {
        var allModules = Object.keys(EVUI.Modules);
        var numModules = allModules.length;
        var updated = false;

        for (var x = 0; x < numModules; x++) //walk the list of all module keys found in EVUI
        {
            var curModuleKey = allModules[x];
            var lowerKey = curModuleKey.toLowerCase();

            var curModule = EVUI.Modules[curModuleKey];
            var cachedModule = _moduleCache[lowerKey];

            if (cachedModule == null) //module wasn't in the cache, go scan its contents and add it
            {
                var moduleEntry = new ModuleEntry();
                moduleEntry.module = curModule;
                moduleEntry.name = curModuleKey;

                buildModuleEnumEntries(moduleEntry, curModule);
                _moduleCache[lowerKey] = moduleEntry;
                updated = true;
            }
            else //module was in the cache. See if we still have the same module reference. If not, go update the cache.
            {
                if (cachedModule.module !== curModule)
                {
                    buildModuleEnumEntries(moduleEntry, curModule);
                    updated = true;
                }
            }
        }

        return updated;
    };

    /**If we were handed a module reference, go find it in the modules list (so we know its name) or see if it was overwritten with a newer module.
    @param {Object} moduleObj An object that could be one of EventUI's modules.
    @returns {ModuleEntry}*/
    var getModuleEntryByReference = function (moduleObj)
    {
        var matchingModule = null;
        var moduleName = null;

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(moduleObj.name) === false) //the module will have a name in the final built version of the library, but for the local debugging copy it will not
        {
            moduleName = moduleObj.name;
            matchingModule = EVUI.Modules[moduleName];
        }
        else //no module name - go find something that matches based on the reference
        {
            if (moduleObj.Constants === undefined || moduleObj.Dependencies === undefined) //if it's missing either Dependencies or Constants, it's either Core or not a module at all
            {
                if (moduleObj === EVUI.Modules.Core || (moduleObj.Settings !== undefined && moduleObj.Utils !== undefined && typeof moduleObj.Utils.stringIsNullOrWhitespace === "function"))
                {
                    moduleName = "Core";
                    matchingModule = moduleObj;
                }
            }
            else //has the correct properties to be a real module, go do a reference check
            {
                var moduleKeys = Object.keys(EVUI.Modules);

                var numKeys = moduleKeys.length;
                for (var x = 0; x < numKeys; x++)
                {
                    var key = moduleKeys[x];
                    var mod = EVUI.Modules[key];

                    if (mod === moduleObj)
                    {
                        matchingModule = mod;
                        moduleName = key;
                        break;
                    }
                }
            }
        }

        if (matchingModule == null) return null;

        var lowerName = moduleName.toLowerCase();
        var existing = _moduleCache[lowerName];
        var needsRefresh = false;

        if (existing == null) //no module with the given name in the cache, go add it
        {
            existing = new ModuleEntry();
            existing.name = moduleName;
            existing.module = matchingModule;

            _moduleCache[lowerName] = existing;
            needsRefresh = true;
        }

        if (existing.module !== matchingModule) needsRefresh = true; //found the existing module, see if it has been updated since it was last scanned

        if (needsRefresh === true)
        {
            buildModuleEnumEntries(existing, moduleObj);
        }

        return existing;
    };

    /**Builds the enumCache for a given module object.
    @param {ModuleEntry} moduleEntry The module being refreshed or built.
    @param {Object} newModuleObj The module being scanned.*/
    var buildModuleEnumEntries = function (moduleEntry, newModuleObj)
    {
        var existingEnums = Object.keys(moduleEntry.module);
        var numEnums = existingEnums.length;
        for (var x = 0; x < numEnums; x++) //purge the cache of everything already existing in the enum cache for the given module.
        {
            delete _enumCache[existingEnums[x]];
        }

        var newEnums = Object.keys(newModuleObj);
        var newEntries = {};
        var numEnums = newEnums.length;
        var constants = null;
        var dependencies = null;

        for (var x = 0; x < numEnums; x++) //walk each value in the module and see if it follows the rules for being a potential enum
        {
            var key = newEnums[x];

            var curObj = newModuleObj[key];

            if (curObj == null) continue;
            if (typeof curObj !== "object") continue; //must be an object and not a constructor function
            if (curObj.constructor !== Object.prototype.constructor) continue; //enums are always plain objects
            if (Object.isFrozen(curObj) === false) continue; //enums are always frozen

             //Constants and Dependencies follow all the rules, but are special and get special handling because they do not have unique names
            if (key === "Constants")
            {
                constants = curObj;
                continue;
            }
            else if (key === "Dependencies")
            {
                dependencies = curObj;
                continue;
            }

            //not a special enum, go build an entry for it and add it to its respective caches
            var enumEntry = buildEnumEntry(curObj, key, moduleEntry)
            if (enumEntry != null)
            {
                var lowerKey = key.toLowerCase();
                newEntries[lowerKey] = enumEntry;
                _enumCache[lowerKey] = enumEntry;
            }
        }

        moduleEntry.enumEntries = newEntries;
        moduleEntry.module = newModuleObj;
        moduleEntry.constants = buildEnumEntry(constants, "Constants", moduleEntry);
        moduleEntry.dependencies = buildEnumEntry(dependencies, "Dependencies", moduleEntry);;
    };

    /**Builds an EnumEntry for the given object.
    @param {Object} enumObj The enum constants table.
    @param {String} name The name of the enum.
    @param {ModuleEntry} moduleEntry The module that contains the enum.
    @returns {EnumEntry}*/
    var buildEnumEntry = function (enumObj, name, moduleEntry)
    {
        if (enumObj == null) return null;

        var enumEntry = new EnumEntry();
        enumEntry.name = name;
        enumEntry.module = moduleEntry;
        enumEntry.enumObj = enumObj;

        var enumKeys = Object.keys(enumObj);
        var numKeys = enumKeys.length;
        for (var x = 0; x < numKeys; x++)
        {
            var curKey = enumKeys[x];
            var curValue = enumObj[curKey];

            enumEntry.values[curKey.toLowerCase()] = curValue;
        }

        return enumEntry;
    };

    /**Helper method to get an EnumEntry from the cache.
    @param {String} enumName The name of the enum to get.
    @returns {EnumEntry}*/
    var getEnumEntry = function (enumName)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(enumName) === true) return undefined;
        return _enumCache[enumName];
    };

    /**Helper method to get the ModuleEntry from the cache.
    @param {String} moduleName The name of the module to get.
    @returns {ModuleEntry} */
    var getModuleEntry = function (moduleName)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(moduleName) === true) return undefined;
        return _moduleCache[moduleName];
    }

    /**Object for holding cached details about a Module.
    @class*/
    var ModuleEntry = function ()
    {
        /**String. The name of the module.
        @type {String}*/
        this.name = null;

        /**Object. The actual Module object.
        @type {Object}*/
        this.module = null;

        /**Object. The EnumEntry for the Constants table in the Module.
        @type {EnumEntry}*/
        this.constants = null;

        /**Object. The EnumEntry for the Dependencies table in the Module.
        @type {EnumEntry}*/
        this.dependencies = null;

        /**Object. Lookup dictionary of all enums in the module. The keys are the lower-case names of the enums, the values are EnumEntries.
        @type {Object}*/
        this.enumEntries = {};
    };

    /**Helper method for getting an EnumEntry from a ModuleEntrty.
    @param {String} enumName The name of the enum to get.
    @returns {EnumEntry}*/
    ModuleEntry.prototype.getEnumEntry = function (enumName)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(enumName) === true) return undefined;
        return this.enumEntries[enumName];
    }

    /**Object for holding cached information about an enum and its members.
    @class*/
    var EnumEntry = function ()
    {
        /**Object. The ModuleEntry of the module that contains this enum.
        @type {ModuleEntry}*/
        this.module = null;

        /**String. The name of the enum as it appears in the code.
        @type {String}*/
        this.name = null;

        /**Object. The actual enum object reference.
        @type {Object}*/
        this.enumObj = null;

        /**Object. A case-corrected dictionary of enum value keys to their values in the enum.
        @type {Object}*/
        this.values = {};
    };

    /**Object for holdig the parse results of an arbitrary string path for an enum or an enum value.
    @class*/
    var ParsedEnumPath = function ()
    {
        /**String. The name of the value to get in the enum to get.
        @type {String}*/
        this.enumValueKey = null;

        /**Object. The enum that contains the value being retrieved.
        @type {EnumEntry}*/
        this.enumEntry = null;

        /**Object. The module that contains the value being retrieved.
        @type {ModuleEntry}*/
        this.moduleEntry = null;
    };
};

/**Static instance of the EnumValueGetter.
@type {EVUI.Modules.Enums.EnumValueGetter}*/
EVUI.Modules.Enums.ValueGetter = null;
(function ()
{
    var getter = null;
    Object.defineProperty(EVUI.Modules.Enums, "ValueGetter", {
        get: function ()
        {
            if (getter == null) getter = new EVUI.Modules.Enums.EnumValueGetter();
            return getter;
        },
        configurable: false,
        enumerable: true
    });
})();

/**Gets either an enum object or a value from an enum object.
@param {String|Object} enumNameOrModule Either the path to an enum, an enum's name, a module object, or the name of a module.
@param {String} enumKeyOrName Optional. Either the name/path of the enum (if the first parameter was a module) object and its value.
@param {String} enumKey Optional. The key of the value to get from the enum.
@returns {Any}*/
$evui.enum = function (enumNameOrModule, enumKeyOrName, enumKey)
{
    return EVUI.Modules.Enums.ValueGetter.getEnumValue(enumNameOrModule, enumKeyOrName, enumKey);
};

/**Gets a constant value from a module's Constants table.
@param {String} moduleName The name of the module to get the constant from.
@param {String} constValueName The name of the constant value to get.
@returns {Any}*/
$evui.const = function (moduleName, constValueName)
{
    return EVUI.Modules.Enums.ValueGetter.getConstant(moduleName, constValueName);
};

/**Gets a module object based on its name.
@param {String} moduleName The name of the module to get.
@returns {Object}*/
$evui.module = function (moduleName)
{
    return EVUI.Modules.Enums.ValueGetter.getModule(moduleName);
};

Object.freeze(EVUI.Modules.Enums);

/*#ENDWRAP(Enums)#*/


/********************************************************Events.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.Events|Event)#*/
/*#REPLACE(EVUI.Modules.Events|Event)#*/

/**Module for custom events that are not attached to the DOM.
@module*/
EVUI.Modules.Events = {};

/*#MODULEDEF(Event|"1.0";|"Events")#*/
/*#VERSIONCHECK(EVUI.Modules.Events|Event)#*/

EVUI.Modules.Events.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
    EventStream: Object.freeze({ version: "1.0", required: true }),
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.Events.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();


Object.freeze(EVUI.Modules.Events.Dependencies);

/**Constants table relating to the EventManager. */
EVUI.Modules.Events.Constants = {};

/**The handler that will be fired for each event.
@param {EVUI.Modules.Events.EventManagerEventArgs} eventHandlerArgs An instance of EventManagerEventArgs.*/
EVUI.Modules.Events.Constants.Fn_Handler = function (eventHandlerArgs) { };

/**The callback that will be fired once the ask operation is complete.
@param {EVUI.Modules.Events.AskResult[]} answers An array of AskResponses representing the response from each EventListener that was asked to respond.*/
EVUI.Modules.Events.Constants.Fn_AskResultCallback = function (answers) { };

Object.freeze(EVUI.Modules.Events.Constants);

/**Utility for managing sending signals between areas of code without being bound to DOM elements.
@class*/
EVUI.Modules.Events.EventManager = function ()
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Events.Dependencies);

    var _self = this;

    /**We keep an internal list of listeners composed of InternalEventListener objects to make the HandlerID immutable.
    @type {InternalEventListener[]}*/
    var _listeners = [];

    /**Represents the internal metadata about an event.
    @class*/
    var InternalEventListener = function ()
    {
        /**The EventListener object being managed.
        @type {EVUI.Modules.Events.EventListener}*/
        this.eventListener = null;

        /**The order in which the listener was registered relative to other listeners with the same name.
        @type {Number}*/
        this.ordinal = null;

        /**The mode of operation for the EventListener. Must be a value from EventListenerMode.
        @type {Number}*/
        this.mode = EventListenerMode.None;
    };

    /**Enum for keeping track of how an EventListner should be treated.
    @enum*/
    var EventListenerMode =
    {
        None: -1,
        FireUntilRemoved: 0,
        FireOnce: 1,
        Removed: 2
    };

    /**Enum for determining the behavior of the EventSession being executed.
    @enum*/
    var SessionMode =
    {
        None: -1,
        Trigger: 0,
        Ask: 1
    };

    /**Represents the internal data aggregated for a list of events that will be executed.
    @class*/
    var EventSession = function ()
    {
        /**String. The unique identifier for the session.
        @type {String}*/
        this.sessionID = EVUI.Modules.Core.Utils.makeGuid();

        /**Object. The arguments used to trigger the event.
        @type {EVUI.Modules.Events.EventTriggerArgs}*/
        this.triggerArgs = null;

        /**Array. The array of InternalEventListeners that are going to be executed.
        @type {InternalEventListener[]}*/
        this.listeners = [];

        /**Function. If the mode is "Ask", this is the callback that will return the AskResponses to the caller.
        @type {EVUI.Modules.Events.Constants.Fn_AskResultCallback}*/
        this.callback = null;

        /**Number. The mode of operation for this EventSession. Must be a value from the SessionMode enum.
        @type {Number}*/
        this.mode = SessionMode.None;

        /**Array. The array of results that were returned from each EventListener that responded to an ask operation.
        @type {EVUI.Modules.Events.AskResult[]}*/
        this.askResults = [];

        /**Object. The EventStream managing the flow of the events.
        @type {EVUI.Modules.EventStream.EventStream}*/
        this.eventStream = null;
    };

    /**Adds a listener to the EventManager to be executed whenever trigger is called on an event with the same name.
    @param {EVUI.Modules.Events.EventListenerAddRequest|String} eventListenerOrEventName Either a YOLO EventListener object or the name of the event to listen for,
    @param {EVUI.Modules.Events.Constants.Fn_Handler} handler The function that will be executed when this event is triggered.
    @param {Number} priority The priority of this event relative to the other events with the same name to determine the execution order of event handlers.
    @param {String} handlerName An identifier to give the handler for tracing purposes.
    @returns {EVUI.Modules.Events.EventListener}*/
    this.on = function (eventListenerOrEventName, handler, priority, handlerName)
    {
        return addListener(eventListenerOrEventName, handler, priority, handlerName, EventListenerMode.FireUntilRemoved);
    };

    /**Adds a listener to the EventManager to be executed whenever trigger is called on an event with the same name and then is removed.
    @param {EVUI.Modules.Events.EventListenerAddRequest|String} eventListenerOrEventName Either a YOLO EventListener object or the name of the event to listen for,
    @param {EVUI.Modules.Events.Constants.Fn_Handler} handler The function that will be executed when this event is triggered.
    @param {Number} priority The priority of this event relative to the other events with the same name to determine the execution order of event handlers.
    @param {String} handlerName An identifier to give the handler for tracing purposes.
    @returns {EVUI.Modules.Events.EventListener}*/
    this.once = function (eventListenerOrEventName, handler, priority, handlerName)
    {
        return addListener(eventListenerOrEventName, handler, priority, handlerName, EventListenerMode.FireOnce);
    };

    /**Removes all the EventListeners with the given event name, callback function and/or exeuctingContext.
    @param {String} eventNameOrIDOrHandler The name or ID of the event to remove.
    @param {EVUI.Modules.Events.Constants.Fn_Handler} handler The function that gets called when the event is invoked.*/
    this.off = function (eventNameOrId, handler)
    {
        var listenersToRemove = [];

        var numListeners = _listeners.length;
        for (var x = 0; x < numListeners; x++)
        {
            var curListener = _listeners[x];

            if (curListener.eventListener.handlerId === eventNameOrId || curListener.eventListener.eventName === eventNameOrId)
            {
                if (typeof handler === "function")
                {
                    if (curListener.eventListener.handler === handler) listenersToRemove.push(curListener);
                }
                else
                {
                    listenersToRemove.push(curListener);
                }
            }
        }

        var numToRemove = listenersToRemove.length;
        for (var x = 0; x < numToRemove; x++)
        {
            var index = _listeners.indexOf(listenersToRemove[x]);
            if (index !== -1) _listeners.splice(index, 1);
        }
    };

    /**Calls all the event listeners with the given name.
    @param {EVUI.Modules.Events.EventTriggerArgs|String} eventNameOrTriggerArgs Either a YOLO EventTriggerArgs object or the name of the event to trigger.
    @param {Any} data Any data to pass to the events being triggered.
    @param {String} triggerName The name to give the trigger for tracing purposes.*/
    this.trigger = function (eventNameOrTriggerArgs, data, triggerName)
    {
        var triggerArgs = toTriggerArgs(eventNameOrTriggerArgs, data, triggerName);

        var session = buildEventSession(triggerArgs, SessionMode.Trigger);
        if (session == null) return;

        launchEvent(session);
    };

    /**Calls all the event listeners with the given name and collects their responses and passes them into the callback function.
    @param {EVUI.Modules.Events.EventTriggerArgs|String} eventNameOrTriggerArgs Either a YOLO EventTriggerArgs object or the name of the event to trigger.
    @param {Any} data Any data to pass to the events being triggered.
    @param {String} triggerName The name to give the trigger for tracing purposes.
    @param {EVUI.Modules.Events.Constants.Fn_AskResultCallback} callback The callback function that will be passed the responses to the ask operation from each handler.*/
    this.ask = function (eventNameOrTriggerArgs, data, triggerName, callback)
    {
        if (typeof callback !== "function") callback = function (askResults) { };

        var triggerArgs = toTriggerArgs(eventNameOrTriggerArgs, data, triggerName);

        var session = buildEventSession(triggerArgs, SessionMode.Ask, callback);
        if (session == null) return callback([]);

        launchEvent(session);
    };

    /**Awaitable. Calls all the event listeners with the given name and collects their responses and returns them as the promise resolution value.
    @param {EVUI.Modules.Events.EventTriggerArgs|String} eventNameOrTriggerArgs Either a YOLO EventTriggerArgs object or the name of the event to trigger.
    @param {Any} data Any data to pass to the events being triggered.
    @param {String} triggerName The name to give the trigger for tracing purposes.
    @returns {Promise<EVUI.Modules.Events.AskResult[]>}*/
    this.askAsync = function (eventNameOrTriggerArgs, data, triggerName)
    {
        return new Promise(function (resolve)
        {
            _self.ask(eventNameOrTriggerArgs, data, triggerName, function (askResponses)
            {
                resolve(askResponses);
            });
        });
    };

    /**Gets all the event listeners with the given event name, callback function and/or exeuctingContext. 
    @param {String} eventName: The name of the event to get.
    @returns {EVUI.Modules.Events.EventListener[]}*/
    this.getEventListeners = function (eventName)
    {
        return getListeners(eventName).map(function (listener) { return listener.eventListener });
    };

    /**Gets an event listener based on its HandlerID.
    @param {String} handlerID: The ID of the event listener handle to get.
    @returns {EVUI.Modules.Events.EventListener}*/
    this.getEventListener = function (handlerID)
    {
        var listener = getListener(handlerID);
        if (listener == null) return null;

        return listener.eventListener;
    };

    /**Adds a listener to the EventManager to be executed whenever trigger is called on an event with the same name and then is removed.
    @param {EVUI.Modules.Events.EventListener|String} eventListenerOrEventName Either a YOLO EventListener object or the name of the event to listen for,
    @param {EVUI.Modules.Events.Constants.Fn_Handler} handler The function that will be executed when this event is triggered.
    @param {Number} priority The priority of this event relative to the other events with the same name to determine the execution order of event handlers.
    @param {String} handlerName An identifier to give the handler for tracing purposes.
    @param {Number} mode The mode in which the event handler will be managed.
    @returns {EVUI.Modules.Events.EventListener}*/
    var addListener = function (eventListenerOrEventName, handler, priority, handlerName, mode)
    {
        if (eventListenerOrEventName == null) return null;
        var eventListener = null;

        //they gave us a list of parameters and not just an object
        if (typeof eventListenerOrEventName === "string")
        {
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(eventListenerOrEventName) === true) throw Error("Event name must be a non-whitespace string.");
            if (typeof handler !== "function") throw Error("Event handler must be a function.");

            eventListener = new EVUI.Modules.Events.EventListener(eventListenerOrEventName, handler, priority, handlerName);
        }
        else if (typeof eventListenerOrEventName === "object") //they gave us an object, make it into one of our objects.
        {
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(eventListenerOrEventName.eventName) === true) throw Error("Event name must be a non-whitespace string.");
            if (typeof eventListenerOrEventName.handler !== "function") throw Error("Event handler must be a function.");

            eventListener = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Events.EventListener(eventListenerOrEventName.eventName, eventListenerOrEventName.handler, eventListenerOrEventName.priority, eventListenerOrEventName.handlerName), eventListenerOrEventName, ["eventName", "handler", "priority", "handlerName", "handlerId"])
        }
        else
        {
            throw Error("Invalid parameters. First parameter must be either a YOLO EventListener object or a non-whitespace string event name.");
        }

        var maxOrdinal = 0;
        var numEntries = _listeners.length;
        for (var x = 0; x < numEntries; x++)
        {
            var curEntry = _listeners[x];
            if (curEntry.eventListener.eventName === eventListener.eventName)
            {
                if (curEntry.ordinal >= maxOrdinal) maxOrdinal = curEntry.ordinal + 1;
            }
        }

        var internalListener = new InternalEventListener();
        internalListener.eventListener = eventListener;
        internalListener.mode = mode;
        internalListener.ordinal = maxOrdinal;

        //add it to our internal index of handlers
        _listeners.push(internalListener);

        //return the handlerId, like how setTimeout and setInterval do
        return eventListener;
    }

    /**Translates the arguments from the trigger and ask functions into a EventTriggerArgs object.
    @param {EVUI.Modules.Events.EventTriggerArgs|String} eventNameOrTriggerArgs Either a YOLO EventTriggerArgs object or the name of the event to trigger.
    @param {Any} data Any data to pass to the events being triggered.
    @param {String} triggerName The name to give the trigger for tracing purposes.
    @returns {EVUI.Modules.Events.EventTriggerArgs}*/
    var toTriggerArgs = function (eventNameOrTriggerArgs, data, triggerName)
    {
        var triggerArgs = new EVUI.Modules.Events.EventTriggerArgs();
        if (typeof eventNameOrTriggerArgs === "string" && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(eventNameOrTriggerArgs) === false)
        {
            triggerArgs.eventName = eventNameOrTriggerArgs;
            triggerArgs.data = data;
            triggerArgs.triggerName = triggerName;
        }
        else if (typeof eventNameOrTriggerArgs === "object")
        {
            EVUI.Modules.Core.Utils.shallowExtend(triggerArgs, eventNameOrTriggerArgs);
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(triggerArgs.eventName) === true) throw Error("Event name must be a non-whitespace string.");
        }
        else
        {
            throw Error("Invalid parameters. Parameter must be a YOLO EventTriggerArgs object or a non-whitespace string.")
        }

        return triggerArgs;
    };

    /**Builds an EventSession by collecting all the EventListeners that will be executed and building the EventStream that will manage their execution.
    @param {EVUI.Modules.Events.EventTriggerArgs} triggerArgs The arguments used for triggering the event.
    @param {Number} mode The mode of the EventSession, must be a value from EventSessionMode.
    @param {EVUI.Modules.Events.Constants.Fn_AskResultCallback} callback The ask result callback if the EventSession is an ask operation.
    @returns {EventSession}*/
    var buildEventSession = function (triggerArgs, mode, callback)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(triggerArgs.eventName) === true) return null;

        var session = new EventSession();
        session.triggerArgs = triggerArgs;
        session.mode = mode;
        session.callback = callback;

        var listeners = getListeners(triggerArgs.eventName);
        if (listeners == null || listeners.length === 0) return null;

        listeners = listeners.sort(function (listener1, listener2)
        {
            if (listener1.eventListener.priority === listener2.eventListener.priority)
            {
                return listener1.orindal - listener2.ordinal;
            }
            else
            {
                return listener2.eventListener.priority - listener1.eventListener.priority;
            }
        });

        session.listeners = listeners;
        session.eventStream = buildEventStream(session);

        return session;
    };

    /**Logs a tracing message about the triggering and handling of an event.
    @param {EVUI.Modules.Events.EventTriggerArgs} triggerArgs The arguments used to trigger the event.
    @param {InternalEventListener} eventListener An instance of InternalEventListener.*/
    var trace = function (triggerArgs, eventListener)
    {
        if (EVUI.Modules.Core.Utils.isSettingTrue("traceEvents") === false) return;

        var handlerName = EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(eventListener.handlerName) ? "unknown" : eventListener.handlerName;
        var triggerName = EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(triggerArgs.triggerName) ? "unknown" : triggerArgs.triggerName;

        var traceMessage = "BTMTRACE: Event \"" + triggerArgs.eventName + "\": (\"" + triggerName + "\") => \"" + handlerName + "\"";

        EVUI.Modules.Core.Utils.log(traceMessage);
    };

    /**Queues the EventSession and dispatches a new event to trigger the new EventStream.
    @param {EventSession} session The session to execute.*/
    var launchEvent = function (session)
    {
        window.setTimeout(function () //set a timeout so the steps in multiple concurrent queued EventStreams go in order instead of in parallel
        {
            session.eventStream.execute();
        });
    };

    /**Builds the EventStream that will execute all of the queued events sequentially.
    @param {EventSession} session The session containing all the data to use in building the EventStream.
    @returns {EVUI.Modules.EventStream.EventStream}*/
    var buildEventStream = function (session)
    {
        var index = 0;
        var numEvents = session.listeners.length;

        var es = new EVUI.Modules.EventStream.EventStream();

        es.processInjectedEventArgs = function (eventStreamArgs)
        {
            var eventManagerArgs = new EVUI.Modules.Events.EventManagerEventArgs(getNextListener(session, index), index + 1);
            eventManagerArgs.data = session.triggerArgs.data;
            eventManagerArgs.totalSteps = numEvents;
            eventManagerArgs.pause = eventStreamArgs.pause;
            eventManagerArgs.resume = eventStreamArgs.resume;
            eventManagerArgs.stopPropagation = eventStreamArgs.stopPropagation;

            if (session.mode === SessionMode.Ask)
            {
                eventManagerArgs.resume = function (answer)
                {
                    if (eventStreamArgs.resume() === true)
                    {
                        registerAnswer(session, eventManagerArgs.listener, answer, true);
                    }
                    
                };
            }

            if (eventStreamArgs.error == null) index++;

            return eventManagerArgs;
        };

        es.processReturnedEventArgs = function (eventManagerArgs, handlerResult)
        {
            if (eventManagerArgs instanceof EVUI.Modules.Events.EventManagerEventArgs) session.triggerArgs.data = eventManagerArgs.data;
            if (session.mode === SessionMode.Ask)
            {
                registerAnswer(session, eventManagerArgs.listener, handlerResult);
            }
        };

        es.endExecutionOnEventHandlerCrash = false;

        var numListeners = session.listeners.length;
        for (var x = 0; x < numListeners; x++)
        {
            addEvent(es, session, x);
        }

        if (session.mode === SessionMode.Ask)
        {
            es.addStep({
                key: "complete",
                name: "onComplete",
                type: EVUI.Modules.EventStream.EventStreamStepType.Job,
                handler: function (args)
                {
                    if (typeof session.callback === "function")
                    {
                        var exeArgs = new EVUI.Modules.Core.AsyncSequenceExecutionArgs();
                        exeArgs.functions = session.callback;
                        exeArgs.parameter = session.askResults;

                        EVUI.Modules.Core.AsyncSequenceExecutor.execute(exeArgs, function (error)
                        {
                            if (error != null)
                            {
                                throw error;
                            }

                            args.resolve();
                        });
                    }
                }
            });
        }

        return es;
    };

    /**Adds an event to the EventStream.
    @param {EVUI.Modules.EventStream.EventStream} es The EventStream to add the listener to.
    @param {EventSession} session The EventSession being executed.
    @param {Number} listenerIndex The index of the current event that is being added to the EventStream.*/
    var addEvent = function (es, session, listenerIndex)
    {
        if (es == null || session == null || session.listeners.length < listenerIndex) return;

        var curListener = session.listeners[listenerIndex];
        if (curListener.mode === EventListenerMode.Removed) return;
        

        es.addStep({
            name: curListener.eventListener.eventName + "-(" + session.sessionID + ")" + "-" + listenerIndex,
            key: curListener.eventListener.eventName,
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (eventManagerArgs)
            {
                if (typeof curListener.eventListener.handler !== "function" || curListener.mode === EventListenerMode.Removed) return;
                trace(session.triggerArgs, eventManagerArgs.listener);

                return eventManagerArgs.listener.handler(eventManagerArgs);
            }
        });

        //if we're in a fire-once scenario, add an extra step after the previous step has completed to remove the event from future lists and to flag it as having been removed.
        if (curListener.mode === EventListenerMode.FireOnce)
        {
            es.addStep({
                name: "removeFireOnce" + curListener.eventListener.eventName + "-(" + session.sessionID + ")" + "-" + listenerIndex,
                key: "remove:" + curListener.eventListener.eventName + "-" + listenerIndex,
                type: EVUI.Modules.EventStream.EventStreamStepType.Job,
                handler: function (jobArgs)
                {
                    curListener.mode = EventListenerMode.Removed;

                    var index = _listeners.indexOf(curListener);
                    if (index !== -1) _listeners.splice(index, 1);

                    jobArgs.resolve();
                }
            });
        }
    };

    /**Gets the next EventListener from the session with the given index.
    @param {EventSession} session The session that contains the listeners to get.
    @param {Number} index The index of the listener to get.
    @returns {EVUI.Modules.Events.EventListener} */
    var getNextListener = function (session, index)
    {
        var internalListener = session.listeners[index];
        if (internalListener == null) return null;

        return internalListener.eventListener;
    };

    /**If the operation is an ask operation, this registers the returned value from the event handler and ties it to the EventListener that was executed.
    @param {EventSession} session The session being executed.
    @param {EVUI.Modules} listener The listener that was completed.
    @param {Any} answer The answer that was returned.*/
    var registerAnswer = function (session, listener, answer, overwrite)
    {
        //make sure we're not filling in an answer for an event listener that was already flagged as being removed in a subsequent step or previous EventStream execution.
        var numListeners = session.listeners.length;
        for (var x = 0; x < numListeners; x++)
        {
            var curListener = session.listeners[x];
            if (curListener.eventListener === listener && curListener.mode === EventListenerMode.Removed) return;
        }

        //find the existing answer and get the existing answer so we can see if it can be overwritten with the new answer.
        var existingAnswer = null;
        var numAnswers = session.askResults.length;
        for (var x = 0; x < numAnswers; x++)
        {
            var curAnswer = session.askResults[x];
            if (curAnswer.eventListner === listener)
            {
                existingAnswer = curAnswer;
                break;
            }
        }

        if (existingAnswer != null) //if the answer's previous value was null and we now have a non-null value for it, overwrite it
        {
            if ((overwrite === true || existingAnswer.response === undefined) && answer !== undefined) existingAnswer.response = answer;
        }
        else //otherwise make a new answer response
        {
            var response = new EVUI.Modules.Events.AskResult();
            response.eventListner = listener;
            response.response = answer;

            session.askResults.push(response);
        }
    };

    /**Gets all the event listeners with the given event name, callback function and/or exeuctingContext. 
    @param {String} eventName: The name of the event to get.
    @returns {InternalEventListener[]}*/
    var getListeners = function (eventName)
    {
        var listeners = [];

        var numEventListeners = _listeners.length;
        for (var x = 0; x < numEventListeners; x++)
        {
            var curListener = _listeners[x];
            if (curListener.eventListener.eventName === eventName) listeners.push(curListener);
        }

        return listeners;
    };

    /**Gets an event listener based on its HandlerID.
    @param {String} handlerID: The ID of the event listener handle to get.
    @returns {InternalEventListener}*/
    var getListener = function (handlerID)
    {
        var numEventListeners = _listeners.length;
        for (var x = 0; x < numEventListeners; x++)
        {
            var curEventListener = _listeners[x];

            if (curEventListener.eventListener.handlerId === handlerID)
            {
                return curEventListener;
            }
        }
    };
};

/**An object that ties together an event name, its callback, its executing context, its priority (if there are other events with the same name) and the unique ID of it's handle.
@param {String} eventName The name of the event.
@param {EVUI.Constants.EventManager.Fn_Handler} handler The function to call when the event is invoked.
@param {Number} priority The priority of this event relative to other events with the same name.
@param {String} handlerName An identifier to give this listener, used for event tracing purposes.
@class*/
EVUI.Modules.Events.EventListener = function (eventName, handler, priority, handlerName)
{
    if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(eventName) === true) throw Error("event name must be a non-whitespace string.");
    if (typeof handler !== "function") throw Error("handler must be a function.");

    var _handlerId = EVUI.Modules.Core.Utils.makeGuid();
    var _priority = typeof priority === "number" ? priority : 0;
    var _eventName = eventName;
    var _handler = handler;
    var _handlerName = typeof handlerName === "string" ? handlerName : null;

    /**String. Read-only. The name of the event.
    @type {String}*/
    this.eventName = null;
    Object.defineProperty(this, "eventName", {    
        get: function () { return _eventName; },
        enumerable: true,
        configurable: false
    });

    /**Function. The function to call when this event is invoked.
    @type {EVUI.Modules.Events.Constants.Fn_Handler}*/
    this.handler = null;
    Object.defineProperty(this, "handler", {    
        get: function () { return _handler },
        set: function (value)
        {
            if (value != null && typeof value !== "function") throw Error("handler must be a function.")
            _handler = value;
        },
        enumerable: true,
        configurable: false
    });

    /**Number. The priority of this event relative to other events with the same name.
    @type {Number}*/
    this.priority = 0;
    Object.defineProperty(this, "priority", {
        get: function () { return _priority; },
        set: function (value)
        {
            if (typeof value !== "number") throw Error("priority must be a number.");
            _priority = value;
        },
        enumerable: true,
        configurable: false
    });

    /**String. Read-only. The unique ID of this event listener.
    @type {String}*/
    this.handlerId = _handlerId;
    Object.defineProperty(this, "handlerId", {
        get: function () { return _handlerId; },
        enumerable: true,
        configurable: false
    });

    /**An identifier to give the handler for tracing purposes.
    @type {String}*/
    this.handlerName = null;
    Object.defineProperty(this, "handlerName", {
        get: function () { return _handlerName; },
        set: function (value)
        {
            if (typeof value !== "string") throw Error("handlerName must be a string.");
            _handlerName = value;
        },
        configurable: false,
        enumerable: true
    });
};

/**Parameter object for creating an EventListener.
@class*/
EVUI.Modules.Events.EventListenerAddRequest = function ()
{
    /**String. The name of the event.
    @type {String}*/
    this.eventName = null;

    /**Function. The function to call when this event is invoked.
    @type {EVUI.Modules.Events.Constants.Fn_Handler}*/
    this.handler = null;

    /**Number. The priority of this event relative to other events with the same name.
    @type {Number}*/
    this.priority = null;

    /**An identifier to give the handler for tracing purposes.
    @type {String}*/
    this.handlerName = null;
};

/**The object that is injected into each handler as the arguments for the event being executed. Contains the user's custom event data as well as the functionality of the async event chain.
@class*/
EVUI.Modules.Events.EventManagerEventArgs = function (listener, currentStepIndex)
{
    var _listener = listener;
    var _currentStep = currentStepIndex;

    /**Object. The EventListener that is currently being executed.
    @type {EVUI.Modules.Events.EventListener}*/
    this.listener = null;
    Object.defineProperty(this, "listener", {
        get: function () { return _listener; },
        configurable: false,
        enumerable: true
    });

    /**Any. The user provided event argument data.
    @type {Any}*/
    this.data = null;

    /**Number. The index of the current step in the sequence of events.
    @type {Number}*/
    this.currentStep = -1;
    Object.defineProperty(this, "currentStep", {
        get: function () { return _currentStep; },
        configurable: false,
        enumerable: true
    });

    /**Number. The total number of events in the event sequence.
    @type {Number}*/
    this.totalSteps = -1;

    /**Function. Pauses the EventStream, preventing the next step from executing until resume is called.*/
    this.pause = function () { };

    /**Function. Resumes the EventStream, allowing it to continue to the next step.*/
    this.resume = function () { };

    /**Function. Stops the EventStream from calling any other event handlers with the same key.*/
    this.stopPropagation = function () { };
};

/**Optional arguments for triggering an event.
@class*/
EVUI.Modules.Events.EventTriggerArgs = function ()
{
    /**String. The name of the event to trigger.
    @type {String}*/
    this.eventName = null;

    /**Any. Any arguments to pass along into the triggering function.
    @type {Any}*/
    this.data = null;

    /**String. An identifier to give the trigger for tracing purposes.
    @type {String}*/
    this.triggerName = null;
};

/**Object representing the answer to an ask request.
@class*/
EVUI.Modules.Events.AskResult = function ()
{
    /**Object. The EventListener that was executed.
    @type {EVUI.Modules.Events.EventListener}*/
    this.eventListner = null;

    /**The value returned from the event handler.
    @type {Any}*/
    this.response = null;
};

/**Global instance of the EventManager, used for consuming and emitting custom events without binding them to the DOM.
@type {EVUI.Modules.Events.EventManager}*/
EVUI.Modules.Events.Manager = null;
(function ()
{
    var manager = null;
    var ctor = EVUI.Modules.Events.EventManager;

    Object.defineProperty(EVUI.Modules.Events, "Manager", {
        get: function ()
        {
            if (manager == null) manager = new ctor();
            return manager;
        },
        configurable: false,
        enumerable: true
    });
})();

delete $evui.events;

/**Global instance of the EventManager, used for consuming and emitting custom events without binding them to the DOM.
@type {EVUI.Modules.Events.EventManager}*/
$evui.events = null;
Object.defineProperty($evui, "events", {
    get: function ()
    {
        return EVUI.Modules.Events.Manager;
    },
    enumerable: true
});

/**Adds a listener to the EventManager to be executed whenever trigger is called on an event with the same name.
@param {EVUI.Modules.Events.EventListenerAddRequest|String} eventListenerOrName Either a YOLO EventListener object or the name of the event to listen for,
@param {EVUI.Modules.Events.Constants.Fn_Handler} handler The function that will be executed when this event is triggered.
@param {Number} priority The priority of this event relative to the other events with the same name to determine the execution order of event handlers.
@param {String} handlerName An identifier to give the handler for tracing purposes.
@returns {EVUI.Modules.Events.EventListener}*/
$evui.on = function (eventListenerOrName, handler, priority, handlerName)
{
    return $evui.events.on(eventListenerOrName, handler, priority, handlerName);
};

/**Adds a listener to the EventManager to be executed whenever trigger is called on an event with the same name and then is removed.
@param {EVUI.Modules.Events.EventListenerAddRequest|String} eventListenerOrName Either a YOLO EventListener object or the name of the event to listen for,
@param {EVUI.Modules.Events.Constants.Fn_Handler} handler The function that will be executed when this event is triggered.
@param {Number} priority The priority of this event relative to the other events with the same name to determine the execution order of event handlers.
@param {String} handlerName An identifier to give the handler for tracing purposes.
@returns {EVUI.Modules.Events.EventListener}*/
$evui.once = function (eventListenerOrName, handler, priority, handlerName)
{
    return $evui.events.once(eventListenerOrName, handler, priority, handlerName);
};

/**Removes all the EventListeners with the given event name, callback function and/or exeuctingContext.
@param {String} eventNameOrIDOrHandler The name or ID of the event to remove.
@param {EVUI.Modules.Events.Constants.Fn_Handler} handler The function that gets called when the event is invoked.*/
$evui.off = function (eventNameOrID, handler)
{
    return $evui.events.off(eventNameOrID, handler);
};

/**Calls all the event listeners with the given name.
@param {EVUI.Modules.Events.EventTriggerArgs|String} eventNameOrTriggerArgs Either a YOLO EventTriggerArgs object or the name of the event to trigger.
@param {Any} data Any data to pass to the events being triggered.
@param {String} triggerName The name to give the trigger for tracing purposes.*/
$evui.trigger = function (eventNameOrTriggerArgs, data, triggerName)
{
    return $evui.events.trigger(eventNameOrTriggerArgs, data, triggerName);
}

/**Calls all the event listeners with the given name and collects their responses and passes them into the callback function.
@param {EVUI.Modules.Events.EventTriggerArgs|String} eventNameOrTriggerArgs Either a YOLO EventTriggerArgs object or the name of the event to trigger.
@param {Any} data Any data to pass to the events being triggered.
@param {String} triggerName The name to give the trigger for tracing purposes.
@param {EVUI.Modules.Events.Constants.Fn_AskResultCallback} callback The callback function that will be passed the responses to the ask operation from each handler.*/
$evui.ask = function (eventNameOrTriggerArgs, data, triggerName, callback)
{
    return $evui.events.ask(eventNameOrTriggerArgs, data, triggerName, callback)
};

/**Awaitable. Calls all the event listeners with the given name and collects their responses and returns them as the promise resolution value.
@param {EVUI.Modules.Events.EventTriggerArgs|String} eventNameOrTriggerArgs Either a YOLO EventTriggerArgs object or the name of the event to trigger.
@param {Any} data Any data to pass to the events being triggered.
@param {String} triggerName The name to give the trigger for tracing purposes.
@returns {Promise<EVUI.Modules.Events.AskResult[]>}*/
$evui.askAsync = function (eventNameOrTriggerArgs, data, triggerName)
{
    return $evui.events.askAsync(eventNameOrTriggerArgs, data, triggerName)
};

/*#ENDWRAP(Event)#*/


/********************************************************EventStream.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/
/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.EventStream|ES)#*/
/*#REPLACE(EVUI.Modules.EventStream|ES)#*/

/**Module for containing the EventStream, an asynchronous Promise driven chain of arbitrary functions used to create event-driven interfaces.
@module*/
EVUI.Modules.EventStream = {};

/*#MODULEDEF(ES|"1.0"|"EventStream")#*/
/*#VERSIONCHECK(EVUI.Modules.EventStream|ES)#*/

EVUI.Modules.EventStream.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true })
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.EventStream.Dependencies, "checked",
    {
        get: function () { return checked; },
        set: function (value)
        {
            if (typeof value === "boolean") checked = value;
        },
        configurable: false,
        enumberable: true
    });

})();

Object.freeze(EVUI.Modules.EventStream.Dependencies);

/**Constants table for the EventStream module. */
EVUI.Modules.EventStream.Constants = {};

/**Function for completing a "Job" step in an EventStream.  
@param {EVUI.Modules.EventStream.EventStreamJobResult} jobResult An instance of EVUI.Modules.EventStream.EventStreamJobResult that carries the result of the job. */
EVUI.Modules.EventStream.Constants.Fn_Job_Callback = function (jobResult) { };

/**Function for handling a Step in a EventStream.
@param {EVUI.Modules.EventStream.EventStreamJobArgs|EVUI.Modules.EventStream.EventStreamEventArgs} jobOrEventArgs If the step is a Job, this will be an instance of EventStreamJobArgs. If this step is an event it gets either a EventStreamEventArgs 
or custom event arguments defined by another author.*/
EVUI.Modules.EventStream.Constants.Fn_Step_Handler = function (jobOrEventArgs) { };

/**Function for handling a Step in a EventStream that is a Job.
@param {EVUI.Modules.EventStream.EventStreamJobArgs} jobArgs An instance of EventStreamJobArgs.*/
EVUI.Modules.EventStream.Constants.Fn_Job_Handler = function (jobArgs) { };

/**Function for handling a Step in a EventStream that is an event.
@param {EVUI.Modules.EventStream.EventStreamEventArgs} eventArgs Either a EventStreamEventArgs object or custom event arguments defined by another author.*/
EVUI.Modules.EventStream.Constants.Fn_Event_Handler = function (eventArgs) { };

/**Synchronous event handler for handling cases where an error occurred at any point during the process. Cannot be an async function.
@param {EVUI.Modules.EventStream.EventStreamEventArgs} eventArgs An instance of EventStreamEventArgs.
@param {EVUI.Modules.EventStream.EventStreamError} ex The error that was thrown by the code in the event sequence or the response caused by a rejection of a job.*/
EVUI.Modules.EventStream.Constants.Fn_OnError = function (eventArgs, ex) { };

/**Synchronous event handler that executes whenever the EventStream has been completed or terminated. Cannot be an async function.
@param {EVUI.Modules.EventStream.EventStreamEventArgs} eventArgs An instance of EventStreamEventArgs.*/
EVUI.Modules.EventStream.Constants.Fn_OnComplete = function (eventArgs) { };

/**Synchronous event handler for handling cases where the EventStream was canceled before it was finished. Cannot be an async function.
@param {EVUI.Modules.EventStream.EventStreamEventArgs} eventArgs An instance of EventStreamEventArgs.*/
EVUI.Modules.EventStream.Constants.Fn_OnCancel = function (eventArgs) { };

/**Takes the event args generated for default events and gives the consumer of the EventStream a chance to inject its own event args. Cannot be an async function.
@param {EVUI.Modules.EventStream.EventStreamEventArgs} eventArgs An instance of EventStreamEventArgs.
@returns {Object}*/
EVUI.Modules.EventStream.Constants.Fn_ProcessInjectedEventArgs = function (eventArgs) { };

/**Takes the event args that were passed into the event handler and gives the consumer a chance to react to any changes made to them or react to the value returned from the event handler. Cannot be an async function.
@param {EVUI.Modules.EventStream.EventStreamEventArgs} args An instance of EventStreamEventArgs or the event args made in processInjectedEventArgs.
@param {Any} handlerResult The returned value from the handler.
@param {EVUI.Modules.EventStream.EventStreamStep} step An instance of EventStreamStep
@param {Any} jobState The current private state object for the EventStream that is only available to Jobs.
@param {Any} eventState The current public state object for the EventStream that is only available to Events.*/
EVUI.Modules.EventStream.Constants.Fn_ProcessReturnedEventArgs = function (args, handlerResult, step, jobState, eventState) { }

/**Manager for an asynchronous yet ordered sequence of functions.
@param {EVUI.Modules.EventStream.EventStreamConfig} config Configuration options to initialize the EventStream with.
@class*/
EVUI.Modules.EventStream.EventStream = function (config)
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.EventStream.Dependencies);

    var _self = this; //self reference for closures
    var _sequence = []; //the current sequence of steps
    var _status = EVUI.Modules.EventStream.EventStreamStatus.NotStarted; //the current state of execution for the sequence of steps
    var _pausedStepIndex = -1; //in the event that this event chain was paused, this is the current index of the last event fired
    var _jobExecuting = false; //whether or not a job step is currently executing
    var _pausedWhileJobExecuting = false; //whether or not someone canceled the job outside of the event handler
    var _lastJobResult = null; //the return value of a job that was paused before its callback was fired
    var _timerID = -1; //the ID of the timer callback 
    var _nonPropagatedEvents = []; //events that have been set to not be fired again if they occur multiple times in the same sequence
    var _numSteps = 0; //the number of steps that have been executed by this instance since it was last reset. Every 250 (default, or $evui.settings.stepsBetweenWaits if it is a valid number) steps a setTimeout is used instead of a promise resolution.
    var _asyncMode = false; //whether or not the event stream was started in async mode and returned a promise.
    var _resolver = null; //the "resolve" function from the promise while in async mode
    var _rejecter = null; //the reject function from the promise while in async mode
    var _canUsePromises = typeof Promise !== "undefined";
    var _eventExecuting = false; //whether or not an event is currently being executed
    var _resumedWhileEventExecuting = false; 
    var _p = (_canUsePromises === true) ? Promise.resolve() : null;

    /**The current EVUI.Modules.EventStream.EventStreamStep
    @type {EVUI.Modules.EventStream.EventStreamStep}*/
    var _currentStep = null;

    /**A EVUI.Modules.EventStream.EventStreamError object representing an error thrown at some point during the process 
    @type {EVUI.Modules.EventStream.EventStreamError}*/
    var _error = null;

    /**Boolean. Whether or not the stream can seek and forth between steps. True by default.
    @type {Boolean}*/
    this.canSeek = true;

    /**Boolean. Whether or not a crash in an Event handler will cause the EventStream to stop executing. False by default.
    @type {Boolean}*/
    this.endExecutionOnEventHandlerCrash = false;


    /**Number. The number of milliseconds to wait on each step before failing the EventStream. A negative number means no timeout. -1 by default.
    @type {Number}*/
    this.timeout = -1;

    /**Any. Any data to carry between Jobs in the EventStream. A plain object by default.
    @type {Any}*/
    this.jobState = {};

    /**Any. Any data to carry between Events in the EventStream. A plain object by default.
    @type {Any}*/
    this.eventState = {};

    /**Any. The "this" context to execute job and event handlers under.
    @type {Any}*/
    this.context = null;

    /**Object. A BubblingEventsManager that bubbling events will be drawn from during the EventStream's execution.
    @type {EVUI.Modules.EventStream.BubblingEventManager}*/
    this.bubblingEvents = null;

    /**Number. When the EventStream is running, this is the number of sequential steps that can be executed before introducing a shot timeout to free up the thread to allow other processes to continue, otherwise an infinite step loop (which is driven by promises) will lock the thread. Small numbers will slow down the EventStream, high numbers may result in long thread locks. 250 by default.
    @type {Number}*/
    this.skipInterval = EVUI.Modules.Core.Utils.getSetting("stepsBetweenWaits");

    /**Gets the current status of the EventStream. Returns a value from EventStreamStatus.
    @returns {Number} A value from the EVUI.Modules.EventStream.EventStreamStatus enum.*/
    this.getStatus = function ()
    {
        return _status;
    };

    /**Gets a COPY of the array of internal steps currently set for this EventStream.
    @returns {EVUI.Modules.EventStream.EventStreamStep[]} An array ofEventStreamSteps.*/
    this.getSteps = function ()
    {
        var copy = _sequence.slice();
        return copy;
    };

    /**Gets the currently executing step.
    @returns {EVUI.Modules.EventStream.EventSteamStep} The currently executing EventStreamStep.*/
    this.getCurrentStep = function ()
    {
        return _currentStep;
    };

    /**Whether or not the EventStream is currently in executing and in an immutable state.
    @returns {Boolean} True if the EventStream is actively working, false if it is in a paused, completed, or canceled state.*/
    this.isWorking = function ()
    {
        return !isStable();
    };

    /**Gets a step based on it's EventKey.
    @param {String} key The EventKey for the step to get.
    @param {Number} type The EVUI.Modules.EventStream.EventStreamStepType of the step to get.
    @returns {EVUI.Modules.EventStream.EventStreamStep} The EventStreamStep with the given key/type combination.*/
    this.getStep = function (key, type)
    {
        var result = getStep(key, type);
        if (result == null) return null;

        return result;
    };

    /**Clears the EventStream of all members.
    @returns {Boolean}*/
    this.clear = function ()
    {
        if (isStable() === false) return EVUI.Modules.Core.Utils.debugReturn("EVUI.Modules.EventStream.EventStream", "Clear", "Cannot clear chain mid-execution.", false);

        _sequence = [];
        this.bubblingEvents = null;

        this.reset();

        return true;
    };

    /**Synchronous event handler for handling cases where an error occurred at any point during the process. Cannot be an async function.
    @param {EVUI.Modules.EventStream.EventStreamEventArgs} args An instance of EventStreamEventArgs.
    @param {EVUI.Modules.EventStream.EventStreamError} ex The error that was thrown by the code in the event sequence or the response caused by a rejection of a job.*/
    this.onError = function (args, ex)
    {
    };

    /**Synchronous event handler for handling cases where the EventStream was canceled before it was finished. Cannot be an async function.
    @param {EVUI.Modules.EventStream.EventStreamEventArgs} args An instance of EventStreamEventArgs.*/
    this.onCancel = function (args)
    {

    };

    /**Synchronous event handler that executes whenever the EventStream has been completed or terminated. Cannot be an async function.
    @param {EVUI.Modules.EventStream.EventStreamEventArgs} args An instance of EventStreamEventArgs.*/
    this.onComplete = function (args)
    {

    };

    /**Executes the EventStream.
    @returns {Boolean}*/
    this.execute = function ()
    {
        if (this.reset() === false) return EVUI.Modules.Core.Utils.debugReturn("EVUI.Modules.EventStream.EventStream", "Execute", "Failed to reset EventStream, cannot begin execution.", false);

        _status = EVUI.Modules.EventStream.EventStreamStatus.Working;

        //kick off the process
        triggerAsyncCall(function ()
        {
            _currentStep = _sequence[0];
            executeStep(_sequence, 0);
        }, 0);

        return true;
    };

    /**Executes the EventStream in an awaitable mode.
    @returns {Promise}*/
    this.executeAsync = function ()
    {
        return new Promise(function (resolve, reject)
        {
            if (_self.execute() === false)
            {
                _asyncMode = false;
                _resolver = null;
                _rejecter = null;

                reject(new EVUI.Modules.EventStream.EventStreamError("Failed to reset EventStream, cannot begin execution."));
                return;
            }

            _asyncMode = true;
            _resolver = resolve;
            _rejecter = reject;
        });
    };

    /**Resets the EventStream if it is not currently executing.
    @returns {Boolean}*/
    this.reset = function ()
    {
        if (isStable() === false) return EVUI.Modules.Core.Utils.debugReturn("EVUI.Modules.EventStream.EventStream", "Reset", "Cannot reset chain mid-execution.", false);
        clearQueuedTimeout();

        _status = EVUI.Modules.EventStream.EventStreamStatus.NotStarted;
        _self.eventState = (_self.eventState === undefined) ? {} : _self.eventState;
        _self.jobState = (_self.jobState === undefined) ? {} : _self.jobState;
        _currentStep = null;
        _pausedStepIndex = -1;
        _pausedWhileJobExecuting = false;
        _error = null;
        _lastJobResult = null;
        _jobExecuting = false;
        _timeout = -1;
        _nonPropagatedEvents = []
        _numSteps = 0;

        if (_asyncMode === true)
        {
            _asyncMode = false;
            var reject = _rejecter;
            _resolver = null;
            _rejecter = null;

            reject(new EVUI.Modules.EventStream.EventStreamError("Stream was reset before Promise resolution."));
        }

        return true;
    };

    /**Takes the event args generated for default events and gives the consumer of the EventStream a chance to inject its own event args. Cannot be an async function.
    @param {EVUI.Modules.EventStream.EventStreamEventArgs} args An instance of EventStreamEventArgs.
    @returns {Object}*/
    this.processInjectedEventArgs = function (args)
    {
        return args;
    };

    /**Takes the event args that were passed into the event handler and gives the consumer a chance to react to any changes made to them or react to the value returned from the event handler. Cannot be an async function.
    @param {EVUI.Modules.EventStream.EventStreamEventArgs} args An instance of EventStreamEventArgs or the event args made in processInjectedEventArgs.
    @param {Any} handlerResult The returned value from the handler.
    @param {EVUI.Modules.EventStream.EventStreamStep} step An instance of EventStreamStep
    @param {Object} jobState The current private state object for the EventStream that is only available to Jobs.
    @param {Object} eventState The current public state object for the EventStream that is only available to Events.*/
    this.processReturnedEventArgs = function (args, handlerResult, step, jobState, eventState)
    {
    };

    /**Cancels the operation in progress.
    @returns {Boolean}*/
    this.cancel = function ()
    {
        if (_status === EVUI.Modules.EventStream.EventStreamStatus.Working)
        {
            _status = EVUI.Modules.EventStream.EventStreamStatus.Canceled;
        }
        else
        {
            if (_status === EVUI.Modules.EventStream.EventStreamStatus.Canceled || _status === EVUI.Modules.EventStream.EventStreamStatus.Finished || _status === EVUI.Modules.EventStream.EventStreamStatus.Error) return false;

            var args = makeEventArgs(_currentStep, _sequence, true);

            cancel(args);
            finish(args);
        }

        return true;
    };

    /**Pauses the operation in progress.
    @returns {Boolean}*/
    this.pause = function ()
    {
        if (_status === EVUI.Modules.EventStream.EventStreamStatus.Working)
        {
            _status = EVUI.Modules.EventStream.EventStreamStatus.Paused;
            _pausedStepIndex = _sequence.indexOf(_currentStep);

            if (_jobExecuting === true)
            {
                _pausedWhileJobExecuting = true;
            }
            else //paused during an event, need to make sure the NEXT step is executed and not resuming a job.
            {
                _pausedStepIndex++;
            }

            clearQueuedTimeout(); //stop any timeout if we pause the operation
            return true;
        }

        return EVUI.Modules.Core.Utils.debugReturn("EVUI.Modules.EventStream.EventStream", "Pause", "Chain is not currently executing, nothing to pause.", false);
    };

    /**Resumes the operation in progress if it has been paused.
    @returns {Boolean}*/
    this.resume = function ()
    {
        if (_status !== EVUI.Modules.EventStream.EventStreamStatus.Paused) return EVUI.Modules.Core.Utils.debugReturn("EVUI.Modules.EventStream.EventStream", "Resume", "Chain is not paused, cannot resume.", false);

        _status = EVUI.Modules.EventStream.EventStreamStatus.Working;

        if (_pausedWhileJobExecuting === true) //we were in the middle of some other async job when this got paused, so we start back up in the callback (which we blocked calling)
        {
            _pausedWhileJobExecuting = false;
            _pausedStepIndex = -1;
            triggerAsyncCall(function () { jobCompleteCallback(_lastJobResult, _currentStep, _sequence) })
        }
        else //we were likely paused by the event args, so the event handler was firing when we paused, so just start the next step
        {
            if (_eventExecuting === false)
            {
                var index = _pausedStepIndex;
                _pausedStepIndex = -1;

                triggerAsyncCall(function () { executeStep(_sequence, index) }, 0);
            }
            else
            {
                _resumedWhileEventExecuting = true;
            }
        }

        return true;
    };

    /**Seeks the async EventStream to a new stage in the chain.
    @param {Number|EVUI.Modules.EventStream.EventStreamStep|String} indexOrKey Either the step object, the index of the step object, or the key of the step object to seek to.
    @returns {Boolean}*/
    this.seek = function (indexOrKey)
    {
        if (_self.canSeek !== true) throw Error("Seeking disabled. Set \"canSeek\" to true.");

        var step = null;

        if (typeof indexOrKey === "number")
        {
            if (indexOrKey >= 0 && indexOrKey < _sequence.length)
            {
                step = _sequence[indexOrKey];
            }
        }
        else if (typeof indexOrKey === "string")
        {
            step = _self.getStep(indexOrKey);
        }
        else if (typeof indexOrKey === "object")
        {
            if (_sequence.indexOf(indexOrKey) !== -1) step = indexOrKey;
        }

        if (step == null) return EVUI.Modules.Core.Utils.debugReturn("EVUI.Modules.EventStream.EventStream", "Seek", "Invalid parameters, could not find a step in the internal protected sequence to seek to.", false);
        var currentlyExecuting = _status === EVUI.Modules.EventStream.EventStreamStatus.Working;
        _status = EVUI.Modules.EventStream.EventStreamStatus.Seeking;

        //set what we need to resume
        _pausedStepIndex = _sequence.indexOf(step);
        _currentStep = step;

        //clear anything else that could have been set while paused
        _pausedWhileJobExecuting = false;
        _lastJobResult = null;
        _nonPropagatedEvents = [];

        if (currentlyExecuting === false) //if we're not currently executing, we need to kick off the process again
        {
            triggerAsyncCall(function () { executeStep(_sequence, _pausedStepIndex) });
        }

        return true;
    };

    /**Causes the EventStream to error out.
    @param {Error} ex An exception to use for the error status.
    @param {String} message A message to display in the error.*/
    this.error = function (ex, message)
    {
        if (isStable() === true) return EVUI.Modules.Core.Utils.debugReturn("EVUI.Modules.EventStream.EventStream", "Error", "Chain is stopped, cannot trigger error.", false);

        _error = new EVUI.Modules.EventStream.EventStreamError("A manual error was thrown" + ((typeof message === "string" && message.length > 0) ? ": " + message : "."), ex, EVUI.Modules.EventStream.EventStreamStage.ErrorCommand, ((_currentStep != null) ? _currentStep.key : null));

        if (_status === EVUI.Modules.EventStream.EventStreamStatus.Working)
        {
            _status = EVUI.Modules.EventStream.EventStreamStatus.Error;
        }
        else if (_status === EVUI.Modules.EventStream.EventStreamStatus.Paused)
        {
            clearQueuedTimeout();
            var args = makeEventArgs(_currentStep, _sequence, true, ex);

            fail(args);
            finish(args);
        }
    };

    /**Stops any other steps from executing with the same event key as the current step.
    @returns {Boolean}*/
    this.stopPropagation = function ()
    {
        if (_currentStep == null) return false;
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(_currentStep.key) === true) return EVUI.Modules.Core.Utils.debugReturn("EVUI.Modules.EventStream.EventStream", "StopPropagation", "Cannot stop the propagation of an event with no key.", false);

        if (_nonPropagatedEvents.indexOf(_currentStep.key) === -1)
        {
            _nonPropagatedEvents.push(_currentStep.key);
        }

        return true;
    };

    /**Adds a step to the EventStream. If the first argument is a function, it is treated as a Job type step.
    @param {EVUI.Modules.EventStream.EventStreamStep|EVUI.Modules.EventStream.Constants.Fn_Job_Handler} step An YOLO of EventStreamStep or function to execute after all the other steps have been executed.
    @returns {EVUI.Modules.EventStream.EventStream}*/
    this.addStep = function (step)
    {
        if (step == null) return null;

        var streamStep = null;
        if (typeof step === "function")
        {
            streamStep = new EVUI.Modules.EventStream.EventStreamStep();
            streamStep.key = EVUI.Modules.Core.Utils.makeGuid();
            streamStep.name = "Step " + _sequence.length + " (" + streamStep.key + ")"
            streamStep.handler = step;
        }
        else if (typeof step === "object")
        {
            if (EVUI.Modules.Core.Utils.instanceOf(step, EVUI.Modules.EventStream.EventStreamStep) === false)
            {
                streamStep = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.EventStream.EventStreamStep(), step);
            }
            else
            {
                streamStep = step;
            }

            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(streamStep.key) === true) streamStep.key = EVUI.Modules.Core.Utils.makeGuid();
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(streamStep.name) === true) streamStep.name = "Step " + _sequence.length + " (" + streamStep.EventKey + ")"
        }
        else
        {
            throw Error("Unrecognized input. Must be an object or function.");
        }

        _sequence.push(streamStep);

        return this;
    };

    /**Adds a job to the EventStream.
    @param {EVUI.Modules.EventStream.Constants.Fn_Job_Handler|String} handlerOrKey Either the job handler or the key of the job.
    @param {EVUI.Modules.EventStream.Constants.Fn_Job_Handler|String} handlerOrName Optional. Either the job handler or the name of the job.
    @param {EVUI.Modules.EventStream.Constants.Fn_Job_Handler|Number} handlerOrTimeout Optional. Either the job handler or the timeout for the job.
    @param {EVUI.Modules.EventStream.Constants.Fn_Job_Handler} handler Optional. The handler for the job.
    @returns {EVUI.Modules.EventStream.EventStream} */
    this.addJob = function (handlerOrKey, handlerOrName, handlerOrTimeout, handler)
    {
        var step = getStepAmbiguously(handlerOrKey, handlerOrName, handlerOrTimeout, handler);
        step.type = EVUI.Modules.EventStream.EventStreamStepType.Job;

        return this.addStep(step);
    };

    /**Adds an event to the EventStream.
    @param {EVUI.Modules.EventStream.Constants.Fn_Event_Handler|String} handlerOrKey Either the event handler or the key of the event.
    @param {EVUI.Modules.EventStream.Constants.Fn_Event_Handler|String} handlerOrName Optional. Either the event handler or the name of the event.
    @param {EVUI.Modules.EventStream.Constants.Fn_Event_Handler|Number} handlerOrTimeout Optional. Either the event handler or the timeout for the event.
    @param {EVUI.Modules.EventStream.Constants.Fn_Event_Handler} handler Optional. The handler for the event.
    @returns {EVUI.Modules.EventStream.EventStream} */
    this.addEvent = function (handlerOrKey, handlerOrName, handlerOrTimeout, handler)
    {
        var step = getStepAmbiguously(handlerOrKey, handlerOrName, handlerOrTimeout, handler);
        step.type = EVUI.Modules.EventStream.EventStreamStepType.Event;

        return this.addStep(step);
    };

    /**Gets an EventStreamStep based on ambiguous input.
    @param {Function|String} handlerOrKey Either the event handler or the key of the event.
    @param {Function|String} handlerOrName Optional. Either the event handler or the name of the event.
    @param {Function|Number} handlerOrTimeout Optional. Either the event handler or the timeout for the event.
    @param {Function} handler Optional. The handler for the event.
    @returns {EVUI.Modules.EventStream.EventStreamStep} */
    var getStepAmbiguously = function (handlerOrKey, handlerOrName, handlerOrTimeout, handler)
    {
        var handler = null;
        var key = null;
        var name = null;
        var timeout = _self.timeout;
        var handlerSet = false;

        if (typeof handlerOrKey === "function")
        {
            handler = handlerOrKey;
            handlerSet = true;
        }
        else if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(handlerOrKey) === false)
        {
            key = handlerOrKey;
        }

        if (handlerSet === false && typeof handlerOrName === "function")
        {
            handler = handlerOrName;
            handlerSet = true;
        }
        else if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(handlerOrKey) === false)
        {
            name = handlerOrName;
        }

        if (handlerSet === false && typeof handlerOrTimeout === "function")
        {
            handler = handlerOrTimeout;
            handlerSet = true;
        }
        else if (typeof handlerOrTimeout === "number")
        {
            timeout = handlerOrTimeout;
        }

        if (handlerSet === false && typeof handler === "function")
        {
            handlerSet = true;
        }

        if (handlerSet === false) throw Error("Function expected.");

        var step = new EVUI.Modules.EventStream.EventStreamStep();
        step.handler = handler;
        step.key = key;
        step.name = name;
        step.timeout = timeout;

        return step;
    };

    /**Overridable function for passing a custom value into the resolve function of a promise if the EventStream is running in async mode. Cannot be an async function.
    @returns {Any}*/
    this.getPromiseResolutionValue = function ()
    {

    };   

    /**Internal guts of the async execution of the various steps in the EventStream.
    @param {EVUI.Modules.EventStream.EventStreamStep[]} sequence An array of EVUI.Modules.EventStream.EventStreamStep to execute.
    @param {Number} stepIndex The index of the next step to execute.*/
    var executeStep = function (sequence, stepIndex)
    {
        //make sure we look at the current status of the operation before continuing.
        if (handleStatus(_currentStep, sequence) === false) return;

        //try and get the step
        var step = sequence[stepIndex];
        if (step == null) return finish(makeEventArgs(_currentStep, sequence, true)); //step not there, likely over the bounds of the array - all done

        stepIndex++;
        _currentStep = step;

        handleStep(step);
    };

    /**Main switch for alternating between different step behaviors based on the "Type" property of the step. Defaults to job.
    @method handleStep
    @param {EVUI.Modules.EventStream.EventStreamStep} step An instance of EVUI.Modules.EventStream.EventStreamStep representing the step to execute.*/
    var handleStep = function (step)
    {
        if (step == null)
        {
            _self.error(null, "Failed to handle step, no step present.");
        }

        //see if the event is one of the events we have been told not to execute again during this sequence
        var isNonPropagatedEvent = (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(step.key) === false && _nonPropagatedEvents.indexOf(step.key) !== -1);

        //no function to fire, move on to the next step
        if (typeof step.handler !== "function" || isNonPropagatedEvent === true)
        {
            triggerAsyncCall(function ()
            {
                executeStep(_sequence, _sequence.indexOf(step) + 1);
            });

            return;
        }

        //figure out what behavior we want
        var type = EVUI.Modules.EventStream.EventStreamStepType.Job;
        if (typeof step.type === "string")
        {
            type = EVUI.Modules.EventStream.EventStreamStepType.getStepType(step.type);
        }

        if (type === EVUI.Modules.EventStream.EventStreamStepType.Job)
        {
            handleJob(step);
        }
        else if (type === EVUI.Modules.EventStream.EventStreamStepType.Event || type === EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent)
        {
            handleEvent(step);
        }
    };

    /**Entry point for executing a job function.
    @method handleJob
    @param {EVUI.Modules.EventStream.EventStreamStep} step A EVUI.Modules.EventStream.EventStreamStep to execute as a job.*/
    var handleJob = function (step)
    {
        //before doing any work, start the timeout timer
        queueTimeout(step);

        //set a flag preventing multiple fires of the callback
        var callbackFired = false;

        //this is the internal callback that gets injected into the "Job" function - it's up to the author of the Job function to call the callback - otherwise the event chain fails.
        //takes a EVUI.Modules.EventStream.EventStreamJobResult as an optional parameter.
        var callback = function (jobResult)
        {
            if (callbackFired === true) return; //callback already fired, don't fire again
            callbackFired = true;

            clearQueuedTimeout(); //we also clear the timeout in jobCompleteCallback, but since we're executing that asynchronously, its possible the thread may get blocked in the meantime by something else and cause the timer to go off. So we cancel it before doing anything else

            //in case this callback was called synchronously by the Job function, we execute it asynchronously
            triggerAsyncCall(function ()
            {
                _lastJobResult = jobResult;
                jobCompleteCallback(jobResult, step, _sequence);
            });
        };

        try
        {
            _jobExecuting = true;

            var jobArgs = new EVUI.Modules.EventStream.EventStreamJobArgs(_self, callback);
            jobArgs.resolvedValue = (_lastJobResult == null) ? null : _lastJobResult.resolvedValue;
            jobArgs.key = step.key;
            jobArgs.name = step.name;

            if (_self.context != null)
            {
                step.handler.call(_self.context, jobArgs)
            }
            else
            {
                step.handler(jobArgs); //pass in the current state data and the callback into the job
            }
        }
        catch (ex) //job failed, end the process
        {
            _jobExecuting = false;
            _error = new EVUI.Modules.EventStream.EventStreamError("Job failed.", ex, EVUI.Modules.EventStream.EventStreamStage.Job, step.key);
            clearQueuedTimeout();

            var args = makeEventArgs(_currentStep, _sequence, true, _error);

            fail(args);
            return finish(args);
        }
    };

    /**Entry point to executing an event.
    @method handleEvent
    @param {EVUI.Modules.EventStream.EventStreamStep} step An instance of EVUI.Modules.EventStream.EventStreamStep to execute.*/
    var handleEvent = function (step)
    {
        _eventExecuting = true;

        //execute the event handler associated with this event. This can change the current _status of the event chain via the event args object that is passed into the event handler
        var eventHandlerResult = executeEventHandler(_currentStep, _sequence);

        _eventExecuting = false;
        if (eventHandlerResult instanceof ReturnedEventPromiseWrapper)
        {
            var completeEvent = function (value)
            {
                if (typeof _self.processReturnedEventArgs === "function")
                {
                    try
                    {
                        var returnResult = _self.processReturnedEventArgs(eventHandlerResult.args, value, step, _self.jobState, _self.eventState);
                        if (EVUI.Modules.Core.Utils.isPromise(returnResult) === true) throw Error("processReturnedEventArgs cannot be an async function.");
                    }
                    catch (ex) //failed, record the error
                    {
                        _status = EVUI.Modules.EventStream.EventStreamStatus.Error;
                        _error = new EVUI.Modules.EventStream.EventStreamError("Error processing returned event args.", ex, EVUI.Modules.EventStream.EventStreamStage.ProcessReturnedEventArgs, step.key);
                    }
                }

                //handle any change in status that may have happened during the execution of the handler
                if (handleStatus(step, _sequence) === false) return;

                triggerBubblingEvents(step, function ()
                {
                    //get the next step in the sequence based on the index of the current step. If the current step is not in sequence, let the indexer fail and the next step will handle the fail case
                    var nextStepindex = _sequence.indexOf(step);
                    if (nextStepindex >= 0) nextStepindex++;

                    //call the next step
                    triggerAsyncCall(function () { executeStep(_sequence, nextStepindex) }, 0);
                });
            };

            eventHandlerResult.promise.catch(function (error) //promise catching logic
            {
                _error = new EVUI.Modules.EventStream.EventStreamError("Error executing event handler.", error, EVUI.Modules.EventStream.EventStreamStage.Handler, step.key);
                _status = EVUI.Modules.EventStream.EventStreamStatus.Error;

                completeEvent(error)
            });

            eventHandlerResult.promise.then(function (value) //we can't use await, but we can mimic the behavior with .then
            {
                completeEvent(value);
            });
        }
        else
        {
            //handle any change in status that may have happened during the execution of the handler
            if (handleStatus(step, _sequence) === false) return;

            triggerBubblingEvents(step, function ()
            {
                //get the next step in the sequence based on the index of the current step. If the current step is not in sequence, let the indexer fail and the next step will handle the fail case
                var nextStepindex = _sequence.indexOf(step);
                if (nextStepindex >= 0) nextStepindex++;

                //call the next step
                triggerAsyncCall(function () { executeStep(_sequence, nextStepindex) }, 0);                
            });
        }
    };

    /**Creates a sub EventStream that handles all of the events added via "addEventListener"
    @param {EVUI.Modules.EventStream.EventStreamStep} step The step to get events for.
    @param {Function} callback A callback function to call once the sub EventStream completes.*/
    var triggerBubblingEvents = function (step, callback)
    {
        if (_self.bubblingEvents == null || typeof _self.bubblingEvents.getBubblingEvents !== "function") return callback();

        var bubblingEvents = null;

        try
        {
            bubblingEvents = _self.bubblingEvents.getBubblingEvents(step);
        }
        catch (ex)
        {
            EVUI.Modules.Core.Utils.log(ex);
            return callback();
        }

        if (bubblingEvents == null) return callback();

        var numEvents = bubblingEvents.length;
        if (numEvents === 0) return callback();

        var config = new EVUI.Modules.EventStream.EventStreamConfig();
        config.context = _self.context;
        config.canSeek = _self.canSeek;
        config.endExecutionOnEventHandlerCrash = true;
        config.eventState = _self.eventState;
        config.processReturnedEventArgs = _self.processReturnedEventArgs;
        config.skipInterval = _self.skipInterval;
        config.timeout = (typeof _self.timeout === "number") ? _self.timeout : -1;
        config.onComplete = function () { callback(); } //call the callback in the complete handler, which will fire no matter what.

        var subStream = new EVUI.Modules.EventStream.EventStream(config);

        //set up an option on the seek function to optionally seek back in the parent stream instead of the sub stream
        subStream.processInjectedEventArgs = function (eventArgs)
        {
            var processedArgs = _self.processInjectedEventArgs(eventArgs);
            if (_self.canSeek === true && processedArgs.seek != null)
            {
                processedArgs.seek = function (indexOrKey, seekInParent)
                {
                    if (seekInParent === true)
                    {
                        subStream.cancel();
                        _self.seek(indexOrKey);
                    }
                    else
                    {
                        subStream.seek(indexOrKey);
                    }
                };
            }

            return processedArgs;
        };

        for (var x = 0; x < numEvents; x++)
        {
            var curEvent = bubblingEvents[x];
            if (curEvent == null) continue;

            subStream.addStep(makeBubblingStep(step, curEvent));
        }

        //execute the sub-stream
        subStream.execute();
    };

    /**Makes a EventStreamStep representing the "bubbling" events that come off of real events via being added by addEventListener.
    @param {EVUI.Modules.EventStream.EventStreamStep} parentStep The event who the bubbling event is being made for.
    @param {EVUI.Modules.EventStream.EventStreamEventListener} eventListener The internal listener containing the data needed to handle the event.
    @returns {EVUI.Modules.EventStream.EventStreamStep}  */
    var makeBubblingStep = function (parentStep, eventListener)
    {
        var step = new EVUI.Modules.EventStream.EventStreamStep();
        step.key = eventListener.eventName;
        step.tieout = parentStep.timeout;
        step.type = EVUI.Modules.EventStream.EventStreamStepType.Event;
        step.handler = function (eventArgs)
        {
            if (typeof eventListener.handler === "function")
            {
                return eventListener.handler(eventArgs);
            }
        };

        return step;
    };

    /**Callback function following each job step. Handles the response, calls the handler, and continues the async loop.
    @method jobCompleteCallback
    @param {EVUI.Modules.EventStream.EventStreamJobResult} jobResult An instance of EVUI.Modules.EventStream.EventStreamJobResult produced by the step's Job function.
    @param {EVUI.Modules.EventStream.EventStreamStep} step An instance of EVUI.Modules.EventStream.EventStreamStep representing the step being executed.
    @param {EVUI.Modules.EventStream.EventStreamStep[]} sequence An Array of EVUI.Modules.EventStream.EventStreamStep representing the chain of events being executed.*/
    var jobCompleteCallback = function (jobResult, step, sequence)
    {
        _jobExecuting = false;

        //clear the idle timeout, the job finished before the timeout hit
        clearQueuedTimeout();

        //process the job result and set the _status accordingly
        stepCallback(jobResult);

        //do whatever the status says we should do
        if (handleStatus(step, sequence) === false) return;

        //get the next step in the sequence based on the index of the current step. If the current step is not in sequence, let the indexer fail and the next step will handle the fail case
        var nextStepindex = sequence.indexOf(step);
        if (nextStepindex >= 0) nextStepindex++;

        //call the next step
        triggerAsyncCall(function () { executeStep(sequence, nextStepindex) }, 0);
    };

    /**Gets a EVUI.Modules.EventStream.EventStreamStep from the internal sequence based on its EventKey.
    @method getStep
    @param {String} key The EventKey of the EVUI.Modules.EventStream.EventStreamStep to get.
    @param {Number} type The EventType of the EVUI.Modules.EventStream.EventStreamStep to get.
    @returns {EVUI.Modules.EventStream.EventStreamStep} The matching EVUI.Modules.EventStream.EventStreamStep with the matching key/type combination, or null if there is no match.*/
    var getStep = function (key, type)
    {
        if (typeof key !== "string") return null;
        var lowerKey = key.toLowerCase();

        var numSteps = _sequence.length;
        for (var x = 0; x < numSteps; x++)
        {
            var curStep = _sequence[x];

            if (curStep.key.toLowerCase() === lowerKey)
            {
                if (type != null)
                {
                    var type = EVUI.Modules.EventStream.EventStreamStepType.getStepType(type);
                    var eventType = EVUI.Modules.EventStream.EventStreamStepType.getStepType(curStep.Type);
                    if (type == eventType) return curStep;
                }
                else
                {
                    return curStep;
                }
            }
        }

        return null;
    };

    /**Makes an event args object to be passed into the step's event handler.
    @method makeEventArgs
    @param {EVUI.Modules.EventStream.EventStreamStep} step An instance of EVUI.Modules.EventStream.EventStreamStep representing the step the event args are for.
    @param {EVUI.Modules.EventStream.EventStreamStep[]} sequence An Array of EVUI.Modules.EventStream.EventStreamStep representing the current execution chain.
    @param {Boolean} ignoreProcessCrash There is an option for the user to make their own event args, setting this to true makes it so a crash in the user's function doesn't crash the EventStream.
    @param {EVUI.Modules.EventStream.EventStreamError} error An instance of EVUI.Modules.EventStream.EventStreamError representing an aggregation of error data.
    @returns {EVUI.Modules.EventStream.EventStreamArgs} Either a EVUI.Modules.EventStream.EventStreamArgs or a custom event args object.*/
    var makeEventArgs = function (step, sequence, ignoreProcessCrash, error)
    {
        if (typeof ignoreProcessCrash === "boolean" && ignoreProcessCrash !== false) ignoreProcessCrash = true;
        if (step == null) step = new EVUI.Modules.EventStream.EventStreamStep();

        var eventArgs = new EVUI.Modules.EventStream.EventStreamEventArgs(_self.eventState);
        eventArgs.currentStep = sequence.indexOf(step);
        eventArgs.key = step.key;
        eventArgs.stepType = step.type;
        eventArgs.totalSteps = sequence.length;
        eventArgs.status = _self.getStatus();
        eventArgs.error = error;
        attachEvents(eventArgs, step);

        if (typeof _self.processInjectedEventArgs == "function" && step.type !== EVUI.Modules.EventStream.EventStreamStepType.Job) //there is a "ProcessEventArgs" override function that is going to be used to make custom event args.
        {
            try
            {
                var processedArgs = _self.processInjectedEventArgs(eventArgs, _self.jobState); //using our args, the user made their own args
                if (EVUI.Modules.Core.Utils.isPromise(processedArgs) === true) throw Error("processInjectedEventArgs cannot be an async function.");

                if (processedArgs != null && typeof processedArgs === "object") //don't use the return value unless its an object
                {
                    eventArgs = processedArgs;
                }
            }
            catch (ex) //the user's function crashed
            {
                eventArgs.error = new EVUI.Modules.EventStream.EventStreamError("ProcessInjectedEventArgs failed.", ex, EVUI.Modules.EventStream.EventStreamStage.ProcessInjectedEventArgs, step.key); //make an error property for the args
                eventArgs.error.innerError = error; //if we were reporting an error while this happened, populate the inner error

                //attach the special closure functions to expose event chain controls
                if (eventArgs == null) return null; //failed to attach args, the person is likely freezing, sealing, or adding read-only handlers to their object. 

                if (ignoreProcessCrash === true) //we're ignoring the crash and are going to return the "wrong" event args - only ever used for the internal event arguments for the OnError, OnComplete, and OnCancel events.
                {
                    return eventArgs;
                }
                else //trigger the OnError and OnComplete events
                {
                    fail(eventArgs);
                    finish(eventArgs);

                    return null;
                }
            }
        }

        return eventArgs;
    };

    /**Attaches the custom event handlers that rely on closures to the event args object.
    @method attachEvents
    @param {Object} eventArgs Any object.
    @param {EVUI.Modules.EventStream.EventStreamStep} step The EVUI.Modules.EventStream.EventStreamStep that the event args are being made for.
    @returns {Object} Either a EVUI.Modules.EventStream.EventStreamArgs object or a custom event args object.*/
    var attachEvents = function (eventArgs, step)
    {
        if (eventArgs == null || typeof eventArgs !== "object") return;

        try
        {
            if (eventArgs instanceof EVUI.Modules.EventStream.EventStreamEventArgs)
            {
                //attach the special closure functions used to control this event chain without ever exposing the event chain.
                eventArgs.cancel = function () { return _self.cancel(); };
                eventArgs.pause = function () { return _self.pause(); };
                eventArgs.resume = function () { return _self.resume(); };
                eventArgs.seek = function (indexOrKey) { return _self.seek(indexOrKey) };
                eventArgs.stopPropagation = function () { return _self.stopPropagation(); };
            }
        }
        catch (ex)
        {
            _error = new EVUI.Modules.EventStream.EventStreamError("Failed to add reserved handlers.", ex, EVUI.Modules.EventStream.EventStreamStage.AttachEvents, step.key);
            _status = EVUI.Modules.EventStream.EventStreamStatus.Error;

            fail(eventArgs);
            finish(eventArgs);

            return null;
        }

        return eventArgs;
    }

    /**Function that processes the result of a EventStreamStep's Job function. Sets the _status to the correct state, depending on the object returned. 
    @method stepCallback
    @param {EVUI.Modules.EventStream.EventStreamJobResult} jobResult An instance of EVUI.Modules.EventStream.EventStreamJobResult that was created by the Job that was previously executed.
    @returns {Object} Returns null if jobResult was null.*/
    var stepCallback = function (jobResult)
    {
        if (jobResult == null) return null;

        if (jobResult.success === false || jobResult.canceled === true) //failing or canceling the operation
        {
            if (jobResult.canceled === true)
            {
                _status = EVUI.Modules.EventStream.EventStreamStatus.Canceled;
            }
            else if (jobResult.success === false)
            {
                _error = new EVUI.Modules.EventStream.EventStreamError(jobResult.message == null ? "Job Error." : jobResult.message, jobResult.error, EVUI.Modules.EventStream.EventStreamStage.Job, ((_currentStep != null) ? _currentStep.key : null));
                if (jobResult.innerError != null) _error.innerError = jobResult.innerError;
                _status = EVUI.Modules.EventStream.EventStreamStatus.Error;
            }
        }
        else if (jobResult.seeking == true)
        {
            _status = EVUI.Modules.EventStream.EventStreamStatus.Seeking;
        }
        else //continuing. Make sure we remember the JobData associated with the step so we can pass it into the next step.
        {
            return null;
        }
    };

    /**Executes the event handler associated with a step.
    @method executeEventHandler
    @param {EVUI.Modules.EventStream.EventStreamStep} step An instance of EVUI.Modules.EventStream.EventStreamStep that is the step being executed.
    @param {EVUI.Modules.EventStream.EventStreamStep[]} sequence An array of EVUI.Modules.EventStream.EventStreamStep representing the chain of events being executed.
    @returns {Any} Any value returned by the user from an event.*/
    var executeEventHandler = function (step, sequence)
    {
        var handlerResult = null;
        if (step == null || typeof step.handler !== "function") return handlerResult;

        var args = makeEventArgs(step, sequence);
        if (args == null) return null; //if the args returned null, it already crashed and triggered the fail and complete events, so we just do nothing from here

        var failed = false;

        //try and execute the handler
        try
        {
            if (_self.context != null && step.type !== EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent) //dont use the context if it's a global event
            {
                handlerResult = step.handler.call(_self.context, args);
            }
            else
            {
                handlerResult = step.handler(args);
            }
        }
        catch (ex) //failed, record the error
        {
            failed = true;
            _error = new EVUI.Modules.EventStream.EventStreamError("Error executing event handler.", ex, EVUI.Modules.EventStream.EventStreamStage.Handler, step.key);
        }

        if (typeof _self.processReturnedEventArgs === "function" && EVUI.Modules.Core.Utils.isPromise(handlerResult) === false) //don't process returned args of a promise, this means the function was an async function or otherwise returned a promise to be awaited
        {
            try
            {
                var returnResult = _self.processReturnedEventArgs(args, (failed === true) ? _error.exception : handlerResult, step, _self.jobState, _self.eventState);
                if (EVUI.Modules.Core.Utils.isPromise(returnResult) === true) throw Error("processReturnedEventArgs cannot be an async function.")
            }
            catch (ex) //failed, record the error
            {
                failed = true;
                _error = new EVUI.Modules.EventStream.EventStreamError("Error processing returned event args.", ex, EVUI.Modules.EventStream.EventStreamStage.ProcessReturnedEventArgs, step.key);
            }
        }

        //only if we crashed and are set to end execution on crash, change the state to error
        if (failed === true)
        {
            _status = EVUI.Modules.EventStream.EventStreamStatus.Error;
        }

        if (EVUI.Modules.Core.Utils.isPromise(handlerResult) === true)
        {
            return new ReturnedEventPromiseWrapper(handlerResult, args);
        }
        else
        {
            //return the return value of the event handler. IF the value is false, we bail out of the event chain
            return handlerResult;
        }
    };

    /**Sets the status to Finished and calls the OnComplete event.
    @method finish
    @param {EVUI.Modules.EventStream.EventStreamEventArgs} args An instance of EVUI.Modules.EventStream.EventStreamEventArgs to pass into OnComplete.*/
    var finish = function (args)
    {
        clearQueuedTimeout();

        //seeking to another step, do not end the chain yet
        if (_status === EVUI.Modules.EventStream.EventStreamStatus.Seeking) return;
        if (_status !== EVUI.Modules.EventStream.EventStreamStatus.Canceled && _status !== EVUI.Modules.EventStream.EventStreamStatus.Error)
        {
            _status = EVUI.Modules.EventStream.EventStreamStatus.Finished;
        }

        if (typeof _self.onComplete === "function")
        {
            try
            {
                args.status = _status;
                args.cancel = function () { throw Error("Invalid operation: A terminating EventStream cannot be canceled.") };
                var completeResult = _self.onComplete(args);

                if (EVUI.Modules.Core.Utils.isPromise(completeResult) === true)
                {
                    throw Error("onComplete cannot be an async function.");
                }
            }
            catch (ex)
            {
                EVUI.Modules.Core.Utils.debugReturn("EVUI.Modules.EventStream.EventStream", "finish", "OnComplete crashed: " + ex.stack);
            }
        }

        if (_status !== EVUI.Modules.EventStream.EventStreamStatus.Seeking)
        {
            _self.jobState = undefined;
            _self.eventState = undefined;

            resolvePromise();
        }
    };

    /**Resolves the core promise of the EventStream if it was running in async mode.*/
    var resolvePromise = function ()
    {
        if (_asyncMode === true)
        {
            _asyncMode = false;
            var reject = _rejecter;
            var resolve = _resolver;

            _resolver = null;
            _rejecter = null;

            if (_error != null && (_error.stage !== EVUI.Modules.EventStream.EventStreamStage.Handler && _self.endExecutionOnEventHandlerCrash !== true))
            {
                reject(_error);
            }
            else
            {
                try
                {
                    var resolutionValue = (typeof _self.getPromiseResolutionValue === "function") ? _self.getPromiseResolutionValue() : undefined; //if we have a resolution value, use it. Otherwise just return true.
                    if (resolutionValue !== undefined) return resolve(resolutionValue);
                    resolve(true);
                }
                catch (ex)
                {
                    reject(new EVUI.Modules.EventStream.EventStreamError("Failed to get promise resolution value.", ex));
                }
            }
        }
    }

    /**Sets the status to error and calls the OnError event.
    @method fail
    @param {EVUI.Modules.EventStream.EventStreamEventArgs} args An instance of EVUI.Modules.EventStream.EventStreamEventArgs to pass into OnError.
    @param {Boolean} setStatus Whether or not to set the status to EVUI.Modules.EventStream.EventStreamStatus.Error*/
    var fail = function (args, setStatus)
    {
        if (setStatus !== false) _status = EVUI.Modules.EventStream.EventStreamStatus.Error;

        if (typeof _self.onError === "function")
        {
            try
            {
                var error = _error;
                if (_error == null && args.error != null) error = args.error;
                args.cancel = function () { throw Error("Invalid operation: A terminating EventStream cannot be canceled.") };
                args.status = _status;

                if (error != null) EVUI.Modules.Core.Utils.log(error.getErrorMessage());
                var errorResult = _self.onError(args, error);

                if (EVUI.Modules.Core.Utils.isPromise(errorResult) === true)
                {
                    throw Error("onError cannot be an async function.");
                }

                return errorResult;
            }
            catch (ex)
            {
                EVUI.Modules.Core.Utils.debugReturn("EVUI.Modules.EventStream.EventStream", "fail", "OnError crashed: " + ex.stack);
            }
        }
        else
        {
            EVUI.Modules.Core.Utils.debugReturn("EVUI.Modules.EventStream.EventStream", "fail", "An error was encountered executing the chain. Hook into OnError for more details.", false);
        }
    };

    /**Sets the status of canceled and calls the OnCancel event.
    @param {EVUI.Modules.EventStream.EventStreamEventArgs} args An instance of EVUI.Modules.EventStream.EventStreamEventArgs to pass into OnCancel.*/
    var cancel = function (args)
    {
        _status = EVUI.Modules.EventStream.EventStreamStatus.Canceled;
        clearQueuedTimeout();

        if (typeof _self.onCancel === "function")
        {
            try
            {
                args.status = _status;
                args.cancel = function () { throw Error("Invalid operation: A terminating EventStream cannot be canceled.") };
                var cancelResult = _self.onCancel(args);

                if (EVUI.Modules.Core.Utils.isPromise(cancelResult) === true)
                {
                    throw Error("onCancel cannot be an async function.");
                }

                return cancelResult;
            }
            catch (ex)
            {
                EVUI.Modules.Core.Utils.debugReturn("EVUI.Modules.EventStream.EventStream", "cancel", "OnCancel crashed: " + ex.stack);
            }
        }
    };

    /**Determines whether or not the EventStream is in a state where it is not executing. If it returns true, the state of the EventStream can be changed - if it returns false, an operation is in progress and
    the state of the EventStream cannot be changed.
    @returns {Boolean} Whether or not the EventStream is in a stable state and can be manipulated.*/
    var isStable = function ()
    {
        if (_status === EVUI.Modules.EventStream.EventStreamStatus.Canceled) return true;
        if (_status === EVUI.Modules.EventStream.EventStreamStatus.Error) return true;
        if (_status === EVUI.Modules.EventStream.EventStreamStatus.Finished) return true;
        if (_status === EVUI.Modules.EventStream.EventStreamStatus.NotStarted) return true;

        //working and paused are the only "unstable" states
        return false;
    };

    /**Reacts to the current status of the EventStream. Returns false if the execution should stop, true if it should continue.
    @method handleStatus
    @param {EVUI.Modules.EventStream.EventStreamStep} step An instance of EVUI.Modules.EventStream.EventStreamStep that is the step being executed.
    @param {EVUI.Modules.EventStream.EventStreamStep[]} sequence An array of EVUI.Modules.EventStream.EventStreamStep representing the chain of events being executed.
    @returns {Boolean} Whether or not to cancel the EventStream (false) or continue (true).*/
    var handleStatus = function (step, sequence)
    {
        if (_status === EVUI.Modules.EventStream.EventStreamStatus.Canceled)
        {
            clearQueuedTimeout();
            var args = makeEventArgs(step, sequence, true);
            cancel(args);
            finish(args);

            return false;
        }
        else if (_status === EVUI.Modules.EventStream.EventStreamStatus.Error)
        {
            clearQueuedTimeout();
            var args = makeEventArgs(step, sequence, true, _error);
            if (_error != null && _error.stage === EVUI.Modules.EventStream.EventStreamStage.Handler && _self.endExecutionOnEventHandlerCrash !== true)
            {
                fail(args, true);
                _status = EVUI.Modules.EventStream.EventStreamStatus.Working;
                return true;
            }
            else
            {
                fail(args);
                finish(args);
            }

            return false;
        }
        else if (_status === EVUI.Modules.EventStream.EventStreamStatus.Paused)
        {
            clearQueuedTimeout();

            if (_pausedStepIndex === -1)
            {
                _pausedStepIndex = sequence.indexOf(step);

                if (_pausedWhileJobExecuting === false)
                {
                    _pausedStepIndex++; //we were paused in an event handler, so resuming needs to execute the NEXT step.
                }
            }

            return false;
        }
        else if (_status === EVUI.Modules.EventStream.EventStreamStatus.Seeking)
        {
            clearQueuedTimeout();

            triggerAsyncCall(function ()
            {
                _status = EVUI.Modules.EventStream.EventStreamStatus.Working;
                executeStep(_sequence, _pausedStepIndex)
            });

            return false;
        }
        else if (_status === EVUI.Modules.EventStream.EventStreamStatus.Working || _status === EVUI.Modules.EventStream.EventStreamStatus.NotStarted)
        {
            return true;
        }
        else if (_status === EVUI.Modules.EventStream.EventStreamStatus.Finished)
        {
            clearQueuedTimeout();
            return false;
        }
        else //somehow someone set a garbage status. Fail it.
        {
            _error = new EVUI.Modules.EventStream.EventStreamError("Unrecognized status: " + _status, null, null, step.key);
            clearQueuedTimeout();
            var args = makeEventArgs(_currentStep, _sequence, true, _error);

            fail(args);
            finish(args);
            return false;
        }
    };

    /**Clears any timeout that has been set.
    @method clearTimeout*/
    var clearQueuedTimeout = function ()
    {
        if (_timerID !== -1)
        {
            clearTimeout(_timerID);
            _timerID = -1;
        }
    };

    /**Sets a timeout based on either the provided step's Timeout property or the global _timeout property.
    @param {EVUI.Modules.EventStream.EventStreamStep} step An instance of EVUI.Modules.EventStream.EventStreamStep*/
    var queueTimeout = function (step)
    {
        clearQueuedTimeout();

        var timeout = (typeof _self.timeout !== "number") ? -1 : _self.timeout;
        if (step != null && typeof step.timeout === "number" && step.timeout >= 0) timeout = step.timeout;

        if (timeout >= 0)
        {
            _timerID = setTimeout(function ()
            {
                _timerID = -1;
                triggerTimeout();
            }, timeout);
        }
    };

    /**Triggers the timeout behavior.
    @method*/
    var triggerTimeout = function ()
    {
        _error = new EVUI.Modules.EventStream.EventStreamError("Step timeout hit.", null, (_currentStep.type === EVUI.Modules.EventStream.EventStreamStepType.Job) ? EVUI.Modules.EventStream.EventStreamStage.Job : EVUI.Modules.EventStream.EventStreamStage.Handler, _currentStep.key);
        _status = EVUI.Modules.EventStream.EventStreamStatus.Error;

        handleStatus(_currentStep, _sequence);
    };

    /**Triggers an asynchronous function call.
    @method*/
    var triggerAsyncCall = function (asyncFunction)
    {
        _numSteps++;
        if (_canUsePromises === false || (typeof _self.skipInterval === "number" && _self.skipInterval > 0 && _numSteps % _self.skipInterval === 0))
        {
            if (typeof setImmediate === "function")
            {
                setImmediate(asyncFunction);
            }
            else
            {
                setTimeout(asyncFunction);
            }
        }
        else
        {
            _p.then(asyncFunction);
        }
    };

    /**Applies any configuration options passed into the EventStream constructor.
    @param {EVUI.Modules.EventStream.EventStreamConfig} config*/
    var applyConfig = function (config)
    {
        if (config == null) return;

        if (typeof config.canSeek === "boolean") _self.canSeek = config.canSeek;
        if (typeof config.endExecutionOnEventHandlerCrash === "boolean") _self.endExecutionOnEventHandlerCrash = config.endExecutionOnEventHandlerCrash;
        if (config.eventState != null) _self.eventState = config.eventState;
        if (config.jobState != null) _self.jobState = config.jobState;
        if (typeof config.skipInterval === "number" && config.skipInterval > 0) _self.skipInterval = config.skipInterval;
        if (typeof config.timeout === "number" && config.timeout > 0) _timeout = config.timeout;
        if (EVUI.Modules.Core.Utils.instanceOf(config.bubblingEvents, EVUI.Modules.EventStream.BubblingEventManager) === true) _self.bubblingEvents = config.bubblingEvents;

        if (typeof config.onCancel === "function") _self.onCancel = config.onCancel;
        if (typeof config.onError === "function") _self.onError = config.onError;
        if (typeof config.onComplete === "function") _self.onComplete = config.onComplete;

        if (typeof config.processInjectedEventArgs === "function") _self.processInjectedEventArgs = config.processInjectedEventArgs;
        if (typeof config.processReturnedEventArgs === "function") _self.processReturnedEventArgs = config.processReturnedEventArgs;
        if (typeof config.getPromiseResolutionValue === "function") _self.getPromiseResolutionValue = config.getPromiseResolutionValue;
        if (config.context != null) _self.context = config.context;
    };

    /**Wrapper object for when a Event step has returned a Promise.
    @param {Promise} promise The promise returned from the Event step.
    @param {Any} args The event arguments injected into the Event step. */
    var ReturnedEventPromiseWrapper = function (promise, args)
    {
        /**The promise returned from the Event step
        @type {Promise}*/
        this.promise = promise;

        /**The event arguments injected into the Event step.
        @type {Any}*/
        this.args = args;
    };

    //apply any configuration options passed into the constructor
    applyConfig(config);
};

/**Represents a step in the EventStream that is executed in the order in which it was added to the EventStream.
 @class
 @param {EVUI.Modules.EventStream.Constants.Fn_Step_Handler} handler The function to execute for this step.
 @param {String} type A value from the EVUI.Modules.EventStream.EventStreamStepType enum.
 @param {String} key The key of the event by which it can be looked up.
 @param {String} name The human-readable name of the step.
 @param {Numner} timeout The amount of time the asynchronous operation of the step can take before it is automatically canceled.*/
EVUI.Modules.EventStream.EventStreamStep = function (handler, type, key, name, timeout)
{
    /**String. A human-readable name to give the step.
    @type {String}*/
    this.name = (typeof name === "string") ? name : null;

    /**String. A string key used to identify this event and prevent propagation of other events with the same key.
    @type {String}*/
    this.key = (typeof key === "string") ? key : null;

    /**Number. The duration of inactivity during the asynchronous portion of this step to wait before timing out.
    @type {Number}*/
    this.timeout = (typeof timeout === "number" && timeout > 0) ? Math.floor(timeout) : -1;

    /**Function. A function to execute either as a work task or as an event trigger.
    @type {EVUI.Modules.EventStream.Constants.Fn_Step_Handler}*/
    this.handler = (typeof handler === "function") ? handler : function (jobOrEventArgs) { };

    /**String. A value from EVUI.Modules.EventStream.EventStreamStepType. Controls how the handler function is executed. If "job" it is executed asynchronously like a promise and is fed a callback object. If "event" it is executed synchronously and can return false to cancel the EventStream.
    @type {String}*/
    this.type = (typeof type === "string") ? type : EVUI.Modules.EventStream.EventStreamStepType.Job;
};

/**Represents the parameter object for the callback handed to the EventStreamStep's "Job" function.
 @class*/
EVUI.Modules.EventStream.EventStreamJobResult = function ()
{
    /**Any. Any value passed into Resolve function in a Job step.
    @type {Any}*/
    this.resolvedValue = null;

    /**Boolean. Whether or not the operation succeeded. False will cause the execution to stop and result in the OnError event being called.
    @type {Boolean}*/
    this.success = false;

    /**Boolean. Whether or not to cancel the operation. True will cause the execution to stop and result in the OnCancel event being called.
    @type {Boolean}*/
    this.canceled = false;

    /**Boolean. Whether or not the EventStream was instructed to seek to another step.
    @type {Boolean}*/
    this.seeking = false;

    /**String. Any message to be used when Success is set to false.
    @type {String}*/
    this.message = null;

    /**Object. An exception object from a catch block. If Success is false, this exception is passed into the EventStream's OnError event args.
    @type {Error}*/
    this.error = null;

    /**Object. An instance of EVUI.Modules.EventStream.EventStreamError that occurred in an enclosing event stream of this event stream.
    @type {EVUI.Modules.EventStream.EventStreamError}*/
    this.innerError = null;
};

/**The EventArgs object for all events in the EventStream, serves as the parameter for all EventHandlers.
 @class*/
EVUI.Modules.EventStream.EventStreamEventArgs = function (state)
{
    /**String. The human-readable name of the current EventStreamStep.
    @type {String}*/
    this.name = null;

    /**String. The unique event key string of the current EventStreamStep.
    @type {String}*/
    this.key = null;

    /**String. The type of event being handled (Event or GlobalEvent).
    @type {String}*/
    this.stepType = null;

    /**Number. The index of the current step in the sequence of steps.
     @type {Number}*/
    this.currentStep = -1;

    /**Number. The total number of steps in the EventStream.
    @type {Number}*/
    this.totalSteps = -1;

    /**Object. An instance of EventStreamError. Will only be populated if there was an error.
    @type {EVUI.Modules.EventStream.EventStreamError}*/
    this.error = null;

    /**Number. The current status of the EventStream. A value from EventStreamStatus.
    @type {Number}*/
    this.status = EVUI.Modules.EventStream.EventStreamStatus.NotStarted;

    /**Function. Cancels the execution of the EventStream. Returns true if the execution was canceled, or false if it was not cancelable.
    @returns {Boolean}*/
    this.cancel = function () { return false; };

    /**Function. Pauses the execution of the EventStream. Returns true if the execution was paused, or false if it was not pausable.
    @returns {Boolean}*/
    this.pause = function () { return false; };

    /**Function. Resumes a paused execution of the EventStream. Returns true if the execution was resumed, or false if it was not resumable.
    @returns {Boolean}*/
    this.resume = function () { return false; };

    /**Function. Stops execution and seeks the EventStream to a new position. Returns true if the EventStream was able to seek to the given step, or false if seeking is not enabled or if the parameters were invalid.
    @param {Number|String} indexOrKey The index or key of the EventStreamStep to seek to.
    @returns {Boolean}*/
    this.seek = function (indexOrKey) { return false; };

    /**Function. Stops any other steps from executing with the same event key as the current step.*/
    this.stopPropagation = function () { return false };

    /**Object. The public event state of the EventStream.
    @type {Object}*/
    this.state = (state != null) ? state : {};
};

/**Object representing the arguments injected into a "job" step.
@class EventStreamJobArgs
@param {EVUI.Modules.EventStream.EventStream} eventStream The EventStream this job args is for.
@param {EVUI.Modules.EventStream.Constants.Fn_Job_Callback} callback The callback function that continues the EventStream.*/
EVUI.Modules.EventStream.EventStreamJobArgs = function (eventStream, callback)
{
    if (eventStream instanceof EVUI.Modules.EventStream.EventStream === false) throw TypeError("eventStream must be a EVUI.Modules.EventStream.EventStream");
    if (typeof callback !== "function") throw TypeError("Callback must be a function.");

    var _eventStream = eventStream;
    var _callback = callback;

    /**String. The human-readable name given to the Job step.
    @type {String}*/
    this.name = null;

    /**String. The unique key given to the Job step.
    @type {String}*/
    this.key = null;

    /**The value that was returned by the previous Job step in the EventStream.
    @type {Any}*/
    this.resolvedValue = null;

    /**Object. The EVUI.Modules.EventStream.EventStream that is currently executing.
    @type {EVUI.Modules.EventStream.EventStream}*/
    this.eventStream = _eventStream;

    /**Cancels the Job and ends the EventStream without raising error handling.*/
    this.cancel = function ()
    {
        var result = new EVUI.Modules.EventStream.EventStreamJobResult();
        result.canceled = true;

        return _callback(result);
    };

    /**Seeks the EventStream to a different step.
    @param {Number|EVUI.Modules.EventStream.EventStreamStep|String} indexOrKey Either the step object, the index of the step object, or the key of the step object to seek to.*/
    this.seek = function (indexOrKey)
    {
        _eventStream.seek(indexOrKey);
        var result = new EVUI.Modules.EventStream.EventStreamJobResult();
        result.success = true;
        result.seeking = true;

        return _callback(result);
    };

    /** Resolves the job and allows the EventStream to advance to the next step.
    @param {Any} value Any value to pass on to the next Job step in the EventStream. */
    this.resolve = function (value)
    {
        var result = new EVUI.Modules.EventStream.EventStreamJobResult();
        result.success = true;
        result.resolvedValue = value;

        return _callback(result);
    };

    /**Ends this step in the EventStream with an error.
    @param {String} message The message to log as an error.
    @param {Error} ex An exception thrown during the course of the Job.
    @param {EVUI.Modules.EventStream.EventStreamError}*/
    this.reject = function (message, ex, innerError)
    {
        if (typeof message !== "string") message = (message != null) ? message.toString() : "Process manually ended with an unknown error.";
        if (message instanceof Error) ex = message;

        var error = new EVUI.Modules.EventStream.EventStreamJobResult();
        error.success = false;
        error.message = message;
        if (ex instanceof Error) error.error = ex;
        if (innerError instanceof EVUI.Modules.EventStream.EventStreamError) error.innerError = innerError;

        return _callback(error);
    };

    /**Gets The EventStream's jobState object that is only accessible to Job steps.
    @returns {Object}*/
    this.getState = function ()
    {
        return _eventStream.jobState;
    };

    /**Any. Sets The EventStream's jobState object that is only accessible to Job steps.
    @returns {Any}*/
    this.setState = function (value)
    {
        _eventStream.jobState = value;
        return value;
    };
};

/**Represents an aggregation of data about an error that occurred during the execution of the EventStream.
 @class*/
EVUI.Modules.EventStream.EventStreamError = function (message, exception, stage, key)
{
    /**String. A Message describing the error.
    @type {String}*/
    this.message = message;

    /**Object. An exception object captured from in a catch block.
    @type {Error}*/
    this.exception = (exception instanceof Error) ? exception : null;

    /**String. The stage when the error occurred. Must be a value from EVUI.Modules.EventStream.EventStreamStage.
    @type {String}*/
    this.stage = stage;

    /**String. The Key that belongs to the step where the error occurred.
    @type {String}*/
    this.key = key;

    /**Object. An instance of EVUI.Modules.EventStream.EventStreamError. If an error occurred while reporting the error, this will be populated with the original error.
    @type {EVUI.Modules.EventStream.EventStreamError}*/
    this.innerError = null;

    /**Gets a string of the error message.
    @method GetErrorMessage*/
    this.getErrorMessage = function ()
    {
        var message = "Error:";
        if (this.message != null) message += " " + this.message + " ";
        if (this.stage != null) message += "Stage: " + stage + ". ";
        if (this.key != null) message += "Step: \"" + this.key + "\"."
        if (this.exception != null) message += "\nException: " +  this.exception.stack;
        if (this.innerError != null) message += "\nInnerError: " + this.innerError.getErrorMessage();

        return message;
    };
};

/**Configuration arguments for instantiating a new EventStream.
@class*/
EVUI.Modules.EventStream.EventStreamConfig = function ()
{
    /**Boolean. Whether or not the stream can seek and forth between steps. True by default.
    @type {Boolean}*/
    this.canSeek = true;

    /**Boolean. Whether or not a crash in an Event handler will cause the EventStream to stop executing. False by default.
    @type {Boolean}*/
    this.endExecutionOnEventHandlerCrash = false;

    /**Number. The number of milliseconds to wait on each step before failing the EventStream. A negative number means no timeout. -1 by default.
    @type {Number}*/
    this.timeout = -1;

    /**Any. Any data to carry between Jobs in the EventStream. A plain object by default.
    @type {Any}*/
    this.jobState = {};

    /**Any. Any data to carry between Events in the EventStream. A plain object by default.
    @type {Any}*/
    this.eventState = {};

    /**Number. When the EventStream is running, this is the number of sequential steps that can be executed before introducing a shot timeout to free up the thread to allow other processes to continue, otherwise an infinite step loop (which is driven by promises) will lock the thread. Small numbers will slow down the EventStream, high numbers may result in long thread locks. 250 by default.
    @type {Number}*/
    this.skipInterval = 250;

    /**Synchronous event handler for handling cases where the EventStream was canceled before it was finished. Cannot be an async function.
    @type {EVUI.Modules.EventStream.Constants.Fn_OnCancel}*/
    this.onCancel = null;

    /**Synchronous event handler for handling cases where an error occurred at any point during the process. Cannot be an async function.
    @type {EVUI.Modules.EventStream.Constants.Fn_OnError}*/
    this.onError = null;

    /**Synchronous event handler that executes whenever the EventStream has been completed or terminated. Cannot be an async function.
    @type {EVUI.Modules.EventStream.Constants.Fn_OnComplete}*/
    this.onComplete = null;

    /**Takes the event args generated for default events and gives the consumer of the EventStream a chance to inject its own event args. Cannot be an async function.
    @type {EVUI.Modules.EventStream.Constants.Fn_ProcessInjectedEventArgs}*/
    this.processInjectedEventArgs = null;

    /**Takes the event args that were passed into the event handler and gives the consumer a chance to react to any changes made to them or react to the value returned from the event handler. Cannot be an async function.
    @type {EVUI.Modules.EventStream.Constants.Fn_ProcessReturnedEventArgs}*/
    this.processReturnedEventArgs = null;

    /**Overridable function for passing a custom value into the resolve function of a promise if the EventStream is running in async mode. Cannot be an async function.*/
    this.getPromiseResolutionValue = null;

    /**Object. A BubblingEventManager used to supply bubbling events for the EventStream.
    @type {EVUI.Modules.EventStream.BubblingEventManager}*/
    this.bubblingEvents = null;

    this.context = null;
};

/**An object that ties together an event name, its callback its priority (if there are other events with the same name) and the unique ID of it's handle.
@param {String} eventName The name of the event.
@param {EVUI.Modules.EventStream.Constants.Fn_Event_Handler} handler The function to call when the event is invoked.
@param {Number} priority The priority of this event relative to other events with the same name.
@param {Boolean} immutable Whether or not this EventStreamListener is immutable and cannot be changed or removed..
@class*/
EVUI.Modules.EventStream.EventStreamEventListener = function (eventName, handler, priority, immutable)
{
    if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(eventName) === true) throw Error("event name must be a non-whitespace string.");
    if (typeof handler !== "function") throw Error("handler must be a function.");

    var _handlerId = EVUI.Modules.Core.Utils.makeGuid();
    var _priority = typeof priority === "number" ? priority : 0;
    var _eventName = eventName;
    var _handler = handler;
    var _immutable = (typeof immutable === "boolean") ? immutable : false;

    /**String. Read-only. The name of the event.
    @type {String}*/
    this.eventName = null;
    Object.defineProperty(this, "eventName", {
        get: function () { return _eventName; },
        enumerable: true,
        configurable: false
    });

    /**Function. The function to call when this event is invoked.
    @type {EVUI.Modules.EventStream.Constants.Fn_Event_Handler}*/
    this.handler = null;
    Object.defineProperty(this, "handler", {
        get: function () { return _handler },
        set: function (value)
        {
            if (_immutable === true) throw Error("EventStreamEventListener is immutable and cannot be changed or removed.");
            if (value != null && typeof value !== "function") throw Error("handler must be a function.")
            _handler = value;
        },
        enumerable: true,
        configurable: false
    });

    /**Number. The priority of this event relative to other events with the same name.
    @type {Number}*/
    this.priority = 0;
    Object.defineProperty(this, "priority", {
        get: function () { return _priority; },
        set: function (value)
        {
            if (_immutable === true) throw Error("EventStreamEventListener is immutable and cannot be changed or removed.");
            if (typeof value !== "number") throw Error("priority must be a number.");
            _priority = value;
        },
        enumerable: true,
        configurable: false
    });

    /**String. Read-only. The unique ID of this event listener.
    @type {String}*/
    this.handlerId = _handlerId;
    Object.defineProperty(this, "handlerId", {
        get: function () { return _handlerId; },
        enumerable: true,
        configurable: false
    });

    /**Boolean. Whether or not this EventStreamListener is immutable and cannot be changed or removed.
    @type {Boolean}*/
    this.immutable = false;
    Object.defineProperty(this, "immutable", {
        get: function () { return _immutable; },
        enumerable: true,
        configurable: false
    });
};

/**Object for containing configuration options for a EventStreamListener.
@class*/
EVUI.Modules.EventStream.EventStreamEventListenerOptions = function ()
{
    /**Boolean. Whether or not the EventStreamListener will be immutable and cannot be changed or removed.
    @type {Boolean}*/
    this.immutable = false;

    /**Whether or not the EventStreamListener will be fired exactly once then removed.
    @type {Boolean}*/
    this.once = false;

    /**Number. The priority of this event relative to other events with the same name.
    @type {Number}*/
    this.priority = null;

    /**Boolean. Whether or not this event should fire after a local or global event.
    @type {Boolean}*/
    this.isGlobal = false;
};

/**Controller for managing a stack of secondary event handlers that "bubble" in order of addition after the primary event has executed by an EventStream. Assign to an EventStream's bubblingEvents property to use.
@class*/
EVUI.Modules.EventStream.BubblingEventManager = function (forceGlobal)
{
    var _eventsDictionary = {}; //the internal registry of events. The keys are event names, and the values are arrays of InternalEventListners.
    var _forceGlobal = forceGlobal;

    /**Add an event listener to fire after an event with the same name has been executed.
    @param {String} eventName The name of the event in the EventStream to execute after.
    @param {EVUI.Modules.EventStream.Constants.Fn_Event_Handler} handler The function to fire.
    @param {EVUI.Modules.EventStream.EventStreamEventListenerOptions} options Options for configuring the event.
    @returns {EVUI.Modules.EventStream.EventStreamEventListener}*/
    this.addEventListener = function (eventName, handler, options)
    {
        var listener = new InternalEventListener();

        if (EVUI.Modules.Core.Utils.instanceOf(eventName, EVUI.Modules.EventStream.EventStreamEventListener) === true) //handed a complete event listener object
        {
            listener.listener = eventName;

            if (handler != null && typeof handler === "object") //second parameter could be the options object
            {
                options = handler;
            }

            if (options != null && typeof options === "object")
            {
                if (EVUI.Modules.Core.Utils.instanceOf(options, EVUI.Modules.EventStream.EventStreamEventListenerOptions) === true) //options object was a real options object, use it
                {
                    listener.options = options;
                }
                else //otherwise extend it onto a different options object
                {
                    options = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.EventStream.EventStreamEventListenerOptions(), options);
                }
            }
            else //no options - just make a new one
            {
                listener.options = new EVUI.Modules.EventStream.EventStreamEventListenerOptions();
            }

            listener.options.immutable = eventName.immutable;
        }
        else //handed normal parameters, make the listener object
        {
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(eventName) === true) throw Error("eventName must be a non-whitespace string.");
            if (typeof handler !== "function") throw Error("Function expected.");
            if (options == null || typeof options !== "object")
            {
                options = new EVUI.Modules.EventStream.EventStreamEventListenerOptions();
            }
            else
            {
                options = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.EventStream.EventStreamEventListenerOptions(), options);
            }

            var eventListener = new EVUI.Modules.EventStream.EventStreamEventListener(eventName, handler, options.priority, options.immutable);
            listener.listener = eventListener;
            listener.options = options;
        }

        if (_forceGlobal === true) options.isGlobal = true;

        //add the listener to the events dictionary
        var existingEvents = _eventsDictionary[listener.listener.eventName];
        if (existingEvents == null)
        {
            existingEvents = [];
            _eventsDictionary[listener.listener.eventName] = existingEvents;
        }

        //calculate the max ordinal in the events list already to ensure that they fire in order of addition.
        var maxOrdinal = 0;
        var numEvents = existingEvents.length;
        for (var x = 0; x < numEvents; x++)
        {
            var curEvent = existingEvents[x];
            if (curEvent.ordinal >= maxOrdinal) maxOrdinal = curEvent.ordinal + 1;
        }

        listener.ordinal = maxOrdinal;
        existingEvents.push(listener);

        return listener.listener;
    };

    /**Gets an array of all the EventStreamEventListeners in order of execution for the given step. Note that events with the "once" option are removed from the internal events dictionary when this function is called.
    @param {EVUI.Modules.EventStream.EventStreamStep} step The step to get the bubbling events for.
    @returns {EVUI.Modules.EventStream.EventStreamEventListener[]}*/
    this.getBubblingEvents = function (step)
    {
        var keyEvents = _eventsDictionary[step.key];
        if (keyEvents == null || keyEvents.length === 0) return null;

        var eventsToFire = [];

        //go add a step for each "bubbling" event
        var numEvents = keyEvents.length;
        for (var x = 0; x < numEvents; x++)
        {
            var curEvent = keyEvents[x];

            //sort the list into global and non-global events
            if (step.type === EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent)
            {
                if (curEvent.options.isGlobal === false) continue;
                eventsToFire.push(curEvent);
            }
            else 
            {
                if (curEvent.options.isGlobal === true) continue;
                eventsToFire.push(curEvent);
            }

            //remove any event with "once" set to true so that it only fires once.
            if (curEvent.options.once === true)
            {
                if (index !== -1) keyEvents.splice(x, 1);
                x--;
            }
        }

        if (keyEvents.length === 0)
        {
            delete _eventsDictionary[step.key];
        }

        var numEventsToFire = eventsToFire.length;
        if (numEventsToFire === 0) return null;

        //sort the events based on their priority first, then their order of addition if they have the same priority.
        eventsToFire.sort(function (listener1, listener2)
        {
            if (listener1.listener.priority === listener2.listener.priority)
            {
                return listener1.orindal - listener2.ordinal;
            }
            else
            {
                return listener2.listener.priority - listener1.listener.priority;
            }
        });

        var listeners = [];
        for (var x = 0; x < numEventsToFire; x++)
        {
            listeners.push(eventsToFire[x].listener)
        };

        return listeners;
    };

    /**Removes an EventStreamEventListener based on its event name, its id, or its handling function.
    @param {String} eventNameOrId The name or ID of the event to remove.
    @param {Function} handler The handling function of the event to remove.
    @returns {Boolean}*/
    this.removeEventListener = function (eventNameOrId, handler)
    {
        var existingList = _eventsDictionary[eventNameOrId];
        if (existingList != null)
        {
            var removed = false;
            var numInList = existingList.length;
            for (var x = 0; x < numInList; x++)
            {
                var curListener = existingList[x];
                if (curListener.listener.handler === handler && curListener.listener.immutable === false)
                {
                    removed = true;
                    existingList.splice(x, 1);
                    x--;
                    numInList--;

                    if (numInList === 0)
                    {
                        delete _eventsDictionary[eventNameOrId];
                        break;
                    }
                }
            }

            return removed;
        }
        else
        {
            for (var prop in _eventsDictionary)
            {
                var curListeners = _eventsDictionary[prop];
                var removed = false;

                var numListeners = curListeners.length;
                for (var x = 0; x < numListeners; x++)
                {
                    var curListener = curListeners[x];
                    if (curListener.listener.immutable === false && (curListener.handlerId === eventNameOrId || curListener.listener.handler === handler))
                    {
                        curListeners.splice(x, 1);
                        numListeners--;

                        if (numListeners === 0)
                        {
                            delete _eventsDictionary[eventNameOrId];
                        }

                        removed = true;
                    }
                }
            }

            return removed;
        }
    };

    /**Represents the data needed for a bubbling event listener to fire after the main handler for an event fires.
    @class*/
    var InternalEventListener = function ()
    {
        /**Object. The event listener to fire.
        @type {EVUI.Modules.EventStream.EventStreamEventListener}*/
        this.listener = null;

        /**Object. The configuration options for the event listener.
        @type {EVUI.Modules.EventStream.EventStreamEventListenerOptions}*/
        this.options = null;

        /**Number. The priority number of this event relative to the other events with the same name. Is used to sort event handlers when the handler's own priority property is equal to another's.
        @type {Number}*/
        this.ordinal = 0;
    };
};

/**Status enum for describing the current state of an instance of EVUI.Modules.EventStream.EventStream.
 @enum*/
EVUI.Modules.EventStream.EventStreamStatus =
{
    /**Work has not started yet.*/
    NotStarted: 0,
    /**Event chain is currently executing.*/
    Working: 1,
    /**Event chain was paused and is awaiting being resumed.*/
    Paused: 2,
    /**Event chain has completed.*/
    Finished: 3,
    /**Event chain has been canceled.*/
    Canceled: 4,
    /**Event chain ended with an error.*/
    Error: 5,
    /*Event chain is going to execute a step out of sequence.*/
    Seeking: 6
};
Object.freeze(EVUI.Modules.EventStream.EventStreamStatus);

/**State enum for indicating what part of the execution of an EventStreamStep an error occurred in.
 @enum*/
EVUI.Modules.EventStream.EventStreamStage =
{
    /**Stage was during the execution of a Job function.*/
    Job: "job",
    /**Stage was during the execution of a EventHandler function.*/
    Handler: "handler",
    /**Stage was generating custom event args.*/
    ProcessInjectedEventArgs: "processInjectedEventArgs",
    /**Stage was processing the event arguments that were returned from the event handler.*/
    ProcessReturnedEventArgs: "processReturnedEventArgs",
    /**Stage was caused by a custom error being raised.*/
    ErrorCommand: "errorCommand",
};
Object.freeze(EVUI.Modules.EventStream.EventStreamStage);

/**Sets the behavior for the Handler function in a EventStreamStep.
 @enum*/
EVUI.Modules.EventStream.EventStreamStepType =
{
    /**The default. Function is executed and is passed an object with the EventStream publicly accessible as well as a callback function to call to continue the operation.*/
    Job: "job",
    /**Function is executed and is passed an event args parameter (either the default args or a custom made set of args).*/
    Event: "event",
    /**Function is executed and is passed an event args parameter (either the default args or a custom made set of args). Exactly the same as Event, but used to flag events that are on Global instances of objects and not local instances.*/
    GlobalEvent: "globalEvent",

    /**Takes a string and returns a correct EventStreamStepType.
    @method GetStepType
    @param {String} stepType The string to match against one of the existing step types.
    @returns {String}*/
    getStepType: function (stepType)
    {
        if (typeof stepType !== "string") return this.Job;
        var lowerStepType = stepType.toLowerCase();

        if (lowerStepType === this.Job) return this.Job;
        if (lowerStepType === this.Event) return this.Event;
        if (lowerStepType === this.GlobalEvent.toLowerCase()) return this.GlobalEvent;
        return this.Job;
    }
};
Object.freeze(EVUI.Modules.EventStream.EventStreamStepType);

/**Creates the beginning of an deferred stream of asynchronous of promises.
@param {EVUI.Modules.EventStream.Constants.Fn_Job_Handler|EVUI.Modules.EventStream.EventStreamConfig} jobOrConfig Either a function to execute that takes a EventStreamJobArgs object as a parameter or the configuration options for the underlying EventStream.
@param {EVUI.Modules.EventStream.Constants.Fn_Job_Handler} job A function to execute that takes a EventStreamJobArgs object as a parameter.
@returns {EVUI.Modules.EventStream.EventStream}*/
$evui.vow = function (jobOrConfig, job)
{
    var config = null;

    if (typeof jobOrConfig === "function")
    {
        job = jobOrConfig;
    }

    if (jobOrConfig != null && typeof jobOrConfig === "object")
    {
        config = jobOrConfig;
    }

    var es = new EVUI.Modules.EventStream.EventStream(config);

    if (typeof job === "function") es.addJob(job);
    es.execute();

    return es;
};

/**Returns a new EventStream in its default state.
@param {EVUI.Modules.EventStream.EventStreamConfig} config Configuration options for the never EventStream.
@returns {EVUI.Modules.EventStream.EventStream}*/
$evui.eventStream = function (config)
{
    return new EVUI.Modules.EventStream.EventStream(config);
};

/*#ENDWRAP(ES)#*/


/********************************************************HtmlLoader.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.HtmlLoader|HtmlLoader)#*/
/*#REPLACE(EVUI.Modules.HtmlLoader|HtmlLoader)#*/

/**Module for containing a EventStream-driven Html partial/placeholder loader that loads foreign Html via Http.
@module*/
EVUI.Modules.HtmlLoader = {};

/*#MODULEDEF(HtmlLoader|"1.0";|"HtmlLoader")#*/
/*#VERSIONCHECK(EVUI.Modules.HtmlLoader|HtmlLoader)#*/

EVUI.Modules.HtmlLoader.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
    EventStream: Object.freeze({ version: "1.0", required: true }),
    Http: Object.freeze({ version: "1.0", required: true })
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.HtmlLoader.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();

Object.freeze(EVUI.Modules.HtmlLoader.Dependencies);

EVUI.Modules.HtmlLoader.Constants = {};

EVUI.Modules.HtmlLoader.Constants.Job_GetHtml = "evui.htmlLoader.getHtml";
EVUI.Modules.HtmlLoader.Constants.Job_InjectHtml = "evui.htmlLoader.injectHtml";
EVUI.Modules.HtmlLoader.Constants.Job_LoadChildren = "evui.htmlLoader.loadChildren";

EVUI.Modules.HtmlLoader.Constants.Attr_PlaceholderID = "evui-loader-placeholder-id";
EVUI.Modules.HtmlLoader.Constants.Attr_ResourceUrl = "evui-loader-placeholder-src";
EVUI.Modules.HtmlLoader.Constants.Attr_ContentLoadState = "evui-loader-content-load-state";

EVUI.Modules.HtmlLoader.Constants.Event_OnBeforePlaceholderLoad = "evui.htmlLoader.onBeforeLoad";
EVUI.Modules.HtmlLoader.Constants.Event_OnGetPlaceholderHtml = "evui.htmlLoader.onGetPlaceholderHtml";
EVUI.Modules.HtmlLoader.Constants.Event_OnPlaceholderInject = "evui.htmlLoader.onInject";
EVUI.Modules.HtmlLoader.Constants.Event_OnBeforeLoadPlaceholderChildren = "evui.htmlLoader.onBeforeLoadChildren";
EVUI.Modules.HtmlLoader.Constants.Event_OnPlaceholderLoaded = "evui.htmlLoader.onPlaceholderLoaded";
EVUI.Modules.HtmlLoader.Constants.Event_OnAllPlaceholdersLoaded = "evui.hmlLoader.onAllPlaceholdersLoaded"

/**Callback function that is called when Html is returned from a web request.
@param {String} html: The Html returned from the web request.*/
EVUI.Modules.HtmlLoader.Constants.Fn_GetHtml_Callback = function (html) { };

/**Callback function that is called when a collection of Html partials have all been loaded.
@param {EVUI.Modules.HtmlLoader.HtmlPartialLoadRequest[]} loadRequests An array of EVUI.Modules.HtmlLoaderController.HtmlPartialLoadRequest representing all the requests that have completed (successfully or not).*/
EVUI.Modules.HtmlLoader.Constants.Fn_GetPartials_Callback = function (loadRequests) { };

/**Callback function that is called when a html placeholder has been completely loaded and injected into the DOM.
 @param {EVUI.Modules.HtmlLoader.HtmlPlaceholder} placeholderResult The details of the completed placeholder load.*/
EVUI.Modules.HtmlLoader.Constants.Fn_GetPlaceholder_Callback = function (placeholderResult) { }

Object.freeze(EVUI.Modules.HtmlLoader.Constants)

/**Controller for loading HTML, either as a bunch of small partial pieces of HTML or for loading larger placeholders which can also contain placeholders.
 @class*/
EVUI.Modules.HtmlLoader.HtmlLoaderController = function (services)
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.HtmlLoader.Dependencies);

    //self reference for closures
    var _self = this;

    /**The services used by the HtmlLoaderController.
    @type {EVUI.Modules.HtmlLoader.HtmlLoaderControllerServices}*/
    var _services = services;

    /**A counter to generate ID's for each load session.
    @type {Number}*/
    var _sessionIdCtr = 0;

    /**Makes a simple GET request to get Html. The request defaults to a GET with a response type of "text". If a different response type is used, the result is translated back into a string.
    @param {EVUI.Modules.HtmlLoader.HtmlRequestArgs} htmlRequestArgsOrUrl The Url of the html or the arguments for getting the Html.
    @param {EVUI.Modules.HtmlLoader.Constants.Fn_GetHtml_Callback} getHtmlCallback  A function to call once the server has completed the request, takes the string version of whatever was returned as a parameter. */
    this.loadHtml = function (htmlRequestArgsOrUrl, getHtmlCallback)
    {
        if (htmlRequestArgsOrUrl == null) throw Error("htmlRequestArgsOrUrl cannot be null.");

        if (typeof getHtmlCallback !== "function") getHtmlCallback = function (html) { };

        if (typeof htmlRequestArgsOrUrl === "string")
        {
            var url = htmlRequestArgsOrUrl;
            htmlRequestArgsOrUrl = new EVUI.Modules.HtmlLoader.HtmlRequestArgs();
            htmlRequestArgsOrUrl.url = url;
        }

        var htmlArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.HtmlLoader.HtmlRequestArgs(), htmlRequestArgsOrUrl);
        htmlArgs.httpArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Http.HttpRequestArgs(), htmlArgs.httpArgs);

        htmlArgs.httpArgs.responseType = "text";
        htmlArgs.httpArgs.method = "GET";
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(htmlArgs.url) === false) htmlArgs.httpArgs.url = htmlArgs.url;

        _services.httpManager.executeRequest(htmlArgs.httpArgs, function (completedRequest)
        {
            if (completedRequest.error != null)
            {
                EVUI.Modules.Core.Utils.log(completedRequest.error.getErrorMessage());
                return getHtmlCallback(null);
            }

            translateResponseToText(completedRequest.xmlHttpRequest, function (textResult)
            {
                return getHtmlCallback(textResult);
            });
        });
    };

    /**Awaitable. Makes a simple GET request to get html. The request defaults to a GET with a response type of "text". If a different response type is used, the result is translated back into a string.
    @param {String|EVUI.Modules.HtmlLoader.HtmlRequestArgs} htmlRequestArgsOrUrl  The Url of the html or the arguments for getting the Html.
    @returns {Promise<String>}*/
    this.loadHtmlAsync = function (htmlRequestArgsOrUrl)
    {
        if (htmlRequestArgsOrUrl == null) throw new Error("htmlRequestArgsOrUrl cannot be null.");

        return new Promise(function (resolve)
        {
            _self.loadHtml(htmlRequestArgsOrUrl, function (textResult)
            {
                resolve(textResult);
            })
        });
    };

    /**Loads an array of PartialLoadRequeusts either as a standalone array or as part of a HtmlPartalLoadArgs object.
    @param {EVUI.Modules.HtmlLoader.HtmlPartialLoadArgs|EVUI.Modules.HtmlLoader.HtmlPartialLoadRequest[]} partialLoadArgsOrPartialRequests Either an array of HtmlPartialLoadRequests or a HtmlPartialLoadArgs object.
    @param {EVUI.Modules.HtmlLoader.Constants.Fn_GetPartials_Callback} loadedCallback A callback that is fired once all the Html partials have been loaded.*/
    this.loadHtmlPartials = function (partialLoadArgsOrPartialRequests, loadedCallback)
    {
        if (partialLoadArgsOrPartialRequests == null) throw new Error("partialLoadArgsOrPartialRequests cannot be null.");

        loadHtmlPartials(partialLoadArgsOrPartialRequests, loadedCallback);
    };

    /**Awaitable. Loads an array of PartialLoadRequeusts either as a standalone array or as part of a HtmlPartalLoadArgs object.
    @param {EVUI.Modules.HtmlLoader.HtmlPartialLoadArgs|EVUI.Modules.HtmlLoader.HtmlPartialLoadRequest[]} partialLoadArgsOrPartialRequests Either an array of HtmlPartialLoadRequests or a HtmlPartialLoadArgs object.
    @returns {Promise<EVUI.Modules.HtmlLoader.HtmlPartialLoadRequest[]>}.*/
    this.loadHtmlPartialsAsync = function (partialLoadArgsOrPartialRequests)
    {
        if (partialLoadArgsOrPartialRequests == null) throw new Error("partialLoadArgsOrPartialRequests cannot be null.");

        return new Promise(function (resolve)
        {
            loadHtmlPartials(partialLoadArgsOrPartialRequests, function (allRequests)
            {
                resolve(allRequests);
            });
        });
    };

    /**Loads an array of PartialLoadRequeusts either as a standalone array or as part of a HtmlPartalLoadArgs object.
    @param {EVUI.Modules.HtmlLoader.HtmlPartialLoadArgs|EVUI.Modules.HtmlLoader.HtmlPartialLoadRequest[]} partialLoadArgsOrPartialRequests Either an array of HtmlPartialLoadRequests or a HtmlPartialLoadArgs object.
    @param {EVUI.Modules.HtmlLoader.Constants.Fn_GetPartials_Callback} loadedCallback A callback that is fired once all the Html partials have been loaded.*/
    var loadHtmlPartials = function (partialLoadArgsOrPartialRequests, allLoadedCallback)
    {
        if (typeof allLoadedCallback !== "function") allLoadedCallback = function (partialLoadResponses) { };

        if (EVUI.Modules.Core.Utils.isArray(partialLoadArgsOrPartialRequests) === true) //we were handed an array of what should be EVUI.Modules.HtmlPartialLoadRequests, make an arguments object to hold them
        {
            var partialLoads = partialLoadArgsOrPartialRequests;
            partialLoadArgsOrPartialRequests = new EVUI.Modules.HtmlLoader.HtmlPartialLoadArgs();
            partialLoadArgsOrPartialRequests.htmlPartialLoadRequests = partialLoads;
        }

        var totalRequests = [];
        var returnedRequests = [];

        //make a safe copy of the arguments to pass into each event stream
        var partialsArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.HtmlLoader.HtmlPartialLoadArgs(), partialLoadArgsOrPartialRequests);
        partialsArgs.httpArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Http.HttpRequestArgs(), partialsArgs.httpArgs);

        //no load requests, something is wrong, just return.
        if (partialsArgs.htmlPartialLoadRequests.length === 0) return callback([]);

        var getPartial = function (partialLoadRequest)
        {
            var httpArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Http.HttpRequestArgs(), partialsArgs.httpArgs);
            httpArgs.context = partialLoadRequest;
            httpArgs.method = "GET";
            httpArgs.responseType = "text";
            httpArgs.url = httpArgs.context.url;

            totalRequests.push(httpArgs.context);

            _services.httpManager.executeRequest(httpArgs, function (completedRequest)
            {
                translateResponseToText(completedRequest.xmlHttpRequest, function (resultText)
                {
                    partialLoadRequest.html = resultText;
                    returnedRequests.push(partialLoadRequest);

                    if (returnedRequests.length === totalRequests.length)
                    {
                        return allLoadedCallback(returnedRequests);
                    }
                })
            });
        };

        //launch all requests in parallel
        var numPartials = partialsArgs.htmlPartialLoadRequests.length;
        for (var x = 0; x < numPartials; x++)
        {
            getPartial(partialsArgs.htmlPartialLoadRequests[x]);
        }
    };

    /**Translates a HTTP response into text.
    @param {XMLHttpRequest} response The XMLHttpRequest used to make the request.
    @param {Function} callback A callback function that contains the translated value.*/
    var translateResponseToText = function (response, callback)
    {
        if (response == null || response.response == null || !((response.status >= 200 && response.status < 300) || response.status === 304)) return callback(null);

        try
        {
            switch (response.responseType)
            {
                case "json":
                    return callback(JSON.stringify(response.response));
                case "document":
                    return callback(response.response.documentElement.outerHTML);
                case "blob":
                case "arraybuffer":
                    var blob = (response.responseType === "blob") ? response.response : new Blob([response.response]);
                    var fr = new FileReader();
                    fr.onload = function ()
                    {
                        return callback(fr.result);
                    }

                    fr.readAsText(blob);
                    break;
                case "text":
                default:
                    return callback(response.response);
            }
        }
        catch (ex)
        {
            return EVUI.Modules.Core.Utils.debugReturn("EVUI.Modules.HtmlLoaderController.Manager", "translateResponseToText", ex.stack, null);
        }
    };

    /**Loads a placeholder and all of its children and injects it into the DOM.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs|String} placeholderIDOrArgs The value of a PlaceholderID attribute or a graph of HtmlPlaceholderLoadArgs.
    @param {EVUI.Modules.HtmlLoader.Constants.Fn_GetPlaceholder_Callback} callback A callback function that is executed once the placeholder load operation is complete.*/
    this.loadPlaceholder = function (placeholderIDOrArgs, callback)
    {
        loadPlaceholder(placeholderIDOrArgs, callback);
    };

    /**Awaitable. Loads a placeholder and all of its children and injects them into the DOM.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs|String} placeholderIDOrArgs The value of a EVUI.Modules.HtmlLoaderController.Constants.Attr_PlaceholderID attribute or a graph of HtmlPlaceholderLoadArgs.
    @returns {Promise<EVUI.Modules.HtmlLoader.HtmlPlaceholder>}*/
    this.loadPlaceholderAsync = function (placeholderIDOrArgs)
    {
        return new Promise(function (resolve)
        {
            loadPlaceholder(placeholderIDOrArgs, function (result)
            {
                resolve(result);
            });
        });
    };

    /**Loads all placeholders currently in the document (elements with the EVUI.Modules.HtmlLoaderController.Constants.Attr_PlaceholderID attribute present with a non-empty string value) in parallel, but excludes those that are flagged as being loaded upon on demand.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs} placehoderLoadArgs The arguments for loading all the placeholders currently in the document.
    @param {EVUI.Modules.HtmlLoader.Constants.Fn_GetPlaceholder_Callback} callback A callback function that is called once all the placeholders in the document have been loaded and injected into the DOM.*/
    this.loadAllPlaceholders = function (placehoderLoadArgs, callback)
    {
        loadAllPlaceholders(placehoderLoadArgs, callback);
    };

    /**Loads all placeholders currently in the document (elements with the EVUI.Modules.HtmlLoaderController.Constants.Attr_PlaceholderID attribute present with a non-empty string value) in parallel, but excludes those that are flagged as being loaded upon on demand.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs} placehoderLoadArgs The arguments for loading all the placeholders currently in the document.
    @returns {Promise<EVUI.Modules.HtmlLoader.HtmlPlaceholder>} callback A callback function that is called once all the placeholders in the document have been loaded and injected into the DOM.*/
    this.loadAllPlaceholdersAsync = function (placehoderLoadArgs)
    {
        return new Promise(function (resolve)
        {
            loadAllPlaceholders(placehoderLoadArgs, function (results)
            {
                resolve(results);
            })
        })
    }

    /**Internal implementation of loading all placeholders currently present in the document (and optionally, all their children). 
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs|String} placeholderLoadArgs The value of a EVUI.Modules.HtmlLoaderController.Constants.Attr_PlaceholderID attribute or a graph of HtmlPlaceholderLoadArgs.
    @param {EVUI.Modules.HtmlLoader.Constants.Fn_GetPlaceholder_Callback} callback A callback function that is executed once the placeholder load operation is complete.*/
    var loadAllPlaceholders = function (placeholderLoadArgs, callback)
    {
        if (typeof placeholderLoadArgs === "string")
        {
            var placeholderID = placeholderLoadArgs;
            placeholderLoadArgs = new EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs();
            placeholderLoadArgs.placeholderID = placeholderID;
        }
        else
        {
            //make a safe copy of the args to work with
            placeholderLoadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs(), placeholderLoadArgs);
            placeholderLoadArgs.httpArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Http.HttpRequestArgs(), placeholderLoadArgs.httpArgs);
        }

        //make the "master" event stream that'll organize the flow for all the parallel event streams it will spawn.
        var es = new EVUI.Modules.EventStream.EventStream();
        es.context = placeholderLoadArgs;

        es.canSeek = false; //no seeking allowed in this case, will cause issues.

        var loaded = []; //all the loaded HtmlPartialLoadResults from the top level of the document
        var launched = []; //all the child sessions that were launched
        var elements = null;

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(placeholderLoadArgs.placeholderID) === false)
        {
            elements = new EVUI.Modules.Dom.DomHelper("[" + EVUI.Modules.HtmlLoader.Constants.Attr_PlaceholderID + "=\"" + placeholderLoadArgs.placeholderID + "\"]", null).elements;
        }
        else
        {
            elements = getLoadableElements(null, placeholderLoadArgs.forceReload, placeholderLoadArgs.ignoreOnDemand);
        }

        //make the "master session" to be the parent to all the child sessions so they don't fire the OnAllPlaceholderLoad events and so the event args generation works correctly.
        var masterSession = new PlaceholderLoadSession();
        masterSession.allChildPlaceholders = elements;
        masterSession.eventStream = es;
        masterSession.loadResults = loaded;
        masterSession.placeholderArgs = placeholderLoadArgs;
        masterSession.placeholderID = "*"; //no placeholder ID as we are doing the whole document
        masterSession.placeholderElement = placeholderLoadArgs.contextElement == null ? placeholderLoadArgs.contextElement : document.documentElement; //no placeholder element as we have multiple root elements, so we just use the document to make the Html loader's event args constructor happy

        //set the common properties on the event stream so it behaves like the normal one when it's raising events
        setUpEventStream(masterSession, callback);

        //make a "dummy" step that launches all placeholder load requests in parallel and doesn't complete until they are all fully loaded.
        es.addJob(function (args)
        {
            var numEles = elements.length;
            for (var x = 0; x < numEles; x++)
            {
                var curEle = elements[x];
                var attrs = EVUI.Modules.Core.Utils.getElementAttributes(curEle);
                var placeholderID = attrs.getValue(EVUI.Modules.HtmlLoader.Constants.Attr_PlaceholderID);

                if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(placeholderID) === true) continue; //no placeholderID = no load

                var childSession = makePlaceholderLoadSession(curEle, masterSession.placeholderArgs, masterSession, function (loadResult) //try and make a session, if something is wrong this will return null (like a circular reference)
                {
                    loaded.push(loadResult);
                    if (loaded.length === launched.length) //once our queued requests and returned requests arrays are the same length we are done.
                    {
                        return args.resolve();
                    }
                });

                if (childSession == null) continue;
                launched.push(curEle);

                if (masterSession.childSessions == null) masterSession.childSessions = [];
                masterSession.childSessions.push(childSession);

                childSession.eventStream.execute(); //begin the loading process
            }

            masterSession.allChildPlaceholders = launched;
            masterSession.loadResults = loaded;

            if (launched.length === 0) //nothing was launched, bail on the whole operation
            {
                return args.cancel();
            }
        });

        //add the final events to the event stream so it fires them off as if it were a normal multi-part placeholder load
        addOnAllPlaceholderLoadedEvents(masterSession);

        //go!
        es.execute();
    };

    /**Loads a placeholder and all of its children and injects it into the DOM.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs|String} placeholderIDOrArgs The value of a PlaceholderID attribute or a graph of HtmlPlaceholderLoadArgs.
    @param {EVUI.Modules.HtmlLoader.Constants.Fn_GetPlaceholder_Callback} callback A callback function that is executed once the placeholder load operation is complete.*/
    var loadPlaceholder = function (placeholderIDOrArgs, callback)
    {
        if (typeof placeholderIDOrArgs === "string")
        {
            var placeholderID = placeholderIDOrArgs;
            placeholderIDOrArgs = new EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs();
            placeholderIDOrArgs.placeholderID = placeholderID;
        }

        var loadSession = makePlaceholderLoadSession(placeholderIDOrArgs.placeholderID, placeholderIDOrArgs, null, function (completed)
        {
            if (typeof callback === "function") callback(completed);
        });

        if (loadSession == null)
        {
            if (typeof callback === "function") return callback(null);
        }

        loadSession.eventStream.execute();
    };

    /**Gets the first element that has the given placeholderID under the contextElement.
    @param {String} placeholderID The ID of the placeholder node to get.
    @param {Element} contextElement A context element to limit the scope of the search.
    @returns {Element}*/
    var getPlaceholderElement = function (placeholderID, contextElement)
    {
        var byPlaceholderID = new EVUI.Modules.Dom.DomHelper("[" + EVUI.Modules.HtmlLoader.Constants.Attr_PlaceholderID + "=\"" + placeholderID + "\"]", contextElement);
        if (byPlaceholderID.first() != null) return byPlaceholderID.first();

        var byUrl = new EVUI.Modules.Dom.DomHelper("[" + EVUI.Modules.HtmlLoader.Constants.Attr_ResourceUrl + "=\"" + placeholderID + "\"]", contextElement);
        return byUrl.first();
    };

    /**Takes the returned list of child placeholders from the event args and passes it back to the EventStream in progress.
    @param {Element[]} selectedArray The array of selected child elements to load.
    @returns {Node[]} */
    var getSelectedChildPlaceholders = function (selectedArray)
    {
        var returnArray = [];
        if (EVUI.Modules.Core.Utils.isArray(selectedArray) === false) return returnArray;

        var numSelected = selectedArray.length;
        for (var x = 0; x < numSelected; x++)
        {
            var curSelected = selectedArray[x];
            if (EVUI.Modules.Core.Utils.isElement(curSelected) === true) returnArray.push(curSelected);
        }

        return returnArray;
    };

    /**Gets all the Dom that have the PlaceholderID attribute on them.
    @param {Node} context A context limiting node to search inside of.
    @returns {Element[]}*/
    var getChildLoadElements = function (context)
    {
        //first, get everything that has a placeholderID
        var eh = new EVUI.Modules.Dom.DomHelper("[" + EVUI.Modules.HtmlLoader.Constants.Attr_PlaceholderID + "],[" + EVUI.Modules.HtmlLoader.Constants.Attr_ResourceUrl + "],[" + EVUI.Modules.HtmlLoader.Constants.Attr_PlaceholderID + "][" + EVUI.Modules.HtmlLoader.Constants.Attr_ResourceUrl + "]", context);
        var eles = eh.elements.slice();

        //make sure they all have placeholder ID attributes - if they don't just use the URL as the placeholderID.
        var numEles = eles.length;
        for (var x = 0; x < numEles; x++)
        {
            var curEle = eles[x];
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(curEle.getAttribute(EVUI.Modules.HtmlLoader.Constants.Attr_PlaceholderID)) === true) curEle.setAttribute(EVUI.Modules.HtmlLoader.Constants.Attr_PlaceholderID, curEle.getAttribute(EVUI.Modules.HtmlLoader.Constants.Attr_ResourceUrl))
        }

        return eles;
    };

    /**Gets all the elements that should be loaded beneath a given element.
    @param {Node} context A context limiting node to search inside of.
    @param {Boolean} forceReload Whether or not to ignore the "loaded" content load state and to reload the content anyways.
    @param {Boolean} ignoreOnDemand Whether or not to ignore the "ondemand" content load state and force the load of the element instead.
    @returns {Element[]} */
    var getLoadableElements = function (context, forceReload, ignoreOnDemand)
    {
        var loadableEles = [];

        var children = getChildLoadElements(context);
        var numChildren = children.length;
        for (var x = 0; x < numChildren; x++)
        {
            var curChild = children[x];
            var attrs = EVUI.Modules.Core.Utils.getElementAttributes(curChild);
            var loadState = attrs.getValue(EVUI.Modules.HtmlLoader.Constants.Attr_ContentLoadState);
            if (loadState != null)
            {
                loadState = loadState.toLowerCase();
                if (loadState === EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.Loaded && forceReload !== true) continue;
                if (loadState === EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.OnDemand && ignoreOnDemand !== true) continue;
                if (loadState === EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.Loading || loadState === EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.Pending) continue;
            }

            curChild.setAttribute(EVUI.Modules.HtmlLoader.Constants.Attr_ContentLoadState, EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.Pending);

            loadableEles.push(curChild);
        }

        return loadableEles;
    };

    /**Makes a container to hold the details of a recursive placeholder load session.
    @param {String|Element} placeholderID The ID of the placeholder to load or the resolved element to load.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs} sourcePlaceholderLoadArgs The event args to clone and use for the load session.
    @param {PlaceholderLoadSession} parentSession The session that spawned this session.
    @param {EVUI.Modules.HtmlLoader.Constants.Fn_GetPlaceholder_Callback} callback A callback function to call once the placeholder has been fully loaded.
    @returns {PlaceholderLoadSession} */
    var makePlaceholderLoadSession = function (placeholderID, sourcePlaceholderLoadArgs, parentSession, callback)
    {
        var ele = null;
        var anonymousPlaceholder = false;

        //no placeholder ID means none of the below will work, just return null and fail the operation.
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(placeholderID) === true)
        {
            if (EVUI.Modules.Core.Utils.isElement(placeholderID) === true)
            {
                ele = placeholderID;
                placeholderID = ele.getAttribute(EVUI.Modules.HtmlLoader.Constants.Attr_PlaceholderID);
            }
            else if (sourcePlaceholderLoadArgs != null && sourcePlaceholderLoadArgs.httpArgs != null && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(sourcePlaceholderLoadArgs.httpArgs.url) === false)
            {
                placeholderID = sourcePlaceholderLoadArgs.httpArgs.url;
                anonymousPlaceholder = true;
            }
            else
            {
                throw Error("placeholderID must be a non-whitespace string.");
            }
        }

        var circularRef = false;
        if (parentSession != null) //if we have a parent session we are the child of another session, make sure we don't have some infinite recursion going on
        {
            var lowerPlaceholder = placeholderID.toLowerCase();
            var parent = parentSession;
            while (parent != null)
            {
                if (parent.placeholderID.toLowerCase() === lowerPlaceholder) //this placeholder is loading itself via its parentage, fail the operation
                {
                    circularRef = true;
                    break;
                }

                parent = parent.parentSession;
            }
        }

        //get the element that we will be injecting html into.
        if (ele == null)
        {
            if (parentSession != null && parentSession.loadedFragment != null) //we have a parent session, so we have a recursive load happening, look inside the loaded fragment for the child node
            {
                ele = getPlaceholderElement(placeholderID, parentSession.loadedFragment);
            }
            else if (anonymousPlaceholder === false) //we do not have a child session (or a fragment), use the context node to narrow the search
            {
                ele = getPlaceholderElement(placeholderID, sourcePlaceholderLoadArgs.contextElement);
            }
        }

        //no element, nowhere to stick html - make a dummy div to load into if we have a valid URL to get HTML from.
        if (ele == null)
        {
            if (sourcePlaceholderLoadArgs != null && sourcePlaceholderLoadArgs.httpArgs != null && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(sourcePlaceholderLoadArgs.httpArgs.url) === false)
            {
                var loadDiv = document.createElement("div");
                loadDiv.setAttribute(EVUI.Modules.HtmlLoader.Constants.Attr_PlaceholderID, placeholderID);
                loadDiv.setAttribute(EVUI.Modules.HtmlLoader.Constants.Attr_ResourceUrl, sourcePlaceholderLoadArgs.httpArgs.url);

                ele = loadDiv;
            }
            else
            {
                throw Error("Cannot load placeholder - no placeholderID or loadable resource url present.")
            }
        }

        if (circularRef === true) //we had a circular reference - flag the element and move on without blowing up the browser. NOTE IT IS STILL POSSIBLE TO HAVE A CIRCULAR REFERENCE LOOP VIA URLS. The server may or may not return something different for the same url, so we can't use urls for this check. Also, the http event args lets the user change the url.
        {
            ele.setAttribute(EVUI.Modules.HtmlLoader.Constants.Attr_ContentLoadState, EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.CircularReference);
            return callback(null);
        }

        //clone the arguments for this session.
        var newArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs(), sourcePlaceholderLoadArgs);
        newArgs.httpArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Http.HttpRequestArgs(), newArgs.httpArgs);
        newArgs.httpArgs.headers = newArgs.httpArgs.headers.map(function (header) { return EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Http.HttpRequestHeader(), header); });
        newArgs.PlaceholderID = placeholderID;

        var session = new PlaceholderLoadSession();
        session.placeholder = new EVUI.Modules.HtmlLoader.HtmlPlaceholder(session);
        session.parentSession = parentSession;
        session.placeholderArgs = newArgs;
        session.placeholderElement = ele;
        session.placeholderID = placeholderID;
        session.eventStream = buildEventStream(session, callback);

        if (parentSession != null)
        {
            if (parentSession.childSessions == null) parentSession.childSessions = [];
            parentSession.childSessions.push(session);
        }

        session.loadState = EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.Pending;
        return session;
    };

    /**Sets up the basic properties of an EventStream for the placeholder loader.
    @param {PlaceholderLoadSession} session Context data about the placeholder load operation in progress.*/
    var setUpEventStream = function (session, callback)
    {
        //set the event state to be whatever the context was
        session.eventStream.eventState = session.placeholderArgs.context;

        //make a factory for creating the special event arguments for the partial loader.
        session.eventStream.processInjectedEventArgs = function (eventArgs)
        {
            var htmlArgs = new EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadEventArgs();
            htmlArgs.cancel = eventArgs.cancel;
            htmlArgs.pause = eventArgs.pause;
            htmlArgs.resume = eventArgs.resume;
            htmlArgs.stopPropagation = eventArgs.stopPropagation;
            htmlArgs.context = eventArgs.state;
            htmlArgs.key = eventArgs.key + ((eventArgs.stepType === EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent) ? ".global" : "");
            htmlArgs.placeholder = session.placeholder;

            return htmlArgs;
        };

        //set up the logic for handling the filtration of child members by the user
        session.eventStream.processReturnedEventArgs = function (htmlArgs, handlerResult, step)
        {
            if (step.key === EVUI.Modules.HtmlLoader.Constants.Event_OnBeforeLoadPlaceholderChildren)
            {
                session.selectedChildPlaceholders = getSelectedChildPlaceholders(session.allChildPlaceholders);
            }
        };

        //set up the final callback
        session.eventStream.onComplete = function ()
        {
            if (typeof callback === "function")
            {
                return callback(session.placeholder);
            }
        };

        session.eventStream.onError = function (errorArgs, error)
        {
            EVUI.Modules.Core.Utils.log(error.getErrorMessage());
        };
    };

    /**Adds the "OnBeforeLoad" events that give the user an opportunity to bail on the whole operation or modify the http args.
    @param {PlaceholderLoadSession} session Context data about the placeholder load operation in progress. */
    var addOnBeforeLoadEvents = function (session)
    {
        session.eventStream.addStep(
            {
                key: EVUI.Modules.HtmlLoader.Constants.Event_OnBeforePlaceholderLoad,
                name: "onBeforePlaceholderLoad",
                type: EVUI.Modules.EventStream.EventStreamStepType.Event,
                handler: function (eventArgs)
                {
                    if (typeof session.placeholderArgs.onBeforePlaceholderLoad === "function")
                    {
                        return session.placeholderArgs.onBeforePlaceholderLoad(eventArgs);
                    }
                }
            });

        session.eventStream.addStep(
            {
                key: EVUI.Modules.HtmlLoader.Constants.Event_OnBeforePlaceholderLoad,
                name: "onBeforePlaceholderLoad",
                type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
                handler: function (eventArgs)
                {
                    if (typeof _self.onBeforePlaceholderLoad === "function")
                    {
                        return _self.onBeforePlaceholderLoad(eventArgs);
                    }
                }
            });
    };

    /**Adds the "OnBeforeLoadChildren" events that give the user an opportunity to filter the list of child placeholders that will be loaded.
    @param {PlaceholderLoadSession} session Context data about the placeholder load operation in progress. */
    var addOnBeforeLoadChildrenEvents = function (session)
    {
        session.eventStream.addStep(
            {
                key: EVUI.Modules.HtmlLoader.Constants.Event_OnBeforeLoadPlaceholderChildren,
                name: "onBeforeLoadPlaceholderChildren",
                type: EVUI.Modules.EventStream.EventStreamStepType.Event,
                handler: function (eventArgs)
                {
                    if (typeof session.placeholderArgs.onBeforeLoadPlaceholderChildren === "function")
                    {
                        return session.placeholderArgs.onBeforeLoadPlaceholderChildren(eventArgs);
                    }
                }
            });

        session.eventStream.addStep(
            {
                key: EVUI.Modules.HtmlLoader.Constants.Event_OnBeforeLoadPlaceholderChildren,
                name: "onBeforeLoadPlaceholderChildren",
                type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
                handler: function (eventArgs)
                {
                    if (typeof _self.onBeforeLoadPlaceholderChildren === "function")
                    {
                        return _self.onBeforeLoadPlaceholderChildren(eventArgs);
                    }

                }
            });
    };

    /**Adds the "OnInject" events that give the user an opportunity to modify the document fragment before it is injected into it's parent.
    @param {PlaceholderLoadSession} session Context data about the placeholder load operation in progress. */
    var addOnInjectEvents = function (session)
    {
        session.eventStream.addStep(
            {
                key: EVUI.Modules.HtmlLoader.Constants.Event_OnPlaceholderInject,
                name: "onPlaceholderInject",
                type: EVUI.Modules.EventStream.EventStreamStepType.Event,
                handler: function (eventArgs)
                {
                    if (typeof session.placeholderArgs.onPlaceholderInject === "function")
                    {
                        return session.placeholderArgs.onPlaceholderInject(eventArgs);
                    }
                }
            });

        session.eventStream.addStep(
            {
                key: EVUI.Modules.HtmlLoader.Constants.Event_OnPlaceholderInject,
                name: "onPlaceholderInject",
                type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
                handler: function (eventArgs)
                {
                    if (typeof _self.onPlaceholderInject === "function")
                    {
                        return _self.onPlaceholderInject(eventArgs);
                    }
                }
            });
    };

    /**Adds the "OnPlaceholderLoaded" events that give the user an opportunity to inspect/react to the final loaded result in the session's parent.
    @param {PlaceholderLoadSession} session Context data about the placeholder load operation in progress. */
    var addOnPlaceholderLoadedEvents = function (session)
    {
        session.eventStream.addStep(
            {
                key: EVUI.Modules.HtmlLoader.Constants.Event_OnPlaceholderLoaded,
                name: "onPlaceholderLoaded",
                type: EVUI.Modules.EventStream.EventStreamStepType.Event,
                handler: function (eventArgs)
                {
                    if (typeof session.placeholderArgs.onPlaceholderLoaded === "function")
                    {
                        return session.placeholderArgs.onPlaceholderLoaded(eventArgs);
                    }
                }
            });

        session.eventStream.addStep(
            {
                key: EVUI.Modules.HtmlLoader.Constants.Event_OnPlaceholderLoaded,
                name: "onPlaceholderLoaded",
                type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
                handler: function (eventArgs)
                {
                    if (typeof _self.onPlaceholderLoaded === "function")
                    {
                        return _self.onPlaceholderLoaded(eventArgs);
                    }
                }
            });
    };

    /**Adds the "OnAllPlaceholderLoaded" events that fire once the highest parent session has completed loading and signals that the operation is complete.
    @param {PlaceholderLoadSession} session Context data about the placeholder load operation in progress. */
    var addOnAllPlaceholderLoadedEvents = function (session)
    {
        if (session.parentSession == null)
        {
            session.eventStream.addStep(
                {
                    key: EVUI.Modules.HtmlLoader.Constants.Event_OnAllPlaceholdersLoaded,
                    name: "onAllPlaceholdersLoaded",
                    type: EVUI.Modules.EventStream.EventStreamStepType.Event,
                    handler: function (eventArgs)
                    {
                        if (typeof session.placeholderArgs.onAllPlaceholdersLoaded === "function")
                        {
                            return session.placeholderArgs.onAllPlaceholdersLoaded(eventArgs);
                        }
                    }
                });

            session.eventStream.addStep(
                {
                    key: EVUI.Modules.HtmlLoader.Constants.Event_OnAllPlaceholdersLoaded,
                    name: "onAllPlaceholdersLoaded",
                    type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
                    handler: function (eventArgs)
                    {
                        if (typeof _self.onAllPlaceholdersLoaded === "function")
                        {
                            return _self.onAllPlaceholdersLoaded(eventArgs);
                        }
                    }
                });
        }
    }

    /**Builds the EventStream for the placeholder load operation and attaches all the settings, events, and jobs required to complete the operation.
    @param {PlaceholderLoadSession} session Context data about the placeholder load operation in progress. 
    @returns {EVUI.Modules.EventStream.EventStream}*/
    var buildEventStream = function (session, callback)
    {
        var eventStream = new EVUI.Modules.EventStream.EventStream();
        session.eventStream = eventStream;
        session.eventStream.context = session.placeholderArgs;

        //set basic event stream properties
        setUpEventStream(session, callback);

        addOnBeforeLoadEvents(session);

        //add the "get Html" step that invokes the HttpEventStream to perform the http operation.
        eventStream.addStep(
            {
                key: EVUI.Modules.HtmlLoader.Constants.Job_GetHtml,
                name: "GetHtml",
                type: EVUI.Modules.EventStream.EventStreamStepType.Job,
                handler: function (jobArgs)
                {
                    var placeholderAttrs = EVUI.Modules.Core.Utils.getElementAttributes(session.placeholderElement);
                    var loadState = placeholderAttrs.getValue(EVUI.Modules.HtmlLoader.Constants.Attr_ContentLoadState);

                    //check to make sure the load state isn't already "loaded" - only re-load it if ForceReload is true. Otherwise, just bail and go to the end of the event stream.
                    if (loadState != null && loadState.toLowerCase() === EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.Loaded && session.placeholderArgs.forceReload === false)
                    {
                        return jobArgs.cancel();
                    }

                    //get the URL off of the element. It doesn't actually have to be there and can be set/changed in the HttpEventStream's EventStream.
                    var url = placeholderAttrs.getValue(EVUI.Modules.HtmlLoader.Constants.Attr_ResourceUrl);

                    var htmlArgs = new EVUI.Modules.HtmlLoader.HtmlRequestArgs();
                    htmlArgs.url = url;
                    htmlArgs.httpArgs = session.placeholderArgs.httpArgs;

                    _self.loadHtml(htmlArgs, function (html)
                    {
                        if (html != null) //call worked, we got a string back
                        {
                            var docFrag = stringToDocFrag(html); //make  a document fragment out of the string
                            session.loadedFragment = docFrag;
                            session.html = html;
                            session.url = htmlArgs.url

                            if (session.placeholderArgs.recursive === true) //we're doing a recursive load, go get all the children flagged with a placeholder ID
                            {
                                session.allChildPlaceholders = getLoadableElements(docFrag, session.placeholderArgs.forceReload, session.placeholderArgs.ignoreOnDemand);
                                session.selectedChildPlaceholders = session.allChildPlaceholders.slice();
                            }
                            else //no recursion, just use empty arrays to make the event args generator happy
                            {
                                session.allChildPlaceholders = [];
                                session.selectedChildPlaceholders = [];
                            }
                        }

                        return jobArgs.resolve();
                    });
                }
            });

        addOnBeforeLoadChildrenEvents(session);

        //launches a volley of parallel event streams to go and load all the child placeholders of this placeholder. Remains in limbo until all the children are done.
        eventStream.addStep(
            {
                key: EVUI.Modules.HtmlLoader.Constants.Job_LoadChildren,
                name: "LoadChildren",
                type: EVUI.Modules.EventStream.EventStreamStepType.Job,
                handler: function (jobArgs)
                {
                    var numChildSessions = session.selectedChildPlaceholders.length;
                    if (numChildSessions === 0) //no children, just continue to the next step
                    {
                        return jobArgs.resolve();
                    }

                    var actualChildren = [];
                    var numLoaded = 0;

                    for (var x = 0; x < numChildSessions; x++)
                    {
                        var curChild = session.selectedChildPlaceholders[x];
                        var attrs = EVUI.Modules.Core.Utils.getElementAttributes(curChild);

                        var placeholderID = attrs.getValue(EVUI.Modules.HtmlLoader.Constants.Attr_PlaceholderID);
                        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(placeholderID) === true) continue; //no placeholder ID, should not load child (we could, but we wont.)

                        var childSession = makePlaceholderLoadSession(curChild, session.placeholderArgs, session, function (loadResult) //make a child session using this session's arguments
                        {
                            numLoaded++;
                            if (numLoaded === session.childSessions.length) //the loaded results and the number of queued sessions is the same, we're done. This stream can move on to the next step.
                            {
                                jobArgs.resolve();
                            }
                        });

                        if (childSession == null) continue; //for some reason the child session was not created (usually a validation failure)

                        actualChildren.push(curChild);

                        curChild.setAttribute(EVUI.Modules.HtmlLoader.Constants.Attr_ContentLoadState, EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.Loading);
                        session.loadState = EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.Loading;
                        childSession.eventStream.execute(); //kick off the child load process.
                    }

                    session.selectedChildPlaceholders = actualChildren;
                    if (actualChildren.length === 0) //no children were queued to be loaded, just continue to the next step.
                    {
                        return jobArgs.resolve();
                    }
                }
            });

        addOnInjectEvents(session);

        //inject the html into the placeholder element
        eventStream.addStep(
            {
                key: EVUI.Modules.HtmlLoader.Constants.Job_InjectHtml,
                name: "InjectHtml",
                type: EVUI.Modules.EventStream.EventStreamStepType.Job,
                handler: function (jobArgs)
                {
                    if (session.loadedFragment != null) //we have content, blow away old content and replace it with new content
                    {
                        var eh = new EVUI.Modules.Dom.DomHelper(session.placeholderElement);
                        eh.empty();

                        var injected = eh.append(session.loadedFragment);
                        session.loadedContent = injected.elements;

                        eh.attr(EVUI.Modules.HtmlLoader.Constants.Attr_ContentLoadState, EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.Loaded); //set the load state so this placeholder isn't loaded again
                        session.loadState = EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.Loaded;
                    }
                    else //no content, flag it as failed
                    {
                        session.placeholderElement.setAttribute(EVUI.Modules.HtmlLoader.Constants.Attr_ContentLoadState, EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.Failed);
                        session.loadState = EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.Failed;
                    }

                    jobArgs.resolve();
                }
            });

        addOnPlaceholderLoadedEvents(session);
        addOnAllPlaceholderLoadedEvents(session);

        return eventStream;
    };

    /**Parses a string into a document fragment.
    @param {String} str A string of HTML.  
    @returns {DocumentFragment} */
    var stringToDocFrag = function (str)
    {
        var div = document.createElement("div");
        div.innerHTML = str;

        var docFrag = document.createDocumentFragment();

        while (div.childNodes.length > 0)
        {
            var curChild = div.childNodes[0];
            docFrag.append(curChild);
        }

        return docFrag;
    };

    var ensureServices = function ()
    {
        if (_services == null || typeof _services !== "object")
        {
            _services = new EVUI.Modules.HtmlLoader.HtmlLoaderControllerServices();
        }

        if (_services.httpManager == null || typeof _services.httpManager !== "object")
        {
            Object.defineProperty(_services, "httpManager", {
                get: function ()
                {
                    return EVUI.Modules.Http.Http;
                },
                configurable: false,
                enumerable: true
            })
        }
    };

    /**Event that executes before the request to get HTML from the server has been sent and gives the opportunity to stop the operation before it begins.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadEventArgs} args: An instance of EVUI.Modules.HtmlLoaderController.HtmlPlaceholderLoadEventArgs describing the current load operation.*/
    this.onBeforePlaceholderLoad = function (args)
    {

    };

    /**Event that executes before the HTML returned from the server is injected into the DOM and gives the user the ability to manipulate the HTML while it is still in a document fragment.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadEventArgs} args: An instance of EVUI.Modules.HtmlLoaderController.HtmlPlaceholderLoadEventArgs describing the current load operation.*/
    this.onPlaceholderInject = function (args)
    {

    };

    /**Event that executes before any recursive child loads occur and gives the user the opportunity to edit the list of children being theoretically loaded.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadEventArgs} args: An instance of EVUI.Modules.HtmlLoaderController.HtmlPlaceholderLoadEventArgss describing the current load operation.*/
    this.onBeforeLoadPlaceholderChildren = function (args)
    {

    };

    /**Event that executes after the placeholder - and all of its children - have been injected and the load operation is complete.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadEventArgs} args: An instance of EVUI.Modules.HtmlLoaderController.HtmlPlaceholderLoadEventArgs describing the current load operation.*/
    this.onPlaceholderLoaded = function (args)
    {

    };

    /**Event that executes after all the placeholders have been loaded recursively.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadEventArgs} args: An instance of EVUI.Modules.HtmlLoaderController.HtmlPlaceholderLoadEventArgs describing the current load operation.*/
    this.onAllPlaceholdersLoaded = function (args)
    {

    };

    /**Represents the data about a HTML partial load session in progress.
    @class*/
    var PlaceholderLoadSession = function ()
    {
        /**The unique ID of this placeholder load session.
        @type {Number}*/
        this.id = _sessionIdCtr++;

        /**Object. The public placeholder object.
        @type {EVUI.Modules.HtmlLoader.HtmlPlaceholder}*/
        this.placeholder = null;

        /**Object. The session that initiated this session.
        @type {PlaceholderLoadSession}*/
        this.parentSession = null;

        /**Object. The arguments for loading the placeholder.
        @type {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs} */
        this.placeholderArgs = null;

        /**Object. The EventStream running the load operation.
        @type {EVUI.Modules.EventStream.EventStream}*/
        this.eventStream = null;

        /**Array. All the child placeholders to load.
        @type {PlaceholderLoadSession[]}*/
        this.childSessions = [];

        /**String. The Html that came back from the server.
        @type {String}*/
        this.html = null;

        /**String. The Url that was used to make the request.
        @type {String}*/
        this.url = null;

        /**Object. The document fragment that contains the loaded Html.
        @type {DocumentFragment}*/
        this.loadedFragment = null;

        /**Array. The content that was injected into the placeholder.
        @type {Element[]}*/
        this.loadedContent = null;

        /**Object. The Element that the placeholder will be injected into.
        @type {Element}*/
        this.placeholderElement = null;

        /**Array. All the Dom that had the PlaceholderID attribute on them contained within the original html load result.
        @type {Element[]}*/
        this.allChildPlaceholders = null;

        /**Array. Dom that the user decided to load.
        @type {Element[]}*/
        this.selectedChildPlaceholders = null;

        /**String. The PlaceholderID of the root placeholder being loaded.
        @type {String}*/
        this.placeholderID = null;

        /**String. The current state of the load operation.
        @type {String}*/
        this.loadState = null;
    };

    ensureServices();
};

/**Request arguments for requesting a string of HTML from a server. All requests are asynchronous GET requests with a responseType of "text" by default.
@class*/
EVUI.Modules.HtmlLoader.HtmlRequestArgs = function ()
{
    /**String. The Url to get the HTML from. 
    @type {String}*/
    this.url = null;

    /**Object. An instance of HttpRequestArgs containing any further configuration of the Http request.
    @type {EVUI.Modules.Http.HttpRequestArgs}*/
    this.httpArgs = new EVUI.Modules.Http.HttpRequestArgs();
};

/**Object for loading a HTML partial.
@class*/
EVUI.Modules.HtmlLoader.HtmlPartialLoadRequest = function (url, key)
{
    /**String. The Url to get the Html from.
    @type {String}*/
    this.url = (url == null) ? undefined : url;

    /**String. The Html that was returned from the server.
    @type {String}*/
    this.html = undefined;

    /**String. A string to use to look up this HtmlPartialLoadRequest after it has loaded.
    @type {String}*/
    this.key = (key == null) ? undefined : key;
};

/**Arguments for loading a set of Html partials. 
@class*/
EVUI.Modules.HtmlLoader.HtmlPartialLoadArgs = function ()
{
    var _partialLoadRequests = [];

    /**Array. An array of EVUI.Modules.HtmlLoaderController.HtmlPartialLoadRequest representing all the Html partials to get.
    @type {EVUI.Modules.HtmlLoader.HtmlPartialLoadRequest[]}*/
    this.htmlPartialLoadRequests = null;
    Object.defineProperty(this, "htmlPartialLoadRequests",
        {
            get: function () { return _partialLoadRequests; },
            set: function (value)
            {
                if (EVUI.Modules.Core.Utils.isArray(value) === false) throw new Error("HtmlPartialLoadRequests must be an array.");
                _partialLoadRequests = value;
            },
            configurable: false,
            enumerable: true
        });

    /**Object. An instance of HttpRequestArgs containing any further configuration of the Http requests.
    @type {EVUI.Modules.Http.HttpRequestArgs}*/
    this.httpArgs = new EVUI.Modules.Http.HttpRequestArgs();
};

/**EventArguements object for loading placeholders.
@class*/
EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadEventArgs = function ()
{
    /**Object. The HtmlPlaceholderLoadArgs being used to load placeholders.
    @type {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs}*/
    this.placeholder = null;

    /**Object. The context object for this event that gets passed between events. 
    @type {Any}*/
    this.context = null;

    /**Pauses the load/injection process indefinitely until Resume is called.
    @method Pause*/
    this.pause = function () { };
    /**Resumes a paused load/injection process.
    @method Resume*/
    this.resume = function () { };
    /**Cancels the load/injection process at its current state.
    @method Cancel*/
    this.cancel = function () { };
    /**Prevents any further events with the same key from being executed.
    @method StopPropagation*/
    this.stopPropagation = function () { };
};

/**Container object for all the settings that can effect the behavior of a HtmlLoaderController operation.
@class */
EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs = function ()
{
    var _contextNode = null;

    /**String. The ID of the root placeholder element to load.
    @type {String}*/
    this.placeholderID = null;

    /**Boolean. Whether or not to recursively load all placeholders under the root. True by default.
    @type {Boolean}*/
    this.recursive = true;

    /**Boolean. Whether or not to ignore the "onDemand" content setting, forcing all onDemand placeholders to be loaded automatically at once. False by default.
    @type {Boolean}*/
    this.ignoreOnDemand = false;

    /**Boolean. Force the reload and replacement of all content found under the ContextNode regardless of its content load state. False by default.
    @type {Boolean}*/
    this.forceReload = false;

    /**Object. An instance of HttpRequestArgs containing any further configuration of the Http request.
    @type {EVUI.Modules.Http.HttpRequestArgs}*/
    this.httpArgs = new EVUI.Modules.Http.HttpRequestArgs();

    /**Object. An Element to narrow the context of the load operation.
    @type {Element}*/
    this.contextElement = null;
    Object.defineProperty(this, "contextElement",
        {
            get: function () { return _contextNode; },
            set: function (value)
            {
                var newValue = EVUI.Modules.Core.Utils.getValidElement(value);
                if (newValue != null) value = newValue;

                if (value != null && EVUI.Modules.Core.Utils.isElement(value) === false && value instanceof Document === false && value instanceof DocumentFragment === false) throw new Error("contextElement must be derived from Element.");
                _contextNode = value;
            },
            configurable: false,
            enumerable: true
        });

    /**Event that executes before the request to get HTML from the server has been sent and gives the opportunity to stop the operation before it begins.
    les.HtmlLoaderController.HtmlPlaceholderLoadEventArgs} args: An instance of EVUI.Modules.HtmlLoaderController.HtmlPlaceholderLoadEventArgs describing the current load operation.*/
    this.onBeforePlaceholderLoad = function (args)
    {

    };

    /**Event that executes before any recursive child loads occur and gives the user the opportunity to edit the list of children being theoretically loaded.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadEventArgs} args: An instance of EVUI.Modules.HtmlLoaderController.HtmlPlaceholderLoadEventArgss describing the current load operation.*/
    this.onBeforeLoadPlaceholderChildren = function (args)
    {
    };

    /**Event that executes before the HTML returned from the server is injected into the DOM and gives the user the ability to manipulate the HTML while it is still in a document fragment.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadEventArgs} args: An instance of EVUI.Modules.HtmlLoaderController.HtmlPlaceholderLoadEventArgs describing the current load operation.*/
    this.onPlaceholderInject = function (args)
    {

    };

    /**Event that executes after the placeholder - and all of its children - have been injected into its parent and the load operation is complete.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadEventArgs} args: An instance of EVUI.Modules.HtmlLoaderController.HtmlPlaceholderLoadEventArgs describing the current load operation.*/
    this.onPlaceholderLoaded = function (args)
    {

    };

    /**Event that executes after all the placeholders have been loaded and injected into the DOM.
    @param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadEventArgs} args: An instance of EVUI.Modules.HtmlLoaderController.HtmlPlaceholderLoadEventArgs describing the current load operation.*/
    this.onAllPlaceholdersLoaded = function (args)
    {

    };
};

/**Object representing the return value of a HtmlPlaceholder load operation. 
 @class*/
EVUI.Modules.HtmlLoader.HtmlPlaceholder = function (session)
{
    if (session == null) throw new Error("Object expected.");
    var _session = session;
    var _content = null;
    var _children = null;

    /**String. The ID of the placeholder that was loaded.
    @type {String}*/
    this.placeholderID = null;
    Object.defineProperty(this, "placeholderID", {
        get: function ()
        {
            return _session.placeholderID;
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The Element containing the injected content.
    @type {Element}*/
    this.placeholderElement = null;
    Object.defineProperty(this, "placeholderElement", {
        get: function ()
        {
            return _session.placeholderElement;
        },
        configurable: false,
        enumerable: true
    });

    /**String. The raw Html returned from the server.
    @type {String}*/
    this.html = null;
    Object.defineProperty(this, "html", {
        get: function ()
        {
            return _session.html;
        },
        configurable: false,
        enumerable: true
    });

    /**String. The base url the request was made to.
    @type {String}*/
    this.url = null;
    Object.defineProperty(this, "url", {
        get: function ()
        {
            return _session.url;
        },
        configurable: false,
        enumerable: true
    });

    /**Object. If this was a recursive load, this will be the parent of the current placeholder if it is not the root placeholder.
    @type {EVUI.Modules.HtmlLoader.HtmlPlaceholder}*/
    this.parentPlaceholder = null;
    Object.defineProperty(this, "parentPlaceholder", {
        get: function ()
        {
            if (_session.parentSession != null)
            {
                return _session.parentSession.placeholder;
            }
            else
            {
                return null;
            }
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The Element that was injected into the Placeholder.
    @type {Node[]}*/
    this.loadedContent = null;
    Object.defineProperty(this, "loadedContent", {
        get: function ()
        {
            if (_content != null) return _content;
            if (_session.loadedContent != null && _session.loadedContent.length > 0)
            {
                _content = Object.freeze(_session.loadedContent.slice());
            }

            return _content;
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The instance of EVUI.Modules.HtmlLoaderController.HtmlPlaceholderLoadArgs used to load this placeholder.
    @type {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs}*/
    this.loadArgs = null;
    Object.defineProperty(this, "loadArgs", {
        get: function ()
        {
            return _session.placeholderArgs;
        },
        configurable: false,
        enumerable: true
    });

    /**Array. An array of EVUI.Modules.HtmlLoaderController.HtmlPlaceholderLoadResult representing the child placeholders loaded under this one.
    @type {EVUI.Modules.HtmlLoader.HtmlPlaceholder[]}*/
    this.children = null;
    Object.defineProperty(this, "children", {
        get: function ()
        {
            if (_children != null) return _children;
            if (_session.childSessions != null && _session.childSessions.length)
            {
                _children = _session.childSessions.slice();
                _children.sort(function (sessionA, sessionB) { return sessionA.id - sessionB.id });
                _children = _children.map(function (session) { return session.placeholder });
            }

            return _children;
        },
        configurable: false,
        enumerable: true
    });

    /**String. A value from HtmlPlaceholderLoadState indicating the completion state of the HtmlPlaceholder's load operation.
    @type {String}*/
    this.loadState = null;
    Object.defineProperty(this, "loadState", {
        get: function ()
        {
            return _session.loadState;
        },
        configurable: false,
        enumerable: true
    });
};

/**The result state value of the evui-loader-contentLoadState attribute on an element which was the parent to a placeholder that was loaded.
@enum*/
EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState =
{
    /**Placeholder will be loaded the next time it is requested.*/
    OnDemand: "ondemand",
    /**Placeholder has been loaded and will not be loaded again.*/
    Loaded: "loaded",
    /**Placeholder failed to load due to an error or Http error.*/
    Failed: "failed",
    /**Placeholder was the child of itself and created a circular reference.*/
    CircularReference: "circular",
    /*Placeholder has been slated for loading.*/
    Pending: "pending",
    /*Placeholder is in the process of being loaded.*/
    Loading: "loading"
};
Object.freeze(EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState);

/**Object to inject the standard dependencies used by the HtmlLoaderController into it via its constructor.
@class*/
EVUI.Modules.HtmlLoader.HtmlLoaderControllerServices = function ()
{
    /**Object. An instance of Http module's HttpManager object.
    @type {EVUI.Modules.Http.HttpManager}*/
    this.httpManager = null;
};

/**Global instance of a EVUI.Modules.HtmlLoaderController.HtmlLoaderController.
 @type {EVUI.Modules.HtmlLoader.HtmlLoaderController}*/
EVUI.Modules.HtmlLoader.Manager = null;
(function ()
{
    var loader = null;

    Object.defineProperty(EVUI.Modules.HtmlLoader, "Manager",
        {
            get: function ()
            {
                if (loader == null) loader = new EVUI.Modules.HtmlLoader.HtmlLoaderController();
                return loader;
            },
            configurable: false,
            enumerable: true
        });
})();

delete $evui.htmlLoader;

/**Global instance of the HtmlLoaderController, used to load fragments of Html or inject Html into placeholders in other Html.
@type {EVUI.Modules.HtmlLoader.HtmlLoaderController}*/
$evui.htmlLoader = null;
Object.defineProperty($evui, "htmlLoader",
    {
        get: function ()
        {
            return EVUI.Modules.HtmlLoader.Manager;
        },
        enumerable: true
    });

/**Makes a simple GET request to get Html. The request defaults to a GET with a response type of "text". If a different response type is used, the result is translated back into a string.
@param {EVUI.Modules.HtmlLoader.HtmlRequestArgs} htmlRequestArgsOrUrl The Url of the html or the arguments for getting the Html.
@param {EVUI.Modules.HtmlLoader.Constants.Fn_GetHtml_Callback} getHmlCallback  A function to call once the server has completed the request, takes the string version of whatever was returned as a parameter. */
$evui.loadHtml = function (htmlRequestArgsOrUrl, getHtmlCallback)
{
    return $evui.htmlLoader.loadHtml(htmlRequestArgsOrUrl, getHtmlCallback);
};

/**Awaitable. Makes a simple GET request to get html. The request defaults to a GET with a response type of "text". If a different response type is used, the result is translated back into a string.
@param {EVUI.Modules.HtmlLoader.HtmlRequestArgs} htmlRequestArgs  The Url of the html or the arguments for getting the Html.
@returns {Promise<String>}*/
$evui.loadHtmlAsync = function (htmlRequestArgsOrUrl)
{
    return $evui.htmlLoader.loadHtmlAsync(htmlRequestArgsOrUrl);
};

/**Loads an array of PartialLoadRequeusts either as a standalone array or as part of a HtmlPartalLoadArgs object.
@param {EVUI.Modules.HtmlLoader.HtmlPartialLoadArgs|EVUI.Modules.HtmlLoader.HtmlPartialLoadRequest[]} partialLoadArgsOrPartialRequests Either an array of HtmlPartialLoadRequests or a HtmlPartialLoadArgs object.
@param {EVUI.Modules.HtmlLoader.Constants.Fn_GetPartials_Callback} loadedCallback A callback that is fired once all the Html partials have been loaded.*/
$evui.loadHtmlPartials = function (partialLoadArgsOrPartialRequests, loadedCallback)
{
    return $evui.htmlLoader.loadAllPlacehoders(partialLoadArgsOrPartialRequests, loadedCallback);
};

/**Awaitable. Loads an array of PartialLoadRequeusts either as a standalone array or as part of a HtmlPartalLoadArgs object.
@param {EVUI.Modules.HtmlLoader.HtmlPartialLoadArgs|EVUI.Modules.HtmlLoader.HtmlPartialLoadRequest[]} partialLoadArgsOrPartialRequests Either an array of HtmlPartialLoadRequests or a HtmlPartialLoadArgs object.
@returns {Promise<EVUI.Modules.HtmlLoader.HtmlPartialLoadRequest[]>}.*/
$evui.loadHtmlPartialsAsync = function (partialLoadArgsOrPartialRequests)
{
    return $evui.htmlLoader.loadHtmlPartialsAsync(partialLoadArgsOrPartialRequests);
};

/**Loads a placeholder and all of its children and injects it into the DOM.
@param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs|String} placeholderIDOrArgs The value of a PlaceholderID attribute or a graph of HtmlPlaceholderLoadArgs.
@param {EVUI.Modules.HtmlLoader.Constants.Fn_GetPlaceholder_Callback} callback A callback function that is executed once the placeholder load operation is complete.*/
$evui.loadPlaceholder = function (placeholderIDOrArgs, callback)
{
    return $evui.htmlLoader.loadPlaceholder(placeholderIDOrArgs, callback);
};

/**Awaitable. Loads a placeholder and all of its children and injects them into the DOM.
@param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs|String} placeholderIDOrArgs The value of a EVUI.Modules.HtmlLoaderController.Constants.Attr_PlaceholderID attribute or a graph of HtmlPlaceholderLoadArgs.
@param {EVUI.Modules.HtmlLoader.Constants.Fn_GetPlaceholder_Callback} callback A callback function that is executed once the placeholder load operation is complete.
@returns {Promise<EVUI.Modules.HtmlLoader.HtmlPlaceholder>}*/
$evui.loadPlaceholderAsync = function (placeholderIDOrArgs)
{
    return $evui.htmlLoader.loadPlaceholderAsync(placeholderIDOrArgs);
};

/**Loads all placeholders currently in the document (elements with the EVUI.Modules.HtmlLoaderController.Constants.Attr_PlaceholderID attribute present with a non-empty string value) in parallel, but excludes those that are flagged as being loaded upon on demand.
@param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs} placehoderLoadArgs The arguments for loading all the placeholders currently in the document.
@param {EVUI.Modules.HtmlLoader.Constants.Fn_GetPlaceholder_Callback} callback A callback function that is called once all the placeholders in the document have been loaded and injected into the DOM.*/
$evui.loadAllPlaceholders = function (placehoderLoadArgs, callback)
{
    return $evui.htmlLoader.loadAllPlaceholders(placehoderLoadArgs, callback);
};

/**Awaitable. Loads all placeholders currently in the document (elements with the EVUI.Modules.HtmlLoaderController.Constants.Attr_PlaceholderID attribute present with a non-empty string value) in parallel, but excludes those that are flagged as being loaded upon on demand.
@param {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs} placehoderLoadArgs The arguments for loading all the placeholders currently in the document.
@returns {Promise<EVUI.Modules.HtmlLoader.HtmlPlaceholder>} callback A callback function that is called once all the placeholders in the document have been loaded and injected into the DOM.*/
$evui.loadAllPlaceholdersAsync = function (placehoderLoadArgs)
{
    return $evui.htmlLoader.loadAllPlaceholdersAsync(placehoderLoadArgs);
};

Object.freeze(EVUI.Modules.HtmlLoader);
/*#ENDWRAP(HtmlLoaderController)#*/


/********************************************************Http.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.Http|Http)#*/
/*#REPLACE(EVUI.Modules.Http|Http)#*/

/**Module for containing an EventStream driven Http interface.
@module*/
EVUI.Modules.Http = {};

/*#MODULEDEF(Http|"1.0";|"Http")#*/
/*#VERSIONCHECK(EVUI.Modules.Http|Http)#*/

EVUI.Modules.Http.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
    EventStream: Object.freeze({ version: "1.0", required: true }),
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.Http.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();


Object.freeze(EVUI.Modules.Http.Dependencies);

EVUI.Modules.Http.Constants = {};

/**
 * 
 * @param {EVUI.Modules.Http.CompletedHttpRequest} completedRequest
 */
EVUI.Modules.Http.Constants.Fn_HttpCallback = function (completedRequest) { }

EVUI.Modules.Http.Constants.Event_OnBeforeSend = "evui.http.beforesend";
EVUI.Modules.Http.Constants.Event_OnSuccess = "evui.http.success";
EVUI.Modules.Http.Constants.Event_OnError = "evui.http.error";
EVUI.Modules.Http.Constants.Event_OnComplete = "evui.http.complete";
EVUI.Modules.Http.Constants.Event_OnAllComplete = "evui.http.complete.all";

EVUI.Modules.Http.Constants.Job_OpenRequest = "evui.http.open";
EVUI.Modules.Http.Constants.Job_SendRequest = "evui.http.send";
EVUI.Modules.Http.Constants.Job_RequestComplete = "evui.http.request.complete";

/**Event handler for bubbling global events attached to the HttpManager.
@param {EVUI.Modules.Http.HttpEventArgs} httpEventArgs The event arguments for the event.*/
EVUI.Modules.Http.Constants.Fn_Event_Handler = function (httpEventArgs) { };

Object.freeze(EVUI.Modules.Http.Constants);

/** A utility class designed to abstract away making HTTP requests directly and expose a standard EventStream driven interface. Meant for internal use only.
@class*/
EVUI.Modules.Http.HttpManager = function ()
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Http.Dependencies);

    var _self = this; //self-reference for closures

    /**Internal array of all currently executing request instances.
    @type {RequestInstance[]} */
    var _requests = [];

    /**Internal array of all completed request instances since the last time the stack of requests was refreshed.
    @type {RequestInstance[]} */
    var _completedRequests = [];

    /**Bubbling event handler for collecting events with the same keys as the primary events in the handler.
    @type {EVUI.Modules.EventStream.BubblingEventManager}*/
    var _bubbler = new EVUI.Modules.EventStream.BubblingEventManager();

    /**Executes a HTTP request with the given arguments.
    @param {EVUI.Modules.Http.HttpRequestArgs} requestArgs A YOLO HttpRequestArgs that contains the information needed to run the Http request.
    @param {EVUI.Modules.Http.Constants.Fn_HttpCallback} callback A callback to call once the HTTP request completes.*/
    this.executeRequest = function (requestArgs, callback)
    {
        if (typeof callback !== "function") callback = function () { };

        var requestInstance = buildRequest(requestArgs);
        var completedRequest = null;
        requestInstance.eventStream.getPromiseResolutionValue = function ()
        {
            completedRequest = buildCompletedRequest(requestInstance);

            return completedRequest;
        };

        requestInstance.eventStream.executeAsync().then(function (completedRequest)
        {
            return callback(completedRequest);
        }).catch(function(ex)
        {
            return callback(completedRequest);
        });
    };

    /**Executes a HTTP request with the given arguments that it can be awaited.
    @param {EVUI.Modules.Http.HttpRequestArgs} requestArgs A YOLO HttpRequestArgs that contains the information needed to run the Http request.
    @returns {Promise<EVUI.Modules.Http.CompletedHttpRequest>}*/
    this.executeRequestAsync = function (requestArgs)
    {
        var requestInstance = buildRequest(requestArgs);
        requestInstance.eventStream.getPromiseResolutionValue = function ()
        {
            var completedRequest = buildCompletedRequest(requestInstance);

            return completedRequest;
        };

        return requestInstance.eventStream.executeAsync();
    };

    /**Builds the EventStream and RequestInstance required to run a HTTP request.
    @param {EVUI.Modules.Http.HttpRequestArgs} requestArgs An instance or graph pf EVUI.Modules.Http.HttpRequestArgs that contains the information needed to run the Http request.
    @returns {RequestInstance} */
    var buildRequest = function (requestArgs)
    {
        if (requestArgs == null) throw new Error("requestArgs cannot be null.");

        requestArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Http.HttpRequestArgs(), requestArgs);
        if (requestArgs.headers != null) requestArgs.headers = requestArgs.headers.map(function (header) { return EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Http.HttpRequestHeader(), header); });

        var requestInstance = buildRequestInstance(requestArgs);
        _requests.push(requestInstance);

        buildEventStream(requestInstance);
        return requestInstance;
    };

    /**Gets a copy of the internal array of all active HTTP requests.
    @returns {EVUI.Modules.Http.HttpRequestInstance[]}*/
    this.getAllActiveRequests = function ()
    {
        var copy = [];

        var numRequests = _requests.length;
        for (var x = 0; x < numRequests; x++)
        {
            copy.push(new EVUI.Modules.Http.HttpRequestInstance(_requests[x]));            
        }

        return copy;
    };

    /**Add an event listener to fire after an event with the same name has been executed.
    @param {String} eventName The name of the event in the EventStream to execute after.
    @param {EVUI.Modules.Http.Constants.Fn_Event_Handler} handler The function to fire.
    @param {EVUI.Modules.EventStream.EventStreamEventListenerOptions} options Options for configuring the event.
    @returns {EVUI.Modules.EventStream.EventStreamEventListener}*/
    this.addEventListener = function (eventName, handler, options)
    {
        return _bubbler.addEventListener(eventName, handler, options);
    };

    /**Removes an EventStreamEventListener based on its event name, its id, or its handling function.
    @param {String} eventNameOrId The name or ID of the event to remove.
    @param {Function} handler The handling function of the event to remove.
    @returns {Boolean}*/
    this.removeEventListener = function (eventNameOrId, handler)
    {
        return _bubbler.removeEventListener(eventNameOrId, handler);
    };

    /**Builds the internal RequestInstance object that manages the lifetime of the XMLHttpRequest. Sets up the EventStream's function and setting overrides.
    @param {EVUI.Modules.Http.HttpRequestArgs} requestArgs The request arguments for the request.
    @returns {RequestInstance} */
    var buildRequestInstance = function (requestArgs)
    {
        var entry = new RequestInstance();
        entry.eventStream = new EVUI.Modules.EventStream.EventStream();
        entry.eventStream.context = requestArgs;
        entry.httpRequestArgs = requestArgs;
        entry.requestID = EVUI.Modules.Core.Utils.makeGuid();
        entry.xmlHttpRequest = new XMLHttpRequest();
        entry.requestStatus = RequestStatus.NotStarted;

        entry.eventStream.canSeek = true; //we need to seek to fast forward to error handing events if something crashes
        entry.eventStream.endExecutionOnEventHandlerCrash = false; //user handler errors should never block execution of the event stream
        entry.eventStream.eventState = requestArgs.context == null ? {} : requestArgs.context; //set the internal state object to either be a blank object or whatever the user supplied
        entry.eventStream.bubblingEvents = _bubbler; //attach the bubbling events

        entry.eventStream.onError = function (args, error) //log any errors, but otherwise do nothing
        {
            entry.error = error;
            entry.requestStatus = RequestStatus.Exception;

            if (entry.xmlHttpRequest.readyState !== XMLHttpRequest.DONE)
            {
                entry.xmlHttpRequest.abort();
            }

            entry.eventStream.seek(EVUI.Modules.Http.Constants.Event_OnComplete);
        };

        entry.eventStream.processInjectedEventArgs = function (args) //build the HttpEventArgs object for each stage in the request.
        {
            var request = entry.httpRequestArgs;
            request.context = entry.eventStream.eventState;

            var xhr = null;
            if (args.key === EVUI.Modules.Http.Constants.Event_OnComplete) xhr = entry.xmlHttpRequest;
            if (args.key === EVUI.Modules.Http.Constants.Event_OnError) xhr = entry.xmlHttpRequest;
            if (args.key === EVUI.Modules.Http.Constants.Event_OnSuccess) xhr = entry.xmlHttpRequest;

            var error = (entry.requestStatus === RequestStatus.Exception || entry.requestStatus === RequestStatus.Failed || entry.requestStatus === RequestStatus.TimedOut) ? entry.error : null;

            var httpEventArgs = new EVUI.Modules.Http.HttpEventArgs(request, xhr, error, entry.response);
            httpEventArgs.key = args.key;
            httpEventArgs.stopPropagation = function () { args.stopPropagation(); };
            httpEventArgs.requestStatus = entry.requestStatus;

            httpEventArgs.cancel = function () //when the user 'cancels' the request, just fast forward to OnComplete.
            {
                if (entry.xmlHttpRequest.status !== XMLHttpRequest.DONE)
                {
                    entry.xmlHttpRequest.abort();
                    entry.requestStatus = RequestStatus.Canceled;
                }

                if (args.key !== EVUI.Modules.Http.Constants.Event_OnComplete && args.key !== EVUI.Modules.Http.Constants.Event_OnAllComplete)
                {
                    entry.eventStream.seek(EVUI.Modules.Http.Constants.Event_OnComplete);
                }
            };

            httpEventArgs.pause = function () { args.pause(); };
            httpEventArgs.resume = function () { args.resume(); };

            return httpEventArgs;
        };

        //make sure any changes or reassignments to the state object are remembered
        entry.eventStream.processReturnedEventArgs = function (args, result, currentStep, jobState, publicState)
        {
            entry.eventStream.eventState = args.context;
        };

        return entry;
    };

    /**Adds all the steps to the event stream needed for running the Http request.
    @param {RequestInstance} requestInstance The RequestInstance managing the request.*/
    var buildEventStream = function (requestInstance)
    {
        var es = requestInstance.eventStream;

        //set up local on before send event
        es.addStep({
            key: EVUI.Modules.Http.Constants.Event_OnBeforeSend,
            name: "onBeforeSend",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (httpEventArgs)
            {
                if (typeof requestInstance.httpRequestArgs.onBeforeSend === "function")
                {
                    return requestInstance.httpRequestArgs.onBeforeSend(httpEventArgs);
                }
            }
        });

        //set up the global on before send event
        es.addStep({
            key: EVUI.Modules.Http.Constants.Event_OnBeforeSend,
            name: "onBeforeSend",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (httpEventArgs)
            {
                if (typeof _self.onBeforeSend === "function")
                {
                    return _self.onBeforeSend(httpEventArgs);
                }
            }
        });

        //set up the job that opens and sets all the settings for the XMLHttpRequest
        es.addStep({
            key: EVUI.Modules.Http.Constants.Job_OpenRequest,
            name: "openRequest",
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            /**@param {EVUI.Resources.EventStreamJobArgs} jobArgs*/
            handler: function (jobArgs)
            {
                requestInstance.requestStatus = RequestStatus.Opened;

                var xhr = requestInstance.xmlHttpRequest;
                var requestArgs = requestInstance.httpRequestArgs;

                try
                {
                    //try and use the provided method and url to open the request
                    xhr.open(requestArgs.method, requestArgs.url, true);

                    //set the applicable settings
                    if (requestArgs.withCredentials === true) xhr.withCredentials = true;
                    if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(requestArgs.contentType) === false) xhr.setRequestHeader("Content-Type", requestArgs.contentType);
                    if (typeof requestArgs.timeout === "number" && requestArgs.timeout > 0) xhr.timeout = requestArgs.timeout;

                    //add all the headers
                    if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(requestArgs.headers) === true)
                    {
                        var numHeaders = requestArgs.headers.length;
                        for (var x = 0; x < numHeaders; x++)
                        {
                            //we make a case insensitive object because in case users do not use the correct casing.
                            var cio = new EVUI.Modules.Core.CaseInsensitiveObject(requestArgs.headers[x]);
                            var key = cio.getValue("Key");
                            var value = cio.getValue("Value");

                            if (typeof key !== "string" && typeof key !== "number") continue; //invalid key type
                            if (value != null && typeof value !== "string" && typeof value !== "number" && typeof value !== "boolean") continue; //value is an object or a function, which are invalid

                            xhr.setRequestHeader(key.toString(), value.toString());
                        }
                    }

                    if (typeof requestArgs.responseType === "string")
                    {
                        switch (requestArgs.responseType.toLowerCase())
                        {
                            case EVUI.Modules.Http.HttpResponseType.ArrayBuffer:
                                xhr.responseType = "arraybuffer";
                                break;
                            case EVUI.Modules.Http.HttpResponseType.Blob:
                                xhr.responseType = "blob";
                                break;
                            case EVUI.Modules.Http.HttpResponseType.HTML:
                            case EVUI.Modules.Http.HttpResponseType.XML:
                            case EVUI.Modules.Http.HttpResponseType.Document:
                                xhr.responseType = "document";
                                break;
                            case EVUI.Modules.Http.HttpResponseType.JSON:
                                xhr.responseType = "json";
                                break;
                            case EVUI.Modules.Http.HttpResponseType.Text:
                                xhr.responseType = "text";
                                break;
                            default:
                                xhr.responseType = requestArgs.responseType;
                        }
                    }
                }
                catch (ex) //something failed, fast-forward to the error events
                {
                    requestInstance.error = new EVUI.Modules.EventStream.EventStreamError("Failed to construct XMLHttpRequest.", ex, EVUI.Modules.EventStream.EventStreamStage.Job, EVUI.Modules.Http.Constants.Job_OpenRequest);
                    requestInstance.requestStatus = RequestStatus.Exception;
                    jobArgs.eventStream.seek(EVUI.Modules.Http.Constants.Event_OnError);
                    return jobArgs.resolve();
                }

                jobArgs.resolve();
            }
        });

        //set up the step where we launch the request
        es.addStep({
            key: EVUI.Modules.Http.Constants.Job_SendRequest,
            name: "sendRequest",
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            handler: function (jobArgs)
            {
                try
                {
                    var loaded = false;
                    var error = false;
                    var timeout = false;

                    requestInstance.xmlHttpRequest.addEventListener("load", function ()
                    {
                        var status = requestInstance.xmlHttpRequest.status;
                        loaded = true;

                        if ((status >= 200 && status < 300) || status === 304)
                        {
                            requestInstance.response = requestInstance.xmlHttpRequest.response;
                            jobArgs.resolve(); //continues to the "OnSuccess" events
                        }
                        else
                        {
                            requestInstance.response = requestInstance.xmlHttpRequest.response;
                            requestInstance.error = new EVUI.Modules.EventStream.EventStreamError("HTTP Error: Server Returned " + requestInstance.xmlHttpRequest.status, null, EVUI.Modules.EventStream.EventStreamStage.Job, EVUI.Modules.Http.Constants.Job_SendRequest);
                            requestInstance.requestStatus = RequestStatus.Failed;
                            jobArgs.eventStream.seek(EVUI.Modules.Http.Constants.Event_OnError);
                            jobArgs.resolve();
                        }
                    }, { once: true });

                    requestInstance.xmlHttpRequest.addEventListener("loadend", function ()
                    {
                        if (loaded === false && error === false && timeout === false)
                        {
                            requestInstance.response = requestInstance.xmlHttpRequest.response;
                            requestInstance.error = new EVUI.Modules.EventStream.EventStreamError("HTTP Error: An unknown error occurred.", null, EVUI.Modules.EventStream.EventStreamStage.Job, EVUI.Modules.Http.Constants.Job_SendRequest);
                            requestInstance.requestStatus = RequestStatus.Aborted;
                            
                            jobArgs.eventStream.seek(EVUI.Modules.Http.Constants.Event_OnComplete);
                            jobArgs.resolve();
                        }
                    }, { once: true });

                    requestInstance.xmlHttpRequest.addEventListener("timeout", function ()
                    {
                        timeout = true;
                        requestInstance.response = requestInstance.xmlHttpRequest.response;
                        requestInstance.error = new EVUI.Modules.EventStream.EventStreamError("HTTP Error: Request timed out after  " + requestInstance.xmlHttpRequest.timeout + " milliseconds.", null, EVUI.Modules.EventStream.EventStreamStage.Job, EVUI.Modules.Http.Constants.Job_SendRequest);
                        requestInstance.requestStatus = RequestStatus.TimedOut;
                        jobArgs.eventStream.seek(EVUI.Modules.Http.Constants.Event_OnError);
                        jobArgs.resolve();
                    }, { once: true });

                    requestInstance.xmlHttpRequest.addEventListener("error", function (args)
                    {
                        error = true;
                        requestInstance.response = requestInstance.xmlHttpRequest.response;
                        requestInstance.error = new EVUI.Modules.EventStream.EventStreamError("HTTP Error: An unknown error occurred.", null, EVUI.Modules.EventStream.EventStreamStage.Job, EVUI.Modules.Http.Constants.Job_SendRequest);
                        requestInstance.requestStatus = RequestStatus.Failed;
                        jobArgs.eventStream.seek(EVUI.Modules.Http.Constants.Event_OnError);
                        jobArgs.resolve();
                    }, { once: true });

                    if (requestInstance.httpRequestArgs.body == null)
                    {
                        requestInstance.xmlHttpRequest.send()
                    }
                    else
                    {
                        requestInstance.xmlHttpRequest.send(requestInstance.httpRequestArgs.body);
                    }
                }
                catch (ex)
                {
                    requestInstance.error = new EVUI.Modules.EventStream.EventStreamError("Failed to send XMLHttpRequest.", ex, EVUI.Modules.EventStream.EventStreamStage.Job, EVUI.Modules.Http.Constants.Job_SendRequest);
                    requestInstance.requestStatus = RequestStatus.Exception;
                    jobArgs.eventStream.seek(EVUI.Modules.Http.Constants.Event_OnError);
                    return jobArgs.resolve();
                }
            }
        });

        //local event for success
        es.addStep({
            key: EVUI.Modules.Http.Constants.Event_OnSuccess,
            name: "onSuccess",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (httpEventArgs)
            {
                if (typeof requestInstance.httpRequestArgs.onSuccess === "function")
                {
                    return requestInstance.httpRequestArgs.onSuccess(httpEventArgs);
                }
            }
        });

        //global event for success
        es.addStep({
            key: EVUI.Modules.Http.Constants.Event_OnSuccess,
            name: "onSuccess",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (httpEventArgs)
            {
                if (_self.onSuccess === "function")
                {
                    return _self.onSuccess(httpEventArgs);
                }
            }
        });

        //this "job" skips over the error handlers and goes straight to the on complete handlers
        es.addStep({
            key: EVUI.Modules.Http.Constants.Job_RequestComplete,
            name: "requestComplete",
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            handler: function (jobArgs)
            {
                requestInstance.eventStream.seek(EVUI.Modules.Http.Constants.Event_OnComplete);
                jobArgs.resolve();
            }
        });

        //local error handler
        es.addStep({
            key: EVUI.Modules.Http.Constants.Event_OnError,
            name: "onError",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (httpEventArgs)
            {
                if (typeof requestInstance.httpRequestArgs.onError === "function")
                {
                    return requestInstance.httpRequestArgs.onError(httpEventArgs);
                }
            }
        });

        //global error handler
        es.addStep({
            key: EVUI.Modules.Http.Constants.Event_OnError,
            name: "OnError",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (httpEventArgs)
            {
                if (typeof _self.onError === "function")
                {
                    return _self.onError(httpEventArgs);
                }
            }
        });

        //local complete handler
        es.addStep({
            key: EVUI.Modules.Http.Constants.Event_OnComplete,
            name: "OnComplete",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (httpEventArgs)
            {
                if (typeof requestInstance.httpRequestArgs.onComplete === "function")
                {
                    return requestInstance.httpRequestArgs.onComplete(httpEventArgs);
                }
            }
        });

        //global complete handler
        es.addStep({
            key: EVUI.Modules.Http.Constants.Event_OnComplete,
            name: "OnComplete",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (httpEventArgs)
            {
                if (typeof _self.onComplete === "function")
                {
                    return _self.onComplete(httpEventArgs);
                }
            }
        });

        es.addStep({
            key: EVUI.Modules.Http.Constants.Event_OnComplete,
            name: "onAllComplete",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function ()
            {
                return finishRequest(requestInstance);
            }
        });
    };

    /**Creates a CompletedHttpRequest object out of a RequestInstance.
    @param {RequestInstance} requestInstance The RequestInstance managing the lifetime of the HttpRequest.
    @returns {EVUI.Modules.Http.CompletedHttpRequest}*/
    var buildCompletedRequest = function (requestInstance)
    {
        var completedRequest = new EVUI.Modules.Http.CompletedHttpRequest(requestInstance.xmlHttpRequest);
        completedRequest.error = requestInstance.error;
        completedRequest.httpRequestArgs = requestInstance.httpRequestArgs;
        completedRequest.requestID = requestInstance.requestID;
        completedRequest.xmlHttpRequest = requestInstance.xmlHttpRequest;
        completedRequest.response = requestInstance.response;
        completedRequest.statusCode = requestInstance.xmlHttpRequest.status;
        completedRequest.requestStatus = requestInstance.requestStatus;

        return completedRequest;
    };

    /**Completes the request process and fires on OnAllComplete event if all pending Http requests have completed.
    @param {RequestInstance} requestInstance The RequestInstance managing the lifetime of the HttpRequest.*/
    var finishRequest = function (requestInstance)
    {
        var index = _requests.indexOf(requestInstance);
        if (index > -1) _requests.splice(index, 1);
        
        var numCompletedRequests = _completedRequests.push(requestInstance);
        
        if (_requests.length === 0)
        {
            var completedRequests = [];
            for (var x = 0; x < numCompletedRequests; x++)
            {
                var curComplete = _completedRequests[x];
                completedRequests.push(buildCompletedRequest(curComplete));
                _completedRequests.splice(x, 1);
                numCompletedRequests--;
                x--;
            }

            if (typeof _self.onAllComplete === "function")
            {
                return _self.onAllComplete(completedRequests);
            }
        }
    };

    /**Event that fires before any XMLHttpRequest is created, gives the opportunity to manipulate anything about the HttpRequestArgs. Return false to abort the operation.
    @param {EVUI.Modules.Http.HttpEventArgs} httpEventArgs The event arguments containing the data and options for the request.*/
    this.onBeforeSend = function (httpEventArgs)
    {

    };

    /**Event that fires when any XMLHttpRequest has returned with successful status code. The HttpRequestArgs are immutable beyond in this step, but the XMLHttpRequest is available in this step.
    @param {EVUI.Modules.Http.HttpEventArgs} httpEventArgs The event arguments containing the data and the XMLHttpRequest.*/
    this.onSuccess = function (httpEventArgs)
    {

    };

    /**Event that fires under one of two conditions: if any XMLHttpRequest returned something other than successful status code, or if there was an exception anywhere in any EventStream. If there
    was an exception, the Error property of the HttpEventArgs will be populated.
    @param {EVUI.Modules.Http.HttpEventArgs} httpEventArgs The event arguments containing the data and options for the XMLHttpRequest.*/
    this.onError = function (httpEventArgs)
    {

    };

    /**Event that fires whenever the request completes or is canceled. If the XMLHttpRequest returned something other than a 200 status code, or if there was an exception anywhere in the EventStream. If there
    was an exception, the Error property of the HttpEventArgs will be populated, otherwise the XMLHttpRequest is available for inspection.
    @param {EVUI.Modules.Http.HttpEventArgs} httpEventArgs The event arguments containing the data and options for the XMLHttpRequest.*/
    this.onComplete = function (httpEventArgs)
    {

    };

    /**Event that fires when all queued requests sent by this instance of HttpManager have completed.
    @param {EVUI.Modules.Http.CompletedHttpRequest[]} completedHttpRequests All the HTTP requests that have completed since the event was last fired.*/
    this.onAllComplete = function (completedRequests)
    {

    };

    /**A container for all the objects required to make a XMLHttpRequest. 
    @class*/
    var RequestInstance = function ()
    {
        /**String. The ID of the request. 
        @type {String}*/
        this.requestID = null;

        /**Object. The EventStream that is coordinating the execution of the XMLHttpRequest.
        @type {EVUI.Modules.EventStream.EventStream}*/
        this.eventStream = null;

        /**Object. The HttpRequestArgs that contain the information needed to run the request.
        @type {EVUI.Modules.Http.HttpRequestArgs}*/
        this.httpRequestArgs = null;

        /**Object. The XMLHttpRequest that is being executed.
        @type {XMLHttpRequest}*/
        this.xmlHttpRequest = null;

        /**Number. A value from RequestState indicating the state of the XMLHttpRequest.
        @type {Number}*/
        this.requestStatus = RequestStatus.NotStarted;

        /**Object. The error that occurred during the execution of the request.
        @type {EVUI.Modules.EventStream.EventStreamError}*/
        this.error = null;

        /**Any. The parsed response from the XMLHttpRequest.
        @type {Any}*/
        this.response = null;
    };

    /**Enum for describing the status of the request in progress.*/
    var RequestStatus = EVUI.Modules.Http.HttpRequestStatus;
};

/**Object for containing all the data needed to run a simple HTTP request.
@class*/
EVUI.Modules.Http.HttpRequestArgs = function ()
{
    var _url = null;
    var _method = null
    var _headers = [];
    var _contentType = null;
    var _withCredentials = false;
    var _responseType = null;
    var _timeout = null;

    /**String. The URL to make the request to.
     @type {String}*/
    this.url = null;
    Object.defineProperty(this, "url", {
        get: function () { return _url; },
        set: function (value)
        {
            if (value != null && typeof value !== "string") throw new Error("url must be a string.");
            _url = value;
        },
        configurable: false,
        enumerable: true
    });

    /**String. The HTTP verb to make with the request.
    @type {String}*/
    this.method = null;
    Object.defineProperty(this, "method", {
        get: function () { return _method; },
        set: function (value)
        {
            if (value != null && typeof value !== "string") throw new Error("method must be a string.");
            _method = value;
        },
        configurable: false,
        enumerable: true
    });

    /**Array. An array of EVUI.Modules.Http.HttpRequestHeader representing the headers to send along with the request.
    @type {EVUI.Modules.Http.HttpRequestHeader[]}*/
    this.headers = null;
    Object.defineProperty(this, "headers", {
        get: function () { return _headers; },
        set: function (value)
        {
            if (value != null && EVUI.Modules.Core.Utils.isArray(value) === false) throw new Error("headers must be an array.");
            _headers = value;
        },
        enumerable: true,
        configurable: false
    });

    /**Any. The body of the request to send to the server. This value is used as-is and must be compatible with the XMLHTTPReqeust's rules for valid message bodies.
    @type {Any}*/
    this.body = null;

    /**The mime type of the message body.
    @type {String}*/
    this.contentType = null;
    Object.defineProperty(this, "contentType", {
        get: function () { return _contentType },
        set: function (value)
        {
            if (value != null && typeof value !== "string") throw new Error("contentType must be a string.")
        },
        enumerable: true,
        configurable: false
    });

    /**Boolean. Whether or not cookies should be sent along for cross-domain requests.
    @type {Boolean}*/
    this.withCredentials = false;
    Object.defineProperty(this, "withCredentials", {
        get: function () { return _withCredentials; },
        set: function (value)
        {
            if (typeof value !== "boolean") throw new Error("withCredentials must be a boolean.");
            _withCredentials = value;
        },
        enumerable: true,
        configurable: false
    });

    /**String. The expected response type from the server. Must be a value from EVUI.Modules.Http.HttpResponseType.
    @type {String}*/
    this.responseType = null;
    Object.defineProperty(this, "responseType", {
            get: function () { return _responseType; },
            set: function (value)
            {
                if (value != null && typeof value !== "string") throw new Error("responseType must be a string.")
                _responseType = value;
            },
            enumerable: true,
            configurable: false
    });

    /**Number. The maximum amount of time the request can take before automatically failing.
    @type {Number}*/
    this.timeout = null;
    Object.defineProperty(this, "timeout", {
        get: function () { return _timeout; },
        set: function (value)
        {
            if (value != null && typeof value !== "number") throw new Error("timeout must be a number.");
            _timeout = value;
        },
        configurable: false
    });

    /**Any. Any additional information to carry along between steps in the HttpManager.
    @type {Any}*/
    this.context = null;

    /**Event that fires before the XMLHttpRequest is created, gives the opportunity to manipulate anything about the HttpRequestArgs.
    @param {EVUI.Modules.Http.HttpEventArgs} httpEventArgs The event arguments containing the data and options for the request.*/
    this.onBeforeSend = function (httpEventArgs)
    {

    };

    /**Event that fires when the XMLHttpRequest has returned with successful status code. The HttpRequestArgs are immutable beyond in this step, but the XMLHttpRequest is available in this step.
    @param {EVUI.Modules.Http.HttpEventArgs} httpEventArgs The event arguments containing the data and the XMLHttpRequest.*/
    this.onSuccess = function (httpEventArgs)
    {

    };

    /**Event that fires under one of two conditions: if the XMLHttpRequest returned something other than a successful status code, or if there was an exception anywhere in the EventStream. If there
    was an exception, the Error property of the HttpEventArgs will be populated.
    @param {EVUI.Modules.Http.HttpEventArgs} httpEventArgs The event arguments containing the data and options for the XMLHttpRequest.*/
    this.onError = function (httpEventArgs)
    {

    };

    /**Event that fires whenever the request completes or is canceled. If the XMLHttpRequest returned something other than a 200 status code, or if there was an exception anywhere in the EventStream. If there
    was an exception, the Error property of the HttpEventArgs will be populated.
    @param {EVUI.Modules.Http.HttpEventArgs} httpEventArgs The event arguments containing the data and options for the XMLHttpRequest.*/
    this.onComplete = function (httpEventArgs)
    {

    };
};

/**An object representing a key-value pair for a HTTP header.
@class*/
EVUI.Modules.Http.HttpRequestHeader = function (key, value)
{
    if (key != null && typeof key !== "string" && typeof key !== "number") throw new Error("HttpRequestHeader key must be a string or a number.");
    if (value != null && typeof value !== "string" && typeof value !== "number" && typeof key !== "boolean") throw new Error("HttpRequestHeader value must be a string, boolean, or a number.");

    var _key = key;
    var _value = value;

    /**String or Number. The name of the header. 
    @type {String|Number}*/
    this.key = null;
    Object.defineProperty(this, "key", {
        get: function () { return _key; },
        set: function (value)
        {
            if (value == null || (typeof key !== "string" && typeof key !== "number")) throw new Error("HttpRequestHeader key must be a string or a number.");
            _key = value;
        },
        enumerable: true,
        configurable: false
    });

    /**String, Boolean, or Number. The value of the header.
    @type {String|Number|Boolean}*/
    this.value = null;
    Object.defineProperty(this, "value", {
        get: function () { return _value; },
        set: function (value)
        {
            if (value == null || (typeof value !== "string" && typeof value !== "number" && typeof key !== "boolean")) throw new Error("HttpRequestHeader value must be a string, boolean, or a number.");
            _value = value;
        },
        enumerable: true,
        configurable: false
    });
};

/**Event arguments used by the HttpManager to coordinate the sending of HTTP requests.
@class*/
EVUI.Modules.Http.HttpEventArgs = function (request, xhr, error, response)
{
    if (request instanceof EVUI.Modules.Http.HttpRequestArgs == false) throw new Error("Request must be an instance of HttpRequestArgs");
    var _request = request;
    var _xhr = xhr;
    var _error = error;
    var _response = response;

    /**Object. The HttpRequestArgs that contain the mutable details of the request.
    @type {EVUI.Modules.Http.HttpRequestArgs}*/
    this.request = null;
    Object.defineProperty(this, "request", {
        get: function () { return _request; },
        configurable: false,
        enumerable: true
    });

    /**Object. The XMLHttpRequest that was executed and has completed.
    @type {XMLHttpRequest}*/
    this.xmlHttpRequest = null;
    Object.defineProperty(this, "xmlHttpRequest", {
        get: function () { return _xhr; },
        configurable: false,
        enumerable: true
    });

    /**Object. The EVUI.Modules.EventStream.EventStreamError that contain the details of the request.
    @type {EVUI.Modules.EventStream.EventStreamError}*/
    this.error = null;
    Object.defineProperty(this, "error", {
        get: function () { return _error; },
        configurable: false,
        enumerable: true
    });

    /**Any. In the event of a successful completion of the request, the ResponseType is used to interpret the response from the server and produce the final result of the request.
    @type {Any}*/
    this.response = null;
    Object.defineProperty(this, "response", {
        get: function () { return _response; },
        configurable: false,
        enumerable: true
    });

    /**Number. The Http status code of the request.
    @type {Number}*/
    this.statusCode = 0;
    Object.defineProperty(this, "statusCode", {
        get: function () { return _xhr == null ? 0 : _xhr.status; },
        configurable: false,
        enumerable: true
    });

    /**Boolean. Whether or not the status code was in the successful range.
    @type {Boolean}*/
    this.success = false;
    Object.defineProperty(this, "success", {
        get: function ()
        {
            if (_xhr == null) return false;
            return ((_xhr.status >= 200 && _xhr.status < 300) || _xhr.status === 304)
        },
        configurable: false,
        enumerable: true
    });

    /**Number. The current HttpRequestStatus of the request.
    @type {Number}*/
    this.requestStatus = EVUI.Modules.Http.HttpRequestStatus.NotStarted;

    /**String. The unique key current step in the EventStream.
    @type {String}*/
    this.key = null;

    /**Pauses the EventStream, preventing the next step from executing until Resume is called.*/
    this.pause = function () { };

    /**Resumes the EventStream, allowing it to continue to the next step.*/
    this.resume = function () { };

    /**Cancels the EventStream and aborts the execution of the XMLHttpRequest.*/
    this.cancel = function () { }

    /**Stops the EventStream from calling any other event handlers with the same key.*/
    this.stopPropagation = function () { };

    /**Object. Any state value to carry between events.
    @type {Object}*/
    this.context = {};
};

/**An object that contains all the information about a completed HTTP request. 
@class*/
EVUI.Modules.Http.CompletedHttpRequest = function (xhr)
{
    var _self = this;
    var _xhr = xhr;
    var _responseHeaders = null;

    /**String. The ID of the request. 
    @type {String}*/
    this.requestID = null;

    /**Boolean. Whether or not the status code was in the successful range.
    @type {Boolean}*/
    this.success = false;
    Object.defineProperty(this, "success", {
        get: function ()
        {
            return ((_self.statusCode >= 200 && _self.statusCode < 300) || _self.statusCode === 304);
        },
        configurable: false,
        enumerable: true
    });

    /**Any. The response from the server.
    @type {Any}*/
    this.response = null;

    /**Object. The HttpRequestArgs that contain the information needed to run the request.
    @type {EVUI.Modules.Http.HttpRequestArgs}*/
    this.httpRequestArgs = null;

    /**Object. The XMLHttpRequest that was executed.
    @type {XMLHttpRequest}*/
    this.xmlHttpRequest = null;
    Object.defineProperty(this, "xmlHttpRequest", {
        get: function ()
        {
            return _xhr;
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The error that occurred during the execution of the request if one occurred.
    @type {EVUI.Modules.EventStream.EventStreamError}*/
    this.error = null;

    /**Number. The HttpRequestStatus of the request when it finished.
    @type {Number}*/
    this.requestStatus = EVUI.Modules.Http.HttpRequestStatus.NotStarted;

    /**Number. The Http status code of the request.
    @type {Number}*/
    this.statusCode = 0;

    /**Array. An array of HttpRequestHeaders representing the headers that came back with the response.
    @type {EVUI.Modules.Http.HttpRequestHeader[]}*/
    this.responseHeaders = null;
    Object.defineProperty(this, "responseHeaders", {
        get: function ()
        {
            if (_responseHeaders != null) return _responseHeaders;
            if (_responseHeaders == null)
            {
                if (_xhr.readyState !== XMLHttpRequest.DONE) return null;
                _responseHeaders = [];

                var headerStr = _xhr.getAllResponseHeaders();
                if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(headerStr) === true) return _responseHeaders;

                var rawHeaders = headerStr.split(/\r\n/g);
                var numHeaders = rawHeaders.length;
                for (var x = 0; x < numHeaders; x++)
                {
                    var curHeader = rawHeaders[x];

                    var keyEnd = curHeader.indexOf(":");
                    if (keyEnd === -1) continue;

                    var key = curHeader.substring(0, keyEnd).trim();
                    var value = (keyEnd + 1 >= curHeader.length) ? "" : curHeader.substring(keyEnd + 1).trim();

                    var header = new EVUI.Modules.Http.HttpRequestHeader(key, value);
                    _responseHeaders.push(header);
                }

                return _responseHeaders;                
            }
        },
        configurable: false,
        enumerable: true
    })
};

/**An immutable copy of the internal object that represents an active XMLHTTPRequest.
@class*/
EVUI.Modules.Http.HttpRequestInstance = function (request)
{
    var _request = request;
    var requestArgs = EVUI.Utils.ShallowExtend(new EVUI.Modules.Http.HttpRequestArgs(), request.HttpRequestArgs);

    /**String. The ID of the request.
    @type {String}*/
    this.requestID = null;
    Object.defineProperty(this, "requestID",
        {
            get: function () { return _request.requestID },
            enumerable: true
        });

    /**Number. A value from the EVUI.Resources.EventStreamStatus enum indicating the status of the interal EventStream.
    @type {Number}*/
    this.eventStreamStatus = EVUI.Resources.EventStreamStatus.NotStarted;
    Object.defineProperty(this, "eventStreamStatus",
        {
            get: function () { return _request.eventStream.getStatus(); },
            enumerable: true
        });

    /**Object. The HttpRequestArgs that contain the information needed to run the request.
    @type {EVUI.Modules.Http.HttpRequestArgs}*/
    this.request = null;
    Object.defineProperty(this, "request",
        {
            get: function () { return requestArgs },
            enumerable: true
        });

    /**Object. The XMLHttpRequest that was executed.
    @type {XMLHttpRequest}*/
    this.xmlHttpRequest = null;
    Object.defineProperty(this, "xmlHttpRequest",
        {
            get: function () { return _request.xmlHttpRequest },
            enumerable: true
        });

    /**String. A value from the EVUI.Modules.Http.HttpRequestStatus enum.
    @type {Number}*/
    this.requestStatus = EVUI.Modules.Http.HttpRequestStatus.NotStarted;
    Object.defineProperty(this, "requestStatus",
        {
            get: function () { return _request.requestStatus },
            enumerable: true
        });

    /**Object. The error that occurred during the execution of the request.
    @type {EVUI.Modules.EventStream.EventStreamError}*/
    this.error = null;
    Object.defineProperty(this, "error",
        {
            get: function () { return _request.error },
            enumerable: true
        });

    /**Any. The parsed response from the XMLHttpRequest.
    @type {Any}*/
    this.response = null;
    Object.defineProperty(this, "response",
        {
            get: function () { return _request.response },
            enumerable: true
        });

    /**Forces a paused HTTP request to be resumed.
    @returns {Boolean}*/
    this.forceResume = function ()
    {
        if (_request.EventStream.getStatus() === EVUI.Resources.EventStreamStatus.Paused) return _request.eventStream.resume();
        return false;
    };
};

/**Enum for describing the status of the request in progress.
@enum*/
EVUI.Modules.Http.HttpRequestStatus =
{
    NotStarted: 0,
    Opened: 1,
    Sent: 2,
    Complete: 3,
    Canceled: 4,
    Failed: 5,
    Exception: 6,
    TimedOut: 7,
    Aborted: 8
};
Object.freeze(EVUI.Modules.Http.HttpRequestStatus);

/**Enum for describing the desired response from the server.
@enum*/
EVUI.Modules.Http.HttpResponseType =
{
    Unknown: "unknown",
    Blob: "blob",
    ArrayBuffer: "arraybuffer",
    XML: "xml",
    HTML: "html",
    Text: "text",
    JSON: "json",
    Document: "document"
};
Object.freeze(EVUI.Modules.Http.HttpResponseType);

/**Global instance of HttpManager, a utility used for making HTTP requests using a sequence of events.
@type {EVUI.Modules.Http.HttpManager}*/
EVUI.Modules.Http.Http = null;
(function ()
{
    var ctor = EVUI.Modules.Http.HttpManager;
    var http = null;

    Object.defineProperty(EVUI.Modules.Http, "Http",
    {
        get: function ()
        {
            if (http == null) http = new ctor();
            return http;
        },
        enumerable: true,
        configurable: false
    });
})();

delete $evui.httpEventStream;

/**The global instance of HttpManager, a utility used for making Http requests.
@type {EVUI.Modules.Http.HttpManager}*/
$evui.httpManager = null;
Object.defineProperty($evui, "httpManager",
{
    get: function ()
    {
        return EVUI.Modules.Http.Http;
    },
    enumerable: true
});

/**Executes an XMLHttpRequest using the HttpRequestArgs
@param {EVUI.Modules.Http.HttpRequestArgs} requestArgs An instance or graph of HttpRequestArgs that describe the type of XMLHttpRequest to make.
@param {EVUI.Modules.Http.Constants.Fn_HttpCallback} callback A callback to call once the HTTP request completes**/
$evui.http = function (requestArgs, callback)
{
    $evui.httpManager.executeRequest(requestArgs, callback);
};


/** Executes an XMLHttpRequest using HttpRequestArgs
@param {EVUI.Modules.Http.HttpRequestArgs} requestArgs An instance or graph of HttpRequestArgs that describe the type of XMLHttpRequest to make.
@returns {Promise<EVUI.Modules.Http.CompletedHttpRequest>} */
$evui.httpAsync = function (requestArgs)
{
    return $evui.httpManager.executeRequestAsync(requestArgs);
};

/*#ENDWRAP(Http)#*/


/********************************************************IFrames.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.IFrames|IFrames)#*/
/*#REPLACE(EVUI.Modules.IFrames|IFrames)#*/

/**Module containing utilities for managing cross-window communication with child iframes and/or when running as a child to another window.
@module*/
EVUI.Modules.IFrames = {};

/*#MODULEDEF(IFrames|"1.0";|"IFrames")#*/
/*#VERSIONCHECK(EVUI.Modules.IFrames|IFrames)#*/

EVUI.Modules.IFrames.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
    EventStream: Object.freeze({ version: "1.0", required: true }),
    Dom: Object.freeze({version: "1.0", required: true})
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.IFrames.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();

Object.freeze(EVUI.Modules.IFrames.Dependencies);

/**Constants table for the IFrames module.*/
EVUI.Modules.IFrames.Constants = {};

/**Selector function for getting a a child IFrame from the internal IFrame list. Return true to select the IFrame.
@param {EVUI.Modules.IFrames.IFrame} childIFrame The current IFrame.
@returns {Boolean}*/
EVUI.Modules.IFrames.Constants.Fn_IFrameSelector = function (childIFrame) { };

/**Callback method that will execute when an ask operation completes or times out.
@param {Any} message The data property of the message that was returned from the target window.*/
EVUI.Modules.IFrames.Constants.Fn_AskCallback = function (messageData) { };

/**Handler function for all iframe events.
@param {EVUI.Modules.IFrames.IFrameEventArgs} iframeEventArgs The event arguments describing the incoming or outgoing cross-window message.*/
EVUI.Modules.IFrames.Constants.Fn_IFrameEventHandler = function (iframeEventArgs) { };

/**ContextID for any dynamically created IFrame object being used in an IFrameEventArgs object that has not been added to the IFrameManager yet.
@type {String}*/
EVUI.Modules.IFrames.Constants.PlaceholderIFrameContextID = "evui.iframe.placeholder";

/**Event key for the event that fires when a message arrives in this Window.
@type {String}*/
EVUI.Modules.IFrames.Constants.Event_OnMessage = "evui.iframes.onmessage";

/**Event key for the event that fires when a message arrives in this Window and is handled by a named IFrameMessageListener.
@type {String}*/
EVUI.Modules.IFrames.Constants.Event_OnHandler = "evui.iframes.onhandler";

/**Event key for the event that fires when a message arrives in this Window in response to an ask operation.
@type {String}*/
EVUI.Modules.IFrames.Constants.Event_OnAsk = "evui.iframes.onask"

/**Event key for the event that fires when a message is sent from this Window to another.
@type {String}*/
EVUI.Modules.IFrames.Constants.Event_OnSend = "evui.iframes.onsend";

Object.freeze(EVUI.Modules.IFrames.Constants);

/**Manager for IFrame elements that coordinates the receiving and sending of messages between parent and child Windows.
@class*/
EVUI.Modules.IFrames.IFrameManager = function ()
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.IFrames.Dependencies);

    var _self = this; //self reference for closures

    var _signature = "evui.iframe.message"; //internal signature to help the manager recognize messages sent to or from itself in another window

    /**Object. The IFrameEntry of the parent Window that is hosting this Window.
    @type {IFrameEntry}*/
    var _parent = null;

    /**Boolean. Whether or not the messaging handler has been attached.
    @type {Boolean}*/
    var _handlerAttached = false;

    /**Array. The array of child IFrameEntries being managed by this one.
    @type {IFrameEntry[]}*/
    var _children = [];

    /**Number. The amount of time to wait before automatically calling the callback for an ask operation.
    @type {Number}*/
    var _defaultAskTimeout = 5000;

    /**Represents the union of all the objects required for the IFrameManager to manage parent and child Windows.
    @class*/
    var IFrameEntry = function ()
    {
        /**Object. The publicly visible IFrame object for the user to use.
        @type {EVUI.Modules.IFrames.IFrame}*/
        this.iFrame = null;

        /**Object. The internal container of functionality that the public IFrame object wraps.
        @type {IFrameHandle}*/
        this.handle = null;

        /**Array. Internal array of unresolved message sessions that are pending ask operations.
        @type {IFrameMessageSession[]}*/
        this.messageSessions = [];
    };

    /**The internal container of functionality that is injected into the publicly facing IFrame objects. Contains the state and entry points to all the functionality required to manage an IFrame.
    @class*/
    var IFrameHandle = function ()
    {
        var _self = this;
        var _url = null;
        var _origin = null;

        /**The type of Window that the IFrameHandle is associated with.
        @type {String}*/
        this.windowType = EVUI.Modules.IFrames.WindowType.None;

        /**A unique identifier for this Handle.
        @type {String}*/
        this.contextID = null;

        /**Either the parent Window or an iframe element.
        @type {Window|Element}*/
        this.element = null;

        /**An array of the message listeners attached to this IFrame.
        @type {EVUI.Modules.IFrames.IFrameMessageListener[]}*/
        this.messageHandlers = [];

        /**The origin of the URL associated with either the parent window or the iframe.
        @type {String}*/
        this.origin = null;
        Object.defineProperty(this, "origin",
        {
            get: function ()
            {
                if (_self.windowType === EVUI.Modules.IFrames.WindowType.Child)
                {
                    if (_origin == null || (_self.element != null && _self.element.src !== _url))
                    {
                        _origin = getOrigin(_self.element.src);
                        _url = _self.element.src;
                    }
                }

                return _origin;                
            },
            set: function (value)
            {
                _origin = value;
            }
        });

        /**The URL associated with either the parent window or the iframe.
        @type {String}*/
        this.url = null;
        Object.defineProperty(this, "url", {
            get: function ()
            {
                if (_self.windowType === EVUI.Modules.IFrames.WindowType.Child)
                {
                    if (_self.element != null && _self.element.src !== _url)
                    {
                        _origin = getOrigin(_self.element.src);
                        _url = _self.element.src;
                    }
                }

                return _url;
            },
            set: function (value)
            {
                _url = value;
            }
        });

        /**Event handler for when a message is sent to this child iframe or parent window.
        @param {EVUI.Modules.IFrames.IFrameEventArgs} iframeEventArgs The event arguments for the event.*/
        this.onSend = function (iframeEventArgs)
        {

        };

        /**Event handler for when a message is received by the current window from the child iframe or parent window.
        @param {EVUI.Modules.IFrames.IFrameEventArgs} iframeEventArgs The event arguments for the event.*/
        this.onMessage = function (iframeEventArgs)
        {

        };

        /**Sends a message to the child iframe or parent window associated with this handle.
        @param {Any} data Any information to send to the other window.
        @param {String|EVUI.Modules.IFrames.SendMessageArgs} messageCodeOrArgs Either the string identifier for the IFrameMessageListener in the other window to invoke, or a yolo object of a SendMessageArgs.
        @param {String} senderName The name of the sender, used for tracing purposes.
        @param {String} askSessionID If the operation is a response to an ask operation, this is the ID of the ask operation.*/
        this.send = function (data, messageCodeOrArgs, senderName, askSessionID)
        {
            send(this, data, messageCodeOrArgs, senderName, askSessionID);
        };

        /**Adds an IFrameMessageListener to the Handle that is invoked when an incoming message arrives with the matching message code.
        @param {String} messageCode The identifier to listen for.
        @param {EVUI.Modules.IFrames.Constants.Fn_IFrameEventHandler} handler The function to call when a message with the given message code arrives.*/
        this.addMessageHandler = function (messageCode, handler)
        {
            if (this.contextID === EVUI.Modules.IFrames.Constants.PlaceholderIFrameContextID) throw Error("Cannot add or remove message handlers to a placeholder IFrame entry.");
            addMessageHandler(this, messageCode, handler);
        };

        /**Removes an IFrameMessageListener from the Handle.
        @param {String} messageCode The identifier of the IFrameMessageListener to remove.
        @returns {Boolean}*/
        this.removeMessageHandler = function (messageCode)
        {
            if (this.contextID === EVUI.Modules.IFrames.Constants.PlaceholderIFrameContextID) throw Error("Cannot add or remove message handlers to a placeholder IFrame entry.");
            return removeMessageHandler(this, messageCode);
        };

        /**Sends a message to the child iframe or parent window that can be responded to directly that bypasses the normal message handlers and instead directly invokes the provided callback with whatever value the other window responded with.
        @param {Any} data Any information to send to the other window.
        @param {String|EVUI.Modules.IFrames.AskArgs} messageCodeOrArgs Either the string identifier for the IFrameMessageListener in the other window to invoke, or a yolo object of a AskArgs.
        @param {String} senderName The name of the sender, used for tracing purposes.
        @param {EVUI.Modules.IFrames.Constants.Fn_AskCallback} callback A callback to call once the other window responds.*/
        this.ask = function (data, messageCodeOrArgs, senderName, callback)
        {
            if (this.contextID === EVUI.Modules.IFrames.Constants.PlaceholderIFrameContextID) throw Error("Cannot ask from a placeholder IFrame entry.");
            ask(this, data, messageCodeOrArgs, senderName, callback);
        };

        /**Awaitable. Sends a message to the child iframe or parent window that can be responded to directly that bypasses the normal message handlers and instead directly invokes the provided callback with whatever value the other window responded with.
        @param {Any} data Any information to send to the other window.
        @param {String|EVUI.Modules.IFrames.AskArgs} messageCodeOrArgs Either the string identifier for the IFrameMessageListener in the other window to invoke, or a yolo object of a AskArgs.
        @param {String} senderName The name of the sender, used for tracing purposes.
        @returns {Promise<Any>}*/
        this.askAsync = function (data, messageCodeOrArgs, senderName)
        {
            if (this.contextID === EVUI.Modules.IFrames.Constants.PlaceholderIFrameContextID) throw Error("Cannot ask from a placeholder IFrame entry.");
            return askAsync(this, data, messageCodeOrArgs, senderName);
        };

        /**Removes the Handle from the IFrameManager.
        @returns {Boolean}*/
        this.remove = function ()
        {
            return remove(this);
        };
    };

    /**Represents a session of a message being sent to or received from another window.
    @class*/
    var IFrameMessageSession = function ()
    {
        /**String. The unique ID of this session.
        @type {String}*/
        this.sessionID = null;

        /**Object. The wrapper that will actually be sent across windows that contains the message and its metadata.
        @type {MessageWrapper}*/
        this.messageWapper = null;

        /**Object. The IFrameEntry that contains information about the window or iframe that is either sending or receiving the message.
        @type {IFrameEntry}*/
        this.entry = null;

        /**Object The EventStream that is executing the send or receive operation.
        @type {EVUI.Modules.EventStream.EventStream}*/
        this.eventStream = null;

        /**Object. If the operation is an ask operation, this is the arguments that was passed in with the ask operation.
        @type {EVUI.Modules.IFrames.AskArgs}*/
        this.askArgs = null;

        /**Function. The callback function associated with the ask operation.
        @type {EVUI.Modules.IFrames.Constants.Fn_AskCallback}*/
        this.askCallback = null;

        /**Boolean. Whether or not the ask callback has been fired.
        @type {Boolean}*/
        this.askCallbackFired = false;
    };

    /**The object that is actually sent to/received from another window, contains the metadata about the message as well as the payload of data sent by the user.
    @class*/
    var MessageWrapper = function ()
    {
        /**Object. Metadata about the message being sent.
        @type {MessageMetadata}*/
        this.metadata = null;

        /**Any. The data sent by the user.
        @type {Any}*/
        this.data = null;
    };

    /**Simple metadata about the message sent to/received from another window. 
    @class*/
    var MessageMetadata = function ()
    {
        /**String. A special signature property to help identify the message being received as a message sent by the IFrame manager and not by an exterior source.
        @type {String}*/
        this.signature = _signature;

        /**String. The unique ID of the message session that sent the message.
        @type {String}*/
        this.sessionID = null;

        /**String. The unique ID of the ask session to respond to if this message is part of an ask operation.
        @type {String}*/
        this.askSessionID = null;

        /**String. The message code of the handler to invoke upon receiving a message.
        @type {String}*/
        this.messageCode = null;

        /**String. The name of the sending entity to be used for tracing purposes.
        @type {String}*/
        this.senderName = null;
    };


    /**Object.If this window is the child of another window, this is the IFrame interface through which it can be interacted with - otherwise it is null.
    @type {EVUI.Modules.IFrames.IFrame}*/
    this.parentWindow = null;
    Object.defineProperty(this, "parentWindow", {
        get: function ()
        {
            if (_parent == null) return null;
            return _parent.iFrame;
        },
        enumerable: true,
        configurable: false
    });

    /**Number. The number of milliseconds to wait before automatically failing and calling the callback for an ask operation. Defaults to 5000.
    @type {Number}*/
    this.defaultAskTimeout = 5000;
    Object.defineProperty(this, "defaultAskTimeout", {
        get: function () { return _defaultAskTimeout; },
        set: function (value)
        {
            if (typeof value !== "number" || value < 0) throw Error("defaultAskTimeout must be a positive number.");
            _defaultAskTimeout = value
        },
        configurable: false,
        enumerable: true
    });

    /**Gets a child IFrame reference based off its contextID or match from a selector function.
    @param {String|EVUI.Modules.IFrames.Constants.Fn_IFrameSelector} contextIDOrSelector Either the contextID of the child IFrame or a selector function to return the first matching child IFrame.
    @returns {EVUI.Modules.IFrames.IFrame}*/
    this.getChild = function (contextIDOrSelector)
    {
        if (typeof contextIDOrSelector === "string")
        {
            var child = getChildIFrame(contextIDOrSelector);
            if (child == null) return null;

            return child;
        }
        else if (typeof contextIDOrSelector === "function")
        {
            var numChildren = _children.length;
            for (var x = 0; x < numChildren; x++)
            {
                var curChild = _children[x];
                if (contextIDOrSelector(curChild.iFrame) === true)
                {
                    return curChild.iFrame;
                } 
            }

            return null;
        }
        else
        {
            throw Error("Invalid input, string or function expected.");
        }
    };

    /**Gets a child IFrame reference based off of a selector function.
    @param {EVUI.Modules.IFrames.Constants.Fn_IFrameSelector} selector Either the contextID of the child IFrame or a selector function to return the first matching child IFrame.
    @returns {EVUI.Modules.IFrames.IFrame[]}*/
    this.getChildren = function (selector)
    {
        if (typeof selector === "function")
        {
            var children = [];
            var numChildren = _children.length;
            for (var x = 0; x < numChildren; x++)
            {
                var curChild = _children[x];
                if (selector(curChild.iFrame) === true)
                {
                    children.push(curChild.iFrame);
                }
            }

            return children;
        }
        else
        {
            return _children.map(function (c) { return c.iFrame; });
        }
    };

    /**Global event handler that fires any time the IFrameManager receives a message from another window. Only executes when the incoming message was sent from an origin known to the IFrameManager and was sent from another window's IFrameManager. Is not executed on Ask operations.
    @param {EVUI.Modules.IFrames.IFrameEventArgs} iframeEventArgs The event arguments for the iframe event.*/
    this.onMessage = function (iframeEventArgs)
    {

    };

    /**Global event handler that fires any time any message is sent to another window via one of the IFrameManager's managed IFrame entries.
    @param {EVUI.Modules.IFrames.IFrameEventArgs} iframeEventArgs The event arguments for the iframe event.*/
    this.onSend = function (iframeEventArgs)
    {

    };

    /**Adds a child iframe to the IFrameManager or registers the parent's URL/origin with the IFrameManager.
    @param {Element|String|EVUI.Modules.IFrames.ParentWindowAddRequest|EVUI.Modules.IFrames.IFrameAddRequest} addRequestOrIFrame Either an iframe Element, a CSS selector selecting iframe elements, a yolo ParentWindowAddRequest object, or a yolo IFrameAddRequest object.
    @returns {EVUI.Modules.IFrames.IFrame}*/
    this.addIFrame = function (addRequestOrIFrame)
    {
        var addRequest = new EVUI.Modules.IFrames.IFrameAddRequest();        

        if (isIframe(addRequestOrIFrame) === true) //registering a parent window or child iframe reference
        {
            addRequest.element = addRequestOrIFrame;
            addRequest.iframeType = EVUI.Modules.IFrames.WindowType.Child;
            addRequest.url = addRequestOrIFrame.src;
        }
        else //otherwise we have an object to extend into the add request
        {
            addRequest = EVUI.Modules.Core.Utils.shallowExtend(addRequest, addRequestOrIFrame);
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(addRequest.url) === false && _parent != null)
        {
            if (_parent.handle.url == null)
            {
                _parent.handle.url = addRequest.url;
                _parent.handle.origin = getOrigin(addRequest.url);
            }

            overwriteEvents(addRequest, _parent.iFrame);

            return _parent.iFrame;            
        }

        if (typeof addRequest.element === "string") //we have what is potentially a CSS selector 
        {
            var eh = new EVUI.Modules.Dom.DomHelper(addRequest.element);
            var iframes = eh.elements.filter(function (ele) { return isIframe(ele); });

            var numIframes = iframes.length;
            if (numIframes === 0) throw Error("Invalid arguments - no url or valid iframe element selector provided, no way to establish cross-window communication.");

            var returnValues = [];
            for (var x = 0; x < numIframes; x++)
            {
                var added = _self.addIFrame(iframes[x]);
                if (added != null) returnValues.push(added);
            }

            return returnValues;
        }
        else if (isIframe(addRequest.element) === false) //we didn't have a string or element, fail the operation
        {
            throw Error("Invalid arguments - no parent window or iframe element provided, no way to establish cross-window communication.");
        }

        //we have an element, see if we havent registered the element already 
        var existing = null;
        var numExisting = _children.length;
        for (var x = 0; x < numExisting; x++)
        {
            var curExisting = _children[x];
            if (curExisting.handle.element === addRequest.element)
            {
                existing = curExisting;
                break;
            }
        }

        if (existing != null) //we already have a handler for that element, just update the record with the provided events and return it
        {
            overwriteEvents(addRequest, existing.iFrame);
            return existing.iFrame;
        }

        //make, register, and return the new entry's IFrame
        var entry = new IFrameEntry();
        entry.handle = buildIFrameHandle(addRequest, EVUI.Modules.IFrames.WindowType.Child);
        entry.iFrame = new EVUI.Modules.IFrames.IFrame(entry.handle);

        overwriteEvents(addRequest, entry.iFrame);

        _children.push(entry);
        return entry.iFrame;
    };

    /**Creates an IFrameHandle that contains the injectable functionality for the IFrame object.
    @param {EVUI.Modules.IFrames.IFrameAddRequest} addRequest The IFrameAddRequest used as the basis for the handle.
    @returns {IFrameHandle}*/
    var buildIFrameHandle = function (addRequest, iframeType)
    {
        var handle = new IFrameHandle();
        handle.contextID = EVUI.Modules.Core.Utils.makeGuid();
        handle.element = addRequest.element;
        handle.url = isIframe(addRequest.element) === true ? addRequest.element.src : null;
        handle.windowType = iframeType;

        return handle;
    };

    /**Sends a message to another window.
    @param {IFrameHandle} handle The IFrameHandle of the window that will receive the message.
    @param {Any} data The data the user provided to send to the other window.
    @param {String|EVUI.Modules.IFrames.SendMessageArgs} messageCodeOrArgs Either the code of the handler to receive the message or the SendMessageArgs containing information about the send operation.
    @param {String} senderName The name of the sender to use for tracing purposes.
    @param {String} askSessionID If this is a response to an ask session, this is the ID of the ask to fulfill.*/
    var send = function (handle, data, messageCodeOrArgs, senderName, askSessionID)
    {
        var entry = getEntryFromHandle(handle);
        if (entry == null) makePlaceholderEntry(handle.element); //if we didn't find an entry for the iframe, we're sending from a placeholder, so we need to go make a new placeholder to complete the event arguments.

        var sendArgs = new EVUI.Modules.IFrames.SendMessageArgs();
        if (typeof messageCodeOrArgs === "object")
        {
            sendArgs = EVUI.Modules.Core.Utils.shallowExtend(sendArgs, messageCodeOrArgs);
        }
        else if (typeof messageCodeOrArgs === "string")
        {
            sendArgs.messageCode = messageCodeOrArgs;
        }

        sendArgs.senderName = senderName;

        //make the internal record of the send session that will be used to create the event stream to manage the lifetime of the send process
        var messageSession = new IFrameMessageSession();
        messageSession.sessionID = EVUI.Modules.Core.Utils.makeGuid();
        messageSession.entry = entry;
        messageSession.messageWapper = new MessageWrapper();
        messageSession.messageWapper.data = data;
        messageSession.messageWapper.metadata = new MessageMetadata();
        messageSession.messageWapper.metadata.askSessionID = askSessionID;
        messageSession.messageWapper.metadata.messageCode = sendArgs.messageCode;
        messageSession.messageWapper.metadata.sessionID = messageSession.sessionID;
        messageSession.messageWapper.metadata.senderName = sendArgs.senderName;

        handleOutgoingMessage(messageSession);
    };

    /**Adds a listener to call when a message arrives in this window with a specific message code.
    @param {IFrameHandle} handle The handle that will respond to the message code.
    @param {String} messageCode The string identifier that will be checked when a message arrives and used to match the message up with the proper handler.
    @param {EVUI.Modules.IFrames.Constants.Fn_IFrameEventHandler} handler The function to invoke when a message with the given messageCode arrives.*/
    var addMessageHandler = function (handle, messageCode, handler)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(messageCode) === true) throw Error("MessageCode must be a non-whitespace string.");
        if (typeof handler !== "function" && handler != null) throw Error("Handler must be a function.");

        var messageHandler = getMessageHandler(handle, messageCode);
        if (messageHandler != null) throw Error("IFrame already has a message handler for \"" + messageCode + "\".");

        var messageHandler = new EVUI.Modules.IFrames.IFrameMessageListener(messageCode, handler);
        handle.messageHandlers.push(messageHandler);
    };


    /**Removes a listener from the IFrameHandle.
    @param {IFrameHandle} handle The IFrameHandle to remove the listener from.
    @param {String} messageCode The message code of the listener to remove.
    @returns {Boolean}*/
    var removeMessageHandler = function (handle, messageCode)
    {
        var messageHandler = getMessageHandler(handle, messageCode);
        if (messageHandler == null) return false;

        var index = handle.messageHandlers.indexOf(messageHandler);
        if (index !== -1) handle.messageHandlers.splice(index, 1);

        true;
    };

    /**Sends a message to another window which has the option of responding to the call site of the ask directly.
    @param {IFrameHandle} handle The IFrameHandle of the window that will receive the message.
    @param {Any} data The data the user provided to send to the other window.
    @param {String|EVUI.Modules.IFrames.SendMessageArgs} messageCodeOrArgs Either the code of the handler to receive the message or the AskArgs containing information about the send operation.
    @param {String} senderName The name of the sender to use for tracing purposes.
    @param {EVUI.Modules.IFrames.Constants.Fn_AskCallback} callback The callback function to call when the ask operation returns from the other window.*/
    var ask = function (handle, data, messageCodeOrArgs, senderName, callback)
    {
        if (typeof callback !== "function")
        {
            if (typeof messageCodeOrArgs === "function") callback = messageCodeOrArgs;
            if (typeof senderName === "function") callback = senderName;
        }

        if (typeof callback !== "function") throw Error("Ask operation must have a callback.");

        var entry = getEntryFromHandle(handle);
        if (entry == null) throw Error("Cannot ask from unregistered iframe.");

        var askArgs = new EVUI.Modules.IFrames.AskArgs();
        if (typeof messageCodeOrArgs === "object")
        {
            askArgs = EVUI.Modules.Core.Utils.shallowExtend(askArgs, messageCodeOrArgs);
        }
        else if (typeof messageCodeOrArgs === "string")
        {
            askArgs.messageCode = messageCodeOrArgs;
        }

        askArgs.senderName = senderName;
        if (typeof askArgs.responseTimeout !== "number" || askArgs.responseTimeout < 0) askArgs.responseTimeout = _defaultAskTimeout;

        var messageSession = new IFrameMessageSession();
        messageSession.sessionID = EVUI.Modules.Core.Utils.makeGuid();
        messageSession.entry = entry;
        messageSession.askArgs = askArgs;
        messageSession.askCallback = callback;
        messageSession.messageWapper = new MessageWrapper();
        messageSession.messageWapper.data = data;
        messageSession.messageWapper.metadata = new MessageMetadata();
        messageSession.messageWapper.metadata.askSessionID = EVUI.Modules.Core.Utils.makeGuid();
        messageSession.messageWapper.metadata.messageCode = askArgs.messageCode;
        messageSession.messageWapper.metadata.sessionID = messageSession.sessionID;
        messageSession.messageWapper.metadata.senderName = askArgs.senderName;

        handleOutgoingMessage(messageSession);
    };

    /**Sends a message to another window which has the option of responding to the call site of the ask directly.
    @param {IFrameHandle} handle The IFrameHandle of the window that will receive the message.
    @param {Any} data The data the user provided to send to the other window.
    @param {String|EVUI.Modules.IFrames.SendMessageArgs} messageCodeOrArgs Either the code of the handler to receive the message or the AskArgs containing information about the send operation.
    @param {String} senderName The name of the sender to use for tracing purposes.
    @returns {Promise<Any>}*/
    var askAsync = function (handle, data, messageCodeOrArgs, senderName)
    {
        return new Promise(function (resolve, reject)
        {
            ask(handle, data, messageCodeOrArgs, senderName, function (answer)
            {
                resolve(answer);
            });
        });
    };

    /**Removes an IFrame from the manager.
    @param {IFrameHandle} handle
    @returns {Boolean}*/
    var remove = function (handle)
    {
        var numChildren = _children.length;
        for (var x = 0; x < numChildren; x++)
        {
            var curChild = _children[x];
            if (curChild.handle === handle)
            {
                _children.splice(x, 1);
                return true;
            }
        }

        return false;
    };

    /**Overwrites the event handlers on the IFrame.
    @param {EVUI.Modules.IFrame.IFrameAddRequest} addRequest The request to add (or in this case, modify) the IFrame record.
    @param {IFrameHandle} iFrame The handle of the IFrame whose events are being overwritten.*/
    var overwriteEvents = function (addRequest, iFrame)
    {
        if (typeof addRequest.onMessage === "function") iFrame.onMessage = addRequest.onMessage;
        if (typeof addRequest.onSend === "function") iFrame.onSend = addRequest.onSend;
    };

    /**Gets a child IFrameEntry based on its contextID.
    @param {String} contextID The ID of the child IFrame to get.
    @returns {IFrameEntry} */
    var getChildIFrame = function (contextID)
    {
        var numChildren = _children.length;
        for (var x = 0; x < numChildren; x++)
        {
            var curChild = _children[x];
            if (curChild.contextID === contextID) return curChild;
        }

        return null;
    };

    /**Gets the origin of an arbitrary URL. 
    @param {String} url The URL to get the origin from.
    @returns {String}*/
    var getOrigin = function (url)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(url) === true) return null;

        try
        {
            var aTag = document.createElement("a");
            aTag.href = url;

            return aTag.origin;
        }
        catch (ex)
        {
            return null;
        }
    };

    /**Hooks up the message handler for the IFrameManager to listen for incoming messages from other windows.
    @param {EVUI.Modules.IFrames} iframeModule The current iframe module, used to validate that this module has not been overwritten (in which case it won't fire).*/
    var hookUpMessageHandler = function (iframeModule)
    {
        if (_handlerAttached === true) return;
        _handlerAttached = true;

        if (parent !== window)
        {
            var addRequest = new EVUI.Modules.IFrames.IFrameAddRequest();
            addRequest.element = parent;
            addRequest.iframeType = EVUI.Modules.IFrames.WindowType.Parent;

            _parent = new IFrameEntry();
            _parent.handle = buildIFrameHandle(addRequest, EVUI.Modules.IFrames.WindowType.Parent);
            _parent.iFrame = new EVUI.Modules.IFrames.IFrame(_parent.handle);
        }

        //hook into the window's message event
        addEventListener("message", function (messageEvent)
        {
            if (messageEvent.origin == null || iframeModule.versionState === "overwritten") return; //first make sure we have an origin and that the module is still valid

            var incomingOrigin = messageEvent.origin;
            if (isOriginRegistered(incomingOrigin) === false) return; //not a whitelisted origin, don't process

            if (messageEvent.data == null || messageEvent.data.metadata == null || messageEvent.data.metadata.signature !== _signature) return; //not a eventui message, don't process

            var entry = getEntryFromContentWindow(messageEvent.source); //figure out which entry to use based on the WindowProxy object in the event args
            if (entry == null) //not a managed iframe
            {
                var incomingIFrame = getIFrameFromContentWindow(messageEvent.source); //go find the iframe element on the page that sent the message
                if (incomingIFrame == null) return; //cloudn't find it, bail

                if (EVUI.Modules.Core.Utils.isSettingTrue("autoAddIncomingIFrames") === true) //if we're auto-adding iframes, register the new iframe with the manager.
                {
                    var addResult = _self.addIFrame(targetIframe);
                    if (addResult == null) return; //adding failed, bail

                    entry = getEntryFromContentWindow(messageEvent.source); //go find the "real" object we just added and use it
                }

                if (entry == null) //if we STILL don't have an entry, make a dummy one just so the event arguments object we make later has everything it needs to work properly
                {
                    entry = makePlaceholderEntry(incomingIFrame);
                }
            }         

            //finally, build and launch an event stream to manage the receive process.
            handleIncomingMessageSession(messageEvent, entry);
        });
    };

    /**Handles an incoming message and build the EventStream related functionality.
    @param {MessageEvent} messageEvent The browser's event args for the message event.
    @param {IFrameEntry} iframeEntry The IFrame entry that sent the message.*/
    var handleIncomingMessageSession = function (messageEvent, iframeEntry)
    {
        var wrapper = new MessageWrapper();
        wrapper.metadata = new MessageMetadata();
        wrapper.metadata.sessionID = messageEvent.data.metadata.sessionID;
        wrapper.metadata.messageCode = messageEvent.data.metadata.messageCode;
        wrapper.metadata.askSessionID = messageEvent.data.metadata.askSessionID;
        wrapper.data = messageEvent.data.data;

        var messageSession = new IFrameMessageSession();
        messageSession.entry = iframeEntry;
        messageSession.sessionID = EVUI.Modules.Core.Utils.makeGuid();
        messageSession.messageWapper = wrapper;

        configureEventStream(messageSession, true);

        var es = messageSession.eventStream;

        var askSession = getAskSession(messageSession.entry, messageSession.messageWapper.metadata.askSessionID);
        if (askSession != null && askSession.askArgs != null && typeof askSession.askCallback === "function" && messageSession.askCallbackFired === false) //if we have an "unanswered" ask session, fire its callback and do nothing else.
        {
            askSession.askCallbackFired = true;

            es.addStep({
                type: EVUI.Modules.EventStream.EventStreamStepType.Event,
                key: EVUI.Modules.IFrames.Constants.Event_OnAsk,
                handler: function (eventArgs)
                {
                    return askSession.askCallback(eventArgs.message.data);
                }
            });
        }
        else //otherwise, use the normal even procession.
        {
            es.addStep({
                type: EVUI.Modules.EventStream.EventStreamStepType.Event,
                key: EVUI.Modules.IFrames.Constants.Event_OnMessage,
                handler: function (eventArgs)
                {
                    if (typeof iframeEntry.handle.onMessage === "function")
                    {
                        return iframeEntry.handle.onMessage(eventArgs);
                    }
                }
            });

            es.addStep({
                type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
                key: EVUI.Modules.IFrames.Constants.Event_OnMessage,
                handler: function (eventArgs)
                {
                    if (typeof _self.onMessage === "function")
                    {
                        return _self.onMessage(eventArgs);
                    }
                }
            });

            es.addStep({
                type: EVUI.Modules.EventStream.EventStreamStepType.Event,
                key: EVUI.Modules.IFrames.Constants.Event_OnHandler,
                handler: function (eventArgs)
                {
                    var handler = getMessageHandler(messageSession.entry.handle, messageSession.messageWapper.metadata.messageCode);
                    if (handler != null && typeof handler.handler === "function")
                    {
                        return handler.handler(eventArgs);
                    }
                }
            });
        }

        //kick off the process
        es.execute();
    };

    /**Creates the EventStream related functionality for sending a message to another window.
    @param {IFrameMessageSession} messageSession All the data we know about the message being sent.*/
    var handleOutgoingMessage = function (messageSession)
    {
        configureEventStream(messageSession);

        var es = messageSession.eventStream;

        es.addStep({
            key: EVUI.Modules.IFrames.Constants.Event_OnSend,
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (eventArgs)
            {
                if (typeof messageSession.entry.handle.onSend === "function")
                {
                    return messageSession.entry.handle.onSend(eventArgs);
                }
            }
        });

        es.addStep({
            key: EVUI.Modules.IFrames.Constants.Event_OnSend,
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (eventArgs)
            {
                if (typeof _self.onSend === "function")
                {
                    return _self.onSend(eventArgs);
                }
            }
        });

        es.addStep({
            key: "evui.iframes.send",
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            handler: function (jobArgs)
            {
                var target = null;

                if (messageSession.entry === _parent)
                {
                    if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(_parent.handle.origin) === true) return jobArgs.reject("Parent window origin unset.");
                    target = parent;
                }
                else
                {
                    if (messageSession.entry.handle.element.contentWindow != null) target = messageSession.entry.handle.element.contentWindow;
                }

                if (target != null)
                {
                    target.postMessage(messageSession.messageWapper, messageSession.entry.handle.origin);
                }
                else
                {
                    return jobArgs.reject("Could not resolve message target.");
                }

                jobArgs.resolve();
            }
        });

        if (messageSession.askArgs != null) //if we have an ask session, add a job that completes the callback on the timeout.
        {
            messageSession.entry.messageSessions.push(messageSession);

            es.addStep({
                key: "evui.iframes.asktimeout",
                type: EVUI.Modules.EventStream.EventStreamStepType.Job,
                handler: function (jobArgs)
                {
                    var finish = function (value)
                    {
                        var index = messageSession.entry.messageSessions.indexOf(messageSession);
                        if (index !== -1) messageSession.entry.messageSessions.splice(index, 1);

                        return (value instanceof Error) ? jobArgs.reject("Ask callback crashed.", value) : jobArgs.resolve(value);
                    };

                    setTimeout(function () //set the failsafe timeout
                    {
                        if (messageSession.askCallbackFired === false) //only if the callback has not yet fired
                        {
                            messageSession.askCallbackFired = true;

                            try
                            {
                                var result = messageSession.askCallback(undefined); //call the callback
                                if (EVUI.Modules.Core.Utils.isPromise(result) === true) //if it's a promise, handle the "then" and "catch" parts of the promise so the event stream finishes.
                                {
                                    result.then(function (value)
                                    {
                                        finish(value);
                                    }).catch(function (ex)
                                    {
                                        finish(ex);
                                    });
                                }
                                else //otherwise just finish
                                {
                                    finish(result);
                                }
                            }
                            catch (ex) //handler crashed, finish with the exception
                            {
                                finish(ex);
                            }
                        }
                        else //handler already fired, remove the message session from the callback stack
                        {
                            finish()
                        }

                    }, messageSession.askArgs.responseTimeout);
                }
            });
        }

        es.execute();
    };

    var traceOutgoingMessage = function (messageSession)
    {

    };

    var traceIncomingMessage = function (messageSession)
    {

    };


    /**Sets up the common properties of the EventStream for both sending and receiving messages.
    @param {IFrameMessageSession} messageSession Everything that is known about the incoming or outgoing message.
    @param {Boolean} receiving Whether or not we are receiving a message.*/
    var configureEventStream = function (messageSession, receiving)
    {
        var es = new EVUI.Modules.EventStream.EventStream();
        es.context = messageSession.entry.iFrame;

        es.processInjectedEventArgs = function (eventArgs)
        {
            var message = makeMessageFromWrapper(messageSession.messageWapper, messageSession.entry.handle.windowType);
            var iframeArgs = new EVUI.Modules.IFrames.IFrameEventArgs(messageSession.entry.iFrame, message);
            iframeArgs.cancel = eventArgs.cancel;
            iframeArgs.context = es.eventState;
            iframeArgs.key = eventArgs.key;
            iframeArgs.pause = eventArgs.pause;
            iframeArgs.resume = eventArgs.resume;
            iframeArgs.stopPropagation = eventArgs.stopPropagation;
            iframeArgs.respond = function (data, messageCodeOrArgs, senderName)
            {
                if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(messageSession.messageWapper.metadata.askSessionID) === false)
                {
                    messageSession.entry.handle.send(data, messageCodeOrArgs, senderName, messageSession.messageWapper.metadata.askSessionID);
                }
                else
                {
                    messageSession.entry.handle.send(data, messageCodeOrArgs, senderName);
                }
            };

            if (receiving !== true) delete iframeArgs.respond;

            return iframeArgs;
        };

        es.processReturnedEventArgs = function (iframeArgs)
        {
            es.eventState = iframeArgs.state;
        };

        es.canSeek = false;
        messageSession.eventStream = es;
    };

    /**Makes an IFrameMessage from an incoming MessageWrapper.
    @param {MessageWrapper} messageWrapper The incoming wrapper for the message.
    @param {String} senderType A value from the WindowType enum indicating if this message came from a child or a parent.
    @returns {EVUI.Modules.IFrames.IFrameMessage} */
    var makeMessageFromWrapper = function (messageWrapper, senderType)
    {
        var message = new EVUI.Modules.IFrames.IFrameMessage();
        message.messageSenderType = senderType;
        message.messageCode = messageWrapper.metadata.messageCode;
        message.data = messageWrapper.data;

        return message;
    };


    /**Determines whether an origin is registered with the IFrameManager or not.
    @param {String} origin The origin of the incoming iframe message.
    @returns {Boolean} */
    var isOriginRegistered = function (origin)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(origin) === true) return false;

        var lowerOrigin = origin.toLowerCase();
        if (lowerOrigin === location.origin.toLowerCase()) return true; //same origin, allow

        if (_parent != null)
        {
            if (_parent.handle.origin === lowerOrigin) return true; //parent origin, allow
        }

        var numChildren = _children.length;
        for (var x = 0; x < numChildren; x++)
        {
            if (_children[x].handle.origin === lowerOrigin) return true; //one of the registered child origins, allow
        }

        return false; //otherwise, don't allow
    };

    /**Walks the list of child iframes (and the parent window) to figure out which IFrameEntry has the matching WindowProxy for the given source.
    @param {Window|WindowProxy} messageSource The "source" property of the browser's message event args.
    @returns {iFrameEntry} */
    var getEntryFromContentWindow = function (messageSource)
    {
        if (_parent != null)
        {
            if (parent !== window && parent === messageSource) return _parent;
        }

        var numChildren = _children.length;
        for (var x = 0; x < numChildren; x++)
        {
            var curChild = _children[x];
            if (curChild.handle.element.contentWindow === messageSource) return curChild;
        }

        return null;
    };

    /**Gets all the iframe elements on the page and finds the one with the matching WindowProxy as the contentWindow.
    @param {WindowProxy} contentWindow
    @returns {Element} */
    var getIFrameFromContentWindow = function (contentWindow)
    {
        var iframes = new EVUI.Modules.Dom.DomHelper("iframe");
        var targetIframe = null;

        var numIframes = iframes.elements.length;
        for (var x = 0; x < numIframes; x++)
        {
            var curIFrame = iframes.elements[x];
            if (curIFrame.contentWindow === contentWindow)
            {
                targetIframe = curIFrame;
                break;
            }
        }

        return targetIframe;
    }

    /**Makes a dummy entry that has all the properties of a regular IFrameEntry, except it is not part of the managed collection of this IFrameManager.
    @param {Element} iframeElement The iframe element that the placeholder entry is being created for.
    @returns {IFrameEntry} */
    var makePlaceholderEntry = function (iframeElement)
    {
        var addRequest = new EVUI.Modules.IFrames.IFrameAddRequest();
        addRequest.element = iframeElement;

        var handler = buildIFrameHandle(addRequest, EVUI.Modules.IFrames.WindowType.Child);
        handler.contextID = EVUI.Modules.IFrames.Constants.PlaceholderIFrameContextID;

        var iframe = new EVUI.Modules.IFrames.IFrame(handler);
        var entry = new IFrameEntry();
        entry.handle = handler;
        entry.iFrame = iframe;

        return entry;
    };

    /**Determines whether or not an object is an iframe element.
    @param {Element} element The element to check.
    @returns {Boolean}*/
    var isIframe = function (element)
    {
        return (EVUI.Modules.Core.Utils.isElement(element) === true && element.tagName.toLowerCase() === "iframe");
    };

    /**Determines whether or not an object is this window's parent window.
    @param {Any} element The object to check.
    @returns {Boolean}*/
    var isParentWindow = function (element)
    {
        return (element instanceof Window && element === parent && parent !== window);
    };

    /**Gets the ask session with the matching ID.
    @param {IFrameEntry} entry The IFrameEntry that is receiving the message.
    @param {String} askSessionID The ID of the ask session.
    @returns {IFrameMessageSession} */
    var getAskSession = function (entry, askSessionID)
    {
        var numSessions = entry.messageSessions.length;
        for (var x = 0; x < numSessions; x++)
        {
            var curEntry = entry.messageSessions[x];
            if (curEntry.messageWapper.metadata.askSessionID === askSessionID) return curEntry;
        }

        return null;
    }

    /**Gets the message handler that matches the given message code.
    @param {IFrameHandle} handler The IFrameHandle that could contain the message handler to get.
    @param {String} messageCode The code of the message handler to get.
    @returns {EVUI.Modules.IFrames.IFrameMessageListener}*/
    var getMessageHandler = function (handler, messageCode)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(messageCode) === true) return null;

        var numHandlers = handler.messageHandlers.length;
        for (var x = 0; x < numHandlers; x++)
        {
            var curHandler = handler.messageHandlers[x];
            if (curHandler.messageCode === messageCode) return curHandler;
        }

        return null;
    };

    /**Gets an IFrameEntry based on the IFrameHandle passed in.
    @param {IFrameHandle} handle The IFrameHandle to get the matching entry for.
    @returns {IFrameEntry} */
    var getEntryFromHandle = function (handle)
    {
        if (handle === _parent.handle) return _parent;

        var numChildren = _children.length;
        for (var x = 0; x < numChildren; x++)
        {
            var curChild = _children[x];
            if (curChild.handle === handle) return curChild;
        }

        return null;
    };

    //hook up the message handler upon initialization
    hookUpMessageHandler(EVUI.Modules.IFrames);
};

/**Object containing data sent from another window.
@class*/
EVUI.Modules.IFrames.IFrameMessage = function ()
{
    this.messageSenderType = EVUI.Modules.IFrames.WindowType.None;
    this.messageCode = null;
    this.data = null;
};

/**Enum for tracking the type of window sent or received a message, or what type of window an IFrame object represents.*/
EVUI.Modules.IFrames.WindowType =
{
    None: "none",
    Parent: "parent",
    Child: "child"
};
Object.freeze(EVUI.Modules.IFrames.WindowType);

/**Object that represents either a parent or child window that is managed by the IFrameManager.
@class*/
EVUI.Modules.IFrames.IFrame = function (iframeHandle)
{
    if (iframeHandle == null) throw Error("Invalid Arguments: Missing IFrameHandle.");
    if (iframeHandle.element !== parent && (EVUI.Modules.Core.Utils.isElement(iframeHandle.element) === false && iframeHandle.element.tagName.toLowerCase() !== "iframe")) throw Error("Invalid Arguments: Invalid IFrameHandle.");

    var _handle = iframeHandle;

    /**String. Read only. A value from WindowType indicating the type of window this IFrame represents.
    @type {String}*/
    this.windowType = EVUI.Modules.IFrames.WindowType.None;
    Object.defineProperty(this, "windowType", {
        get: function ()
        {
            return _handle.windowType;
        },
        configurable: false,
        enumerable: true
    });

    /**String. Read only. The unique identifier for the iframe or parent window this object represents.
    @type {String}*/
    this.contextID = null;
    Object.defineProperty(this, "contextID", {
        get: function ()
        {
            return _handle.contextID;
        },
        configurable: false,
        enumerable: true
    });

    /**String. Read only. The origin of the iframe or parent window.
    @type {String}*/
    this.origin = null;
    Object.defineProperty(this, "origin", {
        get: function ()
        {
            return _handle.origin;
        },
        configurable: false,
        enumerable: true
    });

    /**Object. Read only. The iframe Element or the parent window of the current window.
    @type {Element|WindowProxy}*/
    this.element = null;
    Object.defineProperty(this, "element", {
        get: function ()
        {
            return _handle.element;
        },
        configurable: false,
        enumerable: true
    });

    /**String. Read only. The URL of the iframe or parent window.
    @type {String}*/
    this.url = null;
    Object.defineProperty(this, "url", {
        get: function ()
        {
            return _handle.url;
        },
        configurable: false,
        enumerable: true
    });

    /**Event handler that fires every time a message was sent from this iframe or parent window.
    @type {EVUI.Modules.IFrames.Constants.Fn_IFrameEventHandler}*/
    this.onMessage = null;
    Object.defineProperty(this, "onMessage", {
        get: function ()
        {
            return _handle.onMessage;
        },
        set: function (value)
        {
            _handle.onMessage = value;
        },
        configurable: false,
        enumerable: true
    });

    /**Event handler that fires every time a message is sent to this iframe or parent window.
    @type {EVUI.Modules.IFrames.Constants.Fn_IFrameEventHandler}*/
    this.onSend = null;
    Object.defineProperty(this, "onSend", {
        get: function ()
        {
            return _handle.onSend;
        },
        set: function (value)
        {
            _handle.onSend = value;
        },
        configurable: false,
        enumerable: true
    });

    /**Sends a message to the iframe or parent window.
    @param {Any} data Any data to send to the other window.
    @param {String|EVUI.Modules.IFrames.SendMessageArgs} messageCodeOrArgs Optional. Either a string indicating which message handler to call in the other window or a yolo SendMessageArgs object.
    @param {String} senderName Optional. A name to give the sender of the message. Used for tracing purposes.*/
    this.send = function (data, messageCodeOrArgs, senderName)
    {
        _handle.send(data, messageCodeOrArgs, senderName);
    };

    /**Adds a message handler to this IFrame that will be triggered when a message arrives with the matching messageCode.
    @param {String} messageCode The message code to listen for on an incoming message.
    @param {EVUI.Modules.IFrames.Constants.Fn_IFrameEventHandler} handler The function to call when a message is received with the matching message code.*/
    this.addMessageHandler = function (messageCode, handler)
    {
        _handle.addMessageHandler(messageCode, handler);
    };

    /**Removes a message handler with the matching messageCode.
    @param {String} messageCode The message code to remove the handler for.
    @returns {Boolean}*/
    this.removeMessageHandler = function (messageCode)
    {
        return _handle.removeMessageHandler(messageCode);
    };

    /**Gets the message handler with the given messageCode.
    @param {String} messageCode The message code of the handler to get.
    @returns {EVUI.Modules.IFrames.IFrameMessageListener} */
    this.getMessageHandler = function (messageCode)
    {
        var numHandlers = _handle.messageHandlers.length;
        for (var x = 0; x < numHandlers; x++)
        {
            var curHandler = _handle.messageHandlers[x];
            if (curHandler.messageCode === messageCode) return curHandler;
        }

        return null;
    };

    /**Gets a copy of the internal array of message handlers associated with this IFrame.
    @returns {[EVUI.Modules.IFrames.IFrameMessageListener]}*/
    this.getMessageHandlers = function ()
    {
        return _handle.messageHandlers.slice();
    };

    /**Sends a message to the iframe or parent window that can be responded to directly. The response will bypass the normal handling events and will be passed directly into the callback.
    @param {Any} data The data to send to the other window.
    @param {String|EVUI.Modules.IFrames.AskArgs} messageCodeOrArgs Optional. Either a string indicating which message handler to call in the other window or a yolo AskArgs object.
    @param {String} senderName Optional. A name to give the sender of the message. Used for tracing purposes.
    @param {EVUI.Modules.IFrames.Constants.Fn_AskCallback} callback A callback function to fire when the other window responds.*/
    this.ask = function (data, messageCodeOrArgs, senderName, callback)
    {
        _handle.ask(data, messageCodeOrArgs, senderName, callback);
    };

    /**Awaitable. Sends a message to the iframe or parent window that can be responded to directly. The response will bypass the normal handling events and will be passed directly into the callback.
    @param {Any} data The data to send to the other window.
    @param {String|EVUI.Modules.IFrames.AskArgs} messageCodeOrArgs Optional. Either a string indicating which message handler to call in the other window or a yolo AskArgs object.
    @param {String} senderName Optional. A name to give the sender of the message. Used for tracing purposes.
    @returns {Promise<Any>}*/
    this.askAsync = function (data, messageCodeOrArgs, senderName)
    {
        return _handle.askAsync(data, messageCodeOrArgs, senderName);
    };

    /**Removes the IFrame from the IFrameManager.
    @returns {Boolean}*/
    this.remove = function ()
    {
        return _handle.remove();
    };
};

/**The event arguments for when a message is sent or received.
@class*/
EVUI.Modules.IFrames.IFrameEventArgs = function (iframe, message)
{
    var _iframe = iframe;
    var _message = message;

    /**String. The unique key of this event.
    @type {String}*/
    this.key = null;

    /**Object. The window that sent the message.
    @type {EVUI.Modules.IFrames.IFrame}*/
    this.sendingIFrame = null;
    Object.defineProperty(this, "sendingIFrame", {
        get: function () { return _iframe },
        enumerable: true,
        configurable: false
    });

    /**Object. The message sent from another window.
    @type {EVUI.Modules.IFrames.IFrameMessage}*/
    this.message = null;
    Object.defineProperty(this, "message", {
        get: function () { return _message; },
        enumerable: true,
        configurable: false
    });

    /** */
    this.pause = function () { };
    this.resume = function () { };
    this.cancel = function () { };
    this.stopPropagation = function () { };
    this.respond = function (data, messageCodeOrArgs, senderName) { };
    this.context = {};
};

/**Arguments for adding an iframe or parent window to the iframe manager.
@class*/
EVUI.Modules.IFrames.IFrameAddRequest = function ()
{
    /**Element. The iframe element, parent window, or CSS selector of an iframe to add to the iframe manager.
    @type {Element|Window|String}*/
    this.element = null;

    /**Function. The event handler to call when a message arrives from the provided element or parent window.
    @type {EVUI.Modules.IFrames.Constants.Fn_IFrameEventHandler}*/
    this.onMessage = null;

    /**Function. The event handler to call when a message is sent to the provided element or parent window.
    @type {EVUI.Modules.IFrames.Constants.Fn_IFrameEventHandler}*/
    this.onSend = null;
};

/**Arguments for registering the parent window's domain to the iframe manager.
@class*/
EVUI.Modules.IFrames.ParentWindowAddRequest = function ()
{
    /**String. The URL of the parent window or iframe (if it does not have a valid src property set yet).
    @type {String}*/
    this.url = null;

    /**Function. The event handler to call when a message arrives from the provided element or parent window.
    @type {EVUI.Modules.IFrames.Constants.Fn_IFrameEventHandler}*/
    this.onMessage = null;

    /**Function. The event handler to call when a message is sent to the provided element or parent window.
    @type {EVUI.Modules.IFrames.Constants.Fn_IFrameEventHandler}*/
    this.onSend = null;
};

/**Additional arguments for sending a message to another window.
@class*/
EVUI.Modules.IFrames.SendMessageArgs = function ()
{
    /**String. The name of the event to trigger.
    @type {String}*/
    this.messageCode = null;

    /**String. An identifier to give the sender for tracing purposes.
    @type {String}*/
    this.senderName = null;
};

/**Additional arguments for sending a message to another window and waiting for a response.
@class*/
EVUI.Modules.IFrames.AskArgs = function ()
{
    /**String. The name of the event to trigger.
    @type {String}*/
    this.messageCode = null;

    /**String. An identifier to give the sender for tracing purposes.
    @type {String}*/
    this.senderName = null;

    /**Number. The number of milliseconds to wait before automatically failing the ask operation.
    @type {Number}*/
    this.responseTimeout = -1;
};

/**Represents an event listener that will be called when a message with the matching message code is received. 
@param {String} messageCode The message code to listen for.
@param {EVUI.Modules.IFrames.Constants.Fn_IFrameEventHandler} handler The function to fire when a message with the matching message code is received.
@class*/
EVUI.Modules.IFrames.IFrameMessageListener = function (messageCode, handler)
{
    var _messageCode = messageCode;
    var _handler = handler;

    /**String. The message code to listen for.
    @type {String}*/
    this.messageCode = null;
    Object.defineProperty(this, "messageCode", {
        get: function ()
        {
            return _messageCode;
        },
        configurable: false,
        enumerable: true
    });

    /**Function. The function to fire when a message with the matching message code is received.
    @type {EVUI.Modules.IFrames.Constants.Fn_IFrameEventHandler}*/
    this.handler = null;
    Object.defineProperty(this, "handler", {
        get: function ()
        {
            return _handler;
        },
        set: function (value)
        {
            if (value == null || typeof handler === "function")
            {
                _handler = value;
            }
            else
            {
                throw Error("Function expected.");
            }
        },
        enumerable: true,
        configurable: false
    });
};

/**Global instance of the IFrameManager.
@type {EVUI.Modules.IFrames.IFrameManager}*/
EVUI.Modules.IFrames.Manager = null;
(function ()
{
    var manager = null;
    Object.defineProperty(EVUI.Modules.IFrames, "Manager", {
        get: function ()
        {
            if (manager == null) manager = new EVUI.Modules.IFrames.IFrameManager();
            return manager;
        },
        configurable: false,
        enumerable: true
    });
})();


delete $evui.iframes;

/**Global instance of the IFrameManager.
@type {EVUI.Modules.IFrames.IFrameManager}*/
$evui.iframes = null;
Object.defineProperty($evui, "iframes", {
    get: function () { return EVUI.Modules.IFrames.Manager; },
    enumerable: true
});

/**Adds a child iframe to the IFrameManager or registers the parent's URL/origin with the IFrameManager.
@param {Element|String|EVUI.Modules.IFrames.ParentWindowAddRequest|EVUI.Modules.IFrames.IFrameAddRequest} addRequestOrIFrame Either an iframe Element, a CSS selector selecting iframe elements, a yolo ParentWindowAddRequest object, or a yolo IFrameAddRequest object.
@returns {EVUI.Modules.IFrames.IFrame}*/
$evui.addIFrame = function (addRequestOrIFrame)
{
    return $evui.iframes.addIFrame(addRequestOrIFrame);
};

Object.freeze(EVUI.Modules.IFrames);

/*#ENDWRAP(IFrames)#*/



/********************************************************Modals.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.Modal|Modal)#*/
/*#REPLACE(EVUI.Modules.Modal|Modal)#*/

/**Core module containing the Initialization and Utility functionality that is shared by all other modules.
@module*/
EVUI.Modules.Modals = {};

/*#MODULEDEF(Modal|"1.0";|"Modal")#*/
/*#VERSIONCHECK(EVUI.Modules.Modal|Modal)#*/

EVUI.Modules.Modals.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
    Panes: Object.freeze({ version: "1.0", required: true })
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.Modals.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();

Object.freeze(EVUI.Modules.Modals.Dependencies);

EVUI.Modules.Modals.Constants = {};

/**Function for selecting a PaneEntry object. Return true to select the PaneEntry parameter as part of the result set.
@param {EVUI.Modules.Modals.Modal} modal The PaneEntry providing metadata about a Modal object.
@returns {Boolean}*/
EVUI.Modules.Modals.Constants.Fn_ModalSelector = function (modal) { return true; }

/**Function for reporting whether or not a Modal was successfully Loaded.
@param {Boolean} success Whether or not the load operation completed successfully.*/
EVUI.Modules.Modals.Constants.Fn_LoadCallback = function (success) { };

/**Function for reporting whether or not an operation Modal was successful.
@param {Boolean} success Whether or not the operation completed successfully.*/
EVUI.Modules.Modals.Constants.Fn_ModalOperationCallback = function (success) { };

EVUI.Modules.Modals.Constants.CSS_Position = "evui-position";
EVUI.Modules.Modals.Constants.CSS_ClippedX = "evui-clipped-x";
EVUI.Modules.Modals.Constants.CSS_ClippedY = "evui-clipped-y";
EVUI.Modules.Modals.Constants.CSS_ScrollX = "evui-scroll-x";
EVUI.Modules.Modals.Constants.CSS_ScrollY = "evui-scroll-y"
EVUI.Modules.Modals.Constants.CSS_Transition_Show = "evui-transition-show";
EVUI.Modules.Modals.Constants.CSS_Transition_Hide = "evui-transition-hide";

/**String. The name of the ID attribute for the Modal, used to look up a definition of a Modal.
@type {String}*/
EVUI.Modules.Modals.Constants.Attribute_ID = "evui-m-id";

/**String. The name of the attribute that signifies which element should receive initial focus when the Modal is displayed.
@type {String}*/
EVUI.Modules.Modals.Constants.Attribute_Focus = "evui-m-focus";

/**String. The name of the attribute that signifies that a click event on the Element should close the Modal.
@type {String}*/
EVUI.Modules.Modals.Constants.Attribute_Close = "evui-m-close";

/**String. The name of the attribute on an element that triggers the showing of a Modal what the URL to get the Modal's HTML from is (Requires EVUI.Modules.Http).
@type {String}*/
EVUI.Modules.Modals.Constants.Attribute_SourceURL = "evui-m-src";

/**String. The name of the attribute on an element that triggers the showing of a Modal of what placeholder to load for the Modal's HTML (Requires EVUI.Modules.HtmlLoaderController).
@type {String}*/
EVUI.Modules.Modals.Constants.Attribute_PlaceholderID = "evui-m-placeholder-id";

/**String. The name of the attribute on an element that triggers the showing or hiding of a Modal whether or not the Modal should be unloaded when it is hidden.
@type {String}*/
EVUI.Modules.Modals.Constants.Attribute_UnloadOnHide = "evui-m-unload";

/**String. The name of the attribute on an element that triggers the showing or hiding of a Modal that is used to indicate special behavior as defined by a consumer of the Modal.
@type {String}*/
EVUI.Modules.Modals.Constants.Attribute_Context = "evui-m-cxt";

/**String. The name of the attribute on an element that triggers the showing of a Modal what CSS selector to use to find the element to show as the Modal. Only the first result will be used.
@type {String}*/
EVUI.Modules.Modals.Constants.Attribute_Selector = "evui-m-selector";

/**String. The name of the attribute on an element that triggers the showing of a Modal whether or not to center the modal on the screen.
@type {String}*/
EVUI.Modules.Modals.Constants.Attribute_Center = "evui-m-center";

/**String. The name of the attribute on an element that triggers the showing of a Modal whether or not to take up the entire screen.
@type {String}*/
EVUI.Modules.Modals.Constants.Attribute_Fullscreen = "evui-m-fullscreen";

/**String. The name of the attribute on an element that triggers the showing of a Modal whether or not to show a backdrop
@type {String}*/
EVUI.Modules.Modals.Constants.Attribute_Backdrop = "evui-m-show-backdrop";

EVUI.Modules.Modals.Constants.Default_ObjectName = "Modal";
EVUI.Modules.Modals.Constants.Default_ManagerName = "ModalManager";
EVUI.Modules.Modals.Constants.Default_CssPrefix = "evui-m";
EVUI.Modules.Modals.Constants.Default_EventNamePrefix = "evui.m";
EVUI.Modules.Modals.Constants.Default_AttributePrefix = "evui-m";

Object.freeze(EVUI.Modules.Modals.Constants);

/**Class for managing Modal object.
@class*/
EVUI.Modules.Modals.ModalManager = function (services)
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Modals.Dependencies);

    var _self = this; //self-reference for closures

    /**The internal PaneManager of the ModalManager.
    @type {EVUI.Modules.Panes.PaneManager}*/
    var _manager = null;

    /**The settings overrides for the ModalManager.
    @type {EVUI.Modules.Panes.PaneManagerSettings}*/
    var _settings = null;

    /**Adds a Modal to the WidowManager.
    @param {EVUI.Modules.Modals.Modal} modal A YOLO object representing a Modal object. This object is copied onto a real Modal object is then discarded.
    @returns {EVUI.Modules.Modals.Modal}*/
    this.addModal = function (modal)
    {
        if (modal == null) throw Error(_settings.objectName + " cannot be null.");
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(modal.id) === true) throw Error(_settings.objectName + "must have an id that is a non-whitespace string.");

        var existing = _settings.getPaneEntry(modal.id);
        if (existing != null) throw Error("A " + _settings.objectName + " with an id of \"" + modal.id + "\" already exists.");

        _manager.addPane(getDefaultPane(modal));

        existing = _settings.getPaneEntry(modal.id);
        return existing.wrapper;
    };

    /**Removes a Modal from the ModalManager. Does not unload the Modal's element from the DOM.
    @param {EVUI.Modules.Modals.Modal|String} modalOrID
    @returns {Boolean}*/
    this.removeModal = function (modalOrID)
    {
        return _manager.removePane(modalOrID);
    };

    /**Gets a ModalEntry object based on its ID or a selector function.
    @param {EVUI.Modules.Modals.Constants.Fn_ModalSelector|String} modalIDOrSelector A selector function to select a Modal object (or multiple ModalEntry objects) or the ID of the Modal to get the ModalEntry for.
    @param {Boolean} getAllMatches If a selector function is provided, all the ModalEntries that satisfy the selector are included. Otherwise a single ModalEntry object is returned. False by default.
    @returns {EVUI.Modules.Modals.Modal|EVUI.Modules.Modals.Modal[]} */
    this.getModal = function (modalIDOrSelector, getAllMatches)
    {
        var entries = null;

        if (typeof modalIDOrSelector === "function")
        {
            entries = _settings.getPaneEntry(function () { return true; }, true).map(function (entry) { return entry.wrapper; }).filter(modalIDOrSelector);
            if (getAllMatches !== true && entries != null) return entries[0];
            return entries;
        }
        else
        {
            entries = _settings.getPaneEntry(modalIDOrSelector, getAllMatches);
        }

        if (entries == null) return null;

        if (EVUI.Modules.Core.Utils.isArray(entries) === false)
        {
            return entries.wrapper;
        }
        else
        {
            return entries.map(function (entry) { return entry.wrapper; })
        }
    };

    /**Shows (and loads, if necessary or if a reload is requested) a Modal asynchronously. Provides a callback that is called once the Modal operation has completed successfully or otherwise.
    @param {EVUI.Modules.Modals.Modal|String} modalOrID Either a YOLO Modal object to extend into the existing Modal, the real Modal reference, or the string ID of the Modal to show.
    @param {EVUI.Modules.Modals.ModalShowArgs|EVUI.Modules.Modals.Constants.Fn_ModalOperationCallback} modalShowArgs Optional.  The arguments for showing the Modal, or the callback. If omitted or passed as a function, the Modal's existing show/load settings are used instead.
    @param {EVUI.Modules.Modals.Constants.Fn_ModalOperationCallback} callback Optional. A callback that is called once the operation completes.*/
    this.showModal = function (modalOrID, modalShowArgs, callback)
    {
        var entry = getModalAmbiguously(modalOrID, true);

        var paneShowArgs = new EVUI.Modules.Panes.PaneShowArgs();
        paneShowArgs.showSettings = _settings.cloneShowSettings(entry.pane.showSettings);
        paneShowArgs.loadArgs = new EVUI.Modules.Panes.PaneLoadArgs();
        paneShowArgs.loadArgs.loadSettings = _settings.cloneLoadSettings(entry.pane.loadSettings);

        if (typeof modalShowArgs === "function")
        {
            callback = modalShowArgs;
            modalShowArgs = null;
        }
        else if (modalShowArgs != null && typeof modalShowArgs === "object")
        {
            modalShowArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalShowArgs(paneShowArgs), modalShowArgs, ["type"]);
            if (modalShowArgs.showSettings != null)
            {
                modalShowArgs.showSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalShowSettings(paneShowArgs.showSettings), modalShowArgs.showSettings);
            }
            else
            {
                modalShowArgs.showSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalShowSettings(paneShowArgs.showSettings), entry.wrapper.showSettings);
            }


            if (modalShowArgs.loadArgs != null && modalShowArgs.loadArgs.loadSettings != null)
            {
                modalShowArgs.loadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalLoadArgs(paneShowArgs.loadArgs), modalShowArgs.loadArgs, ["type"]);
                modalShowArgs.loadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalLoadSettings(paneShowArgs.loadArgs.loadSettings), modalShowArgs.loadArgs.loadSettings);
            }
            else
            {
                modalShowArgs.loadArgs = new EVUI.Modules.Modals.ModalLoadArgs(paneShowArgs.loadArgs);
                modalShowArgs.loadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalLoadSettings(paneShowArgs.loadArgs.loadSettings), entry.wrapper.loadSettings, ["type"]);;
            }
        }
        else
        {
            modalShowArgs = null;
        }

        if (modalShowArgs == null)
        {
            modalShowArgs = new EVUI.Modules.Modals.ModalShowArgs(paneShowArgs);
            modalShowArgs.showSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalShowSettings(paneShowArgs.showSettings), entry.wrapper.showSettings);
            modalShowArgs.loadArgs = new EVUI.Modules.Modals.ModalLoadArgs(paneShowArgs.loadArgs);
            modalShowArgs.loadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalLoadSettings(paneShowArgs.loadArgs.loadSettings), entry.wrapper.loadSettings);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(modalShowArgs);

        _manager.showPane(entry.pane.id, paneShowArgs, callback);
    };

    /**Awaitable. (and loads, if necessary or if a reload is requested) a Modal asynchronously.
    @param {EVUI.Modules.Modals.Modal|String} modalOrID Either a YOLO Modal object to extend into the existing Modal, the real Modal reference, or the string ID of the Modal to show.
    @param {EVUI.Modules.Modals.ModalShowArgs} modalShowArgs Optional.  A YOLO object representing the arguments for showing the Modal. If omitted, the Modal's existing show/load settings are used instead.
    @returns {Promise<Boolean>}*/
    this.showModalAsync = function (modalOrID, modalShowArgs)
    {
        return new Promise(function (resolve)
        {
            _self.showModal(modalOrID, modalShowArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Hides (and unloads if requested) a Modal asynchronously. Provides a callback that is called call once the Modal operation has completed successfully or otherwise.
    @param {EVUI.Modules.Modals.Modal|String} modalOrID Either a YOLO Modal object to extend into the existing Modal, the real Modal reference, or the string ID of the Modal to hide.
    @param {EVUI.Modules.Modals.ModalHideArgs|EVUI.Modules.Modals.Constants.Fn_ModalOperationCallback} modalHideArgs Optional. A YOLO object representing arguments for hiding a Modal or a callback. If omitted or passed as a function, the Modal's existing hide/unload settings are used instead.
    @param {EVUI.Modules.Modals.Constants.Fn_ModalOperationCallback} callback Optional. A callback that is called once the operation completes.*/
    this.hideModal = function (modalOrID, modalHideArgs, callback)
    {
        var entry = getModalAmbiguously(modalOrID);

        var paneHideArgs = new EVUI.Modules.Panes.PaneHideArgs();
        paneHideArgs.unloadArgs = new EVUI.Modules.Panes.PaneUnloadArgs();

        if (typeof modalHideArgs === "function")
        {
            callback = modalHideArgs;
            modalHideArgs = null;
        }
        else if (modalHideArgs != null && typeof modalHideArgs === "object")
        {
            modalHideArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalHideArgs(paneHideArgs), modalHideArgs, ["type"]);
            modalHideArgs.unloadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalUnloadArgs(paneHideArgs.unloadArgs, modalHideArgs.unloadArgs));
        }
        else
        {
            modalHideArgs = null;
        }


        if (modalHideArgs == null)
        {
            modalHideArgs = new EVUI.Modules.Modals.ModalHideArgs(paneHideArgs);
            modalHideArgs.unloadArgs = new EVUI.Modules.Modals.ModalUnloadArgs(paneHideArgs.unloadArgs);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(modalHideArgs);
        _manager.hidePane(entry.pane.id, paneHideArgs, callback);
    };

    /**Awaitable. Hides (and unloads if requested) a Modal asynchronously.
    @param {EVUI.Modules.Modals.Modal|String} modalOrID Either a YOLO Modal object to extend into the existing Modal, the real Modal reference, or the string ID of the Modal to hide.
    @param {EVUI.Modules.Modals.ModalHideArgs} modalHideArgs Optional. A YOLO object representing the arguments for hiding a Modal. If omitted, the Modal's existing hide/unload settings are used instead.
    @returns {Promise<Boolean>}*/
    this.hideModalAsync = function (modalOrID, modalHideArgs)
    {
        return new Promise(function (resolve)
        {
            _self.hideModal(modalOrID, modalHideArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Hides all visible Modals asynchronously. Provides a callback function that is called once all the visible Modals have been hidden.
    @param {EVUI.Modules.Panes.ModalHideArgs} modalHideArgs Optional. A YOLO object representing the arguments for hiding a Modal. If omitted, the Modal's existing hide/unload settings are used instead.
    @param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback The callback that is called once all the Modal's hide operations have completed.*/
    this.hideAllModals = function (modalHideArgs, callback)
    {
        if (typeof callback !== "function") callback = function () { };
        var allVisible = this.getModal(function (dd) { return dd.isVisible; });
        var numVisible = allVisible.length;
        var numHidden = 0;

        if (numVisible === 0) return callback(true);

        for (var x = 0; x < numVisible; x++)
        {
            this.hideModal(allVisible[x], modalHideArgs, function ()
            {
                numHidden++;
                if (numHidden === numVisible)
                {
                    return callback(true);
                }
            });
        }
    };

    /**Awaitable. Hides all Modals asynchronously.
    @param {EVUI.Modules.Panes.PaneHideArgs} paneHideArgs Optional. A YOLO object representing the arguments for hiding a Modal. If omitted, the Modal's existing hide/unload settings are used instead.
    @returns {Promise<Boolean>} */
    this.hideAllModalsAsync = function (paneHideArgs)
    {
        return new Promise(function (resolve)
        {
            _self.hideAllModals(paneHideArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Asynchronously loads a Modal. Provides a callback that is called after the operation has completed successfully or otherwise.
    @param {EVUI.Modules.Modals.Modal|String} modalOrID Either a YOLO Modal object to extend into the existing Modal, the real Modal reference, or the string ID of the Modal to load.
    @param {EVUI.Modules.Modals.ModalLoadArgs|EVUI.Modules.Modals.Constants.Fn_ModalOperationCallback} modalLoadArgs Optional. A YOLO object representing arguments for loading a Modal or a callback. If omitted or passed as a function, the Modal's existing load settings are used instead.
    @param {EVUI.Modules.Modals.Constants.Fn_ModalOperationCallback} callback Optional. A callback to call once the operation completes.*/
    this.loadModal = function (modalOrID, modalLoadArgs, callback)
    {
        var entry = getModalAmbiguously(modalOrID, false);

        var paneLoadArgs = new EVUI.Modules.Panes.PaneLoadArgs();
        paneLoadArgs.loadSettings = _settings.cloneLoadSettings(entry.pane.loadSettings);

        if (typeof modalLoadArgs === "function")
        {
            callback = modalLoadArgs;
            modalLoadArgs = null;
        }
        else if (modalLoadArgs != null && typeof modalLoadArgs === "object")
        {
            modalLoadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalLoadArgs(paneLoadArgs), modalLoadArgs, ["type"]);
            if (modalLoadArgs.loadSettings != null)
            {
                modalLoadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalLoadSettings(paneLoadArgs.loadSettings), modalLoadArgs.loadSettings);
            }
            else
            {
                modalLoadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalLoadSettings(paneLoadArgs.loadSettings), entry.wrapper.loadSettings);
            }
        }
        else
        {
            modalLoadArgs = null;
        }

        if (modalLoadArgs == null)
        {
            modalLoadArgs = new EVUI.Modules.Modals.ModalLoadArgs(paneLoadArgs);
            modalLoadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalLoadSettings(paneLoadArgs.loadSettings), entry.wrapper.loadSettings);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(modalLoadArgs);
        _manager.loadPane(entry.pane.id, paneLoadArgs, callback);
    };

    /**Awaitable. Asynchronously loads a Modal.
    @param {EVUI.Modules.Modals.Modal|String} modalOrID Either a YOLO Modal object to extend into the existing Modal, the real Modal reference, or the string ID of the Modal to load.
    @param {EVUI.Modules.Modals.ModalLoadArgs} modalLoadArgs Optional. A YOLO object representing arguments for loading a Modal.
    @returns {Promise<Boolean>}*/
    this.loadModalAsync = function (modalOrID, modalLoadArgs)
    {
        return new Promise(function (resolve)
        {
            _self.loadModal(modalOrID, modalLoadArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Asynchronously unloads a Modal, which disconnects the Modal's element and removes it from the DOM if it was loaded remotely. Provides a callback that is called after the operation has completed successfully or otherwise.
    @param {EVUI.Modules.Modals.Modal|String} modalOrID Either a YOLO Modal object to extend into the existing Modal, the real Modal reference, or the string ID of the Modal to unload.
    @param {EVUI.Modules.Modals.ModalUnloadArgs|EVUI.Modules.Modals.Constants.Fn_ModalOperationCallback} modalUnloadArgs Optional. A YOLO object representing arguments for unloading a Modal or a callback. If omitted or passed as a function, the Modal's existing unload settings are used instead.
    @param {EVUI.Modules.Modals.Constants.Fn_ModalOperationCallback} callback Optional. A callback to call once the operation completes.*/
    this.unloadModal = function (modalOrID, modalUnloadArgs, callback)
    {
        var entry = getModalAmbiguously(modalOrID);
        var paneUnloadArgs = new EVUI.Modules.Panes.PaneUnloadArgs();

        if (typeof modalUnloadArgs === "function")
        {
            callback = modalUnloadArgs;
            modalUnloadArgs = null;
        }
        else if (modalUnloadArgs != null && typeof modalUnloadArgs === "object")
        {
            modalUnloadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Modals.ModalUnloadArgs(paneUnloadArgs), modalUnloadArgs);
        }
        else
        {
            modalUnloadArgs = null;
        }

        if (modalUnloadArgs == null)
        {
            modalUnloadArgs = new EVUI.Modules.Modals.ModalUnloadArgs(paneUnloadArgs);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(modalUnloadArgs);
        _manager.unloadPane(entry.pane.id, paneUnloadArgs, callback);
    };

    /**Awaitable. Asynchronously unloads a Modal, which disconnects the Modal's element and removes it from the DOM if it was loaded remotely.
    @param {EVUI.Modules.Modals.Modal|String} modalOrID Either a YOLO Modal object to extend into the existing Modal, the real Modal reference, or the string ID of the Modal to unload.
    @param {EVUI.Modules.Modals.ModalUnloadArgs} modalUnloadArgs Optional. A YOLO object representing arguments for unloading a Modal. If omitted the Modal's existing unload settings are used instead.
    @returns {Promise<Boolean>}*/
    this.unloadModalAsync = function (modalOrID, modalUnloadArgs)
    {
        return new Promise(function (resolve)
        {
            _self.unloadModal(modalOrID, modalUnloadArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Makes or extends an object at the end of the PaneManager's function for applying the changes made to the Pane.
   @param {PaneCreationResult} paneCreateResult The result of creating the pane.
   @returns {EVUI.Modules.Panes.Pane}*/
    var makeOrExtendObject = function (createResult)
    {
        var modal = createResult.pane.modal;
        delete createResult.pane.modal;

        return makeOrExtendModal(modal, createResult.pane, createResult.exists);
    };

    /**Builds the ModalEventArgs to use in the EventStream.
    @param {EVUI.Modules.Panes.PaneArgsPackage} argsPackage The argument data from the PaneManager about the current state of the Modal.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The PaneEventArgs that were created for the event.
    @returns {EVUI.Modules.Modals.ModalEventArgs} */
    var buildEventArgs = function (argsPackage, paneEventArgs)
    {
        if (argsPackage.foreignArgs == null)
        {
            argsPackage.foreignArgs = createForeignArgs(argsPackage);
        }

        var args = null;
        if (paneEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Hide)
        {
            args = argsPackage.foreignArgs.hideArgs;
        }
        else if (paneEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Load)
        {
            args = argsPackage.foreignArgs.loadArgs;
        }
        else if (paneEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Show)
        {
            args = argsPackage.foreignArgs.showArgs;
        }
        else if (paneEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Unload)
        {
            args = argsPackage.foreignArgs.unloadArgs;
        }

        var modalEventArgs = new EVUI.Modules.Modals.ModalEventArgs(argsPackage, args);
        modalEventArgs.cancel = paneEventArgs.cancel;
        modalEventArgs.key = paneEventArgs.key;
        modalEventArgs.pause = paneEventArgs.pause;
        modalEventArgs.resume = paneEventArgs.resume;
        modalEventArgs.stopPropagation = paneEventArgs.stopPropagation;
        modalEventArgs.context = paneEventArgs.context;

        return modalEventArgs;
    };

    /**Makes the foreign arguments for injecting into a ModalEventArgs object from the PaneManager.
    @param {EVUI.Modules.Modals.ModalShowArgs|EVUI.Modules.Modals.ModalHideArgs|EVUI.Modules.Modals.ModalLoadArgs|EVUI.Modules.Modals.ModalUnloadArgs} modalArgs
    @returns {EVUI.Modules.Panes.PaneArgsPackage}.*/
    var makeCurrentActionArgs = function (modalArgs)
    {
        var currentActionArgs = new EVUI.Modules.Panes.PaneArgsPackage();
        if (modalArgs.type === EVUI.Modules.Modals.ModalArgumentType.Hide)
        {
            currentActionArgs.hideArgs = modalArgs;
            currentActionArgs.unloadArgs = modalArgs.unloadArgs;
        }
        else if (modalArgs.type === EVUI.Modules.Modals.ModalArgumentType.Show)
        {
            currentActionArgs.showArgs = modalArgs;
            currentActionArgs.loadArgs = modalArgs.loadArgs;
        }
        else if (modalArgs.type === EVUI.Modules.Modals.ModalArgumentType.Load)
        {
            currentActionArgs.loadArgs = modalArgs;
        }
        else if (modalArgs.type === EVUI.Modules.Modals.ModalArgumentType.Unload)
        {
            currentActionArgs.unloadArgs = modalArgs;
        }

        return currentActionArgs;
    };

    /**Makes the "foreign" arguments for the PaneManager if it does not have them already.
    @param {EVUI.Modules.Panes.PaneArgsPackage} argsPackage The state of the Modal as reported by the Panemanager.
    @returns {EVUI.Modules.Panes.WidowArgsPackage}*/
    var createForeignArgs = function (argsPackage)
    {
        var foreignArgs = new EVUI.Modules.Panes.PaneArgsPackage();
        if (argsPackage.hideArgs != null)
        {
            foreignArgs.hideArgs = new EVUI.Modules.Modals.ModalHideArgs(argsPackage.hideArgs);
            foreignArgs.hideArgs.unloadArgs = new EVUI.Modules.Modals.ModalUnloadArgs(argsPackage.hideArgs.unloadArgs);
        }

        if (argsPackage.showArgs != null)
        {
            foreignArgs.showArgs = new EVUI.Modules.Modals.ModalShowArgs(argsPackage.showArgs);
            foreignArgs.showArgs.showSettings = new EVUI.Modules.Modals.ModalShowSettings(argsPackage.showArgs.showSettings);
            foreignArgs.showArgs.loadArgs = new EVUI.Modules.Modals.ModalLoadArgs(argsPackage.showArgs.loadArgs);
            foreignArgs.showArgs.loadArgs.loadSettings = new EVUI.Modules.Modals.ModalLoadSettings(argsPackage.showArgs.loadArgs.loadSettings);
        }

        if (argsPackage.loadArgs != null)
        {
            foreignArgs.loadArgs = new EVUI.Modules.Modals.ModalLoadArgs(argsPackage.loadArgs);
            foreignArgs.loadArgs.loadSettings = new EVUI.Modules.Modals.ModalLoadSettings(argsPackage.loadArgs.loadSettings);
        }

        if (argsPackage.unloadArgs != null)
        {
            foreignArgs.unloadArgs = new EVUI.Modules.Modals.ModalUnloadArgs(argsPackage.unloadArgs);
        }

        return foreignArgs;
    };

    /**Makes or extends a Modal object. Preserves all object references between runs and extends new properties onto the existing objects if they exist. 
    @param {EVUI.Modules.Modals.Modal} yoloModal A YOLO object representing a Modal.
    @returns {EVUI.Modules.Modals.Modal} */
    var makeOrExtendModal = function (yoloModal, pane, exists)
    {
        var modalToExtend = null;
        if (exists === true)
        {
            var preExisting = _settings.getPaneEntry(yoloModal.id);
            modalToExtend = preExisting.wrapper;
        }
        else
        {
            modalToExtend = new EVUI.Modules.Modals.Modal(pane);
        }

        var safeCopy = EVUI.Modules.Core.Utils.shallowExtend({}, yoloModal);
        delete safeCopy.id;
        if (exists === true && yoloModal.element === pane.element) delete safeCopy.element; //if the modal already exists and this is the same reference, don't set it again. Otherwise, let it blow up.
        delete safeCopy.currentPosition;
        delete safeCopy.currentZIndex;
        delete safeCopy.isVisible;
        delete safeCopy.isInitialized;
        delete safeCopy.isLoaded;

        EVUI.Modules.Core.Utils.shallowExtend(modalToExtend, safeCopy, ["showSettings", "loadSettings", "autoCloseSettings"]);
        modalToExtend.showSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Modals.ModalShowSettings(pane.showSettings), modalToExtend.showSettings, yoloModal.showSettings);
        modalToExtend.loadSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Modals.ModalLoadSettings(pane.loadSettings), modalToExtend.loadSettings, yoloModal.loadSettings);
        modalToExtend.autoCloseSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Modals.ModalAutoCloseSettings(pane.autoCloseSettings), modalToExtend.autoCloseSettings, yoloModal.autoCloseSettings);
        return modalToExtend;
    };

    /**Gets a Modal object from ambiguous input.
    @param {EVUI.Modules.Modals.Modal|String|Event} modalOrID Either a YOLO object representing a Modal object, a string ID of a Modal, or browser Event args triggering a Modal action.
    @param {Boolean} addIfMissing Whether or not to add the Modal record if it is not already present.
    @returns {EVUI.Modules.Panes.PaneEntry} */
    var getModalAmbiguously = function (modalOrID, addIfMissing)
    {
        if (modalOrID == null || (typeof modalOrID !== "string" && typeof modalOrID !== "object")) throw Error("Invalid input: " + _settings.objectName + " or string id expected.");

        if (modalOrID instanceof Event)
        {
            var entry = _settings.getPaneEntryAmbiguously(modalOrID, addIfMissing);
            return entry;
        }

        var fakePane = {};
        if (typeof modalOrID === "string")
        {
            fakePane = getDefaultPane({ id: modalOrID });
        }
        else
        {
            fakePane.id = modalOrID.id;
            fakePane.modal = modalOrID;
        }

        return _settings.getPaneEntryAmbiguously(fakePane, addIfMissing);
    };

    /**Gets a YOLO Pane object with all the default properties for a Modal's backing Pane.
    @param {EVUI.Modules.Modals.Modal} modal The modal to use as a wrapper for the Pane.
    @returns {EVUI.Modules.Panes.Pane}*/
    var getDefaultPane = function (modal)
    {
        if (typeof modal.id === "string")
        {
            var existing = _settings.getPaneEntry(modal.id);
            if (existing != null && existing.pane != null)
            {
                var fake = EVUI.Modules.Core.Utils.shallowExtend({}, existing.pane);

                fake.modal = modal;
                return fake;
            }
        }

        var pane =
        {
            id: modal.id,
            autoCloseSettings:
            {
                closeMode: EVUI.Modules.Panes.PaneCloseMode.Explicit,
                autoCloseKeys: ["Escape", "Enter"],
            },
            showSettings:
            {
                center: true,
                backdropSettings:
                {
                    showBackdrop: true
                },
            },

            clipSettings:
            {
                clipMode: EVUI.Modules.Modals.ModalClipMode.Clip,
                clipBounds: document.documentElement
            },
            modal: modal
        };

        return pane;
    };

    /**Interprets a browser event for a Modal operation.
    @param {EVUI.Modules.Panes.Pane} pane The YOLO Pane being created to extend onto a real record.
    @param {Event} browserEvent The event from the browser.
    @returns {EVUI.Modules.Panes.Pane}*/
    var interpretBrowserEvent = function (pane, browserEvent)
    {
        EVUI.Modules.Core.Utils.shallowExtend(pane, getDefaultPane({ id: pane.id }));

        if (pane.showSettings == null) pane.showSettings = {};
        if (pane.showSettings.backdropSettings == null) pane.showSettings.backdropSettings = {};

        var attributes = EVUI.Modules.Core.Utils.getElementAttributes(browserEvent.currentTarget);

        var backdrop = attributes.getValue(EVUI.Modules.Modals.Constants.Attribute_Backdrop);
        var center = attributes.getValue(EVUI.Modules.Modals.Constants.Attribute_Center);
        var fullscreen = attributes.getValue(EVUI.Modules.Modals.Constants.Attribute_Fullscreen);

        if (typeof backdrop === "string")
        {
            backdrop = backdrop.toLowerCase();

            if (backdrop === "false")
            {
                pane.showSettings.backdropSettings.showBackdrop = false;
            }
            else if (backdrop === "true")
            {
                pane.showSettings.backdropSettings.showBackdrop = true;
            }
        }

        if (typeof fullscreen === "string")
        {
            fullscreen = fullscreen.toLowerCase();

            if (fullscreen === "false")
            {
                pane.showSettings.fullscreen = false;
            }
            else if (fullscreen === "true")
            {
                pane.showSettings.fullscreen = true;
            }
        }

        if (typeof center === "string")
        {
            center = center.toLowerCase();

            if (center === "false")
            {
                pane.showSettings.center = false;
            }
            else if (center === "true")
            {
                pane.showSettings.center = true;
            }
        }

        return true;
    };

    _settings = new EVUI.Modules.Panes.PaneManagerSettings();
    _settings.attributePrefix = EVUI.Modules.Modals.Constants.Default_AttributePrefix;
    _settings.cssPrefix = EVUI.Modules.Modals.Constants.Default_CssPrefix;
    _settings.cssSheetName = EVUI.Modules.Styles.Constants.DefaultStyleSheetName;
    _settings.eventNamePrefix = EVUI.Modules.Modals.Constants.Default_EventNamePrefix;
    _settings.managerName = EVUI.Modules.Modals.Constants.Default_ManagerName;
    _settings.objectName = EVUI.Modules.Modals.Constants.Default_ObjectName;
    _settings.makeOrExtendObject = makeOrExtendObject;
    _settings.buildEventArgs = buildEventArgs;
    _settings.interpretBrowserEvent = interpretBrowserEvent;

    if (services == null || typeof services !== "object") services = new EVUI.Modules.Modals.ModalControllerServices();
    if (services.paneManager == null || typeof services.paneManager !== "object")
    {
        services.paneManager = EVUI.Modules.Panes.Manager;
    }

    _settings.httpManager = services.httpManager;
    _settings.stylesheetManager = services.stylesheetManager;
    _settings.htmlLoader = services.htmlLoader;

    _manager = new services.paneManager.createNewPaneManager(_settings);

    /**Global event that fires before the load operation begins for any Modal and is not yet in the DOM and cannot be manipulated in this stage, however the currentActionArgs.loadSettings can be manipulated to change the way the Modal's root element will be loaded.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalLoadArgs.*/
    this.onLoad = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onLoad", targetPath: "onLoad" });

    /**Global even that fires after the load operation has completed for any Modal and is now in the DOM and can be manipulated in this stage. From this point on the Modal's element property cannot be reset..
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalLoadArgs.*/
    this.onLoaded = function (paneEventArgs) { };;
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onLoaded", targetPath: "onLoaded" });

    /**Global event that fires the first time any Modal is shown after being loaded into the DOM, but is not yet visible. After it has fired once, it will not fire again unless the ModalShowArgs.reInitialize property is set to true.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalShowArgs.*/
    this.onInitialize = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onInitialize", targetPath: "onInitialize" });

    /**Global event that fires at the beginning of the show process and before the calculations for any Modal's location are made. The Modal is still hidden, but is present in the DOM and can be manipulated. In order for the positioning calculations in the next step to be accurate, all HTML manipulation should occur in this event.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalShowArgs.*/
    this.onShow = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onShow", targetPath: "onShow" });

    /**Global event that fires after the position of any Modal has been calculated and is available to be manipulated through the calculatedPosition property of the ModalEventArgs. If the calculatedPosition or the showSettings are manipulated, the position will be recalculated (the changes made directly to the position take priority over changes made to the showSettings).
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalShowArgs.*/
    this.onPosition = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onPosition", targetPath: "onPosition" });

    /**Global event that fires once any Modal has been positioned, shown, and had its optional show transition applied and completed. Marks the end of the show process.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalShowArgs.*/
    this.onShown = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onShown", targetPath: "onShown" });

    /**Global event that fires before any Modal has been moved from its current location and hidden. Gives the opportunity to change the hideTransition property of the ModalHideArgs and optionally trigger an unload once the Modal has been hidden.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalHideArgs.*/
    this.onHide = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onHide", targetPath: "onHide" });

    /**Global event that fires after any Modal has been moved from its current location and is now hidden and the hide transition has completed.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalHideArgs.*/
    this.onHidden = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onHidden", targetPath: "onHidden" });

    /**Global event that fires before any Modal has been (potentially) removed from the DOM and had its element property reset to null.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalUnloadArgs.*/
    this.onUnload = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onUnload", targetPath: "onUnload" });

    /**Global event that fires after any Modal has been (potentially) removed from the DOM and had its element property reset to null. From this point on the Modal's element property is now settable to a new Element.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalUnloadArgs.*/
    this.onUnloaded = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onUnloaded", targetPath: "onUnloaded" });
}

/**Represents a UI component that behaves like a standard, centered modal dialog with an optional backdrop by default.
 @class*/
EVUI.Modules.Modals.Modal = function (pane)
{
    if (pane == null) throw Error("Invalid input. Must wrap a Pane.");

    /**Object. The Modal being wrapped by the Modal.
    @type {EVUI.Modules.Panes.Pane}*/
    var _pane = pane;

    /**String. The unique ID of this Modal. ID's are case-insensitive.
    @type {String}*/
    this.id = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "id", targetPath: "id", settings: { set: false } });

    /**Object. The root Element of the Modal. Cannot be reset once it has been assigned to via initialization or a load operation, unload the Modal to reset it.
    @type {Element}*/
    this.element = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "element", targetPath: "element" });

    /**Boolean. Whether or not to unload the Modal from the DOM when it is hidden (only applies to elements that were loaded via HTTP). False by default.
    @type {Boolean}*/
    this.unloadOnHide = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "unloadOnHide", targetPath: "unloadOnHide" });

    /**Object. Calculates and gets the absolute position of the Modal.
    @type {EVUI.Modules.Dom.ElementBounds}*/
    this.currentPosition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "currentPosition", targetPath: "currentPosition", settings: { set: false } });

    /**Number. Calculates and gets the Z-Index of the Modal.
    @type {Number}*/
    this.currentZIndex = -1;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "currentZIndex", targetPath: "currentZIndex", settings: { set: false } });

    /**Boolean. Whether or not the internal state of the Modal thinks it is visible or not. This will be true after the show process has completed and false after an unload or hide operation has been completed.
    @type {Boolean}*/
    this.isVisible = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "isVisible", targetPath: "isVisible", settings: { set: false } });

    /**Boolean. Whether or not the internal state of the Modal thinks it is visible or not. This will be true after the load process has completed, even if the element was set directly before the first load operation.
    @type {Boolean}*/
    this.isLoaded = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "isLoaded", targetPath: "isLoaded", settings: { set: false } });

    /**Boolean. Whether or not the internal state of the Modal thinks it has been initialized or not. This will be true after the onInitialized events fire. */
    this.isInitialized = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "isInitialized", targetPath: "isInitialized", settings: { set: false } });

    /**Object. Show settings for the Modal.
    @type {EVUI.Modules.Modals.ModalShowSettings}*/
    this.showSettings = null;

    /**Object. Settings for loading the Modal.
    @type {EVUI.Modules.Modals.ModalLoadSettings}*/
    this.loadSettings = null;

    /**Object. Settings for controlling what should automatically close the Modal.
    @type {EVUI.Modules.Modals.ModalAutoCloseSettings}*/
    this.autoCloseSettings = null;

    /**Any. Any contextual information to attach to the Modal object.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "context", targetPath: "context" });

    /**Event that fires before the load operation begins for the Modal and is not yet in the DOM and cannot be manipulated in this stage, however the currentActionArgs.loadSettings can be manipulated to change the way the Modal's root element will be loaded.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalLoadArgs.*/
    this.onLoad = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onLoad", targetPath: "onLoad" });

    /**Event that fires after the load operation has completed for the Modal and is now in the DOM and can be manipulated in this stage. From this point on the Modal's element property cannot be reset..
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalLoadArgs.*/
    this.onLoaded = function (paneEventArgs) { };;
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onLoaded", targetPath: "onLoaded" });

    /**Event that fires the first time the Modal is shown after being loaded into the DOM, but is not yet visible. After it has fired once, it will not fire again unless the ModalShowArgs.reInitialize property is set to true.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalShowArgs.*/
    this.onInitialize = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onInitialize", targetPath: "onInitialize" });

    /**Event that fires at the beginning of the show process and before the calculations for the Modal's location are made. The Modal is still hidden, but is present in the DOM and can be manipulated. In order for the positioning calculations in the next step to be accurate, all HTML manipulation should occur in this event.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalShowArgs.*/
    this.onShow = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onShow", targetPath: "onShow" });

    /**Event that fires after the position of the Modal has been calculated and is available to be manipulated through the calculatedPosition property of the ModalEventArgs. If the calculatedPosition or the showSettings are manipulated, the position will be recalculated (the changes made directly to the position take priority over changes made to the showSettings).
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalShowArgs.*/
    this.onPosition = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onPosition", targetPath: "onPosition" });

    /**Event that fires once the Modal has been positioned, shown, and had its optional show transition applied and completed. Marks the end of the show process.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalShowArgs.*/
    this.onShown = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onShown", targetPath: "onShown" });

    /**Event that fires before the Modal has been moved from its current location and hidden. Gives the opportunity to change the hideTransition property of the ModalHideArgs and optionally trigger an unload once the Modal has been hidden.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalHideArgs.*/
    this.onHide = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onHide", targetPath: "onHide" });

    /**Event that fires after the Modal has been moved from its current location and is now hidden and the hide transition has completed.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalHideArgs.*/
    this.onHidden = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onHidden", targetPath: "onHidden" });

    /**Event that fires before the Modal has been (potentially) removed from the DOM and had its element property reset to null.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalUnloadArgs.*/
    this.onUnload = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onUnload", targetPath: "onUnload" });

    /**Event that fires after the Modal has been (potentially) removed from the DOM and had its element property reset to null. From this point on the Modal's element property is now settable to a new Element.
    @param {EVUI.Modules.Modals.ModalEventArgs} paneEventArgs The event arguments for the Modal operation. The currentActionArgs property will be an instance of ModalUnloadArgs.*/
    this.onUnloaded = function (paneEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _pane, { sourcePath: "onUnloaded", targetPath: "onUnloaded" });

    /**Returns a copy of the internal eventBindings array.
    @returns {EVUI.Modules.Panes.PaneEventBinding[]}*/
    this.getEventBindings = function ()
    {
        return _pane.getEventBindings();
    };

    /**Adds an event response to a standard browser event to a child element of the Modal element.
    @param {Element} element The child element of the root pane element to attach an event handler to.
    @param {EVUI.Modules.Dom.Constants.Fn_BrowserEventHandler} handler An event handler to be called when the specified events are triggered.
    @param {String|String[]} event Either a single event name, or an array of event names, or a space delineated string of event names to add.*/
    this.addEventBinding = function (element, event, handler)
    {
        return _pane.addEventBinding(element, event, handler);
    };
};

/**The settings and options for showing a Modal.
@class*/
EVUI.Modules.Modals.ModalShowSettings = function (showSettings)
{
    /**The show settings being set by the ModalShowSettings.
    @type {EVUI.Modules.Panes.PaneShowSettings}*/
    var _showSettings = (showSettings == null || typeof showSettings !== "object") ? new EVUI.Modules.Panes.PaneShowSettings() : showSettings;
    if (_showSettings.backdropSettings == null) _showSettings.backdropSettings = new EVUI.Modules.Panes.PaneBackdropSettings();
    if (_showSettings.clipSettings == null) _showSettings.clipSettings = new EVUI.Modules.Panes.PaneClipSettings();

    /**Boolean. Whether or not to full screen the Modal to cover the entire current view port. False by default.
    @type {Boolean}*/
    this.fullscreen = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "fullscreen", targetPath: "fullscreen" });

    /**Whether or not to explicitly position the Modal so that it is centered on the screen's current view port. True by default.
    @type {Boolean}*/
    this.center = true;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "center", targetPath: "center" });

    /**Boolean. Whether or not to show a backdrop. True by default.
    @type {Boolean}*/
    this.showBackdrop = true;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "showBackdrop", targetPath: "backdropSettings.showBackdrop" });

    /**Object or String. Either class names, a string of CSS rules (without a selector), or an object of key-value pairs of CSS properties to generate a runtime CSS class for.
    @type {Object|String}*/
    this.backdropCSS = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "backdropCSS", targetPath: "backdropSettings.backdropCSS" });

    /**Object. The transition effect to apply when showing the backdrop.
    @type {EVUI.Modules.Modals.ModalTransition}*/
    this.backdropShowTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "backdropShowTransition", targetPath: "backdropSettings.backdropShowTransition" });

    /**Object. The transition effect to apply when showing the backdrop.
    @type {EVUI.Modules.Modals.ModalTransition}*/
    this.backdropHideTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "backdropHideTransition", targetPath: "backdropSettings.backdropHideTransition" });

    /**Number. The opacity of the backdrop. 75% by default.
    @type {Number}*/
    this.backdropOpacity = 0.75;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "backdropOpacity", targetPath: "backdropSettings.backdropOpacity" });

    /**String. The color of the backdrop. #000000 by default.
    @type {Number}*/
    this.backdropColor = "#000000";
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "backdropColor", targetPath: "backdropSettings.backdropColor" });
   
    /**Object. Contains the details of the CSS transition to use to show the Modal (if a transition is desired). If omitted, the Modal is positioned then shown by manipulating the display property directly.
    @type {EVUI.Modules.Modals.ModalTransition}*/
    this.showTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "showTransition", targetPath: "showTransition" })

    /**Object. Contains the details of the CSS transition to use to hide the Modal (if a transition is desired). If omitted, the Modal is positioned then shown by manipulating the display property directly.
    @type {EVUI.Modules.Modals.ModalTransition}*/
    this.hideTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "hideTransition", targetPath: "hideTransition" })

    /**Object. An Element (or CSS selector of an Element) or an ElementBounds object describing the bounds to which the Modal will attempt to fit inside. If omitted, the Modal's current view port is used.
    @type {Element|EVUI.Modules.Dom.ElementBounds|String}*/
    this.clipBounds = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "clipBounds", targetPath: "clipSettings.clipBounds" })

    /**Boolean. Whether or not scrollbars should appear on the X-axis when the Modal has been clipped.
    @type {Boolean}*/
    this.scrollXWhenClipped = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "scrollXWhenClipped", targetPath: "clipSettings.scrollXWhenClipped" })

    /**Boolean. Whether or not scrollbars should appear on the Y-axis when the Modal has been clipped.
    @type {Boolean}*/
    this.scrollYWhenClipped = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "scrollYWhenClipped", targetPath: "clipSettings.scrollYWhenClipped" })

    /**Boolean. Whether or not to include the height and width when positioning the element (when it is not clipped).
    @type {Boolean}*/
    this.setExplicitDimensions = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "setExplicitDimensions", targetPath: "setExplicitDimensions" })
};

/**Event arguments for the events exposed when hiding, showing, loading, or unloading a Modal.
@class*/
EVUI.Modules.Modals.ModalEventArgs = function (argsPackage, currentArgs)
{
    if (argsPackage == null || currentArgs == null) throw Error("Invalid arguments.")

    /**Object. The metadata about the state of the Modal.
    @type {EVUI.Modules.Panes.PaneArgsPackage}*/
    var _argsPackage = argsPackage;

    /**The current event args for the operation.
    @type {Any}*/
    var _currentArgs = currentArgs;

    /**The Modal that is having an action performed on it.
    @type {EVUI.Modules.Modals.Modal}*/
    this.modal = null;
    Object.defineProperty(this, "modal",
        {
            get: function () { return _argsPackage.wrapper; },
            configurable: false,
            enumerable: true
        });

    /**String. The unique key current step in the EventStream.
    @type {String}*/
    this.key = null;

    /**Function. Pauses the EventStream, preventing the next step from executing until resume is called.*/
    this.pause = function () { };

    /**Function. Resumes the EventStream, allowing it to continue to the next step.*/
    this.resume = function () { };

    /**Function. Cancels the EventStream and aborts the execution of the Modal operation.*/
    this.cancel = function () { }

    /**Function. Stops the EventStream from calling any other event handlers with the same key.*/
    this.stopPropagation = function () { };

    /**Object. The position of the Modal that has been calculated in using the currentShowSettings.
    @type {EVUI.Modules.Panes.PanePosition}*/
    this.calculatedPosition = null;
    Object.defineProperty(this, "calculatedPosition",
        {
            get: function () { return _argsPackage.lastCalculatedPosition; },
            configurable: false,
            enumerable: true
        });

    /**Object. The PaneHide/Show/Load/Unload Arguments being used for the operation.
    @type {EVUI.Modules.Modals.ModalShowArgs|EVUI.Modules.Modals.ModalHideArgs|EVUI.Modules.Modals.ModalLoadArgs|EVUI.Modules.Modals.ModalUnloadArgs}*/
    this.currentActionArgs = null;
    Object.defineProperty(this, "currentActionArgs", {
        get: function () { return _currentArgs },
        configurable: false,
        enumerable: true
    });

    /**Object. Any state value to carry between events.
    @type {Object}*/
    this.context = {};
};

/**Arguments for loading a Modal.
 @class*/
EVUI.Modules.Modals.ModalLoadArgs = function (paneLoadArgs)
{
    /**The internal PaneLoadArgs being manipulated.
    @type {EVUI.Modules.Panes.PaneLoadArgs}*/
    var _loadArgs = (paneLoadArgs == null || typeof paneLoadArgs !== "object") ? new EVUI.Modules.Panes.PaneLoadArgs() : paneLoadArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _loadArgs, [{ sourcePath: "type", targetPath: "type" }]);

    /**Any. Any contextual information to pass into the Modal load logic.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _loadArgs, [{ sourcePath: "context", targetPath: "context" }]);

    /**Object. The PaneLoadSettings to use if the Modal has not already been loaded.
    @type {EVUI.Modules.Modals.ModalLoadSettings}*/
    this.loadSettings = null;

    /**Boolean. Whether or not to re-load the Modal.
    @type {Boolean}*/
    this.reload = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _loadArgs, [{ sourcePath: "reload", targetPath: "reload" }]);
};

/**Arguments for showing a Modal.
@class*/
EVUI.Modules.Modals.ModalShowArgs = function (paneShowArgs)
{
    /**The internal settings being set by the wrapper object.
    @type {EVUI.Modules.Panes.PaneShowArgs}*/
    var _paneShowArgs = (paneShowArgs == null || typeof paneShowArgs !== "object") ? new EVUI.Modules.Panes.PaneShowArgs() : paneShowArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneShowArgs, { sourcePath: "type", targetPath: "type", settings: { set: false } });

    /**Any. Any contextual information to pass into the Modal show logic.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneShowArgs, { sourcePath: "context", targetPath: "context" });

    /**Object. The show settings for the Modal.
    @type {EVUI.Modules.Modals.ModalShowSettings}*/
    this.showSettings = null;

    /**Object. The load arguments for loading the Modal if it has not already been loaded.
    @type {EVUI.Modules.Modals.ModalLoadArgs}*/
    this.loadArgs = null;

    /**Whether or not to re-initialize the Modal upon showing it.
    @type {Boolean}*/
    this.reInitialize = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneShowArgs, { sourcePath: "reInitialize", targetPath: "reInitialize" });
};

/**Arguments for hiding a Modal.
@class*/
EVUI.Modules.Modals.ModalHideArgs = function (paneHideArgs)
{
    /**The internal settings being set by the wrapper object.
    @type {EVUI.Modules.Panes.PaneHideArgs}*/
    var _paneHideArgs = (paneHideArgs == null || typeof paneHideArgs !== "object") ? new EVUI.Modules.Panes.PaneHideArgs() : paneHideArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneHideArgs, { sourcePath: "type", targetPath: "type", settings: { set: false } });

    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneHideArgs, { sourcePath: "context", targetPath: "context" });

    /** */
    this.modalHideTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneHideArgs, { sourcePath: "modalHideTransition", targetPath: "paneHideTransition" });

    this.unloadArgs = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneHideArgs, { sourcePath: "unloadArgs", targetPath: "unloadArgs" });
};

/**Arguments for unloading a Modal.
@class*/
EVUI.Modules.Modals.ModalUnloadArgs = function (paneUnloadArgs)
{
    /**The internal settings being set by the wrapper object.
    @type {EVUI.Modules.Panes.PaneUnloadArgs}*/
    var _paneUnloadArgs = (paneUnloadArgs == null || typeof paneUnloadArgs !== "object") ? new EVUI.Modules.Panes.PaneUnloadArgs() : paneUnloadArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneUnloadArgs, { sourcePath: "type", targetPath: "type", settings: { set: false } });

    /**Any. Any contextual information to pass into the Modal hide logic.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneUnloadArgs, { sourcePath: "context", targetPath: "context" });

    /**Boolean. Whether or not to remove the Modal from the DOM once it has been unloaded.
    @type {Boolean}*/
    this.remove = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneUnloadArgs, { sourcePath: "remove", targetPath: "remove" });
};

/**Represents a transition effect that can be applied to a Modal when its position or size changes.
@class*/
EVUI.Modules.Modals.ModalTransition = function ()
{
    /**Object or String. Either class names, a string of CSS rules (without a selector), or an object of key-value pairs of CSS properties to generate a runtime CSS class for.
    @type {Object|String}*/
    this.css = null;

    /**String. CSS definition for a keyframe animation to apply. Note that the keyframe animation's name must appear in the PaneTransition.css property in order to be applied.
    @type {String}*/
    this.keyframes = null;

    /**The duration (in milliseconds) of the transition so that the OnShown/OnHidden events are only fired once the transition is complete.
    @type {Number}*/
    this.duration = 0;
};

/**Settings and options for loading a Modal.
@class */
EVUI.Modules.Modals.ModalLoadSettings = function (paneLoadSettings)
{
    var _paneLoadSettings = (paneLoadSettings == null || typeof paneLoadSettings !== "object") ? new EVUI.Modules.Panes.PaneLoadSettings() : paneLoadSettings;

    /**Object. The Element to show as the Modal.
    @type {Element}*/
    this.element = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "element", targetPath: "element" });

    /**String. A CSS selector that is used to go find the Element to show as the Modal. Only the first result is used.
    @type {String}*/
    this.selector = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "selector", targetPath: "selector" });

    /**Object. If using a CSS selector to find the root element of a Modal, this is the context limiting element to search inside of.
    @type {Element}*/
    this.contextElement = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "contextElement", targetPath: "contextElement" });

    /**Object. HttpRequestArgs for making a Http request to go get the Modal's HTML.
    @type {EVUI.Modules.Http.HttpRequestArgs}*/
    this.httpLoadArgs = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "httpLoadArgs", targetPath: "httpLoadArgs" });

    /**Object. PlaceholderLoadArgs for making a series of Http requests to load the Modal as an existing placeholder.
    @type {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs}*/
    this.placeholderLoadArgs = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _paneLoadSettings, { sourcePath: "placeholderLoadArgs", targetPath: "placeholderLoadArgs" });
};

/**Settings for controlling how the Modal will automatically close itself in response to user events.
@class*/
EVUI.Modules.Modals.ModalAutoCloseSettings = function ()
{
    /**Array. An array of characters/key names ("a", "b", "Escape", "Enter" etc) that will automatically trigger the Modal to be hidden when pressed. Corresponds to the KeyboardEvent.key property.
    @type {String[]}*/
    this.autoCloseKeys = [];

    /**An optional function to use to determine if an auto-close event should hide the Modal. Return false to prevent the Modal from being hidden.
    @param {EVUI.Modules.Panes.PaneAutoTriggerContext} autoTriggerContext The context object generated by the event handler.
    @returns {Boolean}*/
    this.autoCloseFilter = function (autoTriggerContext)
    {
        return true;
    };
};

/**Enum for indicating what type of arguments object the ModalEventArgs.currentArguments property is.
@enum*/
EVUI.Modules.Modals.ModalArgumentType =
{
    /**Arguments are ModalShowArgs.*/
    Show: "show",
    /**Arguments are ModalHideArgs.*/
    Hide: "hide",
    /**Arguments are ModalLoadArgs.*/
    Load: "load",
    /**Arguments are ModalUnloadArgs.*/
    Unload: "unload",
    /**Arguments are ModalMoveResizeArgs.*/
    MoveResize: "moveResize"
};
Object.freeze(EVUI.Modules.Modals.ModalArgumentType);

/**Enum for indicating the behavior of the Modal when it overflows its clipBounds.
@enum*/
EVUI.Modules.Modals.ModalClipMode =
{
    /**When the calculated position of the Modal overflows the clipBounds, it will not be cropped to stay within the clipBounds and will overflow to the outside of the clip bounds.*/
    Overflow: "overflow",
    /**When the calculated position of the Modal overflows the clipBounds, it will be clipped to the maximum dimensions of the clipBounds on the overflowing axes.*/
    Clip: "clip",
    /**When the calculated position of the Modal overflows the clipBounds, it will be shifted in the opposite directions as the overflow to fit within the clipBounds.*/
    Shift: "shift",
};
Object.freeze(EVUI.Modules.Modals.ModalClipMode);

/**Object to inject the standard dependencies used by the ModalController into it via its constructor.
@class*/
EVUI.Modules.Modals.ModalControllerServices = function ()
{
    /**Object. An instance of Http module's HttpManager object.
    @type {EVUI.Modules.Http.HttpManager}*/
    this.httpManager = null;

    /**Object. An instance of the HtmlLoaderController module's HtmlLoaderController object.
    @type {EVUI.Modules.HtmlLoader.HtmlLoaderController}*/
    this.htmlLoader = null;

    /**Object. An instance of the Styles module's StylesheetManager object.
    @type {EVUI.Modules.Styles.StyleSheetManager}*/
    this.stylesheetManager = null;

    /**Object. An instance of the Panes module's PaneManager object.
    @type {EVUI.Modules.Panes.PaneManager}*/
    this.panesManager = null;
};

/**Global instance of the ModalManager, used for creating and using simple modals that are positioned relative to a point or another element.
@type {EVUI.Modules.Modals.ModalManager}*/
EVUI.Modules.Modals.Manager = null;
(function ()
{
    var ctor = EVUI.Modules.Modals.ModalManager;
    var manager = null;

    Object.defineProperty(EVUI.Modules.Modals, "Manager", {
        get: function ()
        {
            if (manager == null) manager = new ctor();
            return manager;
        },
        enumerable: true,
        configurable: false
    });
})();

Object.freeze(EVUI.Modules.Modals);

delete $evui.modals;

/**Global instance of the ModalManager, used for creating and using simple modals that are positioned relative to a point or another element.
@type {EVUI.Modules.Modals.ModalManager}*/
$evui.modals = null;
Object.defineProperty($evui, "modals", {
    get: function () { return EVUI.Modules.Modals.Manager; },
    enumerable: true
});

/**Adds a Modal to the WidowManager.
@param {EVUI.Modules.Modals.Modal} yoloModal A YOLO object representing a Modal object. This object is copied onto a real Modal object is then discarded.
@returns {EVUI.Modules.Modals.Modal}*/
$evui.addModal = function (yoloModal)
{
    return $evui.modals.addModal(yoloModal);
};

/**Shows (and loads, if necessary or if a reload is requested) a Modal asynchronously. Provides a callback that is called call once the Modal operation has completed successfully or otherwise.
@param {EVUI.Modules.Modals.Modal|String} modalOrID Either a YOLO Modal object to extend into the existing Modal, the real Modal reference, or the string ID of the Modal to show.
@param {EVUI.Modules.Modals.ModalShowArgs|EVUI.Modules.Modals.Constants.Fn_ModalOperationCallback} modalShowArgs Optional. A YOLO object representing the arguments for showing the Modal, or the callback. If omitted or passed as a function, the Modal's existing show/load settings are used instead.
@param {EVUI.Modules.Modals.Constants.Fn_ModalOperationCallback} callback Optional. A callback that is called once the operation completes.*/
$evui.showModal = function (modalOrID, modalShowArgs, callback)
{
    return $evui.modals.showModal(modalOrID, modalShowArgs, callback);
};

/**Awaitable. (and loads, if necessary or if a reload is requested) a Modal asynchronously.
@param {EVUI.Modules.Modals.Modal|String} modalOrID Either a YOLO Modal object to extend into the existing Modal, the real Modal reference, or the string ID of the Modal to show.
@param {EVUI.Modules.Modals.ModalShowArgs} modalShowArgs Optional.  A YOLO object representing the arguments for showing the Modal. If omitted, the Modal's existing show/load settings are used instead.
@returns {Promise<Boolean>}*/
$evui.showModalAsync = function (modalOrID, modalShowArgs)
{
    return $evui.modals.showModalAsync(modalOrID, modalShowArgs);
};

/**Hides (and unloads if requested) a Modal asynchronously. Provides a callback that is called call once the Modal operation has completed successfully or otherwise.
@param {EVUI.Modules.Modals.Modal|String} modalOrID Either a YOLO Modal object to extend into the existing Modal, the real Modal reference, or the string ID of the Modal to hide.
@param {EVUI.Modules.Modals.ModalHideArgs|EVUI.Modules.Modals.Constants.Fn_ModalOperationCallback} modalHideArgs Optional.  A YOLO object representing the arguments for hiding a Modal or the callback. If omitted or passed as a function, the Modal's existing hide/unload settings are used instead.
@param {EVUI.Modules.Modals.Constants.Fn_ModalOperationCallback} callback Optional. A callback that is called once the operation completes.*/
$evui.hideModal = function (modalOrID, modalHideArgs, callback)
{
    return $evui.modals.hideModal(modalOrID, modalHideArgs, callback);
};

/**Awaitable. Hides (and unloads if requested) a Modal asynchronously. Provides a callback that is called call once the Modal operation has completed successfully or otherwise.
@param {EVUI.Modules.Modals.Modal|String} modalOrID Either a YOLO Modal object to extend into the existing Modal, the real Modal reference, or the string ID of the Modal to hide.
@param {EVUI.Modules.Modals.ModalHideArgs} modalHideArgs Optional.  A YOLO object representing the arguments for hiding a Modal. If omitted, the Modal's existing hide/unload settings are used instead.
@returns {Promise<Boolean>}*/
$evui.hideModalAsync = function (modalOrID, modalHideArgs)
{
    return $evui.modals.hideModalAsync(modalOrID, modalHideArgs);
};

/*#ENDWRAP(Modal)#*/


/********************************************************Observers.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.Observers|Observer)#*/
/*#REPLACE(EVUI.Modules.Observers|Observer)#*/

/**Module for functionality applicable to all objects.
@module*/
EVUI.Modules.Observers = {};

/*#MODULEDEF(Observers|"1.0"|"Observers")#*/
/*#VERSIONCHECK(EVUI.Modules.Observers|Observer)#*/

EVUI.Modules.Observers.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.Observers.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();

Object.freeze(EVUI.Modules.Observers.Dependencies);

/**Simple object observer that can report any added, removed, or changed properties of an object or its children recursively.
@param {Object} obj The object to observe.
@class*/
EVUI.Modules.Observers.ObjectObserver = function (obj)
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Observers.Dependencies);

    /**The state of the comparison in the ObjectObserver.
    @type {CompareSession}*/
    var _session = null;

    /**Gets all the changed, added, or removed properties of the object since the state was last set.
    @param {Boolean} setState Whether or not to set the state of the observer to match the current state of the object.
    @returns {EVUI.Modules.Observers.ObservedChangedProperty[]} */
    this.getChanges = function (setState)
    {
        var diff = getDiffs(setState);
        var changes = diff.changedProperties.slice();
        _session.reset();

        return changes;
    };

    /**Extracts an ObjectObserver representing a child object of the object this ObjectObserver is observing. Can optionally be a clone of the state in this ObjectObserver so that the child and the parent can be used independently of each other without impacting each other's state.
    @param {String} path The path from the root object being observed to the child object to observe. Note that the child cannot be a null or undefined reference. 
    @param {Boolean} disconnect Whether or not to clone the internal state of the ObjectObserver for the new child ObjectObserver so that their states won't update each other when getChanges is called. False by default.
    @returns {EVUI.Modules.Observers.ObjectObserver}*/
    this.getChildObserver = function (path, disconnect)
    {
        if (_session == null || _session.root == null) return new EVUI.Modules.Observers.ObjectObserver();
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(path) === true)
        {
            //if we have no path and are disconnecting, we are making a clone of this object observer.
            if (disconnect === true)
            {
                return EVUI.Modules.Observers.ObjectObserver(cloneObservedProperty(_session.root))
            }

            //otherwise we return null
            return null;
        }

        //break the path down into an array of segments to use to dig into the source object.
        var pathSegs = EVUI.Modules.Core.Utils.getValuePathSegments(path);
        var numSegs = pathSegs.length;

        var curProp = _session.root.propDic[pathSegs[0]];
        if (curProp == null) return null;

        for (var x = 1; x < numSegs; x++)
        {
            curProp = curProp.propDic[pathSegs[x]];
            if (curProp == null) return null;
        }

        //if disconnecting, clone the property so it becomes a new "island" with its own state.
        if (disconnect === true)
        {
            curProp = cloneObservedProperty(curProp, null);
        }

        return new EVUI.Modules.Observers.ObjectObserver(curProp);
    };

    /**Returns a copy of the internal dictionary of observed properties.
    @returns {EVUI.Modules.Observers.ObservedProperty}*/
    this.getObservedProperties = function ()
    {
        return cloneObservedProperty(_session.root, null);
    };

    /**Initial scan of the object passed in the constructor when it was created. Sets the initial observed state of the object observer.
     @param {Object} curObj Any object.*/
    var scan = function (curObj)
    {
        var root = new EVUI.Modules.Observers.ObservedProperty();
        root.hostObject = null;
        root.name = null;
        root.originalValue = obj;
        root.propDic = {};
        root.propList = [];

        _session = new CompareSession();
        _session.root = root;
        _session.diffing = false;
        _session.setState = true;
        _session.parentStack.push(curObj);

        getProperties(curObj, root, _session)
    };

    /**Gets all the differences between the last set state and the current state of the object being observed.
    @param {Boolean} setState Whether or not to update the internal observed state of the ObjectObserver.
    @returns {CompareSession}*/
    var getDiffs = function (setState)
    {
        _session.diffing = true;
        _session.setState = setState;

        if (_session.root == null) return session;

        _session.parentStack.push(_session.root.originalValue);

        getProperties(_session.root.originalValue, _session.root, _session);

        return _session;
    };

    /**Recursively clones all of the ObservedProperties under the observedProp passed into the function. Used when creating child observers of this observer.
    @param {ObservedProperty} observedProp The property to clone.
    @param {ObservedProperty} parent The parent of the property to clone.
    @returns {ObservedProperty} */
    var cloneObservedProperty = function (observedProp, parent)
    {
        var newProp = new EVUI.Modules.Observers.ObservedProperty();
        if (parent == null)
        {
            if (observedProp.originalValue == null || typeof observedProp.originalValue !== "object") throw Error("Cannot observe a null reference or non-object.");
            newProp.originalValue = observedProp.originalValue;
        }
        else
        {
            newProp.originalValue = observedProp.originalValue;
            newProp.hostObject = observedProp.hostObject;
            newProp.name = observedProp.name;
            newProp.path = (parent.path == null) ? observedProp.name : parent.path + "." + observedProp.name;
        }

        if (observedProp.propDic == null) return newProp;

        newProp.propList = [];
        newProp.propDic = {};
        newProp.numProps = observedProp.numProps;

        for (var x = 0; x < observedProp.numProps; x++)
        {
            var curProp = observedProp.propList[x];
            newProp.propList.push(curProp);

            var existing = observedProp.propDic[curProp];
            newProp.propDic[curProp] = cloneObservedProperty(existing, newProp);
        }

        return newProp;
    };

    /**Gets all the properties of an object recursively and populates the internal state of the observer with its values.
    @param {Object} curObj The object to observe.
    @param {ObservedProperty} parentObserved The parent property of the current object.
    @param {CompareSession} session The CompareSession that holds the state of the comparison operation.*/
    var getProperties = function (curObj, parentObserved, session)
    {
        if (curObj == null) return;
        if (curObj instanceof Node || curObj === window) return; //we never ever compare nodes or windows, that will set off a recursive explosion of comparisons and wind up comparing everything in the DOM or in the JavaScript universe of the page.

        var unionProps = [];
        var allProps = {};

        //if the source object is an array, take a shortcut to get its properties by using the length to get them instead of reflecting over the object. May miss properties of arrays that are non-numerical, however.
        if (EVUI.Modules.Core.Utils.isArray(curObj) === true)
        {
            var len = curObj.length;
            for (var x = 0; x < len; x++)
            {
                var curProp = x.toString();
                allProps[curProp] = true;
                unionProps.push(curProp);
            }
        }
        else //otherwise iterate over the properties of the object
        {
            var props = EVUI.Modules.Core.Utils.getProperties(curObj);
            var numProps = props.length;

            for (var x = 0; x < numProps; x++) //for (var curProp in curObj)
            {
                var curProp = props[x];

                allProps[curProp] = true;
                unionProps.push(curProp);
            }
        }

        //if we've already compared this object, cross check these properties against the properties that have already been observed.
        if (parentObserved.propDic != null)
        {
            for (var x = 0; x < parentObserved.numProps; x++)
            {
                var curProp = parentObserved.propList[x];
                if (allProps[curProp] === true) continue;
                unionProps.push(curProp);
            }
        }

        var numUnion = unionProps.length;
        for (var x = 0; x < numUnion; x++)
        {
            var curProp = unionProps[x];
            var added = false;
            var curValue = curObj[curProp];
            var existingObserved = parentObserved.propDic[curProp];

            //not observed yet. A new property.
            if (existingObserved == null)
            {
                var observed = new EVUI.Modules.Observers.ObservedProperty();
                observed.hostObject = curObj;
                observed.name = curProp;
                observed.path = (parentObserved.path != null) ? parentObserved.path + "." + curProp : curProp;
                observed.originalValue = curValue;

                //if the parent isn't ready to accept children, set it up to do so.
                if (parentObserved.propDic == null)
                {
                    parentObserved.propDic = {};
                    parentObserved.propList = [];
                }

                //if setting the state, append the property to the dictionary and put its name in the array
                if (session.setState === true)
                {
                    parentObserved.propDic[curProp] = observed;
                    parentObserved.numProps = parentObserved.propList.push(curProp);
                }

                //if diffing, make a diff object to return eventually
                if (session.diffing === true)
                {
                    var diff = new EVUI.Modules.Observers.ObservedChangedProperty();
                    diff.hostObject = observed.hostObject;
                    diff.name = observed.name;
                    diff.newValue = curValue;
                    diff.originalValue = undefined;
                    diff.path = observed.path;
                    diff.type = EVUI.Modules.Observers.ObservedObjectChangeType.Added;

                    session.changedProperties.push(diff);
                }

                existingObserved = observed;
                added = true;
            }

            //if we're diffing and the value isn't new, do a comparison between the old and new values.
            if (session.diffing === true && added === false)
            {
                if (curValue !== existingObserved.originalValue)
                {
                    var diff = new EVUI.Modules.Observers.ObservedChangedProperty();
                    diff.hostObject = existingObserved.hostObject;
                    diff.name = existingObserved.name;
                    diff.newValue = curValue;
                    diff.originalValue = existingObserved.originalValue;
                    diff.path = existingObserved.path;

                    if (curValue === undefined)
                    {
                        diff.type = EVUI.Modules.Observers.ObservedObjectChangeType.Removed;
                    }
                    else
                    {
                        diff.type = EVUI.Modules.Observers.ObservedObjectChangeType.Changed;
                    }

                    session.changedProperties.push(diff);
                }
            }

            //if setting the state, either remove the property if it was no longer present or set its value if it was changed.
            if (session.setState === true && added === false)
            {
                if (curValue === undefined)
                {
                    delete parentObserved.propDic[curProp];
                    var index = parentObserved.propList.indexOf(curProp);
                    if (index !== -1)
                    {
                        parentObserved.propList.splice(index, 1);
                        parentObserved.numProps--;
                    }

                    continue;
                }
                else if (curValue !== existingObserved.originalValue)
                {
                    existingObserved.originalValue = curValue;
                }

                if (existingObserved.hostObject !== curObj) existingObserved.hostObject = curObj;
            }

            //we have a child object, go call getProperties on it to build the recursive hierarchy.
            if (curValue != null && typeof curValue === "object")
            {
                //make sure we're not in a circular reference
                var existingIndex = session.parentStack.indexOf(curValue);
                if (existingIndex !== -1) continue;

                session.parentStack.push(curValue);

                if (existingObserved.propDic == null)
                {
                    existingObserved.propDic = {};
                    existingObserved.propList = [];
                }

                getProperties(curValue, existingObserved, session);

                session.parentStack.pop();
            }
        }
    };

    /**Represents the internal state of the ObjectObserver.
    @class*/
    var CompareSession = function ()
    {
        /**Object. The root ObservedProperty of the ObjectObserver.
        @type {ObservedProperty}*/
        this.root = null;

        /**Array. All of the changed properties of the observed object since its state was last set.
        @type {EVUI.Modules.Observers.ObservedChangedProperty[]}*/
        this.changedProperties = [];

        /**Boolean. Whether or not a diff operation is being performed.
        @type {Boolean}*/
        this.diffing = false;

        /**Boolean. Whether or not to set the internal state of the observer so that only new changes from this point in time forward are reported.
        @type {Boolean}*/
        this.setState = false;

        /**Array. A "stack" of objects that represents the hierarchy of objects above the currently observed object. Used to prevent circular references.
        @type {Obejct[]}*/
        this.parentStack = [];

        /**Resets the state of the CompareSession.*/
        this.reset = function ()
        {
            this.changedProperties.splice(0, this.changedProperties.length); //for some reason splicing the contents of the array is faster than allocating a new array, so we splice it and slice it when we return it.
            this.diffing = false;
            this.setState = false;
            this.parentStack.splice(0, this.parentStack.length);
        };
    };

    if (obj == null || typeof obj !== "object") throw Error("Cannot observe a null reference or non-object.");

    //scan the constructor parameter and set the internal state
    if (EVUI.Modules.Core.Utils.instanceOf(obj, EVUI.Modules.Observers.ObservedProperty) === true)
    {
        _session = new CompareSession();
        _session.root = obj;
    }
    else //otherwise scan the object like normal
    {
        scan(obj);
    }
};

/**Enum representing the type of change that was observed in an ObjectObserver.
 @enum*/
EVUI.Modules.Observers.ObservedObjectChangeType =
{
    /**Default. No change observed.*/
    None: "none",
    /**Property was added.*/
    Added: "added",
    /**Property was removed.*/
    Removed: "removed",
    /**Property value was changed.*/
    Changed: "changed"
};
Object.freeze(EVUI.Modules.Observers.ObservedObjectChangeType);

/**Object representing a property that was added, removed, or changed in an observed object.
@class*/
EVUI.Modules.Observers.ObservedChangedProperty = function ()
{
    /**Object. The object that contains the property.
    @type {Object}*/
    this.hostObject = null;

    /**String. The name of the property.
    @type {String}*/
    this.name = null;

    /**Any. The original value of the property.
    @type {Any}*/
    this.originalValue = null;

    /**Any. The new value of the property.
    @type {Any}*/
    this.newValue = null;

    /**String. The path from the root to the current property in the object hierarchy.
    @type {String}*/
    this.path = null;

    /**String. The type of change that occurred. A value from the ObservedObjectChangeType enum.
    @type {String}*/
    this.type = EVUI.Modules.Observers.ObservedObjectChangeType.None;
};

/**Represents a property of an object.
@class*/
EVUI.Modules.Observers.ObservedProperty = function ()
{
    /**Object. The object that contains the property.
    @type {Object}*/
    this.hostObject = null;

    /**String. The name of the property.
    @type {String}*/
    this.name = null;

    /**Any. The original value of the property.
    @type {Any}*/
    this.originalValue = null;

    /**String. The path from the root to the current property in the object hierarchy.*/
    this.path = null;

    /**Object. A "dictionary" of property names to ObservedProperties that contains the child properties of the object this ObservedProperty represents (if it is an object).
    @type {Object}*/
    this.propDic = null;

    /**Array. An array of all the property names in the propDic. Exists so that the propDic doesn't need to be iterated over in a for...in loop.
    @type {String[]}*/
    this.propList = null;

    /**Number. The number of properties that this object contains. Exists so that the length of propList doesn't need to be calculated over and over.
    @type {Number}*/
    this.numProps = 0;
};

/**Gets a child ObservedProperty of this observed property based on its property path.
@param {String} path The path from the root object to a child object, i.e. "a.b[c].d"
@returns {EVUI.Modules.Observers.ObservedProperty} */
EVUI.Modules.Observers.ObservedProperty.prototype.getChild = function (path)
{
    if (typeof path !== "string") return null;

    var segments = EVUI.Modules.Core.Utils.getValuePathSegments(path);
    var numSegs = segments.length;
    var child = this.propDic[segments[0]];
    if (child == null) return null;

    for (var x = 1; x < numSegs; x++)
    {
        child = child.propDic[segments[x]];
        if (child == null) return null;
    }

    return child;
};

/**Determines whether or not the ObservedProperty has had its value changed since it was generated.
@returns {Boolean}*/
EVUI.Modules.Observers.ObservedProperty.prototype.hasChanged = function ()
{
    if (this.hostObject == null) return true;
    return (this.originalValue !== this.hostObject[this.name]);
};

/**Determines whether or not the ObservedProperty's child properties have had any of their values changed since the parent ObservedProperty was generated.
@param {Boolean} recursive Whether or not to recursively search all child ObservedProperties of this ObservedProperty for changes.
@returns {Boolean}*/
EVUI.Modules.Observers.ObservedProperty.prototype.haveChildrenChanged = function (recursive)
{
    if (this.hostObject == null) return true;
    if (this.numProps === 0) return false;

    var parentObj = this.originalValue;
    var props = EVUI.Modules.Core.Utils.getProperties(parentObj);
    var numProps = props.length;

    for (var x = 0; x < numProps; x++) //for (var prop in parentObj)
    {
        var prop = props[x];

        var curProp = this.propDic[prop];
        if (curProp == null) return true;

        if (recursive === true)
        {
            var childrenChanged = curProp.haveChildrenChanged(true);
            if (childrenChanged === true) return true;
        }
        else
        {
            if (curProp.hasChanged() === true) return true;
        }
    }

    return false;
};

/**Gets the current value of the ObservedProperty.
@returns {Any}*/
EVUI.Modules.Observers.ObservedProperty.prototype.getCurrentValue = function ()
{
    if (this.hostObject == null) return undefined;
    return this.hostObject[this.name];
};

/**A specialized observer that watches an array and reports back structural changes in the array's indexed element values or object references (but not the properties of the referenced objects).
@param {Array} arr The array to observe for changes in the indexed values.
@class*/
EVUI.Modules.Observers.ArrayObserver = function (arr)
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Observers.Dependencies);

    /**String. Special property to "tag" objects with so that they can be looked up in a hash table instead of using indexOf to find their index in the old array.
    @type {String}*/
    var _keyHash = EVUI.Modules.Core.Utils.getHashCode(EVUI.Modules.Core.Utils.makeGuid()).toString(36);

    /**Object. A dictionary of source values and their related hash codes, used for very large strings so they don't have to be hashed over and over.
    @type {{}}*/
    var _hashCache = {};

    /**Array. The array being observed.
    @type {[]}*/
    var _observedArray = null;

    /**Array. The internal copy of the array's original structure. 
    @type {ArrayElementItem[]}*/
    var _observedElements = [];

    /**Gets all the structural changes that have been made to the values at each index in the array.
    @param {Boolean} setState Whether or not to update the observed state of the array with its current values.
    @returns {EVUI.Modules.Observers.ArrayIndexChange[]} */
    this.getChanges = function (setState)
    {
        var newEles = getElements(_observedArray);

        var diff = diffEles(_observedElements, newEles);
        if (setState === true) _observedElements = newEles;

        return diff;
    };

    /**Makes a snapshot array of ArrayElementItems based on an existing array.
    @param {Array} observedArray The array to take the snapshot of.
    @returns {ArrayElementItem[]} */
    var getElements = function (observedArray)
    {
        var observedEles = [];

        var numEles = observedArray.length;
        for (var x = 0; x < numEles; x++)
        {
            var curVal = observedArray[x];
            var eleItem = new ArrayElementItem();
            eleItem.index = x;
            eleItem.value = curVal;
            eleItem.key = getEleKey(curVal);

            observedEles.push(eleItem);
        }

        return observedEles;
    };

    /**Gets the structural differences between the old snapshot of the array and the new snapshot of the array being observed. This function is designed to work in the situation where the same key or reference is repeated in the array.
    @param {ArrayElementItem[]} oldEles The old snapshot of the array.
    @param {ArrayElementItem[]} newEles The new snapshot of the array.
    @returns {EVUI.Modules.Observers.ArrayIndexChange[]} */
    var diffEles = function (oldEles, newEles)
    {
        var existingKeys = {}; //lookup table for sets of elements with the same key and their indexes
        var adds = {}; //all of ArrayChanges for added elements by their new index
        var removes = {}; //all of the ArrayChanges for removed elements by their old index
        var tagged = []; //array of all the objects that got a tag attached to them
        var byReference = []; //array of all the objects or "reference" types (functions, objects, symbols) that could not be tagged.
        var all = []; //array of all ArrayElementCollections in the diff operation
        var changes = []; //the final change array to return
        
        var numOld = oldEles.length;
        var newObserved = newEles.length;

        //build a dictionary of all old keys
        for (var x = 0; x < numOld; x++)
        {
            var curOld = oldEles[x];
            if (curOld.key == null) //key is null - this means it was an object, function, or symbol we haven't encountered yet
            {
                if (Object.isExtensible(curOld.value) === true) //if we can tag the object, tag it with a key so we can look it up based on its key and not its reference
                {
                    if (curOld.value[_keyHash] === undefined) //no key yet
                    {
                        var tag = Math.random().toString(36); //make a random number key and tag the object with it temporarily
                        curOld.value[_keyHash] = tag; 
                        curOld.key = tag;

                        tagged.push(curOld); //add to array of tagged elements so we know to remove it later
                    }
                    else //already had a key - assign it to the old observed item
                    {
                        curOld.key = curOld.value[_keyHash];
                    }
                }
                else //either a sealed/frozen object, a symbol, or a function
                {
                    var collection = getElementCollectionByReference(curOld, byReference); //look for it by reference
                    if (collection == null)
                    {
                        collection = new ArrayElementCollection();
                        collection.value = curOld.value;
                        byReference.push(collection); //didn't find one, add it
                    }

                    //add the item to the collection of items at the reference
                    collection.indexes[x] = curOld;
                    collection.items.push(curOld);
                    collection.numItems++;
                    all.push(collection); //add the collection to the list of all collections made

                    continue;
                }
            }

            //see if the key already exists in the dictionary
            var collection = existingKeys[curOld.key];
            if (collection == null) //it did not - make a new collection and add it to the dictionary
            {
                collection = new ArrayElementCollection();
                collection.value = curOld.value;
                collection.key = curOld.key;
                existingKeys[curOld.key] = collection;
            }

            //add the item to the collection of items with the same key
            collection.items.push(curOld);
            collection.indexes[x] = curOld;
            collection.numItems++;
            all.push(collection);
        }

        //walk whichever array is longest
        var longer = (numOld > newObserved) ? numOld : newObserved;
        for (var x = 0; x < longer; x++)
        {
            var curNew = newEles[x];
            var existing = null;

            if (curNew != null) //if we haven't run off the end of the new array image yet, look for its value in the old array
            {
                existing = getElementCollection(curNew.key, existingKeys);
                if (existing == null) //didn't find it based on a pure key lookup, try looking it up based on its tag if possible
                {
                    var tag = curNew.value[_keyHash];
                    if (tag != null)
                    {
                        existing = getElementCollection(tag, existingKeys);
                    }

                    if (existing == null) //didn't find it based on its tag - look for it by reference if it is one of our special reference types
                    {
                        var type = typeof curNew.value;
                        if (type === "object" || type === "function" || type === "symbol")
                        {
                            existing = getElementCollectionByReference(curNew, byReference);
                        }
                    }
                }

                if (existing == null) //not in the old array - it is a new item
                {
                    var addedChange = new EVUI.Modules.Observers.ArrayIndexChange();
                    addedChange.changeType = EVUI.Modules.Observers.ArrayChangeType.Added;
                    addedChange.newIndex = x;
                    addedChange.oldIndex = -1;
                    addedChange.value = curNew.value;

                    changes.push(addedChange);
                    adds[x] = addedChange;
                    continue;
                }
            }

            if (existing != null) //found the element in the old array somewhere
            {
                existing.found = true;

                //item was in the old array, figure out what happened to it
                var change = getArrayChangeType(existing, curNew);
                if (change == null) continue;

                if (change.changeType === EVUI.Modules.Observers.ArrayChangeType.Added)
                {
                    adds[x] = change;
                }

                changes.push(change);
            }
        }

        //walk all the collections made for the old array image and mark anything that wasn't found as removed
        var oldTotal = all.length;
        for (var x = 0; x < oldTotal; x++)
        {
            var curOld = all[x];
            if (curOld.found === false)
            {
                for (var y = 0; y < curOld.numItems; y++)
                {
                    var removedChange = new EVUI.Modules.Observers.ArrayIndexChange();
                    removedChange.changeType = EVUI.Modules.Observers.ArrayChangeType.Removed;
                    removedChange.newIndex = -1;
                    removedChange.oldIndex = curOld.items[y].index;
                    removedChange.value = curOld.value;

                    changes.push(removedChange);
                    removes[removedChange.oldIndex] = removedChange;
                }
            }
        }

        //walk all of the changes that were found and do some logic to see if the element was simply "shifted" up or down in the array based on an add or remove somewhere else. We have to do this at the end because we don't know what was removed as we go through the array the first time.
        var delta = 0;
        var numChanges = changes.length;
        for (x = 0; x < numChanges; x++)
        {
            var curChange = changes[x];

            if (curChange.changeType !== EVUI.Modules.Observers.ArrayChangeType.Moved) continue; //the below only applies to moved elements

            var wasAdd = adds[x] != null;
            var wasRemoved = removes[x] != null;

            if (wasAdd === true && wasRemoved === true) continue; //we both added and removed something at that index, so no "shifting" has happened
            if (wasAdd === true) delta++;
            if (wasRemoved === true) delta--;

            if (curChange.newIndex === curChange.oldIndex + delta) curChange.changeType = EVUI.Modules.Observers.ArrayChangeType.Shifted;
        }

        //finally, walk all the tagged items and remove their keys and tags so we restore the original state of the observed list and objects
        var numTagged = tagged.length;
        for (var x = 0; x < numTagged; x++)
        {
            var taggedItem = tagged[x];

            taggedItem.key = null;
            delete taggedItem.value[_keyHash];
        }

        return changes;
    };

    /**Gets an ArrayElementCollection based on its key.
    @param {String} key The key of the ArrayElementCollection to find.
    @param {Object} existingKeys The dictionary of ArrayElementCollections organized by key.
    @returns {ArrayElementCollection}*/
    var getElementCollection = function (key, existingKeys)
    {
        if (existingKeys == null) return undefined;
        return existingKeys[key];
    };

    /**Walks an array ArrayElementCollections looking for a value with the same reference.
    @param {ArrayElementItem} arrayItem The item to find.
    @param {ArrayElementCollection[]} referenceList The list of references the value could be in.
    @returns {ArrayElementCollection}*/
    var getElementCollectionByReference = function (arrayItem, referenceList)
    {
        var numRef = referenceList.length;
        for (var x = 0; x < numRef; x++)
        {
            var curRef = referenceList[x];
            if (curRef.value === arrayItem.value)
            {
                return curRef;
            }
        }

        return null;
    };

    /**Gets a unique key for an element in an array based on the element's value. Reference types (objects, functions, symbols) return null.
    @param {Any} val The value to get the key for.
    @returns {String}*/
    var getEleKey = function (val)
    {
        var valType = typeof val;

        if (val === null)
        {
            return "null";
        }
        else if (val === undefined)
        {
            return "undefined";
        }
        else
        {
            if (valType === "object" || valType === "symbol" || valType === "function") return null; //cant identify any of these with a string key, so return nothing.
            val = val.toString();
        }

        var hashKey = valType + "-" + val;
        if (hashKey.length > 43) //just long enough for "string-[GUID]" - any string longer than this gets hashed instead of being used as a key directly (this is to prevent against gigantic string keys in the lookup table)
        {
            var existing = _hashCache[hashKey];
            if (existing == null)
            {
                existing = EVUI.Modules.Core.Utils.getHashCode(hashKey).toString(36); //get the base36 of the huge key
                _hashCache[existing] = hashKey;
            }

            hashKey = existing;
        }

        return hashKey;
    };

    /**Gets an ArrayChangeType based on the circumstances of the changes in the observed array.
    @param {ArrayElementCollection} arrayCollection The existing collection of items with the same value or reference.
    @param {ArrayElementItem} arrayItem The item with the same value or reference
    @returns {String}*/
    var getArrayChangeType = function (arrayCollection, arrayItem)
    {
        var change = new EVUI.Modules.Observers.ArrayIndexChange();
        change.newIndex = arrayItem.index;
        change.value = arrayItem.value;

        if (arrayCollection.indexes[arrayItem.index] != null) //the item was in one of its old slots - no change
        {
            delete arrayCollection.indexes[arrayItem.index]; //remove the item from the dictionary so that it can't match again
            for (var x = 0; x < arrayCollection.numItems; x++)
            {
                if (arrayCollection.items[x].index === arrayItem.index)
                {
                    arrayCollection.items.splice(x, 1);
                    arrayCollection.numItems--;
                }
            }

            return null; //no change to report
        }

        //nothing else in the collection - it got added
        if (arrayCollection.numItems === 0)
        {
            change.oldIndex = -1;
            change.changeType = EVUI.Modules.Observers.ArrayChangeType.Added;

            return change
        }
        else //otherwise, it got moved to a new index
        {
            change.oldIndex = arrayCollection.items[0].index;
            change.changeType = EVUI.Modules.Observers.ArrayChangeType.Moved;
            arrayCollection.items.splice(1, 0);
            arrayCollection.numItems--;

            delete arrayCollection.indexes[change.oldIndex];

            return change;
        }
    };

    /**Represents a snapshotted element of an array.
    @class*/
    var ArrayElementItem = function ()
    {
        /**Number. The index of the element in the array.
        @type {Number}*/
        this.index = -1;

        /**Any. The value at the index in the source array.
        @type {Any}*/
        this.value = null;

        /**String. A unique key for this value if it is not an object, function, or symbol reference.
        @type {String}*/
        this.key = null;
    };

    /**Represents a collection of items with the same key at different indexes in the same array.
    @class*/
    var ArrayElementCollection = function ()
    {
        /**Any. The value that is being referenced by possibly more than one element in the array.
        @type {Any}*/
        this.value = null;

        /**String. A unique key to refer to this collection by. Will either be based on the value of the element or a random string for an object.
        @type {String}*/
        this.key = null;

        /**Object. Dictionary of all the indexes where an element with the same key exists in the array matched to an ArrayElementItem of what is at the given index.
        @type {Object}*/
        this.indexes = {};

        /**Array. The array of all the ArrayElementItems with the same key.
        @type {ArrayElementItem[]}*/
        this.items = [];

        /**Number. The number of items in the items array.
        @type {Number}*/
        this.numItems = 0;

        /**Boolean. Whether or not this collection's key was found in the new array.
        @type {Boolean}*/
        this.found = false;
    };

    if (EVUI.Modules.Core.Utils.isArray(arr) === false) throw Error("Array expected.");

    _observedArray = arr;
    _observedElements = getElements(arr);
};

/**The type of change that was observed in the structure of an array.
@enum*/
EVUI.Modules.Observers.ArrayChangeType =
{
    /**Default. No changes made to an item at a given index.*/
    None: "none",
    /**Item was added to the array.*/
    Added: "add",
    /**Item was removed from the array.*/
    Removed: "remove",
    /**Item was moved from one index to another.*/
    Moved: "move",
    /**Item was shifted up or down in the array in response to other elements before it being added or removed.*/
    Shifted: "shift",
};
Object.freeze(EVUI.Modules.Observers.ArrayChangeType);

/**Object representing a change in the element or reference at a given index in an array.
@class*/
EVUI.Modules.Observers.ArrayIndexChange = function ()
{
    /**Number. The original index of the value in the array.
    @type {Number}*/
    this.oldIndex = -1;

    /**Number. The new index of the value in the array.
    @type {Number}*/
    this.newIndex = -1;

    /**Any. The value in the array that had its index change.
    @type {Any}*/
    this.value = null;

    /**String. A value from the ArrayChangeType enum indicating what type of index change was made to the element.
    @type {String}*/
    this.changeType = EVUI.Modules.Observers.ArrayChangeType.None;
};

/**Observes an object from the time it was passed into the ObjectObserver to when the ObjectOverver's getChanges function is called.   
@param {Object} obj Any user-defined plain object.
@returns {EVUI.Modules.Observers.ObjectObserver} */
$evui.observe = function (obj)
{
    return new EVUI.Modules.Observers.ObjectObserver(obj);
};

/**Observes an array for structural changes from the time it was passed into the ArrayObserver to when the ArrayObserver's getChanges function is called.
@param {Array} arr Any array to observe.
@returns {EVUI.Modules.Observers.ArrayIndexObserver}*/
$evui.observeArray = function (arr)
{
    return new EVUI.Modules.Observers.ArrayObserver(arr);
};

/*#ENDWRAP(Observer)#*/


/********************************************************Panes.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.Panes|Pane)#*/
/*#REPLACE(EVUI.Modules.Panes|Pane)#*/

/**Module for containing a generic, lazy-loaded, EventStream powered UI component that sits on top of other components rather than being injected into the document flow.
@module*/
EVUI.Modules.Panes = {};

/*#MODULEDEF(Pane|"1.0";|"Pane")#*/
/*#VERSIONCHECK(EVUI.Modules.Panes|Pane)#*/

EVUI.Modules.Panes.Constants = {};

/**Function for selecting a PaneEntry object. Return true to select the PaneEntry parameter as part of the result set.
@param {EVUI.Modules.Panes.Pane} pane The PaneEntry providing metadata about a Pane object.
@returns {Boolean}*/
EVUI.Modules.Panes.Constants.Fn_PaneSelector = function (pane) { return true; }

/**Function for selecting a PaneEntry object. Return true to select the PaneEntry parameter as part of the result set.
@param {EVUI.Modules.Panes.PaneEntry} paneEntry The PaneEntry providing metadata about a Pane object.
@returns {Boolean}*/
EVUI.Modules.Panes.Constants.Fn_PaneEntrySelector = function (paneEntry) { return true; }

/**Function for reporting whether or not a Pane was successfully Loaded.
@param {Boolean} success Whether or not the load operation completed successfully.*/
EVUI.Modules.Panes.Constants.Fn_LoadCallback = function (success) { };

/**Function for reporting whether or not an operation Pane was successful.
@param {Boolean} success Whether or not the operation completed successfully.*/
EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback = function (success) { };

EVUI.Modules.Panes.Constants.CSS_Position = "evui-position";
EVUI.Modules.Panes.Constants.CSS_ClippedX = "evui-clipped-x";
EVUI.Modules.Panes.Constants.CSS_ClippedY = "evui-clipped-y";
EVUI.Modules.Panes.Constants.CSS_ScrollX = "evui-scroll-x";
EVUI.Modules.Panes.Constants.CSS_ScrollY = "evui-scroll-y"
EVUI.Modules.Panes.Constants.CSS_Flipped = "evui-flipped";
EVUI.Modules.Panes.Constants.CSS_Moved = "evui-moved";
EVUI.Modules.Panes.Constants.CSS_Resized = "evui-resized";
EVUI.Modules.Panes.Constants.CSS_Backdrop = "evui-backdrop";
EVUI.Modules.Panes.Constants.CSS_Transition_Show = "evui-transition-show";
EVUI.Modules.Panes.Constants.CSS_Transition_Hide = "evui-transition-hide";
EVUI.Modules.Panes.Constants.CSS_Transition_Adjust = "evui-transition-adjust";

/**String. The name of the ID attribute for the Pane, used to look up a definition of a Pane.
@type {String}*/
EVUI.Modules.Panes.Constants.Attribute_ID = "evui-pane-id";

/**String. The name of the attribute that signifies which element should receive initial focus when the Pane is displayed.
@type {String}*/
EVUI.Modules.Panes.Constants.Attribute_Focus = "evui-pane-focus";

/**String. The name of the attribute that signifies that a click event on the Element should close the Pane.
@type {String}*/
EVUI.Modules.Panes.Constants.Attribute_Close = "evui-pane-close";

/**String. The name of the attribute that signifies that a drag event on the Element should move the Pane.
@type {String}*/
EVUI.Modules.Panes.Constants.Attribute_Drag = "evui-pane-drag-handle";

/**String. The name of the attribute on an element that triggers the showing of a Pane what the URL to get the Pane's HTML from is (Requires EVUI.Modules.Http).
@type {String}*/
EVUI.Modules.Panes.Constants.Attribute_SourceURL = "evui-pane-src";

/**String. The name of the attribute on an element that triggers the showing of a Pane of what placeholder to load for the Pane's HTML (Requires EVUI.Modules.HtmlLoaderController).
@type {String}*/
EVUI.Modules.Panes.Constants.Attribute_PlaceholderID = "evui-pane-placeholder-id";

/**String. The name of the attribute on an element that triggers the showing or hiding of a Pane whether or not the Pane should be unloaded when it is hidden.
@type {String}*/
EVUI.Modules.Panes.Constants.Attribute_UnloadOnHide = "evui-pane-unload";

/**String. The name of the attribute on an element that triggers the showing or hiding of a Pane that is used to indicate special behavior as defined by a consumer of the Pane.
@type {String}*/
EVUI.Modules.Panes.Constants.Attribute_Context = "evui-pane-cxt";

/**String. The name of the attribute on an element that triggers the showing of a Pane what CSS selector to use to find the element to show as the Pane. Only the first result will be used.
@type {String}*/
EVUI.Modules.Panes.Constants.Attribute_Selector = "evui-pane-selector";

/**String. The name of the attribute on an element that triggers the showing of a Pane that specifies any of the properties contained in the PaneShowSettings object. It is highly advised to define this object in actual code with the Pane definition or show arguments instead of using this attribute.

Properties must be separated with semicolons and the key-value pairs must be separated by a colon. Dot qualifiers are be used to drill into sub-objects of the PaneShowSettings object (or its child objects) and properties which take an Element reference must instead take a CSS selector. Strings must be surrounded in single-quotes. Quotes within quotes must be escaped single quotes (\').

The value that follows the colon will be parsed as JSON, i.e. "showTransition.css:{'someCssKey':'someValue'}" is valid, but "showTransition.css:{someCssKey:'someValue'}" is not.

For example, "absolutePosition.x: 123; absolutePosition.y: 456" would set the absolute position of the Pane at (123, 456) in the document. 

As another example, "relativePosition.element: '#myElement'; clipSettings.clipBounds.top: 123; clipSettings.clipBounds.left: 456; clipSettings.mode:'shift';" would position the Pane around the element that matches the #myElement selector and would be */
EVUI.Modules.Panes.Constants.Attribute_ShowSettings = "evui-pane-show-settings";

EVUI.Modules.Panes.Constants.Event_OnShow = "evui.pane.onshow";
EVUI.Modules.Panes.Constants.Event_OnHide = "evui.pane.onhide";
EVUI.Modules.Panes.Constants.Event_OnUnload = "evui.pane.onunload";
EVUI.Modules.Panes.Constants.Event_OnLoad = "evui.pane.onload";

EVUI.Modules.Panes.Constants.Event_OnShown = "evui.pane.onshown";
EVUI.Modules.Panes.Constants.Event_OnOnHidden = "evui.pane.onhidden";
EVUI.Modules.Panes.Constants.Event_OnLoaded = "evui.pane.onloaded";
EVUI.Modules.Panes.Constants.Event_OnUnloaded = "evui.pane.onunloaded";

EVUI.Modules.Panes.Constants.Event_OnInitialize = "evui.pane.oninit";
EVUI.Modules.Panes.Constants.Event_OnPosition = "evui.pane.onposition";

EVUI.Modules.Panes.Constants.Job_OnComplete = "evui.pane.oncomplete";

EVUI.Modules.Panes.Constants.Default_ObjectName = "Pane";
EVUI.Modules.Panes.Constants.Default_ManagerName = "PaneManager";
EVUI.Modules.Panes.Constants.Default_CssPrefix = "evui-pane";
EVUI.Modules.Panes.Constants.Default_EventNamePrefix = "evui.pane";
EVUI.Modules.Panes.Constants.Default_AttributePrefix = "evui-pane";

/**The global Z-index reference for all objects that use the pane manager to determine their z-index.
@type {Number}*/
EVUI.Modules.Panes.Constants.GlobalZIndex = null;

(function()
{
    var globalZIndex = null;
    Object.defineProperty(EVUI.Modules.Panes.Constants, "GlobalZIndex",
    {
        get: function () { return globalZIndex; },
        set: function (value)
        {
            if (typeof value !== "number") return;
            if (value < 0)
            {
                globalZIndex = 0
            }
            else
            {
                globalZIndex = value;
            }
        },
        configurable: false,
        enumerable: true
    });
})();

Object.freeze(EVUI.Modules.Panes.Constants);

EVUI.Modules.Panes.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
    EventStream: Object.freeze({ version: "1.0", required: true }),
    Styles: Object.freeze({ version: "1.0", required: true }),
    Dom: Object.freeze({ version: "1.0", required: true }),
    Observers: Object.freeze({ version: "1.0", required: true}),
    HtmlLoader: Object.freeze({ version: "1.0", required: false }),
    Http: Object.freeze({ version: "1.0", required: false })
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.Panes.Dependencies, "checked",
    {
        get: function () { return checked; },
        set: function (value)
        {
            if (typeof value === "boolean") checked = value;
        },
        configurable: false,
        enumberable: true
    });
})();

Object.freeze(EVUI.Modules.Panes.Dependencies);

/**Class for managing an implementation of Pane objects.
@class*/
EVUI.Modules.Panes.PaneManager = function (paneManagerSettings)
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Panes.Dependencies);

    if (EVUI.Modules.Panes.Constants.GlobalZIndex == null)
    {
        var minZIndex = EVUI.Modules.Core.Utils.getSetting("defaultMinimumZIndex");
        if (typeof minZIndex !== "number") minZIndex = 100;

        EVUI.Modules.Panes.Constants.GlobalZIndex = minZIndex;
    }

    var _self = this; //self reference for closures

    /**Number used to organize the sequence of callbacks when it is otherwise ambiguous.
    @type {Number}*/
    var _callbackCounter = 0;

    /**Array. Internal list for all Widows.
    @type {InternalPaneEntry[]}*/
    var _entries = [];

    /**Object. Special settings for the PaneManager to use.
    @type {EVUI.Modules.Panes.PaneManagerSettings}*/
    var _settings = paneManagerSettings;

    /**Object. The backdrop manager used by the PaneManager.
    @type {Function}*/
    var _managerConstructor = (typeof paneManagerSettings === "function") ? paneManagerSettings : EVUI.Modules.Panes.PaneManager;

    /**Special object injected into the public facing PaneEntry that contains all of the writable versions of the public version's read-only data.
    @class*/
    var PaneLink = function ()
    {
        /**Object. The Pane being managed.
        @type {EVUI.Modules.Panes.Pane}*/
        this.pane = null;

        /**Object. The wrapper object that the _settings object created for a custom implementation of the PaneManager.
        @type {Object}*/
        this.wrapper = null;

        /**String. A unique identifier for the pane instance used for the positioning CSS class name.
        @type {String}*/
        this.paneCSSName = null;

        /**Object. The EventStream doing the work of the operations for the Pane.
        @type {EVUI.Modules.EventStream.EventStream}*/
        this.eventStream = null;

        /**Number. Bit flags indicating the current state of the Pane (initialized, loaded, etc).
        @type {Number}*/
        this.paneStateFlags = EVUI.Modules.Panes.PaneStateFlags.None;

        /**String. The current operation the pane is performing (loading, unloading, hiding, showing, etc).
        @type {String}*/
        this.paneAction = EVUI.Modules.Panes.PaneAction.None;

        /**Array. The sequence of all PaneActions the Pane must perform to reach its final action.
        @type {String[]}*/
        this.paneActionSequence = [];

        /**Array. An array of all the elements and their event handlers that have been attached in response to the automatically attached event handlers.
        @type {EVUI.Modules.Panes.PaneEventBinding[]}*/
        this.eventBindings = [];

        /**The PaneManager that owns this pane.
        @type {EVUI.Modules.Panes.PaneManager}*/
        this.manager = null;

        /**String. A special token that is shared between the manager and the Pane object that allows for the setting of the pane's element property.
        @type {String}*/
        this.setSecret = EVUI.Modules.Core.Utils.makeGuid();

        /**Object. A queue of all the callbacks that have been issued during the current operation.
        @type {CallbackStack[]}*/
        this.callbackStack = [];

        /**Object. The last calculated position of the Pane.
        @type {EVUI.Modules.Panes.PanePosition}*/
        this.lastCalculatedPosition = null;

        /**Object. The last set of ShowSettings used to position the Pane.
        @type {EVUI.Modules.Panes.PaneShowSettings}*/
        this.lastShowSettings = null;

        /**Object. The last set of load settings used to load the Pane.
        @type {EVUI.Modules.Panes.PaneLoadSettings}*/
        this.lastLoadSettings = null;

        /**Object. The last used set of resize settings used to position the Pane.
        @type {EVUI.Modules.Panes.PaneResizeMoveArgs}*/
        this.lastResizeArgs = null;

        /**Number. The ID of the callback that is being used to toggle off a transition effect.
        @type {Number}*/
        this.transitionTimeoutID = -1;

        /**String. The selector used to attach to the element that caused a transition CSS action to occur.
        @type {String}*/
        this.transitionSelector = null;

        /**Function. The callback that will be called when the timeout completes or is canceled.
        @type {Function}*/
        this.transitionCallback = null;
    };

    /**Special object that is passed from a Pane object to the canSetElement function when someone attempts to set the element property on a Pane.
    @class*/
    var PaneElementSetter = function ()
    {
        /**Object. The value to set as the Pane element.
        @type {Element}*/
        this.element = null;

        /**String. The unique identifier of the Pane having its element set.
        @type {String}*/
        this.paneID = null;

        /**String. A special token that is shared between the manager and the Pane object that allows for the setting of the pane's element property.
        @type {String}*/
        this.setSecret = null;
    };

    /**Data to inject into the Pane object via its constructor to give it access to its PaneLink, PaneManager, and the private canSetElementFunction.
    @class*/
    var PaneOptions = function ()
    {
        /**Object. The private state of the Pane object that is shared between the Pane and the manager.
        @type {PaneLink}*/
        this.link = null;

        /**The function that determines whether or not a Pane can have its element reset.
        @type {Function}*/
        this.canSetElement = canSetElement;
    };

    /**Internal record for keeping track of Panes.
    @class*/
    var InternalPaneEntry = function ()
    {
        /**String. The case-normalized unique ID of the pane.
        @type {String}*/
        this.lowerPaneID = null;

        /**String. The unique ID of the pane.
        @type {String}*/
        this.paneID = null;

        /**Object. The public facing PaneEntry record.
        @type {EVUI.Modules.Panes.PaneEntry}*/
        this.publicEntry = null;

        /**Object. The internal read-write source of data for the public facing PaneEntry record.
        @type {PaneLink}*/
        this.link = null;
    };

    /**Object for keeping track of all the callbacks issued to an operation during redundant calls to that operation.
    @class*/
    var CallbackStack = function ()
    {
        /**Array. All of the operation sessions queued for the action.
        @type {PaneOperationSession[]}*/
        this.opSessions = [];


        /**String. The action that was issued to be performed.
        @type {String}*/
        this.action = EVUI.Modules.Panes.PaneAction.None;
    };

    /**The result of creating or extending a Pane object.
    @class*/
    var PaneExtensionResult = function ()
    {
        /**Boolean. Whether or not a Pane with the given ID already exists.
        @type {Boolean}*/
        this.exists = false;

        /**Object. The InternalPaneEntry for the Pane.
        @type {InternalPaneEntry}*/
        this.entry = null;

        /**Object. The Pane object that was created or extended.
        @type {EVUI.Modules.Panes.Pane}*/
        this.pane = null;
    };

    /**Represents all the data about a given operation at a moment in time.
    @class*/
    var PaneOperationSession = function ()
    {
        /**String. The unique identifier of this operation session.
        @type {String}*/
        this.sessionID = EVUI.Modules.Core.Utils.makeGuid();

        /**Object. The InternalPaneEntry of the pane.
        @type {InternalPaneEntry}*/
        this.entry = null;

        /**String. The original action that was being performed.
        @type {String}*/
        this.action = null;

        /**String. The current action that is being performed.
        @type {String}*/
        this.currentAction = null;

        /**Function. An callback to call once the operation is complete.
        @type {Function}*/
        this.callback = null;

        /**The arguments being used to show/load the Pane
        @type {EVUI.Modules.Panes.PaneShowArgs} */
        this.showArgs = null;

        /**The arguments being used to load the Pane
        @type {EVUI.Modules.Panes.PaneLoadArgs} */
        this.loadArgs = null;

        /**The arguments being used to hide the Pane.
        @type {EVUI.Modules.Panes.PaneHideArgs}*/
        this.hideArgs = null;

        /**The arguments being used to hide the Pane.
        @type {EVUI.Modules.Panes.PaneUnloadArgs}*/
        this.unloadArgs = null;

        /**Boolean. Whether or not the EventStream should be canceled then restarted with a new chain of events.
        @type {Boolean}*/
        this.cancel = false;

        /**Boolean. Whether or not the EventStream should have a callback added to the current action's callback stack due to multiple calls that are part of the same process. (i.e. a load then a show, the show would continue the load.)
        @type {Boolean}*/
        this.continue = false;

        /**Boolean. Whether or not this event was canceled sometime between when it was queued to run and when it actually ran.
        @type {Boolean}*/
        this.canceled = false;

        /**The step that this step continued on to if there was a continuation.
        @type {PaneOperationSession}*/
        this.continuedTo = null;

        /**Number. The sort order in which this operation's callback will be called.
        @type {Number}*/
        this.callbackOrdinal = _callbackCounter++;

        /**Any. The foreign event arguments passed into the PaneManager by a consumer of the PaneManager.
        @type {EVUI.Modules.Panes.PaneArgsPackage}*/
        this.foreignActionArgs = null;

        /**Makes a PaneArgsPackage to pass into the overridden functions on the PaneManagerSettings object.
        @returns {EVUI.Modules.Panes.PaneArgsPackage}*/
        this.makeArgsPackage = function (context)
        {
            var argsPackage = new EVUI.Modules.Panes.PaneArgsPackage(context);

            argsPackage.foreignArgs = this.foreignActionArgs;
            if (argsPackage.foreignArgs == null && _settings.managerName !== EVUI.Modules.Panes.Constants.Default_ManagerName) EVUI.Modules.Core.Utils.wrapProperties(argsPackage, this, { sourcePath: "foreignActionArgs", targetPath: "foreignActionArgs" });

            argsPackage.hideArgs = this.hideArgs;
            argsPackage.loadArgs = this.loadArgs;
            argsPackage.showArgs = this.showArgs;
            argsPackage.unloadArgs = this.unloadArgs;
            argsPackage.action = this.action;
            argsPackage.currentAction = this.currentAction;
            argsPackage.context = context;
            argsPackage.pane = this.entry.link.pane;
            argsPackage.wrapper = this.entry.link.wrapper;
            argsPackage.lastCalculatedPosition = this.entry.link.lastCalculatedPosition;

            return argsPackage;
        }
    };

    /**Values for determining the sequence of actions the Pane should take. Each step maps to the addition EventStream steps or to behavioral changes when starting, stopping, or continuing the execution of a Pane.
    @enum*/
    var ActionSequence =
    {
        /**Default. No action taken.*/
        None: "none",
        /**Signals that the initialize event should be added.*/
        Initialize: "init",
        /**Signals that the load steps should be added.*/
        Load: "load",
        /**Signals that the show and position steps should be added.*/
        Show: "show",
        /**Signals that the hide steps should be added */
        Hide: "hide",
        /**Signals that the unload steps should be added.*/
        Unload: "unload",
        /**Signals that the positioning step should be added (without the corresponding show steps, used for redundant shows when a Pane is already showing).*/
        Position: "position",
        /**Signals that the current EventStream should be canceled and its callbacks should be called.*/
        CancelCurrent: "cancel",
        /**Signals that a new EventStream should follow the first and have an aggregate callback sequence of both events.*/
        Continue: "continue",
        /**Signals that the callback has been queued (which is automatic) and nothing else should happen.*/
        Queue: "queue"
    };

    /**Object for managing the backdrop used by Panes.
    @class*/
    var BackdropManager = function ()
    {
        var _self = this;

        /**Object representing a pairing of an object's class name to its Z-Index.
        @class*/
        var ZIndexEntry = function (objectName, zIndex)
        {
            /**String. The name of the object in its PaneManager.
            @type {String}*/
            this.objectName = objectName;

            /**Number. The Z-Index of the object's backdrop.
            @type {Number}*/
            this.zIndex = zIndex;
        };

        /**String. The ID of the backdrop element.
        @type {Number}*/
        var _backdropID = EVUI.Modules.Core.Utils.makeGuid();

        /**Object. The div that serves as the backdrop.
        @type {HTMLElement}*/
        var _backdropDiv = null;

        /**Object. The DomHelper that wraps the backdrop div.
        @type {EVUI.Modules.Dom.DomHelper}*/
        var _backdropHelper = null;

        /**Number. The ID of the callback that is being used to toggle off a transition effect.
        @type {Number}*/
        var _transitionTimeoutID = -1;

        /**Function. The callback that will be called when the timeout completes or is canceled.
        @type {Function}*/
        var _transitionCallback = null;

        /**String. The current object that has a backdrop being displayed behind it.
        @type {String}*/
        var _backdropObjectCssName = null;

        /**String. The name of the CSS style sheet that the backdrop styles go into.
        @type {String}*/
        var _backdropCSSSheetName = EVUI.Modules.Styles.Constants.DefaultStyleSheetName;

        /**All of the Z-Index entries of the elements that have a stack of backdrops.
        @type {ZIndexEntry[]}*/
        var _zIndexStack = [];

        /**Shows a backdrop for a Pane at the given z-index.
        @param {String} objectCSSName The name of the object that needs a backdrop.
        @param {EVUI.Modules.Panes.PaneBackdropSettings} backdropSettings The settings for controlling the style of the backdrop and its transition effect.
        @param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback A callback function that is fired once the show transition is complete.*/
        this.showBackdrop = function (objectCSSName, zIndex, backdropSettings, callback)
        {
            if (typeof callback !== "function") callback = function (success) { };
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(objectCSSName) === true || typeof zIndex !== "number") return callback(false);

            //first, cancel any transition that was in progress
            this.cancelTransition();

            //add or update the z-index entry
            var existingEntry = getZIndexEntry(objectCSSName);
            if (existingEntry == null)
            {
                _zIndexStack.push(new ZIndexEntry(objectCSSName, zIndex))
            }
            else
            {
                existingEntry.zIndex = zIndex;
            }

            //set the backdrop
            _backdropObjectCssName = objectCSSName;
            setBackdropShowCSS(backdropSettings, zIndex);

            //apply the transition and call back once its duration is complete.
            applyTransition(backdropSettings.backdropShowTransition, EVUI.Modules.Panes.Constants.CSS_Transition_Show, function (success)
            {
                callback(success);
            });
        };

        /**Sets the Z-Index of the backdrop to be that of the second-highest item in the z-index stack. Use when an item is being hidden and the backdrop needs to be moved backwards in the z-order to allow for things it was covering to be seen again.*/
        this.setBackdropZIndex = function ()
        {
            var current = getZIndexEntry(_backdropObjectCssName);

            var next = getNextHighestZIndex(current);
            if (next == null) return;

            _settings.stylesheetManager.removeRules(_backdropCSSSheetName, getDefaultCssSelector(current.objectName));
            _settings.stylesheetManager.setRules(_backdropCSSSheetName, getDefaultCssSelector(_backdropObjectCssName), { zIndex: next.zIndex });
        };

        /**Hides the backdrop.
        @param {String} objectCSSName The name of the object the backdrop is being hidden for.
        @param {EVUI.Modules.Panes.PaneBackdropSettings} backdropSettings The settings for how to hide the backdrop.
        @param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback A callback that is fired once the hide transition is complete.*/
        this.hideBackdrop = function (objectCSSName, backdropSettings, callback)
        {
            if (typeof callback !== "function") callback = function (success) { };
            if (backdropSettings == null) return callback(false);

            //cancel any transition that is currently happening
            this.cancelTransition();

            _backdropObjectCssName = objectCSSName;

            //apply the removal transition, then actually remove the backdrop. The Pane is "racing" (the PaneManager waits for both to complete before continuing) the transition and is being hidden at the same time as the transition is being applied.
            applyTransition(backdropSettings.backdropHideTransition, EVUI.Modules.Panes.Constants.CSS_Transition_Hide, function (success)
            {
                //remove the z-index entry
                var entry = getZIndexEntry(objectCSSName);
                var index = _zIndexStack.indexOf(entry);
                if (index !== -1) _zIndexStack.splice(index, 1);

                //hide the backdrop
                setBackdropHideCSS();
                callback(success);
            });
        };

        /**Cancels any current transition by calling its callback before its timer would normally call it.*/
        this.cancelTransition = function ()
        {
            if (_transitionTimeoutID === -1) return; //no callback, nothing to do

            try
            {
                //if we have a callback, call it
                if (typeof _transitionCallback === "function") _transitionCallback();
            }
            catch (ex)
            {
                EVUI.Modules.Core.Utils.log(ex.stack);
            }
            finally
            {
                //then clear out all the data about the callback
                clearTimeout(_transitionTimeoutID);
                _transitionCallback = null;
                _transitionTimeoutID = -1;
            }
        };

        /**Gets the ZIndexEntry of an object based on its name.
        @param {String} objectName The name of the object to get.
        @returns {ZIndexEntry}*/
        var getZIndexEntry = function (objectName)
        {
            var numEntries = _zIndexStack.length;
            for (var x = 0; x < numEntries; x++)
            {
                var curEntry = _zIndexStack[x];
                if (curEntry.objectName === objectName) return curEntry;
            }

            return null;
        };

        /**Gets the next highest z-index after the current entry.
        @param {ZIndexEntry} zIndexEntry The entry to get the next highest z-index of.
        @returns {ZIndexEntry} */
        var getNextHighestZIndex = function (zIndexEntry)
        {
            var lowest = null;
            var gap = Number.MAX_VALUE;

            var numEntries = _zIndexStack.length;
            for (var x = 0; x < numEntries; x++)
            {
                var curEntry = _zIndexStack[x];
                if (curEntry === zIndexEntry) continue;

                var curGap = zIndexEntry.zIndex - curEntry.zIndex;
                if (curGap < gap)
                {
                    lowest = curEntry;
                    gap = curGap;
                }
            }

            return lowest;
        };

        /**Sets the CSS for showing a full-screen backdrop, and applies any additional user-provided CSS afterwards so it overrides the default CSS.
        @param {EVUI.Modules.Panes.PaneBackdropSettings} backdropSettings The backdrop settings containing the information to use to make the backdrop.*/
        var setBackdropShowCSS = function (backdropSettings, zIndex)
        {
            //no settings or not instructed to show a backdrop, do nothing.
            if (backdropSettings == null || backdropSettings.showBackdrop === false) return false;

            //make sure our stylesheet is there
            _settings.stylesheetManager.ensureSheet(_backdropCSSSheetName, { lock: true });

            //make sure the backdrop div hasnt been removed
            ensureBackdropDiv();

            //default settings for covering the whole view port
            var defaultSettings =
            {
                position: "fixed",
                top: "0px",
                left: "0px",
                height: "100vh",
                width: "100vw",
                backgroundColor: (typeof backdropSettings.backdropColor === "string") ? backdropSettings.backdropColor : "#000000",
                opacity: (typeof backdropSettings.backdropOpacity === "number") ? backdropSettings.backdropOpacity : 0.75,
                zIndex: zIndex
            };

            _settings.stylesheetManager.setRules(_backdropCSSSheetName, getDefaultCssSelector(_backdropObjectCssName), defaultSettings);
            _backdropHelper.addClass([EVUI.Modules.Panes.Constants.CSS_Backdrop, _backdropObjectCssName]);

            if (backdropSettings.backdropCSS == null) return;
            var defaultSelector = getDefaultCssSelector(_backdropObjectCssName);

            //add any additional CSS as overrides or separate classes if any was specified
            if (typeof backdropSettings.backdropCSS === "string")
            {
                var match = backdropSettings.backdropCSS.match(/[\;\:]/g); //if we have semi-colons or colons we have a string of CSS
                if (match != null && match.length > 0)
                {
                    _settings.stylesheetManager.setRules(_backdropCSSSheetName, defaultSelector, backdropSettings.backdropCSS);
                }
                else //otherwise it's class lists
                {
                    _backdropHelper.addClass(backdropSettings.backdropCSS);
                }
            }
            else //or we have an object of CSS properties
            {
                _settings.stylesheetManager.setRules(_backdropCSSSheetName, defaultSelector, backdropSettings.backdropCSS);
            }
        };

        /**Sets the CSS for hiding the backdrop.*/
        var setBackdropHideCSS = function ()
        {
            //make sure both the backdrop and our stylesheet are both still there
            _settings.stylesheetManager.ensureSheet(_backdropCSSSheetName, { lock: true });
            ensureBackdropDiv();

            //a 0x0 invisible square
            var defaultSettings =
            {
                position: "absolute",
                top: "0px",
                left: "0px",
                height: "0px",
                width: "0px",
            };

            //clear ALL the classes from the backdrop
            while (_backdropDiv.classList.length > 0)
            {
                var curClass = _backdropDiv.classList[0];
                _backdropDiv.classList.remove(curClass);
            }

            //add back the one class that will be used to "hide" the backdrop
            _backdropDiv.classList.add(EVUI.Modules.Panes.Constants.CSS_Backdrop);

            var defaultSelector = getDefaultCssSelector(_backdropObjectCssName);

            //remove the rules that were specific to this backdrop and the general rules for the backdrop.
            _settings.stylesheetManager.removeRules(_backdropCSSSheetName, [defaultSelector, EVUI.Modules.Panes.Constants.CSS_Backdrop]);

            //re-add the rules in their new format.
            _settings.stylesheetManager.setRules(_backdropCSSSheetName, EVUI.Modules.Panes.Constants.CSS_Backdrop, defaultSettings);
        };

        /**Applies a transition effect to the backdrop to show or hide it.
        @param {EVUI.Modules.Panes.PaneTransition} transition The transition to apply.
        @param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback A callback that is called once the transition is complete.*/
        var applyTransition = function (transition, selector, callback)
        {
            if (typeof callback !== "function") callback = function (success) { };
            if (transition == null) return callback(false);

            //the selector that will apply the transition to the backdrop
            var defaultSelector = getDefaultCssSelector(_backdropObjectCssName) + "." + selector;

            if (transition.keyframes != null)
            {
                _settings.stylesheetManager.setRules(_backdropCSSSheetName, transition.keyframes);
            }

            //once again, look to see if we have a string of raw CSS or CSS selectors. Apply them if we do
            if (typeof transition.css === "string")
            {
                var match = transition.css.match(/[\;\:]/g);
                if (match != null && match.length > 0)
                {
                    _settings.stylesheetManager.setRules(_backdropCSSSheetName, defaultSelector, transition.css);
                    _backdropHelper.addClass([selector, _backdropObjectCssName]);
                }
                else
                {
                    selector = transition.css;
                    _backdropHelper.addClass([transition.css, _backdropObjectCssName]);
                }
            }
            else //otherwise we probably have an object, apply that as well
            {
                _settings.stylesheetManager.setRules(_backdropCSSSheetName, defaultSelector, transition.css);
                _backdropHelper.addClass([selector, _backdropObjectCssName]);
            }

            //set our callback to remove the CSS and call the REAL callback to signal that we're all done
            _transitionCallback = function ()
            {
                _backdropHelper.removeClass([selector]);
                _settings.stylesheetManager.removeRules(_backdropCSSSheetName, defaultSelector);
                callback(true);
            };

            //set a timeout for the stated duration of the transition.
            _transitionTimeoutID = setTimeout(function ()
            {
                _self.cancelTransition();
            }, transition.duration);
        };

        /**Gets the default CSS selector to apply to a specific object to the backdrop.
        @param {String} objectCSSName The name of the object.
        @returns {String} */
        var getDefaultCssSelector = function (objectCSSName)
        {
            return "." + objectCSSName + "." + EVUI.Modules.Panes.Constants.CSS_Backdrop;
        };

        /**Makes sure that the backdrop DIV is actually there and available to use. */
        var ensureBackdropDiv = function ()
        {
            if (_backdropDiv == null)
            {
                _backdropDiv = document.createElement("div");
                _backdropDiv.classList.add(EVUI.Modules.Panes.Constants.CSS_Backdrop);
                _backdropDiv.id = _backdropID;

                _backdropHelper = new EVUI.Modules.Dom.DomHelper(_backdropDiv);
            }

            if (_backdropDiv.isConnected === false)
            {
                if (_backdropDiv.parentElement != null) _backdropDiv.remove();
                document.body.appendChild(_backdropDiv);
            }
        };
    };

    /**************************************************************************************PUBLIC FUNCTIONS*************************************************************************************************************/

    /**Adds a Pane to the PaneManager.
    @param {EVUI.Modules.Panes.Pane} pane A YOLO object representing a Pane object. This object is copied onto a real Pane object is then discarded.
    @returns {EVUI.Modules.Panes.Pane}*/
    this.addPane = function (pane)
    {
        if (pane == null) throw Error(_settings.objectName + " cannot be null.");

        var creationResult = makeOrExtendPane(pane, true);
        if (creationResult.exists === true) throw Error("A " + _settings.objectName + " with an id of \"" + creationResult.pane.id + "\" already exists.");

        return creationResult.entry.publicEntry.pane;
    };

    /**Removes a Pane from the PaneManager. Does not unload the Pane's element from the DOM.
    @param {EVUI.Modules.Panes.Pane|String} paneOrID
    @returns {Boolean}*/
    this.removePane = function (paneOrID)
    {
        if (paneOrID == null) return false;

        var id = null;
        if (typeof paneOrID === "string") id = paneOrID;

        id = paneOrID.id;
        if (typeof id !== "string") return false;

        var existing = getInternalPaneEntry(id);
        if (existing != null)
        {
            var index = _entries.indexOf(existing);
            if (index !== -1) _entries.splice(index, 1);
        }

        return true;
    };

    /**Gets a PaneEntry object based on its ID or a selector function.
    @param {EVUI.Modules.Panes.Constants.Fn_PaneSelector|String} paneIDOrSelector A selector function to select a PaneEntry object (or multiple PaneEntry objects) or the ID of the Pane to get the PaneEntry for.
    @param {Boolean} getAllMatches If a selector function is provided, all the PaneEntries that satisfy the selector are included. Otherwise a single PaneEntry object is returned. False by default.
    @returns {EVUI.Modules.Panes.Pane|EVUI.Modules.Panes.Pane[]} */
    this.getPane = function (paneIDOrSelector, getAllMatches)
    {
        if (typeof paneIDOrSelector === "string")
        {
            var existing = getInternalPaneEntry(paneIDOrSelector);
            if (existing != null)
            {
                return existing.publicEntry.pane;
            }
            else
            {
                return null;
            }
        }
        else if (typeof paneIDOrSelector === "function")
        {
            var results = [];
            var numPanes = _entries.length;
            for (var x = 0; x < numPanes; x++)
            {
                var curEntry = _entries[x];
                if (paneIDOrSelector(curEntry.publicEntry.pane) === true)
                {
                    if (getAllMatches === true)
                    {
                        results.push(curEntry.publicEntry.pane);
                    }
                    else
                    {
                        return curEntry.publicEntry.pane;
                    }
                }
            }

            return results;
        }
        else
        {
            return null;
        }
    };

    /**Shows (and loads, if necessary or if a reload is requested) a Pane asynchronously. Provides a callback that is called once the Pane operation has completed successfully or otherwise.
    @param {EVUI.Modules.Panes.Pane|String} paneOrID Either a YOLO Pane object to extend into the existing Pane, the real Pane reference, or the string ID of the Pane to show.
    @param {EVUI.Modules.Panes.PaneShowArgs|EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} paneShowArgs Optional.  The arguments for showing the Pane, or the callback. If omitted or passed as a function, the Pane's existing show/load settings are used instead.
    @param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback Optional. A callback that is called once the operation completes.*/
    this.showPane = function (paneOrID, paneShowArgs, callback)
    {
        var paneEntry = getPaneAmbiguously(paneOrID, true);

        if (typeof paneShowArgs === "function")
        {
            callback = paneShowSettings;
            paneShowArgs = null;
        }
        else if (paneShowArgs != null && typeof paneShowArgs === "object")
        {
            paneShowArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneShowArgs(), paneShowArgs, ["type"]);

            if (paneShowArgs.showSettings != null)
            {
                if (paneShowArgs.showSettings instanceof EVUI.Modules.Panes.PaneShowSettings === false) paneShowArgs.showSettings = makeOrExtendShowSettings(paneShowArgs.showSettings);
            }
            else
            {
                paneShowArgs.showSettings = makeOrExtendShowSettings(paneEntry.link.pane.showSettings);
            }

            if (paneShowArgs.loadArgs != null && paneShowArgs.loadArgs.loadSettings != null)
            {
                if (paneShowArgs.loadArgs.loadSettings instanceof EVUI.Modules.Panes.PaneLoadSettings === false) paneShowArgs.loadArgs.loadSettings = makeOrExtendLoadSettings(paneShowArgs.loadArgs.loadSettings);
            }
            else
            {
                paneShowArgs.loadArgs = new EVUI.Modules.Panes.PaneLoadArgs();
                paneShowArgs.loadArgs.loadSettings = makeOrExtendLoadSettings(paneEntry.link.pane.loadSettings);
            }
        }
        else
        {
            paneShowArgs = null;
        }

        if (paneShowArgs == null)
        {
            paneShowArgs = new EVUI.Modules.Panes.PaneShowArgs();
            paneShowArgs.showSettings = makeOrExtendShowSettings(paneEntry.link.pane.showSettings);
            paneShowArgs.loadArgs = new EVUI.Modules.Panes.PaneLoadArgs();
            paneShowArgs.loadArgs.loadSettings = makeOrExtendLoadSettings(paneEntry.link.pane.loadSettings);
        }

        var opSession = new PaneOperationSession();
        opSession.entry = paneEntry;
        opSession.action = EVUI.Modules.Panes.PaneAction.Show;
        opSession.currentAction = EVUI.Modules.Panes.PaneAction.Show;
        opSession.callback = (typeof callback === "function") ? callback : function (success) { };
        opSession.showArgs = paneShowArgs;
        opSession.loadArgs = paneShowArgs.loadArgs;

        performOperation(opSession);
    };

    /**Awaitable. (and loads, if necessary or if a reload is requested) a Pane asynchronously.
    @param {EVUI.Modules.Panes.Pane|String} paneOrID Either a YOLO Pane object to extend into the existing Pane, the real Pane reference, or the string ID of the Pane to show.
    @param {EVUI.Modules.Panes.PaneShowArgs} paneShowArgs Optional. The arguments for showing the Pane. If omitted, the Pane's existing show/load settings are used instead.
    @returns {Promise<Boolean>}*/
    this.showPaneAsync = function (paneOrID, paneShowArgs)
    {
        return new Promise(function (resolve, reject)
        {
            _self.showPane(paneOrID, paneShowArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Hides (and unloads if requested) a Pane asynchronously. Provides a callback that is called called once the Pane operation has completed successfully or otherwise.
    @param {EVUI.Modules.Panes.Pane|String} paneOrID Either a YOLO Pane object to extend into the existing Pane, the real Pane reference, or the string ID of the Pane to hide.
    @param {EVUI.Modules.Panes.PaneHideArgs|EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} paneHideArgs Optional. A YOLO object representing arguments for hiding a Pane or a callback. If omitted or passed as a function, the Pane's existing hide/unload settings are used instead.
    @param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback Optional. A callback that is called once the operation completes.*/
    this.hidePane = function (paneOrID, paneHideArgs, callback)
    {
        var paneEntry = getPaneAmbiguously(paneOrID, false);

        if (typeof paneHideArgs === "function")
        {
            callback = paneHideArgs;
            paneHideArgs = null;
        }
        else if (paneHideArgs != null && typeof paneHideArgs === "object")
        {
            if (paneHideArgs instanceof EVUI.Modules.Panes.PaneHideArgs === false) paneHideArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneHideArgs(), paneHideArgs, ["type"]);
            if (paneHideArgs.unloadArgs instanceof EVUI.Modules.Panes.PaneUnloadArgs === false) paneHideArgs.unloadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneUnloadArgs(), paneHideArgs.unloadArgs);
        }
        else
        {
            paneHideArgs = null;
        }

        if (paneHideArgs == null)
        {
            paneHideArgs = new EVUI.Modules.Panes.PaneHideArgs();
            paneHideArgs.unloadArgs = new EVUI.Modules.Panes.PaneUnloadArgs();
        }

        var opSession = new PaneOperationSession();
        opSession.entry = paneEntry;
        opSession.action = EVUI.Modules.Panes.PaneAction.Hide;
        opSession.currentAction = EVUI.Modules.Panes.PaneAction.Hide;
        opSession.callback = (typeof callback === "function") ? callback : function (success) { };
        opSession.hideArgs = paneHideArgs;
        opSession.unloadArgs = paneHideArgs.unloadArgs;

        performOperation(opSession);
    };

    /**Awaitable. Hides (and unloads if requested) a Pane asynchronously.
    @param {EVUI.Modules.Panes.Pane|String} paneOrID Either a YOLO Pane object to extend into the existing Pane, the real Pane reference, or the string ID of the Pane to hide.
    @param {EVUI.Modules.Panes.PaneHideArgs} paneHideArgs Optional. The arguments for hiding a Pane. If omitted, the Pane's existing hide/unload settings are used instead.
    @returns {Promise<Boolean>}*/
    this.hidePaneAsync = function (paneOrID, paneHideArgs)
    {
        return new Promise(function (resolve, reject)
        {
            _self.hidePane(paneOrID, paneHideArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Hides all visible Panes asynchronously. Provides a callback function that is called once all the visible Panes have been hidden.
    @param {EVUI.Modules.Panes.PaneHideArgs} paneHideArgs Optional. The arguments for hiding a Pane. If omitted, the Pane's existing hide/unload settings are used instead.
    @param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback The callback that is called once all the Pane's hide operations have completed.*/
    this.hideAllPanes = function (paneHideArgs, callback)
    {
        if (typeof callback !== "function") callback = function () { };
        var allVisible = this.getPane(function (pane) { return pane.isVisible; });
        var numVisible = allVisible.length;
        var numHidden = 0;

        if (numVisible === 0) return callback(true);

        for (var x = 0; x < numVisible; x++)
        {
            this.hidePane(allVisible[x], paneHideArgs, function ()
            {
                numHidden++;
                if (numHidden === numVisible)
                {
                    return callback(true);
                }
            });
        }
    };

    /**Awaitable. Hides all Panes asynchronously.
    @param {EVUI.Modules.Panes.PaneHideArgs} paneHideArgs Optional. The arguments for hiding a Pane. If omitted, the Pane's existing hide/unload settings are used instead.
    @returns {Promise<Boolean>} */
    this.hideAllPanesAsync = function (paneHideArgs)
    {
        return new Promise(function (resolve)
        {
            _self.hideAllPanes(paneHideArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Asynchronously loads a Pane. Provides a callback that is called after the operation has completed successfully or otherwise.
    @param {EVUI.Modules.Panes.Pane|String} paneOrID Either a YOLO Pane object to extend into the existing Pane, the real Pane reference, or the string ID of the Pane to load.
    @param {EVUI.Modules.Panes.PaneLoadArgs|EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} paneLoadArgs Optional. A YOLO object representing arguments for loading a Pane or a callback. If omitted or passed as a function, the Pane's existing load settings are used instead.
    @param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback Optional.A callback to call once the operation completes.*/
    this.loadPane = function (paneOrID, paneLoadArgs, callback)
    {
        var paneEntry = getPaneAmbiguously(paneOrID, true);

        if (typeof paneLoadArgs === "function")
        {
            callback = paneLoadArgs;
            paneLoadArgs = null;
        }
        else if (paneLoadArgs != null && typeof paneLoadArgs === "object")
        {
            if (paneLoadArgs instanceof EVUI.Modules.Panes.PaneLoadArgs === false) paneLoadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneLoadArgs(), paneLoadArgs, ["type"]);
            if (paneLoadArgs.loadSettings != null && paneLoadArgs.loadSettings instanceof EVUI.Modules.Panes.PaneLoadSettings === false)
            {
                paneLoadArgs.loadSettings = makeOrExtendLoadSettings(paneLoadArgs.loadSettings);
            }
        }
        else
        {
            paneLoadArgs = null;
        }

        if (paneLoadArgs == null)
        {
            paneLoadArgs = new EVUI.Modules.Panes.PaneLoadArgs();
            paneLoadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneLoadSettings(), paneEntry.link.pane.loadSettings);
        }

        var opSession = new PaneOperationSession();
        opSession.entry = paneEntry;
        opSession.action = EVUI.Modules.Panes.PaneAction.Load;
        opSession.currentAction = EVUI.Modules.Panes.PaneAction.Load;
        opSession.callback = (typeof callback === "function") ? callback : function (success) { };
        opSession.loadArgs = paneLoadArgs;

        performOperation(opSession);
    };

    /**Awaitable. Asynchronously loads a Pane.
    @param {EVUI.Modules.Panes.Pane|String} paneOrID Either a YOLO Pane object to extend into the existing Pane, the real Pane reference, or the string ID of the Pane to load.
    @param {EVUI.Modules.Panes.PaneLoadArgs} paneLoadArgs Optional. A YOLO object representing arguments for loading a Pane.
    @returns {Promise<Boolean>}*/
    this.loadPaneAsync = function (paneOrID, paneLoadArgs)
    {
        return new Promise(function (resolve, reject)
        {
            _self.loadPane(paneOrID, paneLoadArgs, function (success)
            {
                resolve(success);
            })
        });
    };

    /**Asynchronously unloads a Pane, which disconnects the Pane's element and removes it from the DOM if it was loaded remotely. Provides a callback that is called after the operation has completed successfully or otherwise.
    @param {EVUI.Modules.Panes.Pane|String} paneOrID Either a YOLO Pane object to extend into the existing Pane, the real Pane reference, or the string ID of the Pane to unload.
    @param {EVUI.Modules.Panes.PaneUnloadArgs|EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} paneUnloadArgs Optional. A YOLO object representing arguments for unloading a Pane or a callback. If omitted or passed as a function, the Pane's existing unload settings are used instead.
    @param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback Optional. A callback to call once the operation completes.*/
    this.unloadPane = function (paneOrID, paneUnloadArgs, callback)
    {
        var paneEntry = getPaneAmbiguously(paneOrID, false);

        if (typeof paneUnloadArgs === "function")
        {
            callback = paneUnloadArgs;
            paneUnloadArgs = null;
        }
        else if (paneUnloadArgs != null && typeof paneUnloadArgs === "object")
        {
            if (unloadPaneArgs instanceof EVUI.Modules.Panes.PaneUnloadArgs === false) paneUnloadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneUnloadArgs(), paneUnloadArgs, ["type"]);
        }
        else
        {
            paneUnloadArgs = null;
        }

        if (paneUnloadArgs == null)
        {
            paneUnloadArgs = new EVUI.Modules.Panes.PaneUnloadArgs();
        }

        var opSession = new PaneOperationSession();
        opSession.entry = paneEntry;
        opSession.action = EVUI.Modules.Panes.PaneAction.Unload;
        opSession.currentAction = EVUI.Modules.Panes.PaneAction.Unload;
        opSession.callback = (typeof callback === "function") ? callback : function (success) { };
        opSession.unloadArgs = paneUnloadArgs;

        performOperation(opSession);
    };

    /**Awaitable. Asynchronously unloads a Pane, which disconnects the Pane's element and removes it from the DOM if it was loaded remotely.
    @param {EVUI.Modules.Panes.Pane|String} paneOrID Either a YOLO Pane object to extend into the existing Pane, the real Pane reference, or the string ID of the Pane to unload.
    @param {EVUI.Modules.Panes.PaneUnloadArgs} paneUnloadArgs Optional. A YOLO object representing arguments for unloading a Pane. If omitted the Pane's existing unload settings are used instead.
    @returns {Promise<Boolean>}*/
    this.unloadPaneAsync = function (paneOrID, paneUnloadArgs)
    {
        return new Promise(function (resolve, reject)
        {
            _self.unloadPane(paneOrID, paneUnloadArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Creates a new instance of a PaneManager that will use the resources that are shared between all instances of PaneManager.
    @param {EVUI.Modules.Panes.PaneManagerSettings} paneManagerSettings A YOLO object representing the settings and overrides to use to change the behavior of the new PaneManager.
    @returns {EVUI.Modules.Panes.PaneManager} */
    this.createNewPaneManager = function (paneManagerSettings)
    {
        if (paneManagerSettings == null) paneManagerSettings = new EVUI.Modules.Panes.PaneManagerSettings();
        attachGlobals(paneManagerSettings);

        return new _managerConstructor(paneManagerSettings);
    };

    /**************************************************************************************EVENTS*************************************************************************************************************/

    /**Global event that fires before the load operation begins for any Pane and is not yet in the DOM and cannot be manipulated in this stage, however the currentActionArgs.loadSettings can be manipulated to change the way the Pane's root element will be loaded.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneLoadArgs.*/
    this.onLoad = function (paneEventArgs)
    {

    };

    /**Global event that fires after the load operation has completed for any Pane and is now in the DOM and can be manipulated in this stage. From this point on the Pane's element property cannot be reset..
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneLoadArgs.*/
    this.onLoaded = function (paneEventArgs)
    {

    };

    /**Global event that fires the first time any Pane is shown after being loaded into the DOM, but is not yet visible. After it has fired once, it will not fire again unless the PaneShowArgs.reInitialize property is set to true.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneShowArgs.*/
    this.onInitialize = function (paneEventArgs)
    {

    };

    /**Global event that fires at the beginning of the show process and before the calculations for any Pane's location are made. The Pane is still hidden, but is present in the DOM and can be manipulated. In order for the positioning calculations in the next step to be accurate, all HTML manipulation should occur in this event.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneShowArgs.*/
    this.onShow = function (paneEventArgs)
    {

    };

    /**Global event that fires after the position of any Pane has been calculated and is available to be manipulated through the calculatedPosition property of the PaneEventArgs. If the calculatedPosition or the showSettings are manipulated, the position will be recalculated (any changes made directly to the position take priority over changes made to the showSettings).
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneShowArgs.*/
    this.onPosition = function (paneEventArgs)
    {

    };

    /**Global event that fires once any Pane has been positioned, shown, and had its optional show transition applied and completed. Marks the end of the show process.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneShowArgs.*/
    this.onShown = function (paneEventArgs)
    {

    };

    /**Global event that fires before any Pane has been moved from its current location and hidden. Gives the opportunity to change the hideTransition property of the PaneHideArgs and optionally trigger an unload once the Pane has been hidden.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneHideArgs.*/
    this.onHide = function (paneEventArgs)
    {

    };

    /**Global event that fires after any Pane has been moved from its current location and is now hidden and the hide transition has completed.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneHideArgs.*/
    this.onHidden = function (paneEventArgs)
    {

    };

    /**Global event that fires before any Pane has been (potentially) removed from the DOM and had its element property reset to null.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneUnloadArgs.*/
    this.onUnload = function (paneEventArgs)
    {
    };

    /**Global event that fires after any Pane has been (potentially) removed from the DOM and had its element property reset to null. From this point on the Pane's element property is now settable to a new Element.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneUnloadArgs.*/
    this.onUnloaded = function (paneEventArgs)
    {

    };

    /**************************************************************************************SETUP*************************************************************************************************************/

    /**Gets a Pane's InternalPaneEntry based off of a string ID, a YOLO pane object, or a real pane object.
    @param {String|EVUI.Modules.Panes.Pane} paneOrID The string ID or Pane object to get.
    @param {Boolean} addIfMissing Whether or not to add the pane if it cannot be found.
    @returns {InternalPaneEntry} */
    var getPaneAmbiguously = function (paneOrID, addIfMissing)
    {
        if (paneOrID == null || (typeof paneOrID !== "string" && typeof paneOrID !== "object")) throw Error("Invalid input: " + _settings.objectName + " or string id expected.");

        if (paneOrID instanceof Event) //if the pane is being summoned via an event directly, figure out all we can about it based on the current target's attributes.
        {
            paneOrID = getPaneFromEventArgs(paneOrID);
        }

        var paneID = paneOrID;
        if (typeof paneOrID === "object") paneID = paneOrID.id;
        if (typeof paneID !== "string") throw Error("Invalid input: " + _settings.objectName + " missing id.")

        var paneEntry = getInternalPaneEntry(paneID);
        if (paneEntry == null)
        {
            if (typeof paneOrID === "string" || addIfMissing !== true) throw Error("No " + _settings.objectName + " with an id of \"" + paneID + "\" exists.");

            var addResult = _self.addPane(paneOrID);
            if (addResult == null) throw Error("Failed to add " + _settings.objectName + " with an id of \"" + paneOrID + "\".");

            paneEntry = getInternalPaneEntry(paneID);
        }
        else
        {
            if (typeof paneOrID === "object") makeOrExtendPane(paneOrID, addIfMissing);
        }

        return paneEntry;
    };

    /**Creates a graph of all the properties we can determine about a Pane based on the currentTarget's attributes.
    @param {Event} event The event arguments used to trigger the action of showing or hiding the pane.
    @returns {EVUI.Modules.Panes.Pane} */
    var getPaneFromEventArgs = function (event)
    {
        var paneSettings = {};
        var objectAttrs = EVUI.Modules.Core.Utils.getElementAttributes(event.currentTarget);

        var id = objectAttrs.getValue(getAttributeName(EVUI.Modules.Panes.Constants.Attribute_ID)); //first, make sure we have an ID. If we don't we have to attempt to find all other instances that will involve the same Pane and tag them all with the same ID.
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(id) === true) 
        {
            id = fixPanesWithNoID(event, objectAttrs); //go find everything that has a load option in common with this pane and tag them all with the same ID.
        }

        paneSettings.id = id;

        var src = objectAttrs.getValue(getAttributeName(EVUI.Modules.Panes.Constants.Attribute_SourceURL)); //if we have a src url, we're going to use HTTP to load this pane.
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(src) === false)
        {
            if (paneSettings.loadSettings == null) paneSettings.loadSettings = {};
            paneSettings.loadSettings.httpLoadArgs = {}
            paneSettings.loadSettings.httpLoadArgs.url = src;
            paneSettings.loadSettings.httpLoadArgs.method = "GET";
        }

        var placeholderID = objectAttrs.getValue(getAttributeName(EVUI.Modules.Panes.Constants.Attribute_PlaceholderID)); //if we have a placeholderID, we're going to use the placeholder loading logic to load this pane.
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(placeholderID) === false)
        {
            if (paneSettings.loadSettings == null) paneSettings.loadSettings = {};
            paneSettings.loadSettings.placeholderLoadArgs = new EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs();
            paneSettings.loadSettings.placeholderLoadArgs.placeholderID = placeholderID;
        }

        var context = objectAttrs.getValue(getAttributeName(EVUI.Modules.Panes.Constants.Attribute_Context));
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(context) === false) paneSettings.context = context;

        var selector = objectAttrs.getValue(getAttributeName(EVUI.Modules.Panes.Constants.Attribute_Selector)); //if we have a CSS selector, we will use that to "load" this pane.
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(selector) === false)
        {
            if (paneSettings.loadSettings == null) paneSettings.loadSettings = {};
            paneSettings.loadSettings.selector = selector;
        }

        var unloadOnHide = objectAttrs.getValue(getAttributeName(EVUI.Modules.Panes.Constants.Attribute_UnloadOnHide)); //only set this value if it is a valid boolean value (so it doesn't override the default by accident if it is not found)
        if (unloadOnHide === "true") paneSettings.unloadOnHide = true;
        if (unloadOnHide === "false") paneSettings.unloadOnHide = false;

        if (_settings.interpretBrowserEvent(paneSettings, event) === false)
        {
            var showSettings = objectAttrs.getValue(getAttributeName(EVUI.Modules.Panes.Constants.Attribute_ShowSettings)); //finally, see if any show settings were attached to the element. If so, parse them into a real show settings object.
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(showSettings) === false)
            {
                var parsedSettings = parseSettingsString(showSettings);
                if (parsedSettings.relativePosition != null && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(parsedSettings.relativePosition.relativeElement) === true) parsedSettings.relativePosition.relativeElement = event.currentTarget;
                if (parsedSettings != null) paneSettings.showSettings = parsedSettings;
            }
        }

        return paneSettings;
    };

    /**Attempts to find all the places where a pane is loaded using the same parameters and tags them all with the same ID so that the manager handles them correctly.
    @param {Event} event The event that triggered the pane action.
    @param {EVUI.Modules.Core.CaseInsensitiveObject} targetAttributes The attributes that are on the currentTarget.
    @returns {String} */
    var fixPanesWithNoID = function (event, targetAttributes)
    {
        var urlAttributeName = getAttributeName(EVUI.Modules.Panes.Constants.Attribute_SourceURL);
        var placeholderAttributeName = getAttributeName(EVUI.Modules.Panes.Constants.Attribute_PlaceholderID);
        var selectorAttributeName = getAttributeName(EVUI.Modules.Panes.Constants.Attribute_Selector);
        var idAttr = getAttributeName(EVUI.Modules.Panes.Constants.Attribute_ID);

        var allWithSame = [];
        var same = null;
        var sameAttr = null;
        var url = targetAttributes.getValue(urlAttributeName);
        var placeholderID = targetAttributes.getValue(placeholderAttributeName);
        var selector = targetAttributes.getValue(selectorAttributeName);

        //look for everything with the same load data. The loading data is case-insensitive, so we can't use a direct key=value selector to find them as those are case sensitive, so we just find everything tagged with the same attribute thats being used to load the pane.
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(url) === false)
        {
            allWithSame = document.querySelectorAll("[" + urlAttributeName + "=\"" + url +"\"]");
            sameAttr = urlAttributeName;
            same = url;
        }
        else if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(placeholderID) === false)
        {
            allWithSame = document.querySelectorAll("[" + placeholderAttributeName + "=\"" + placeholderId +"\"]");
            sameAttr = placeholderAttributeName;
            same = placeholderID;
        }
        else if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(selector) === false)
        {
            var selectedElements = document.querySelectorAll(selector); //if the selector hits more than one element, we're not going to use it.
            if (selectedElements.length == 1)
            {
                allWithSame = document.querySelectorAll("[" + selectorAttributeName + "=\""+ selector +"\" ]");
                sameAttr = selectorAttributeName;
                same = selector;
            }
        }

        var existingPane = null;
        var numPanes = _entries.length;

        var allNeedingID = [event.currentTarget];
        var same = EVUI.Modules.Core.Utils.stringNormalize(same);
        var checkedSame = false;
        //walk every element that came back with the matching attribute and see if it's attribute value matches that of the element we're looking for equivalents to.
        var id = null;
        var numSame = allWithSame.length;
        for (var x = 0; x < numSame; x++)
        {
            var curSame = allWithSame[x];
            var value = curSame.getAttribute(sameAttr);
            var curID = curSame.getAttribute(idAttr);

            if (id != null && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(curID) === false && curID !== id) continue;
            if (typeof value !== "string") continue;
            if (EVUI.Modules.Core.Utils.stringNormalize(value) !== same) continue;

            if (id == null && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(curID) === false) //found an ID, we tag them all with the ID we just found
            {
                id = curID;
                continue;
            }
            else if (id == null) //if we have no id, do an expensive check based on existing panes to see if we know which pane we should be showing
            {
                for (var y = 0; y < numPanes; y++)
                {
                    var curEntry = _entries[y];
                    if (curEntry.link.pane.element === curSame) //first check based on an element equality
                    {
                        id = curEntry.paneID;
                        break;
                    }
                    else if (curEntry.link.pane.loadSettings != null && curEntry.link.pane.loadSettings.selector === same) //if not, look at the load settings to see if we can't find the element
                    {
                        if (curEntry.link.pane.loadSettings.contextElement instanceof Node === false)
                        {
                            var ele = document.querySelector(curEntry.link.pane.loadSettings.selector);
                            if (ele != null && ele !== curSame) continue;

                            id = curEntry.paneID;
                            break;
                        }
                        else
                        {
                            var ele = curEntry.link.pane.loadSettings.contextElement.querySelector(curEntry.link.pane.loadSettings.selector);
                            if (ele === curSame)
                            {
                                id = curEntry.paneID;
                                break;
                            }
                        }
                    }
                    else if (checkedSame === false && curEntry.link.pane.loadSettings != null) //no element match, check load settings
                    {
                        var compareVal = null;

                        if (curEntry.link.pane.loadSettings.placeholderLoadArgs != null)
                        {
                            compareVal = curEntry.link.pane.loadSettings.placeholderLoadArgs.placeholderID;
                        }
                        else if (curEntry.link.pane.loadSettings.element === curSame)
                        {
                            id = curEntry.paneID;
                            break;
                        }
                        else if (curEntry.link.pane.loadSettings.httpLoadArgs != null)
                        {
                            compareVal = curEntry.link.pane.loadSettings.httpLoadArgs.url;
                        }


                        if (typeof compareVal === "string") compareVal = compareVal.toLowerCase();
                        if (compareVal === same.toLowerCase())
                        {
                            id = curEntry.paneID;
                            break;
                        }                        
                    }                    
                }

                checkedSame = true;
            }

            allNeedingID.push(curSame);
        }

        if (id == null) id = EVUI.Modules.Core.Utils.makeGuid(); //never found an ID, just make a guid and tag them all with that
        var eh = new EVUI.Modules.Dom.DomHelper(allNeedingID);
        eh.attr(idAttr, id);

        return id;
    };

    /**Gets the name of an attribute for the specific implementation of the PaneManager.
    @param {String} attribute The full (default) attribute name from the Pane module to change to the specific case.
    @returns {String} */
    var getAttributeName = function (attribute)
    {
        var lowerName = attribute.toLowerCase();
        if (EVUI.Modules.Core.Utils.stringStartsWith(EVUI.Modules.Panes.Constants.Default_AttributePrefix, lowerName) === true)
        {
            return _settings.attributePrefix + attribute.substring(EVUI.Modules.Panes.Constants.Default_AttributePrefix.length);
        }

        return attribute;
    };

    /**Turns a string of settings into an object with those settings as properties.
    @param {String} settingsStr The string of settings to parse.
    @returns {Object} */
    var parseSettingsString = function (settingsStr)
    {
        var quoteSpans = getQuoteSpans(settingsStr);
        if (quoteSpans == null) return null;

        var settings = {};
        var properties = [];

        if (EVUI.Modules.Core.Utils.stringEndsWith(";", settingsStr) === false) settingsStr += ";";

        var lastValidSemicolon = 0;

        //we can't just split it because of escaped semi-colons, so we walk it instead.
        var index = 0;
        while (index < settingsStr.length)
        {
            var nextSemicolon = settingsStr.indexOf(";", index);
            if (nextSemicolon === -1) break;

            if (isInQuoteSpan(quoteSpans, nextSemicolon) === true)
            {
                index = nextSemicolon + 1;
                continue;
            }

            var colonIndex = settingsStr.indexOf(":", lastValidSemicolon);
            if (colonIndex === -1) break;

            var propName = settingsStr.substring(lastValidSemicolon, colonIndex);
            var propValue = settingsStr.substring(colonIndex + 1, nextSemicolon);

            properties.push({ name: propName.trim(), value: propValue.trim() });
            index = nextSemicolon + 1;
            lastValidSemicolon = nextSemicolon + 1;
        }

        var numProps = properties.length;
        for (var x = 0; x < numProps; x++)
        {
            assignSetting(settings, properties[x]);
        }

        return settings;
    };

    /**Gets the start and stop indexes of all the runs of characters that are between quotation marks.
     @param {String} settingsStr
     @returns {{start:Number, end:Number}[]}*/
    var getQuoteSpans = function (settingsStr)
    {
        var quoteType = (settingsStr.indexOf("\"") === -1) ? "'" : "\"";

        var spans = [];
        var index = 0;
        var openIndex = -1;

        while (index < settingsStr.length)
        {
            var quoteIndex = settingsStr.indexOf(quoteType, index);
            if (quoteIndex === -1) break;

            if (quoteIndex > 0 && settingsStr[quoteIndex - 1] === "\\")
            {
                index = quoteIndex + 1;
                continue;
            }

            if (openIndex === -1)
            {
                openIndex = quoteIndex;
            }
            else
            {
                spans.push({ start: openIndex, end: quoteIndex });
                openIndex = -1;
            }

            index = quoteIndex + 1;
        }

        if (openIndex !== -1) return EVUI.Modules.Core.Utils.debugReturn(_settings.managerName, "getQuoteSpans", "Invalid settings string, unclosed quote starting at position " + openIndex, null);
        return spans;
    };

    /**Determines if a character index is inside of a span of quotes.
    @param {{start:Number, end:Number}[]} quoteSpans The array of start/stop indexes of quotes.
    @param {Number} index The index to check and see if it is inside of.
    @returns {Boolean} */
    var isInQuoteSpan = function (quoteSpans, index)
    {
        var numSpans = quoteSpans.length;
        for (var x = 0; x < numSpans; x++)
        {
            var curSpan = quoteSpans[x];
            if (index > curSpan.start && index < curSpan.end) return true;
        }

        return false;
    };

    /**Assigns a setting based on a value found in the parsing of a settings string.
    @param {Object} settings The settings object to set the setting on.
    @param {{name: String, value: String}} curSetting The setting to set.*/
    var assignSetting = function (settings, curSetting)
    {
        var segments = curSetting.name.split(".");
        var numSegs = segments.length;
        var curObj = settings;

        for (var x = 0; x < numSegs - 1; x++)
        {
            var curSeg = segments[x];
            if (curObj[curSeg] == null) curObj[curSeg] = {};
            curObj = curObj[curSeg];
        }

        var escaped = curSetting.value.replace(/'|\\'/g, "\"");

        try
        {
            var value = JSON.parse(escaped);
            curObj[segments[numSegs - 1]] = value;
        }
        catch (ex)
        {
            EVUI.Modules.Core.Utils.debugReturn(_settings.managerName, "assignSetting", "Could not parse setting value \"" + escaped + "\" from JSON: " + ex.message);
        }
    };

    /**Gets an InternalPaneEntry based on a Pane's id.
    @param {String} paneID The ID of the Pane to get the PaneEntry for (case-insensitive)..
    @returns {InternalPaneEntry}*/
    var getInternalPaneEntry = function (paneID)
    {
        paneID = paneID.toLocaleLowerCase();

        var numEntries = _entries.length;
        for (var x = 0; x < numEntries; x++)
        {
            var curEntry = _entries[x];
            if (curEntry.lowerPaneID === paneID) return curEntry;
        }

        return null;
    };

    /**Determines whether or not a Pane's element can be set.
    @param {PaneElementSetter} paneElementSetter An object passed in from the Pane's element property setter.
    @returns {String} */
    var canSetElement = function (paneElementSetter)
    {
        var entry = getInternalPaneEntry(paneElementSetter.paneID);
        if (entry == null) throw Error("Failed to set element for pane \"" + paneElementSetter.paneID + "\":  No PaneEntry found for Pane with ID of \"" + paneElementSetter.paneID + "\".");

        if (EVUI.Modules.Core.Utils.hasFlag(entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded)) throw Error("Failed to set element for pane \"" + paneElementSetter.paneID + "\": Pane has been loaded. Unload it before attempting to set element.");

        if (paneElementSetter.element != null)
        {
            if (EVUI.Modules.Core.Utils.isElement(paneElementSetter.element) !== true) throw Error("Failed to set element for pane \"" + paneElementSetter.paneID + "\": The provided value is invalid. Value must be an object derived from Element.");
        }

        if (entry.link.setSecret !== paneElementSetter.setSecret) Error("Failed to set element for pane \"" + paneElementSetter.paneID + "\": Permission denied, tokens do not match.");

        return entry.link.setSecret;
    };

    /**Gets the CSS class name for the Pane.
    @param {InternalPaneEntry} entry The entry containing the pane to get the CSS class name of.
    @returns {String}*/
    var getClassName = function (paneID)
    {
        //remove all whitespace and add the prefix
        var noWhitespaceRegex = new RegExp(/\s+/g);
        var className = _settings.cssPrefix + (EVUI.Modules.Core.Utils.stringEndsWith(_settings.cssPrefix.trim(), "-") ? "" : "-") + paneID;
        className = className.replace(noWhitespaceRegex, "");

        return className;
    };

    /**Takes a pane object passed in by the user and either creates a new pane object or extends its properties onto an existing pane.
    @param {EVUI.Modules.Panes.Pane} yoloPane The YOLO object passed in by the user into one of the entry point functions.
    @returns {PaneExtensionResult}*/
    var makeOrExtendPane = function (yoloPane, addIfMissing)
    {
        if (yoloPane == null) return null;
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(yoloPane.id) === true) throw Error("Pane must have an id that is a non-whitespace string.");

        var result = new PaneExtensionResult();
        var id = yoloPane.id;
        var eventStream = null;
        var paneToExtend = null;
        var existing = getInternalPaneEntry(id);
        if (existing != null)
        {
            result.exists = true;
            result.entry = existing;
            result.pane = existing.link.pane;

            eventStream = existing.link.eventStream;
            paneToExtend = existing.link.pane;
            if (yoloPane === paneToExtend) return result;
        }
        else
        {
            var link = new PaneLink();
            link.eventStream = new EVUI.Modules.EventStream.EventStream();
            eventStream = link.eventStream;

            link.manager = _self;
            link.paneCSSName = getClassName(id);

            var options = new PaneOptions();
            options.canSetElement = canSetElement;
            options.link = link;

            paneToExtend = new EVUI.Modules.Panes.Pane(id, options);

            link.pane = paneToExtend;


            var entry = new EVUI.Modules.Panes.PaneEntry(link);
            var innerEntry = new InternalPaneEntry();
            innerEntry.publicEntry = entry;
            innerEntry.link = link;
            innerEntry.paneID = id;
            innerEntry.lowerPaneID = id.toLocaleLowerCase();

            result.pane = paneToExtend;
            result.exists = false;
            result.entry = innerEntry;

            if (addIfMissing === true)
            {
                _entries.push(innerEntry);
            }
        }

        var safeCopy = EVUI.Modules.Core.Utils.shallowExtend({}, yoloPane);

        delete safeCopy.id;
        if (yoloPane.element === result.entry.link.pane.element) delete safeCopy.element; //if the pane already exists and this is the same reference, don't set it again. Otherwise, let it blow up.
        delete safeCopy.currentPosition;
        delete safeCopy.currentZIndex;
        delete safeCopy.isVisible;
        delete safeCopy.isLoaded;
        delete safeCopy.isInitialized;

        EVUI.Modules.Core.Utils.shallowExtend(paneToExtend, safeCopy, ["showSettings", "loadSettings", "resizeMoveSettings", "autoCloseSettings", "recalcSettings"]);
        paneToExtend.showSettings = makeOrExtendShowSettings(paneToExtend.showSettings, safeCopy.showSettings);
        paneToExtend.loadSettings = makeOrExtendLoadSettings(paneToExtend.loadSettings, safeCopy.loadSettings);
        paneToExtend.resizeMoveSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Panes.PaneResizeMoveSettings(), paneToExtend.resizeMoveSettings, safeCopy.resizeMoveSettings);
        paneToExtend.autoCloseSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Panes.PaneAutoCloseSettings(), paneToExtend.autoCloseSettings, safeCopy.autoCloseSettings);
        paneToExtend.autoCloseSettings.autoCloseKeys = paneToExtend.autoCloseSettings.autoCloseKeys.slice();
        paneToExtend.reclacSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Panes.PaneRecalcSettings(), paneToExtend.reclacSettings, safeCopy.reclacSettings);

        if (EVUI.Modules.Core.Utils.isArray(safeCopy.autoHideKeys) === true) paneToExtend.autoHideKeys = safeCopy.autoHideKeys.slice();

        if (typeof _settings.makeOrExtendObject === "function") result.entry.link.wrapper = _settings.makeOrExtendObject(result);

        return result;
    };

    /**Makes or extends a PaneShowSettings object.
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings A show settings object made by a user.
    @returns {EVUI.Modules.Panes.PaneShowSettings}*/
    var makeOrExtendShowSettings = function (showSettings, yoloSettings)
    {
        if (showSettings == null) return new EVUI.Modules.Panes.PaneShowSettings();

        var copy = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Panes.PaneShowSettings(), showSettings, yoloSettings);
        if (yoloSettings == null) yoloSettings = {};

        if (copy.anchors != null) copy.anchors = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Panes.PaneAnchors(), showSettings.anchors, yoloSettings.anchors);
        if (copy.absolutePosition != null) copy.absolutePosition = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Panes.PaneAbsolutePosition(), showSettings.absolutePosition, yoloSettings.absolutePosition);
        if (copy.documentFlow != null) copy.documentFlow = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Panes.PaneDocumentFlow(), showSettings.documentFlow, yoloSettings.documentFlow);
        if (copy.hideTransition != null) copy.hideTransition = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Panes.PaneTransition(), showSettings.hideTransition, yoloSettings.hideTransition);
        if (copy.showTransition != null) copy.showTransition = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Panes.PaneTransition(), showSettings.showTransition, yoloSettings.showTransition);
        if (copy.relativePosition != null) copy.relativePosition = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Panes.PaneRelativePosition(), showSettings.relativePosition, yoloSettings.relativePosition);
        if (copy.clipSettings != null) copy.clipSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Panes.PaneClipSettings(), showSettings.clipSettings, yoloSettings.clipSettings);
        if (copy.backdropSettings != null) copy.backdropSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Panes.PaneBackdropSettings(), showSettings.backdropSettings, yoloSettings.backdropSettings);

        return copy;
    };

    /**Makes or extends a PaneLoadSettings object.
    @param {EVUI.Modules.Panes.PaneLoadSettings} loadSettings A PaneLoadSettings object made by a user.
    @returns {EVUI.Modules.Panes.PaneShowSettings} */
    var makeOrExtendLoadSettings = function (loadSettings, yoloLoadSettings)
    {
        if (loadSettings == null) return new EVUI.Modules.Panes.PaneLoadSettings();

        var copy = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Panes.PaneLoadSettings(), loadSettings, yoloLoadSettings);
        if (yoloLoadSettings == null) yoloLoadSettings = {};

        if (loadSettings.httpLoadArgs != null || yoloLoadSettings.httpLoadArgs != null)
        {
            EVUI.Modules.Core.Utils.require("Http", EVUI.Modules.Panes.Dependencies["Http"].version, "Cannot use httpLoadArgs.");
            copy.httpLoadArgs = makeOrExtendHttpArgs(loadSettings.httpLoadArgs, yoloLoadSettings.httpLoadArgs);
        }

        if (loadSettings.placeholderLoadArgs != null || yoloLoadSettings.placeholderLoadArgs != null)
        {
            EVUI.Modules.Core.Utils.require("HtmlLoader", EVUI.Modules.Panes.Dependencies["HtmlLoader"].version, "Cannot use placeholderLoadArgs.");
            copy.placeholderLoadArgs = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs(), loadSettings.placeholderLoadArgs, yoloLoadSettings.placeholderLoadArgs);
            copy.placeholderLoadArgs.httpArgs = makeOrExtendHttpArgs((loadSettings.placeholderLoadArgs == null) ? null : loadSettings.placeholderLoadArgs.httpArgs, (yoloLoadSettings.placeholderLoadArgs == null) ? null : loadSettings.placeholderLoadArgs.httpArgs)
        }

        return copy;
    };

    /**Makes or extends a copy of HttpRequestArgs.
    @param {any} httpArgs HttpRequestArgs made by the user.
    @returns {EVUI.Modules.Http.HttpRequestArgs}*/
    var makeOrExtendHttpArgs = function (httpArgs, yoloHttpArgs)
    {
        var copy = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.Http.HttpRequestArgs(), httpArgs, yoloHttpArgs);
        copy.headers = copy.headers == null ? [] : copy.headers.map(function (header) { return EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Http.HttpRequestHeader(), header); });
        return copy;
    };

    /**Makes a clone of the Pane's PaneShowSettings.
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings The show settings to clone.
    @returns {EVUI.Modules.Panes.PaneShowSettings} */
    var cloneShowSettings = function (showSettings)
    {
        var copy = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneShowSettings(), showSettings);

        if (showSettings.absolutePosition != null) copy.absolutePosition = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneAbsolutePosition(), showSettings.absolutePosition);
        if (showSettings.anchors != null) copy.anchors = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneAnchors(), showSettings.anchors);
        if (showSettings.documentFlow != null) copy.documentFlow = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneDocumentFlow(), showSettings.documentFlow);
        if (showSettings.hideTransition != null) copy.hideTransition = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneTransition(), showSettings.hideTransition);
        if (showSettings.showTransition != null) copy.showTransition = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneTransition(), showSettings.showTransition);
        if (showSettings.relativePosition != null) copy.relativePosition = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneRelativePosition(), showSettings.relativePosition);
        if (showSettings.clipSettings != null) copy.clipSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneClipSettings(), showSettings.clipSettings);
        if (showSettings.backdropSettings != null) copy.backdropSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneBackdropSettings(), showSettings.backdropSettings);

        return copy;
    };

    /**Makes a clone of the Pane's PaneLoadSettings.
    @param {EVUI.Modules.Panes.PaneLoadSettings} loadSettings The load settings to clone.
    @returns {EVUI.Modules.Panes.PaneLoadSettings} */
    var cloneLoadSettings = function (loadSettings)
    {
        var copy = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PaneLoadSettings(), loadSettings);

        if (loadSettings.httpLoadArgs != null) 
        {
            EVUI.Modules.Core.Utils.require("Http", EVUI.Modules.Panes.Dependencies["HtmlLoader"].version, "Cannot use httpLoadArgs.");
            copy.httpLoadArgs = cloneHttpArgs(loadSettings.httpLoadArgs);
        }

        if (loadSettings.placeholderLoadArgs != null)
        {
            EVUI.Modules.Core.Utils.require("HtmlLoaderController", EVUI.Modules.Panes.Dependencies["HtmlLoader"].version, "Cannot use placeholderLoadArgs.");
            copy.placeholderLoadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs(), loadSettings.placeholderLoadArgs);
            copy.placeholderLoadArgs.httpArgs = cloneHttpArgs(copy.placeholderLoadArgs.httpArgs);
        }

        return copy;
    };

    /**Clones a set of EVUI.Modules.Http.HttpRequestArgs.
    @param {EVUI.Modules.Http.HttpRequestArgs} httpArgs The HttpArgs to clone.
    @returns {EVUI.Modules.Http.HttpRequestArgs} */
    var cloneHttpArgs = function (httpArgs)
    {
        var copy = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Http.HttpRequestArgs(), httpArgs);
        copy.headers = httpArgs.headers == null ? [] : httpArgs.headers.map(function (header) { return EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Http.HttpRequestHeader(), header); });

        return copy;
    };

    /** Gets a PaneEntry object based on its ID or a selector function.
    @param {EVUI.Modules.Panes.Constants.Fn_PaneEntrySelector|String} paneIDOrSelector A selector function to select a PaneEntry object (or multiple PaneEntry objects) or the ID of the Pane to get the PaneEntry for.
    @param {Boolean} getAllMatches If a selector function is provided, all the PaneEntries that satisfy the selector are included. Otherwise a single PaneEntry object is returned. False by default.
    @returns {EVUI.Modules.Panes.PaneEntry|EVUI.Modules.Panes.PaneEntry[]} */
    var getPaneEntry = function (paneIDOrSelector, getAllMatches)
    {
        if (typeof paneIDOrSelector === "string")
        {
            var existing = getInternalPaneEntry(paneIDOrSelector);
            if (existing != null)
            {
                return existing.publicEntry;
            }
            else
            {
                return null;
            }
        }
        else if (typeof paneIDOrSelector === "function")
        {
            var results = [];
            var numPanes = _entries.length;
            for (var x = 0; x < numPanes; x++)
            {
                var curEntry = _entries[x];
                if (paneIDOrSelector(curEntry.publicEntry) === true)
                {
                    if (getAllMatches === true)
                    {
                        results.push(curEntry.publicEntry);
                    }
                    else
                    {
                        return curEntry.publicEntry;
                    }
                }
            }

            return results;
        }
        else
        {
            return null;
        }
    };

    /**************************************************************************************EVENT SEQUENCING*************************************************************************************************************/

    /**Performs the operation described in the PaneOperationSession. Takes into account the current state of the pane being executed and will cancel, ignore, or continue operations depending on the combination of current action and requested action. 
    All execution begins asynchronously so that multiple calls in the same stack frame behave correctly.
    @param {PaneOperationSession} opSession The operation session to execute on. */
    var performOperation = function (opSession)
    {
        opSession.foreignActionArgs = _settings.currentActionArgs;
        _settings.currentActionArgs = null;

        var callbackStack = getCallbackStack(opSession.entry.link, opSession.action); //add the callback to the stack of callbacks for the current operation.
        if (callbackStack == null)
        {
            callbackStack = new CallbackStack();
            callbackStack.action = opSession.action;
            opSession.entry.link.callbackStack.push(callbackStack);
        }

        if (callbackStack.opSessions.indexOf(opSession) === -1) callbackStack.opSessions.push(opSession);

        var actionSequence = getActionSequence(opSession); //get the steps we will perform to complete the requested action and always queue the callback even if we wind up doing nothing
        actionSequence = validateActionSequence(actionSequence, opSession); //make sure we aren't doing anything redundantly or need to modify the sequence slightly

        if (actionSequence == null || actionSequence.length === 0) //no sequence or zero length sequence means we do nothing, so just call the callbacks.
        {
            return callCallbackStack(opSession.entry.link, opSession.action, true);
        }
        else if (actionSequence[0] === ActionSequence.Queue) //queue the callback for a duplicate operation without setting up a new event stream
        {
            return;
        }

        opSession.cancel = (actionSequence[0] === ActionSequence.CancelCurrent);
        opSession.continue = (actionSequence[0] === ActionSequence.Continue);

        var eventStream = buildEventStream(actionSequence, opSession);

        if (opSession.cancel === true) //if we have a cancel directive, that means we need to stop the current execution of the old event stream and start a new one
        {
            cancelOperation(eventStream, actionSequence, opSession);
        }
        else if (opSession.continue === true) //if we are continuing one operation, record the operation we were continuing so its callback can be included in the callbacks called for this event.
        {
            continueOperation(eventStream, actionSequence, opSession);
        }
        else //not canceling anything, run the event stream like normal.
        {
            startOperation(eventStream, actionSequence, opSession);
        }
    };

    /**Cancels the current operation and begins a new operation.
    @param {EVUI.Modules.EventStream.EventStream} eventStream The new event stream to begin once the previous one ends.
    @param {String[]} actionSequence The sequence of actions that will be performed.
    @param {PaneOperationSession} opSession The metadata about the operation in progress.*/
    var cancelOperation = function (eventStream, actionSequence, opSession)
    {
        flagSessionAsCanceled(opSession.entry.link, opSession.entry.link.paneAction); //mark all the sessions for the operation as canceled - they all were pre-existing and should all be canceled now that an event has come along to overwrite them

        //if we are in the middle of a transition, bail on the transition
        try
        {
            if (opSession.entry.link.transitionTimeoutID !== -1 && typeof opSession.entry.link.transitionCallback === "function")
            {
                opSession.entry.link.transitionCallback();
                opSession.entry.link.transitionTimeoutID = -1;
                opSession.entry.link.transitionCallback = null;
                opSession.entry.link.transitionSelector = null;
            }

            _settings.backdropManager.cancelTransition();
        }
        catch (ex)
        {
            EVUI.Modules.Core.Utils.log(ex.stack);
        }

        if (opSession.entry.link.eventStream.isWorking() === true && opSession.entry.link.eventStream.getStatus() !== EVUI.Modules.EventStream.EventStreamStatus.Seeking) //if the stream is working but not seeking, cancel the operation (which will fast-forward to the cleanup step)
        {
            opSession.entry.link.eventStream.cancel();
            opSession.entry.link.paneActionSequence = actionSequence;
            opSession.entry.link.paneAction = opSession.action;

            opSession.entry.link.eventStream.onComplete = function (eventArgs) //when the previous chain finishes, launch the new one
            {
                opSession.entry.link.eventStream = eventStream;
                eventStream.execute();
            };
        }
        else //the stream is not busy and not seeking - call the callbacks
        {
            var currentStep = opSession.entry.link.eventStream.getCurrentStep();
            if (currentStep != null && currentStep.key !== "pane.oncomplete") opSession.entry.link.eventStream.seek("pane.oncomplete"); //if the streak was busy, fast forward to the cleanup step

            callCallbackStack(opSession.entry.link, opSession.entry.link.paneAction, false, function () //call all the callbacks associated with the step
            {
                opSession.entry.link.paneActionSequence = actionSequence;
                opSession.entry.link.paneAction = opSession.action;

                if (opSession.entry.link.eventStream.isWorking() === false) //if its NOT working, start it up again
                {
                    setTimeout(function () //we set a timeout so synchronous calls cancel each other out and this ensures that the event stream only begins once the current stack frame has cleared.
                    {
                        var callbackStack = getCallbackStack(opSession.entry.link, opSession.action) //make sure the callbacks haven't already been called or the step wasn't canceled (either way it means the stream shouldn't do anything).
                        if (callbackStack != null)
                        {
                            if (callbackStack.opSessions.filter(function (session) { return session === opSession && session.canceled === true; }).length === 0)
                            {
                                opSession.entry.link.eventStream = eventStream;
                                eventStream.execute();
                            }
                        }
                    });
                }
                else //otherwise wait for completion to change streams
                {
                    opSession.entry.link.eventStream.onComplete = function (eventArgs)
                    {
                        opSession.entry.link.eventStream = eventStream;
                        eventStream.execute();
                    };
                }
            });
        }
    };

    /**Triggers the continuation of one event stream after the other completes to form a single composite operation.
    @param {EVUI.Modules.EventStream.EventStream} eventStream The new event stream to begin once the previous one ends.
    @param {String[]} actionSequence The sequence of actions that will be performed.
    @param {PaneOperationSession} opSession The metadata about the operation in progress.*/
    var continueOperation = function (eventStream, actionSequence, opSession)
    {
        var firstAction = opSession.entry.link.paneAction

        //first, establish the link between the two callback stacks so that a cancel operation picks up both callback stacks
        var firstActionCallbackStack = getCallbackStack(opSession.entry.link, firstAction);
        if (firstActionCallbackStack != null && firstActionCallbackStack.opSessions.length > 0)
        {
            firstActionCallbackStack.opSessions[firstActionCallbackStack.opSessions.length - 1].continuedTo = opSession;
        }

        //then cancel the normal step that calls the callback for the previous event stream.
        var completeStep = opSession.entry.link.eventStream.getStep(_settings.eventNamePrefix + ".oncomplete");
        completeStep.handler = function (jobArgs) { jobArgs.resolve(); }

        //then get the same step, but in the new event stream and overwrite its handler to call BOTH callback stacks. We must the last one first and the first one last - this  because of some kind of race condition that predictably inverts the sequence, so we call them backwards 
        var realCompleteStep = eventStream.getStep(_settings.eventNamePrefix + ".oncomplete");
        realCompleteStep.handler = function (jobArgs)
        {
            callCallbackStack(opSession.entry.link, opSession.action, true, function ()
            {
                callCallbackStack(opSession.entry.link, firstAction, true, function ()
                {
                    jobArgs.resolve();
                });
            });
        };

        //finally, rig up the existing stream's oncomplete handler to call the new event stream once it completes.
        opSession.entry.link.eventStream.onComplete = function (eventArgs)
        {
            var callbackStack = getCallbackStack(opSession.entry.link, opSession.action) //make sure the callbacks haven't already been called or the step wasn't canceled (either way it means the stream shouldn't do anything).
            if (callbackStack != null)
            {
                if (callbackStack.opSessions.filter(function (session) { return session === opSession && session.canceled === true; }).length === 0)
                {
                    opSession.entry.link.eventStream = eventStream;
                    eventStream.execute();
                }
            }
        };
    };

    /**Triggers the beginning of an event stream. It is queued with a callback so that multiple calls in the same stack frame cancel each other out before the event stream finally goes. When it finally goes, it will either do nothing and fail out, or it will continue and execute properly.
    @param {EVUI.Modules.EventStream.EventStream} eventStream The new event stream to begin once the previous one ends.
    @param {String[]} actionSequence The sequence of actions that will be performed.
    @param {PaneOperationSession} opSession The metadata about the operation in progress.*/
    var startOperation = function (eventStream, actionSequence, opSession)
    {
        opSession.entry.link.eventStream = eventStream;
        opSession.entry.link.paneActionSequence = actionSequence;
        opSession.entry.link.paneAction = opSession.action;

        setTimeout(function () //we set a timeout so synchronous calls cancel each other out and this ensures that the event stream only begins once the current stack frame has cleared.
        {
            var callbackStack = getCallbackStack(opSession.entry.link, opSession.action) //make sure the callbacks haven't already been called or the step wasn't canceled (either way it means the stream shouldn't do anything).
            if (callbackStack != null)
            {
                if (callbackStack.opSessions.filter(function (session) { return session === opSession && session.canceled === true; }).length === 0)
                {
                    eventStream.execute();
                }
            }
        });
    };

    /**Marks all the current action's operation sessions as canceled so they can be picked up by the callCallbackStack function later. Also cancels any linked sessions.
    @param {PaneLink} link The internal link object to the pane being operated on.
    @param {String} action The action set to mark as canceled.*/
    var flagSessionAsCanceled = function (link, action)
    {
        var callbackStack = getCallbackStack(link, action)
        if (callbackStack != null)
        {
            var numSessions = callbackStack.opSessions.length;
            for (var x = 0; x < numSessions; x++)
            {
                var curSession = callbackStack.opSessions[x];
                curSession.canceled = true;
                if (curSession.continuedTo != null) flagSessionAsCanceled(link, curSession.continuedTo.action);
            }
        }
    };

    /**Constructs an event stream based on the actions in the action sequence.
    @param {String[]} actionSequence The action sequence to build the event stream for.
    @param {PaneOperationSession} opSession The metadata about the operation in progress.
    @returns {EVUI.Modules.EventStream.EventStream}*/
    var buildEventStream = function (actionSequence, opSession)
    {
        var eventStream = new EVUI.Modules.EventStream.EventStream();
        eventStream.context = opSession.entry.link.wrapper;
        if (eventStream.context == null) eventStream.context = opSession.entry.link.pane;

        configureEventStream(eventStream, opSession); //set the settings for the event stream to get it configured to behave properly

        var numSteps = actionSequence.length;
        for (var x = 0; x < numSteps; x++)
        {
            var curStep = actionSequence[x];

            if (curStep === ActionSequence.Initialize)
            {
                addInitSteps(eventStream, opSession);
            }
            else if (curStep === ActionSequence.Load)
            {
                addLoadSteps(eventStream, opSession);
            }
            else if (curStep === ActionSequence.Show)
            {
                addShowSteps(eventStream, opSession);
            }
            else if (curStep === ActionSequence.Position)
            {
                addPositionSteps(eventStream, opSession);
            }
            else if (curStep === ActionSequence.Hide)
            {
                addHideSteps(eventStream, opSession);
            }
            else if (curStep === ActionSequence.Unload)
            {
                addUnloadSteps(eventStream, opSession);
            }
        }

        //finally, add the complete step that will call the operations callbacks.
        addOnCompleteStep(eventStream, opSession);

        return eventStream;
    };


    /**Configures the EventStream so it makes the right event args, responds to changes in the event args properly, and has the correct cancel behavior.
    @param {EVUI.Modules.EventStream.EventStream} eventStream
    @param {PaneOperationSession} opSession*/
    var configureEventStream = function (eventStream, opSession)
    {
        eventStream.canSeek = true;
        eventStream.endExecutionOnEventHandlerCrash = false;
        var curArgs = null;

        eventStream.processInjectedEventArgs = function (eventStreamArgs)
        {
            curArgs = getArgsAndContext(opSession);

            var paneArgs = new EVUI.Modules.Panes.PaneEventArgs(opSession.entry, curArgs);
            paneArgs.cancel = eventStreamArgs.cancel;
            paneArgs.key = eventStreamArgs.key;
            paneArgs.pause = eventStreamArgs.pause;
            paneArgs.resume = eventStreamArgs.resume;
            paneArgs.stopPropagation = eventStreamArgs.stopPropagation;
            paneArgs.context = curArgs.context;

            //let the settings object take the pane args and produce their own special event args if so desired.
            var processedArgs = _settings.buildEventArgs(opSession.makeArgsPackage(curArgs.context), paneArgs);
            if (processedArgs != null) return processedArgs;
            return paneArgs;
        };

        eventStream.processReturnedEventArgs = function (eventStreamArgs)
        {
            curArgs.context = eventStreamArgs.context;

            _settings.processReturnedEventArgs(opSession.makeArgsPackage(curArgs.context), eventStreamArgs);
        };

        eventStream.onCancel = function ()
        {
            eventStream.seek(_settings.eventNamePrefix + ".oncomplete");
        };

        eventStream.onError = function (args, error)
        {
            eventStream.seek(_settings.eventNamePrefix + ".oncomplete");
        }
    };

    /**Gets the correct args parameter and context value for the current operation.
    @param {PaneOperationSession} opSession The operation session to get the current arguments for.
    @returns {EVUI.Modules.Panes.PaneShowArgs|EVUI.Modules.Panes.PaneHideArgs|EVUI.Modules.Panes.PaneLoadArgs|EVUI.Modules.Panes.PaneUnloadArgs} */
    var getArgsAndContext = function (opSession)
    {
        var curArgs = null;
        if (opSession.currentAction === EVUI.Modules.Panes.PaneAction.Show)
        {
            curArgs = opSession.showArgs;
        }
        else if (opSession.currentAction === EVUI.Modules.Panes.PaneAction.Hide)
        {
            curArgs = opSession.hideArgs;
        }
        else if (opSession.currentAction === EVUI.Modules.Panes.PaneAction.Load)
        {
            curArgs = opSession.loadArgs;
            if (opSession.loadArgs.context == null)
            {
                if (opSession.showArgs != null) opSession.loadArgs.context = opSession.showArgs.context;
            }
        }
        if (opSession.currentAction === EVUI.Modules.Panes.PaneAction.Unload)
        {
            curArgs = opSession.unloadArgs;
            if (opSession.unloadArgs.context == null)
            {
                if (opSession.hideArgs != null) opSession.unloadArgs.context = opSession.hideArgs.context;
            }
        }

        return curArgs;
    }

    /**Adds the load sequence steps to the EventStream.
    @param {EVUI.Modules.EventStream.EventStream} eventStream The event stream to receive the events.
    @param {PaneOperationSession} opSession The operation session driving the events.*/
    var addLoadSteps = function (eventStream, opSession)
    {
        var skipLoad = false;

        eventStream.addStep({
            name: "preload",
            key: _settings.eventNamePrefix + ".preload",
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            handler: function (jobArgs)
            {
                opSession.currentAction = EVUI.Modules.Panes.PaneAction.Load;
                if (opSession.entry.link.pane.element != null && opSession.entry.link.pane.element.isConnected === true)
                {
                    opSession.entry.link.paneStateFlags |= EVUI.Modules.Panes.PaneStateFlags.Loaded;
                    skipLoad = true;
                }

                jobArgs.resolve();
            }
        });


        eventStream.addStep({
            name: "onLoad",
            key: _settings.eventNamePrefix + ".onload",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (eventArgs)
            {
                if (EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded) === true) return;

                if (typeof opSession.entry.link.pane.onLoad === "function")
                {
                    return opSession.entry.link.pane.onLoad.call(this, eventArgs)
                }
            }
        });

        eventStream.addStep({
            name: "onLoad",
            key: _settings.eventNamePrefix + ".onload",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (eventArgs)
            {
                if (EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded) === true) return;

                if (typeof _self.onLoad === "function")
                {
                    return _self.onLoad.call(_settings.manager, eventArgs)
                }
            }
        });

        eventStream.addStep({
            name: "load",
            key: _settings.eventNamePrefix + ".load",
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            handler: function (jobArgs)
            {
                if (EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded) === true && opSession.loadArgs.reload === false) return jobArgs.resolve();

                if (opSession.entry.link.pane.element != null)
                {
                    opSession.entry.link.paneStateFlags |= EVUI.Modules.Panes.PaneStateFlags.Loaded;
                    return jobArgs.resolve();
                }

                if (opSession.loadArgs.reload === true)
                {
                    opSession.entry.link.paneStateFlags = EVUI.Modules.Core.Utils.removeFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded);
                    unloadRootElement(opSession.entry);
                }

                loadRootElement(opSession.entry, opSession.loadArgs.loadSettings, function (success)
                {
                    if (success === true)
                    {
                        if (opSession.entry.link.pane.element != null)
                        {
                            if (opSession.entry.link.pane.element.isConnected === false) moveToLoadDiv(opSession.entry);
                        }

                        opSession.entry.link.paneStateFlags |= EVUI.Modules.Panes.PaneStateFlags.Loaded;
                        opSession.entry.link.lastLoadSettings = opSession.loadArgs.loadSettings;
                        jobArgs.resolve();
                    }
                    else
                    {
                        jobArgs.reject("Failed to load " + _settings.objectName + " root element.")
                    }
                });
            }
        });

        eventStream.addStep({
            name: "onLoaded",
            key: _settings.eventNamePrefix + ".onloaded",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (eventArgs)
            {
                if (skipLoad === true) return;

                if (typeof opSession.entry.link.pane.onLoaded === "function")
                {
                    return opSession.entry.link.pane.onLoaded.call(this, eventArgs)
                }
            }
        });

        eventStream.addStep({
            name: "onLoaded",
            key: _settings.eventNamePrefix + ".onloaded",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (eventArgs)
            {
                if (skipLoad === true) return;

                if (typeof _self.onLoaded === "function")
                {
                    return _self.onLoaded.call(_settings.manager, eventArgs)
                }
            }
        });
    };


    /**Adds the initialize sequence steps to the EventStream.
    @param {EVUI.Modules.EventStream.EventStream} eventStream The event stream to receive the events.
    @param {PaneOperationSession} opSession The operation session driving the events.*/
    var addInitSteps = function (eventStream, opSession)
    {
        eventStream.addStep({
            name: "onInitialize",
            key: _settings.eventNamePrefix + ".oninit",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (eventArgs)
            {
                opSession.currentAction = EVUI.Modules.Panes.PaneAction.Show;

                if (EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Initialized) === true) return;
                if (typeof opSession.entry.link.pane.onInitialize === "function")
                {
                    return opSession.entry.link.pane.onInitialize.call(this, eventArgs);
                }
            }
        });

        eventStream.addStep({
            name: "onInitialize",
            key: _settings.eventNamePrefix + ".oninit",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (eventArgs)
            {
                if (EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Initialized) === true) return;

                if (typeof _self.onInitialize === "function")
                {
                    return _self.onInitialize.call(_settings.manager, eventArgs);
                }
            }
        });

        eventStream.addStep({
            name: "initialize",
            key: _settings.eventNamePrefix + ".load",
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            handler: function (jobArgs)
            {
                opSession.entry.link.paneStateFlags |= EVUI.Modules.Panes.PaneStateFlags.Initialized;
                jobArgs.resolve();
            }
        });
    };


    /**Adds the show sequence steps to the EventStream.
    @param {EVUI.Modules.EventStream.EventStream} eventStream The event stream to receive the events.
    @param {PaneOperationSession} opSession The operation session driving the events.*/
    var addShowSteps = function (eventStream, opSession)
    {
        eventStream.addStep({
            name: "onShow",
            key: _settings.eventNamePrefix + ".onshow",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (eventArgs)
            {
                opSession.currentAction = EVUI.Modules.Panes.PaneAction.Show;
                
                if (typeof opSession.entry.link.pane.onShow === "function")
                {
                    return opSession.entry.link.pane.onShow.call(this, eventArgs)
                }
            }
        });

        eventStream.addStep({
            name: "onShow",
            key: _settings.eventNamePrefix + ".onshow",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (eventArgs)
            {
                if (typeof _self.onShow === "function")
                {
                    return _self.onShow.call(_settings.manager, eventArgs)
                }
            }
        });

        addPositionSteps(eventStream, opSession);

        eventStream.addStep({
            name: "onShown",
            key: _settings.eventNamePrefix + ".onshown",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (eventArgs)
            {
                if (typeof opSession.entry.link.pane.onShown === "function")
                {
                    return opSession.entry.link.pane.onShown.call(this, eventArgs)
                }
            }
        });

        eventStream.addStep({
            name: "onShown",
            key: _settings.eventNamePrefix + ".onshown",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (eventArgs)
            {
                if (typeof _self.onShown === "function")
                {
                    return _self.onShown.call(_settings.manager, eventArgs)
                }
            }
        });
    };


    /**Adds the hide sequence steps to the EventStream.
    @param {EVUI.Modules.EventStream.EventStream} eventStream The event stream to receive the events.
    @param {PaneOperationSession} opSession The operation session driving the events.*/
    var addHideSteps = function (eventStream, opSession)
    {
        var skip = false;

        eventStream.addStep({
            name: "onHide",
            key: _settings.eventNamePrefix + ".onHide",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (eventArgs)
            {
                opSession.currentAction = EVUI.Modules.Panes.PaneAction.Hide;
                if (EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Visible) === false)
                {
                    skip = true;
                    return;
                }

                if (typeof opSession.entry.link.pane.onHide === "function")
                {
                    return opSession.entry.link.pane.onHide.call(this, eventArgs)
                }
            }
        });

        eventStream.addStep({
            name: "onHide",
            key: _settings.eventNamePrefix + ".onHide",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (eventArgs)
            {
                if (EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Visible) === false) return;

                if (typeof _self.onHide === "function")
                {
                    return _self.onHide.call(_settings.manager, eventArgs);
                }
            }
        });

        eventStream.addStep({
            name: "hide",
            key: _settings.eventNamePrefix + "hide",
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            handler: function (jobArgs)
            {
                if (EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Visible) === false) return jobArgs.resolve();

                var rootHidden = false;
                var transitionApplied = false;
                var commonCallback = function ()
                {
                    if (rootHidden === false || transitionApplied === false) return;

                    opSession.entry.link.paneStateFlags = EVUI.Modules.Core.Utils.removeFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Visible);
                    opSession.entry.link.paneStateFlags = EVUI.Modules.Core.Utils.removeFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Positioned);
                    jobArgs.resolve();
                }

                hideRootElement(opSession.entry, opSession.entry.link.lastShowSettings, opSession.hideArgs.paneHideTransition, function ()
                {
                    rootHidden = true;
                    commonCallback();
                });

                hideBackdrop(opSession.entry, function (success)
                {
                    transitionApplied = true;
                    commonCallback();
                });
            }
        });

        eventStream.addStep({
            name: "ohHidden",
            key: _settings.eventNamePrefix + ".onhidden",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (eventArgs)
            {
                if (skip === true) return;

                if (typeof opSession.entry.link.pane.onHidden === "function")
                {
                    return opSession.entry.link.pane.onHidden.call(this, eventArgs)
                }
            }
        });

        eventStream.addStep({
            name: "ohHidden",
            key: _settings.eventNamePrefix + ".onhidden",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (eventArgs)
            {
                if (skip === true) return;

                if (typeof _self.onShown === "function")
                {
                    return _self.onShown.call(_settings.manager, eventArgs)
                }
            }
        });
    };


    /**Adds the positioning sequence steps to the EventStream.
    @param {EVUI.Modules.EventStream.EventStream} eventStream The event stream to receive the events.
    @param {PaneOperationSession} opSession The operation session driving the events.*/
    var addPositionSteps = function (eventStream, opSession)
    {
        var positionObserver = null;
        var showArgsObserver = null;

        eventStream.addStep({
            name: "initialPosition",
            key: _settings.eventNamePrefix + ".initialposition",
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            handler: function (jobArgs)
            {
                opSession.action = EVUI.Modules.Panes.PaneAction.Show;
                var position = getPosition(opSession.entry, opSession.showArgs.showSettings);
                opSession.entry.link.lastCalculatedPosition = position;

                positionObserver = new EVUI.Modules.Observers.ObjectObserver(position);
                showArgsObserver = new EVUI.Modules.Observers.ObjectObserver(opSession.showArgs);

                jobArgs.resolve();
            }
        });

        eventStream.addStep({
            name: "onPosition",
            key: _settings.eventNamePrefix + ".onposition",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (eventArgs)
            {
                if (typeof opSession.entry.link.pane.onPosition === "function")
                {
                    return opSession.entry.link.pane.onPosition.call(this, eventArgs)
                }
            }
        });

        eventStream.addStep({
            name: "onPosition",
            key: _settings.eventNamePrefix + ".onposition",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (eventArgs)
            {
                if (typeof _self.onPosition === "function")
                {
                    return _self.onPosition.call(_settings.manager, eventArgs)
                }
            }
        });

        eventStream.addStep({
            name: "finalPosition",
            key: _settings.eventNamePrefix + ".finalposition",
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            handler: function (jobArgs)
            {
                var positionChanges = positionObserver.getChanges();
                var settingsChanges = showArgsObserver.getChanges().filter(function (change) { return change.path.indexOf("showSettings") !== -1 });

                var transitionApplied = false;
                var positioned = false;

                var callback = function ()
                {
                    if (transitionApplied === false || positioned === false) return;

                    opSession.entry.link.paneStateFlags |= EVUI.Modules.Panes.PaneStateFlags.Positioned;
                    opSession.entry.link.paneStateFlags |= EVUI.Modules.Panes.PaneStateFlags.Visible;
                    opSession.entry.link.lastShowSettings = opSession.showArgs.showSettings;
                    jobArgs.resolve();
                };

                if (opSession.showArgs.showSettings.backdropSettings != null && opSession.showArgs.showSettings.backdropSettings.showBackdrop === true)
                {
                    EVUI.Modules.Panes.Constants.GlobalZIndex++;
                    opSession.entry.link.lastCalculatedPosition.zIndex = EVUI.Modules.Panes.Constants.GlobalZIndex;

                     _settings.backdropManager.showBackdrop(opSession.entry.link.paneCSSName, opSession.entry.link.lastCalculatedPosition.zIndex -1 , opSession.showArgs.showSettings.backdropSettings, function ()
                    {
                        transitionApplied = true;
                        callback();
                    });
                }
                else
                {
                    transitionApplied = true;
                    callback();
                }

                if (positionChanges.length === 0 && settingsChanges.length === 0)
                {
                    positionPane(opSession.entry, opSession.showArgs.showSettings, opSession.entry.link.lastCalculatedPosition, function (success)
                    {
                        positioned = true;
                        callback();
                    });
                }
                else if (positionChanges.length > 0)
                {
                    positionPane(opSession.entry, opSession.showArgs.showSettings, opSession.entry.link.lastCalculatedPosition, function (success)
                    {
                        positioned = true;
                        callback();
                    });
                }
                else
                {
                    positionPane(opSession.entry, opSession.showArgs.showSettings, null, function (success)
                    {
                        positioned = true;
                        callback();
                    });
                }
            }
        });
    };

    /**Adds the final, onComplete step to the EventStream that calls all the callbacks for the operation.
    @param {EVUI.Modules.EventStream.EventStream} eventStream The event stream to receive the events.
    @param {PaneOperationSession} opSession The operation session driving the events.*/
    var addOnCompleteStep = function (eventStream, opSession)
    {
        eventStream.addStep({

            name: "OnComplete",
            key: _settings.eventNamePrefix + ".oncomplete",
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            handler: function (args)
            {
                var success = true;
                if (opSession.action === EVUI.Modules.Panes.PaneAction.Hide && EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Visible) === true) success = false;
                if (opSession.action === EVUI.Modules.Panes.PaneAction.Load && EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded) === false) success = false;
                if (opSession.action === EVUI.Modules.Panes.PaneAction.Show && EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Visible) === false) success = false;
                if (opSession.action === EVUI.Modules.Panes.PaneAction.Unload && EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded) === true) success = false;

                callCallbackStack(opSession.entry.link, opSession.action, success, function ()
                {
                    if (opSession.unloadArgs != null && opSession.unloadArgs.remove === true) _self.removePane(opSession.entry.paneID);
                    opSession.entry.link.paneAction = EVUI.Modules.Panes.PaneAction.None;
                    opSession.entry.link.lastCalculatedPosition = null;
                    args.resolve();
                });
            }
        });
    };

    /**Adds the unload sequence steps to the EventStream.
    @param {EVUI.Modules.EventStream.EventStream} eventStream The event stream to receive the events.
    @param {PaneOperationSession} opSession The operation session driving the events.*/
    var addUnloadSteps = function (eventStream, opSession)
    {
        var skip = false;

        eventStream.addStep({
            name: "onUnload",
            key: _settings.eventNamePrefix + ".onunload",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (eventArgs)
            {
                var priorAction = opSession.action;
                opSession.currentAction = EVUI.Modules.Panes.PaneAction.Unload;
                if (EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded) === false)
                {
                    skip = true;
                    return;
                }

                if (opSession.entry.link.pane.unloadOnHide === false && priorAction === ActionSequence.Hide)
                {
                    skip = true;
                    return;
                }

                if (typeof opSession.entry.link.pane.onUnload === "function")
                {
                    return opSession.entry.link.pane.onUnload.call(this, eventArgs)
                }
            }
        });

        eventStream.addStep({
            name: "onUnload",
            key: _settings.eventNamePrefix + ".onunload",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (eventArgs)
            {
                if (skip === true || EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded) === false) return;

                if (typeof _self.onUnload === "function")
                {
                    return _self.onUnload.call(_settings.manager, eventArgs);
                }
            }
        });

        eventStream.addStep({
            name: "unload",
            key: _settings.eventNamePrefix + ".unload",
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            handler: function (jobArgs)
            {
                if (skip === true) return jobArgs.resolve();

                try
                {
                    opSession.entry.link.paneStateFlags = EVUI.Modules.Core.Utils.removeFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded);
                    unloadRootElement(opSession.entry, opSession.entry.link.lastShowSettings);                    
                }
                catch (ex)
                {
                    opSession.entry.link.paneStateFlags = EVUI.Modules.Core.Utils.addFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded);
                }

                opSession.entry.link.paneStateFlags = EVUI.Modules.Core.Utils.removeFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Initialized);
                jobArgs.resolve();
            }
        });

        eventStream.addStep({
            name: "onUnloaded",
            key: _settings.eventNamePrefix + ".onunloaded",
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            handler: function (eventArgs)
            {
                if (skip === true) return;

                if (typeof opSession.entry.link.pane.onUnloaded === "function")
                {
                    return opSession.entry.link.pane.onUnloaded.call(this, eventArgs)
                }
            }
        });

        eventStream.addStep({
            name: "onUnloaded",
            key: _settings.eventNamePrefix + ".onUnloaded",
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            handler: function (eventArgs)
            {
                if (skip === true) return;

                if (typeof _self.onUnloaded === "function")
                {
                    return _self.onUnloaded.call(_settings.manager, eventArgs)
                }
            }
        });
    };

    /**Validates the action sequence by checking the current operation and modifying the action sequence to do the appropriate thing.
    @param {String[]} actionSequence The pre-generated action sequence of proposed events to occur.
    @param {PaneOperationSession} opSession Metadata about the operation in progress.
    @returns {String[]}*/
    var validateActionSequence = function (actionSequence, opSession)
    {
        var opAction = opSession.action;
        var currentAction = opSession.entry.link.paneAction;

        if (opAction === EVUI.Modules.Panes.PaneAction.Load)
        {
            if (opSession.loadArgs.reload === true)
            {
                return actionSequence;
            }
            else
            {
                if (currentAction === EVUI.Modules.Panes.PaneAction.Show)
                {
                    return [ActionSequence.Continue];
                }
                else if (currentAction === EVUI.Modules.Panes.PaneAction.Load)
                {
                    return [ActionSequence.Queue];
                }
                else if (currentAction === EVUI.Modules.Panes.PaneAction.Hide
                    || currentAction === EVUI.Modules.Panes.PaneAction.Unload
                    || currentAction === EVUI.Modules.Panes.PaneAction.None)
                {
                    return actionSequence;
                }
                else
                {
                    throw Error("Invalid action: \"" + currentAction);
                }
            }
        }
        else if (opAction === EVUI.Modules.Panes.PaneAction.Show)
        {
            if (currentAction === EVUI.Modules.Panes.PaneAction.Load)
            {
                return actionSequence;
            }
            else if (currentAction === opAction)
            {
                return [ActionSequence.Queue];
            }
            else
            {
                return actionSequence;
            }
        }
        else
        {
            if (currentAction === opAction)
            {
                return [ActionSequence.Queue];
            }
            else
            {
                return actionSequence;
            }
        }
    };

    /**Gets the sequence of actions to perform based on the operation's metadata and the current state of the pane.
    @param {PaneOperationSession} opSession Metadata about the operation in progress.
    @returns {String[]} */
    var getActionSequence = function (opSession)
    {
        var sequence = [];

        if (opSession.action === EVUI.Modules.Panes.PaneAction.Show)
        {
            sequence = getShowSequence(opSession);
        }
        else if (opSession.action === EVUI.Modules.Panes.PaneAction.Load)
        {
            sequence = getLoadSequence(opSession);
        }
        else if (opSession.action === EVUI.Modules.Panes.PaneAction.Hide)
        {
            sequence = getHideSequence(opSession);
        }
        else if (opSession.action === EVUI.Modules.Panes.PaneAction.Unload)
        {
            sequence = getUnloadSequence(opSession);
        }

        return sequence;
    };

    /**Gets the sequence of events that should occur when issued a show command.
    @param {PaneOperationSession} opSession Metadata about the operation in progress.
    @returns {String[]}*/
    var getShowSequence = function (opSession)
    {
        //showing always starts with loading
        var sequence = getLoadSequence(opSession);
        var shouldCancel = sequence.indexOf(ActionSequence.CancelCurrent) !== -1;

        if (shouldCancel === false && (opSession.entry.link.paneAction === EVUI.Modules.Panes.PaneAction.Hide || opSession.entry.link.paneAction === EVUI.Modules.Panes.PaneAction.Unload)) //if we're doing the opposite of show, stop the operation
        {
            sequence.push(ActionSequence.CancelCurrent);
        }

        if (EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Initialized) === false || opSession.showArgs.reInitialize === true) //whether or not the init function has been called - only called on the first show after it has been loaded. 
        {
            sequence.push(ActionSequence.Initialize);
        }

        sequence.push(ActionSequence.Show); //show includes position

        return sequence;
    };

    /**Gets the sequence of events that should occur when issued a load command.
    @param {PaneOperationSession} opSession Metadata about the operation in progress.
    @returns {String[]}*/
    var getLoadSequence = function (opSession)
    {
        var sequence = [];

        if (EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded) === true) //if we're already loaded
        {
            if (opSession.loadArgs.reload === true) //forcing a reload
            {
                if (opSession.entry.link.paneAction !== EVUI.Modules.Panes.PaneAction.None) //if we were doing anything, we need to cancel it and begin the load again (even another load operation)
                {
                    sequence.push(ActionSequence.CancelCurrent);
                }

                sequence.push(ActionSequence.Load);
                return sequence;
            }
        }
        else //not loaded yet
        {
            if (opSession.entry.link.paneAction !== EVUI.Modules.Panes.PaneAction.None && opSession.entry.link.paneAction !== EVUI.Modules.Panes.PaneAction.Load) //if we were doing anything (other than another load operation), we need to cancel it  
            {
                sequence.push(ActionSequence.CancelCurrent);
            }

            if (opSession.entry.link.paneAction !== EVUI.Modules.Panes.PaneAction.Load) //if we're not doing a load operation, add the load step
            {
                //add the load step
                sequence.push(ActionSequence.Load);
            }
        }

        return sequence;
    };

    /**Gets the sequence of events that should occur when issued a hide command.
    @param {PaneOperationSession} opSession Metadata about the operation in progress.
    @returns {String[]}*/
    var getHideSequence = function (opSession)
    {
        var sequence = [];

        if (opSession.entry.link.paneAction === EVUI.Modules.Panes.PaneAction.Load || opSession.entry.link.paneAction === EVUI.Modules.Panes.PaneAction.Show || opSession.entry.link.paneAction === EVUI.Modules.Panes.PaneAction.Unload) //if it's being loaded or shown (which also loads it), cancel that operation
        {
            sequence.push(ActionSequence.CancelCurrent);
        }

        if (opSession.entry.link.paneAction === EVUI.Modules.Panes.PaneAction.Hide) return sequence;

        sequence.push(ActionSequence.Hide);
        if (EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded) === true) sequence.push(ActionSequence.Unload); //unload on hide is a setting that could change over the course of hide, so we always queue those events when hiding.

        return sequence;
    };

    /**Gets the sequence of events that should occur when issued a show command.
    @param {PaneOperationSession} opSession Metadata about the operation in progress.
    @returns {String[]}*/
    var getUnloadSequence = function (opSession)
    {
        var sequence = [];

        if (opSession.entry.link.paneAction === EVUI.Modules.Panes.PaneAction.Load || opSession.entry.link.paneAction === EVUI.Modules.Panes.PaneAction.Show || opSession.entry.link.paneAction === EVUI.Modules.Panes.PaneAction.Hide) //cancel if anything is happening already
        {
            sequence.push(ActionSequence.CancelCurrent);
        }

        if (EVUI.Modules.Core.Utils.hasFlag(opSession.entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded) === true)
        {
            sequence.push(ActionSequence.Unload);
        }

        return sequence;
    };

    /** Gets a CallbackStack object representing all of the queued callbacks for a given pane action.
    @param {PaneLink} link The link to the pane being executed.
    @param {String} action The type of callback stack to get.
    @returns {CallbackStack}*/
    var getCallbackStack = function (link, action)
    {
        var numStacks = link.callbackStack.length;
        for (var x = 0; x < numStacks; x++)
        {
            var curStack = link.callbackStack[x];
            if (curStack.action === action) return curStack;
        }

        return null;
    };

    /**Calls a CallbackStack, and optionally any linked callback stacks, in the order that they were queued.
    @param {PaneLink} link The link to the pane being executed.
    @param {String} action The action to execute the callbacks for.
    @param {Boolean} success Whether or not the caller has determined if the operation has successfully completed.
    @param {Function} callback A callback function to call once all the other callbacks have been called.*/
    var callCallbackStack = function (link, action, success, callback)
    {
        if (typeof callback !== "function") callback = function (executed) { };

        var callbackStack = getCallbackStack(link, action); //get the callback stack we're calling
        if (callbackStack == null) return callback(false);

        var index = link.callbackStack.indexOf(callbackStack); //remove the entire thing BEFORE we execute any of them
        if (index !== -1) link.callbackStack.splice(index, 1);

        var callbacks = [];
        var allSessions = [];
        var numSession = callbackStack.opSessions.length;
        var hasLink = false;
        for (var x = 0; x < numSession; x++) //check and see if we have any linked continued steps, we need to call both lists of callbacks in one go
        {
            var curSession = callbackStack.opSessions[x];
            if (curSession.continuedTo != null) //we have a link
            {
                var linkedCallbackStack = getCallbackStack(link, curSession.continuedTo.action);
                if (linkedCallbackStack != null && hasLink === false) //we haven't already merged the two together
                {
                    hasLink = true;

                    var canceledSessions = linkedCallbackStack.opSessions.filter(function (op) { return op.canceled; }); //get all the canceled ones
                    if (canceledSessions.length === linkedCallbackStack.opSessions.length) //if they all were canceled, remove the entry from the list
                    {
                        var index = link.callbackStack.indexOf(linkedCallbackStack);
                        if (index !== -1) link.callbackStack.splice(index, 1);
                    }
                    else //otherwise keep the ones that weren't canceled in the list to be called later
                    {
                        linkedCallbackStack.opSessions = linkedCallbackStack.opSessions.filter(function (op) { return op.canceled === false; });
                    }

                    allSessions = allSessions.concat(canceledSessions); //add any sessions that were canceled.
                }
            }

            allSessions.push(curSession);
        }

        //if we have any linked sessions, we concatenated both complete sessions (so we miss no callbacks), but they will be in the wrong order. Sort them to get the true order.
        numSession = allSessions.length;
        if (hasLink === true) allSessions = allSessions.sort(function (a, b) { return a.callbackOrdinal - b.callbackOrdinal });

        for (var x = 0; x < numSession; x++)
        {
            var curSession = allSessions[x];
            if (typeof curSession.callback === "function") callbacks.push(curSession.callback);
        }

        var exeArgs = new EVUI.Modules.Core.AsyncSequenceExecutionArgs();
        exeArgs.functions = callbacks;
        exeArgs.parameter = success;
        exeArgs.forceCompletion = true;

        EVUI.Modules.Core.AsyncSequenceExecutor.execute(exeArgs, function (ex)
        {
            if (ex != null && ex.length > 0) EVUI.Modules.Core.Utils.log(ex);
            callback(true);
        });
    };

    /**************************************************************************************POSITIONING*************************************************************************************************************/

    /**Positions the pane using either a PanePosition or PaneShowSettings.
    @param {InternalPaneEntry} entry
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings Either a PaneShowSettings or a PanePosition object.
    @param {EVUI.Modules.Panes.PanePosition} position Optional. The position to place the pane at, if populated will be used instead of the showSettings for the final position of the pane.
    @param {Function} callback A callback function to call once the Pane has been positioned. */
    var positionPane = function (entry, showSettings, position, callback)
    {
        _settings.stylesheetManager.ensureSheet(_settings.cssSheetName, { lock: true });

        if (position != null && (position instanceof EVUI.Modules.Panes.PanePosition || (typeof position.top === "number" && position.left === "number" && typeof position.mode === "string")))
        {
            position = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PanePosition(position.mode), position, ["mode"]);
        }

        showSettings = (showSettings != null) ? makeOrExtendShowSettings(showSettings) : entry.link.pane.showSettings;     

        setPosition(entry, showSettings, position, callback);
    };

    /**Sets the Position of a Pane.
    @param {InternalPaneEntry} entry The entry representing the Pane to display.
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings The current settings dictating how the Pane will be positioned and displayed.
    @param {Function} callback A callback function to call once the Pane has been positioned and has had its transition effect removed (if there was one).*/
    var setPosition = function (entry, showSettings, position, callback)
    {
        if (typeof callback !== "function") callback = function () { };

        if (position == null)
        {
            entry.link.lastShowSettings = showSettings
            position = getPosition(entry, showSettings); //calculate the position 
        }

        entry.link.lastCalculatedPosition = position;

        removePaneCSS(entry); //remove the CSS from the stylesheet
        removePaneClasses(entry); //remove all the existing classes from the Pane

        if (position == null)
        {
            moveToLoadDiv(entry);
            return callback(false);
        }

        generatePaneCSS(entry, showSettings, position); //build the CSS and apply all the classes
        displayPane(entry, showSettings, position, false, function (success)
        {
            callback(success);
        });
    };

    /**Gets the position of a Pane without disturbing its current position or state.
    @param {InternalPaneEntry} entry The entry representing the Pane to get the position of.
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings The settings for how to display the Pane.
    @returns {EVUI.Modules.Panes.PanePosition}*/
    var getPosition = function (entry, showSettings)
    {
        if (entry == null || entry.link.pane.element == null) return null; //no element, no position
        if (EVUI.Modules.Core.Utils.hasFlag(entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded) === false) return null; //not loaded, can't position it

        //first, remove all the classes we have added that are positioning the element
        var removedClasses = removePaneClasses(entry);

        var ele = new EVUI.Modules.Dom.DomHelper(entry.link.pane.element);
        var position = null;
        var mode = getPositionMode(showSettings);

        if (mode !== EVUI.Modules.Panes.PanePositionMode.DocumentFlow && EVUI.Modules.Core.Utils.hasFlag(entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Visible) === false) //not visible, we can't measure it right now and therefore can't place it
        {
            moveToMeasureDiv(entry); //move it to a special div where it has no height or width, but has invisible overflow. This allows us to measure the element as if it were visible without actually displaying it
            position = calculatePosition(entry, showSettings, mode);
            moveToLoadDiv(entry); //move it out of the special div and put it back in the hidden div
        }
        else //visible, we can measure it as it is.
        {
            position = calculatePosition(entry, showSettings, mode);
        }

        //add all the classes that were removed from it back to it so we complete the operation with no disturbance in the state of the pane.
        ele.addClass(removedClasses);
        return position;
    };

    /**Generates and applies the CSS required to position a Pane.
    @param {InternalPaneEntry} entry The entry representing the Pane.
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings The settings that were used to position the Pane.
    @param {EVUI.Modules.Panes.PanePosition} position The position that was calculated using the show settings.*/
    var generatePaneCSS = function (entry, showSettings, position)
    {
        var positionSelector = getSelector(entry, EVUI.Modules.Panes.Constants.CSS_Position);
        var classesToApply = position.classNames.reverse(); //we reverse them so that they appear in the right order on the element.

        if (position.mode === EVUI.Modules.Panes.PanePositionMode.AbsolutePosition ||
            position.mode === EVUI.Modules.Panes.PanePositionMode.Anchored ||
            position.mode === EVUI.Modules.Panes.PanePositionMode.RelativePosition ||
            position.mode === EVUI.Modules.Panes.PanePositionMode.Centered ||
            position.mode === EVUI.Modules.Panes.PanePositionMode.None)
        {
            var rules = {};
            rules.display = "inline-block";
            rules.position = "absolute";
            rules.top = position.top + "px";
            rules.left = position.left + "px";

            var dimensionRules = getDimensionRules(entry, showSettings, position);
            if (dimensionRules.setHeight === true) rules.height = (position.bottom - position.top) + "px";
            if (dimensionRules.setWidth === true) rules.width = (position.right - position.left) + "px";

            rules.zIndex = position.zIndex.toString();

            _settings.stylesheetManager.setRules(_settings.cssSheetName, positionSelector, rules);
        }
        else if (position.mode === EVUI.Modules.Panes.PanePositionMode.Fullscreen)
        {
            var rules = {};
            rules.display ="inline-block";
            rules.position = "fixed";
            rules.top = "0px";
            rules.left = "0px";
            rules.height = "100vh";
            rules.width = "100vw";
            rules.margin = "0px";

            var dimensionRules = getDimensionRules(entry, showSettings, position);
            if (dimensionRules.setHeight === true)
            {
                rules.top = position.top + "px";
                rules.height = (position.bottom - position.top) + "px";
            }

            if (dimensionRules.setWidth === true)
            {
                rules.left = position.left + "px";
                rules.width = (position.right - position.left) + "px";
            }

            _settings.stylesheetManager.setRules(_settings.cssSheetName, positionSelector, rules);
        }
        else if (position.mode === EVUI.Modules.Panes.PanePositionMode.PositionClass)
        {
            var rules = null;

            var dimensionRules = getDimensionRules(entry, showSettings, position);
            if (dimensionRules.setHeight === true)
            {
                rules = {};
                rules.top = position.top + "px";
                rules.position = "absolute";
                rules.height = (position.bottom - position.top) + "px";
            }

            if (dimensionRules.setWidth === true)
            {
                if (rules == null) rules = {};
                rules.left = position.left + "px";
                rules.position = "absolute";
                rules.width = (position.right - position.left) + "px";
            }

            if (dimensionRules.setHeight === true || dimensionRules.setWidth === true)
            {
                _settings.stylesheetManager.setRules(_settings.cssSheetName, positionSelector, rules);
            }
        }

        var eh = new EVUI.Modules.Dom.DomHelper(entry.link.pane.element); //add all the classes
        eh.addClass(classesToApply);
    };

    /**Gets the rules for whether or not the height or width of a Pane should be explicitly set or not.
    @param {InternalPaneEntry} entry The entry whose height and width may be set.
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings The current show settings used to calculate the position.
    @param {EVUI.Modules.Panes.PanePosition} position The position that was calculated based on the showSettings.
    @returns {{setHeight:Number, setWidth:Number}} */
    var getDimensionRules = function (entry, showSettings, position)
    {
        var setDims = { setHeight: false, setWidth: false };

        if (showSettings.setExplicitDimensions === true) //if the setting for setting the dimensions explicitly is set, set the dimensions.
        {
            setDims.setHeight = true;
            setDims.setWidth = true;

            return setDims;
        }

        //if the pane has been clipped in either direction, we need to explicitly set whichever dimension was clipped.
        if (position.classNames.indexOf(EVUI.Modules.Panes.Constants.CSS_ClippedX) !== -1) setDims.setWidth = true;
        if (position.classNames.indexOf(EVUI.Modules.Panes.Constants.CSS_ClippedY) !== -1) setDims.setHeight = true;

        //if the pane was anchored and one of its alignments is elastic, or if it is bound between two opposite sides, we need to set the height or width explicitly
        if (position.mode === EVUI.Modules.Panes.PanePositionMode.Anchored)
        {
            if (showSettings.anchors.alignX === EVUI.Modules.Panes.AnchorAlignment.Elastic) setDims.setWidth = true;
            if (showSettings.anchors.alignY === EVUI.Modules.Panes.AnchorAlignment.Elastic) setDims.setHeight = true;
            if (showSettings.anchors.left != null && showSettings.anchors.right != null) setDims.setWidth = true;
            if (showSettings.anchors.top != null && showSettings.anchors.bottom != null) setDims.setHeight = true;
        }

        return setDims;
    };

    /**Removes all the CSS rules from the managed sheet that pertain to a particular Pane.
    @param {InternalPaneEntry} entry The entry representing the Pane to remove the CSS of.*/
    var removePaneCSS = function (entry)
    {
        var allClasses = getAllClassNames();
        var numClasses = allClasses.length;

        for (var x = 0; x < numClasses; x++)
        {
            var selector = getSelector(entry, allClasses[x]);
            if (selector == null) continue;

            _settings.stylesheetManager.removeRules(_settings.cssSheetName, selector);
        }
    };

    /**Removes all the auto-generated CSS classes from the Pane without removing the rules from the sheet.
    @param {InternalPaneEntry} entry The entry representing the BantmWindo to remove the classes from.*/
    var removePaneClasses = function (entry)
    {
        var allClasses = getAllClassNames();
        var numClasses = allClasses.length;
        var existingClasses = [];

        var eh = new EVUI.Modules.Dom.DomHelper(entry.link.pane.element);
        for (var x = 0; x < numClasses; x++)
        {
            var curClass = allClasses[x];
            if (eh.hasClass(curClass) === true)
            {
                existingClasses.push(curClass);
                eh.removeClass(curClass);
            }
        }

        return existingClasses;
    };

    /**Gets a selector based on the Pane's class name and an array of classes to join into a single selector.
    @param {InternalPaneEntry} entry The entry of the pane getting the selector for.
    @param {String|String[]} classNames Either a string class name or an array of class names to append to the pane's class name.
    @returns {String} */
    var getSelector = function (entry, classNames)
    {
        if (classNames == null || entry == null) return null;
        if (EVUI.Modules.Core.Utils.isArray(classNames) === false) classNames = [classNames];

        var classesAdded = false;
        var selector = "." + entry.link.paneCSSName;
        var numSelectors = classNames.length;
        for (var x = 0; x < numSelectors; x++)
        {
            var curClass = classNames[x];
            if (typeof curClass !== "string") continue;

            selector += "." + curClass.trim();
            classesAdded = true;
        }

        if (classesAdded === false) return null;
        return selector;
    };

    /**Gets all the possible classes that could have been appended to the Pane's root element.
    @returns {String[]}*/
    var getAllClassNames = function ()
    {
        var allBaseClasses =
            [EVUI.Modules.Panes.Constants.CSS_Position,
            EVUI.Modules.Panes.Constants.CSS_ScrollX,
            EVUI.Modules.Panes.Constants.CSS_ScrollY,
            EVUI.Modules.Panes.Constants.CSS_ClippedX,
            EVUI.Modules.Panes.Constants.CSS_ClippedY,
            EVUI.Modules.Panes.Constants.CSS_Flipped,
            EVUI.Modules.Panes.Constants.CSS_Transition_Show,
            EVUI.Modules.Panes.Constants.CSS_Transition_Hide,
            EVUI.Modules.Panes.Constants.CSS_Transition_Adjust,
            EVUI.Modules.Panes.Constants.CSS_Resized,
            EVUI.Modules.Panes.Constants.CSS_Moved];

        var additionalClasses = _settings.getAdditionalClassNames();
        if (EVUI.Modules.Core.Utils.isArray(additionalClasses) === true) return allBaseClasses.concat(additionalClasses);
        return allBaseClasses;
    };

    /**Performs the final step in displaying a Pane by applying the show transition or by setting the display property of the root element of the BantPane to any visible mode.
    @param {InternalPaneEntry} entry The entry representing the Pane being shown.
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings The settings used to display the Pane.
    @param {EVUI.Modules.Panes.PanePosition} position The calculated position of the Pane using the showSettings.
    @param {Function} callback A callback function to call once the Pane positioning is complete.*/
    var displayPane = function (entry, showSettings, position, adjusting, callback)
    {
        if (typeof callback !== "function") callback = function () { };
        if (position.mode === EVUI.Modules.Panes.PanePositionMode.DocumentFlow) //if the pane is in the document flow, just position it
        {
            insertIntoDocumentFlow(entry, showSettings, position);
        }
        else //otherwise put it in the placement div where it will become visible.
        {
            moveToPlacementDiv(entry);
        }

        var selector = null;
        var transition = null;
        if (adjusting === true)
        {
            if (showSettings.reclacSettings != null && showSettings.reclacSettings.recalcTransition != null) transition = showSettings.reclacSettings.recalcTransition
            selector = EVUI.Modules.Panes.Constants.CSS_Transition_Adjust;
        }
        else
        {
            if (showSettings.showTransition != null) transition = showSettings.showTransition;
            selector = EVUI.Modules.Panes.Constants.CSS_Transition_Show;
        }

        var element = new EVUI.Modules.Dom.DomHelper(entry.link.pane.element);
        hookUpEvents(entry);

        applyTransition(entry, transition, selector, element, function (transitionApplied)
        {
            if (transitionApplied === false)
            {
                element.show();
            }

            callback(true);
        });
    };

    /**Inserts a Pane into the DOM in the position specified by the show settings. If it is already in the correct position nothing is done.
    @param {InternalPaneEntry} entry The entry representing the Pane being shown.
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings The settings used to display the Pane.
    @param {EVUI.Modules.Panes.PanePosition} position The calculated position of the Pane using the showSettings.*/
    var insertIntoDocumentFlow = function (entry, showSettings, position)
    {
        var ele = entry.link.pane.element;
        var relativeElement = new EVUI.Modules.Dom.DomHelper(showSettings.documentFlow.relativeElement);
        if (showSettings.documentFlow.mode === EVUI.Modules.Panes.PaneDocumentFlowMode.Current) return;

        if (showSettings.documentFlow.mode === EVUI.Modules.Panes.PaneDocumentFlowMode.After)
        {
            if (ele.previousSibling !== relativeElement.elements[0])
            {
                ele.remove();
                relativeElement.insertAfter(ele);
            }
        }
        else if (showSettings.documentFlow.mode === EVUI.Modules.Panes.PaneDocumentFlowMode.Append)
        {
            if (ele.parentNode !== relativeElement.elements[0])
            {
                ele.remove();
                relativeElement.append(ele);
            }
        }
        else if (showSettings.documentFlow.mode === EVUI.Modules.Panes.PaneDocumentFlowMode.Before)
        {
            if (ele.nextSibling !== relativeElement.elements[0])
            {
                ele.remove();
                relativeElement.insertAfter(ele);
            }
        }
        else if (showSettings.documentFlow.mode === EVUI.Modules.Panes.PaneDocumentFlowMode.Prepend)
        {
            if (ele.parentNode !== relativeElement.elements[0])
            {
                ele.remove();
                relativeElement.prepend(ele);
            }
        }
        else 
        {
            if (ele.parentNode !== relativeElement.elements[0])
            {
                ele.remove();
                relativeElement.append(ele);
            }
        }
    };

    /**Moves a Pane into the special invisible div with visible overflow that is used to display the pane with absolute coordinates.
    @param {InternalPaneEntry} entry The entry representing the pane to be displayed.*/
    var moveToPlacementDiv = function (entry)
    {
        ensurePlacehmentDiv(); //make sure the placement div is there

        if (entry.link.pane.element != null)
        {
            if (entry.link.pane.element.parentNode !== _settings.placementDiv)
            {
                entry.link.pane.element.remove();
                _settings.placementDiv.appendChild(entry.link.pane.element);
            }
        }
    };

    /**Moves a Pane into a special invisible div with invisible overflow so it can be measured without being seen.
    @param {InternalPaneEntry} entry The entry representing the pane to be measured.*/
    var moveToMeasureDiv = function (entry)
    {
        ensureMeasureDiv();

        if (entry.link.pane.element != null)
        {
            if (entry.link.pane.element.parentNode !==  _settings.measureDiv)
            {
                entry.link.pane.element.remove();
                 _settings.measureDiv.appendChild(entry.link.pane.element);
            }
        }
    };

    /**Moves a Pane into the loading div where panes that are not part of the document flow sit after they are loaded and when they are not displayed.
    @param {InternalPaneEntry} entry The entry representing the pane to put into the loaded div.*/
    var moveToLoadDiv = function (entry)
    {
        ensureLoadDiv();

        if (entry.link.pane.element != null)
        {
            entry.link.pane.element.remove();
            _settings.loadDiv.appendChild(entry.link.pane.element);
        }
    };

    /**Ensures that the div used for positioning the Pane is present in the DOM with the correct in-line style properties to work correctly.*/
    var ensurePlacehmentDiv = function ()
    {
        if (_settings.placementDiv == null)
        {
            _settings.placementDiv = document.createElement("div");
            document.body.appendChild(_settings.placementDiv);
        }
        else
        {
            if (_settings.placementDiv.isConnected == false)
            {
                if (_settings.placementDiv.parentElement != null) _settings.placementDiv.remove();
                document.body.appendChild( _settings.measureDiv)
            }
        }

        _settings.placementDiv.style.height = "0px";
        _settings.placementDiv.style.width = "0px";
        _settings.placementDiv.style.overflow = "visible";
        _settings.placementDiv.style.display = "block";
    };

    /**Ensures that the div used to keep Panes when they are not being measured or displayed is present in the DOM. */
    var ensureLoadDiv = function ()
    {
        if (_settings.loadDiv == null)
        {
            _settings.loadDiv = document.createElement("div");
            document.body.appendChild(_settings.loadDiv);
        }
        else
        {
            if (_settings.loadDiv.isConnected == false)
            {
                if (_settings.loadDiv.parentElement != null) _settings.loadDiv.remove();
                document.body.appendChild(_settings.loadDiv);
            }
        }

        _settings.loadDiv.style.display = "none";
    };

    /**Ensures that the div used to measure the Pane so it can be positioned correctly is in the DOM and has the correct in-line styling.*/
    var ensureMeasureDiv = function ()
    {
        if ( _settings.measureDiv == null)
        {
             _settings.measureDiv = document.createElement("div");
            document.body.appendChild( _settings.measureDiv);
        }
        else
        {
            if ( _settings.measureDiv.isConnected == false)
            {
                if ( _settings.measureDiv.parentElement != null)  _settings.measureDiv.remove();
                document.body.appendChild( _settings.measureDiv)
            }
        }

         _settings.measureDiv.style.height = "0px";
         _settings.measureDiv.style.width = "0px";
         _settings.measureDiv.style.overflow = "hidden"; //this is the magic that makes it all work, hidden overflow is still able to be measured.
         _settings.measureDiv.style.display = "inline-block";
    };

    /**Entry point to the position calculating logic.
     @param {InternalPaneEntry} entry The Pane being positioned.
     @param {EVUI.Modules.Panes.PaneShowSettings} showSettings The settings being used to position the Pane.
     @param {String} mode A value from the EVUI.Modules.Pane.PanePositionMode enum indicating which method to use to calculate the position of the Pane.
     @returns {EVUI.Modules.Panes.PanePosition}*/
    var calculatePosition = function (entry, showSettings, mode)
    {
        if (entry.link.pane.element == null) throw Error("Cannot calculate position of a Pane without an element.");
        if (entry.link.pane.element.isConnected === false) throw Error("Cannot calculate position of a Pane that is not yet part of the DOM.");

        //make a copy of the show settings to manipulate so we don't disturb the original state of the settings
        showSettings = makeOrExtendShowSettings(showSettings);

        var position = new EVUI.Modules.Panes.PanePosition(mode);
        var ele = new EVUI.Modules.Dom.DomHelper(entry.link.pane.element);


        //get the position of the pane based on the detected display mode
        if (mode === EVUI.Modules.Panes.PanePositionMode.AbsolutePosition)
        {
            position = getAbsolutePosition(entry, ele, showSettings.absolutePosition);
        }
        else if (mode === EVUI.Modules.Panes.PanePositionMode.Anchored)
        {
            position = getAnchoredPosition(entry, ele, showSettings.anchors);
        }
        else if (mode === EVUI.Modules.Panes.PanePositionMode.RelativePosition)
        {
            position = getRelativePosition(entry, ele, showSettings.relativePosition);
        }
        else if (mode === EVUI.Modules.Panes.PanePositionMode.Fullscreen)
        {
            position = getFullscreenPosition();
        }
        else if (mode === EVUI.Modules.Panes.PanePositionMode.PositionClass)
        {
            position = getAddClassPosition(showSettings, ele);
        }
        else if (mode === EVUI.Modules.Panes.PanePositionMode.Centered)
        {
            position = getCenteredPosition(ele);
        }
        else if (mode === EVUI.Modules.Panes.PanePositionMode.DocumentFlow)
        {
            return position;
        }

        //after getting the position, apply the clipping settings to the pane.
        position = applyClipSettings(entry, position, showSettings.clipSettings, showSettings);
        if (position == null) return null;

        position.classNames.push(EVUI.Modules.Panes.Constants.CSS_Position);
        position.classNames.push(entry.link.paneCSSName);

        position.zIndex = getNextZIndex();
        EVUI.Modules.Panes.Constants.GlobalZIndex = position.zIndex;

        return position;
    };

    /**Gets the next highest z-index so that the newly placed Pane appears on top of all the others.
    @returns {Number}*/
    var getNextZIndex = function ()
    {
        var highestZIndex = EVUI.Modules.Panes.Constants.GlobalZIndex;

        var numEntries = _entries.length;
        for (var x = 0; x < numEntries; x++)
        {
            var curEntry = _entries[x];
            var curZIndex = curEntry.link.pane.currentZIndex;

            if (curZIndex > highestZIndex) highestZIndex = curZIndex;
        }

        return highestZIndex + 1;
    };

    /**Generates PanePosition based off of a PaneAbsolutePosition argument.
    @param {InternalPaneEntry} entry The pane being positioned.
    @param {EVUI.Modules.Dom.DomHelper} elementHelper The pane's root element.
    @param {EVUI.Modules.Panes.PaneAbsolutePosition} absolutePosition The absolute position of the Pane.
    @returns {EVUI.Modules.Panes.PanePosition} */
    var getAbsolutePosition = function (entry, elementHelper, absolutePosition)
    {
        var offset = elementHelper.offset();
        var position = new EVUI.Modules.Panes.PanePosition(EVUI.Modules.Panes.PanePositionMode.AbsolutePosition);

        position.left = absolutePosition.left;
        position.top = absolutePosition.top;
        position.bottom = (offset.bottom - offset.top) + position.top;
        position.right = (offset.right - offset.left) + position.left;

        return position;
    };

    /**Gets the position of the Pane when it is anchored to one or more elements.
    @param {InternalPaneEntry} entry The pane being positioned.
    @param {EVUI.Modules.Dom.DomHelper} elementHelper The root element of the pane.
    @param {EVUI.Modules.Panes.PaneAnchors} anchorSettings The instructions on how to anchor the pane to another set of elements.
    @returns {EVUI.Modules.Panes.PanePosition} */
    var getAnchoredPosition = function (entry, elementHelper, anchorSettings)
    {
        var position = new EVUI.Modules.Panes.PanePosition(EVUI.Modules.Panes.PanePositionMode.Anchored);

        var currentBounds = elementHelper.offset();
        var height = currentBounds.bottom - currentBounds.top;
        var width = currentBounds.right - currentBounds.left;

        var alignX = getAnchorAlignment(anchorSettings.alignX, "x");
        var alignY = getAnchorAlignment(anchorSettings.alignY, "y");

        var upperBounds = null;
        if (anchorSettings.top != null)
        {
            var ele = new EVUI.Modules.Dom.DomHelper(anchorSettings.top);
            if (ele.elements.length > 0 && (ele.elements[0].isConnected === true || ele.elements[0] === window))
            {
                upperBounds = ele.offset();
                if (ele.elements[0] === window || ele.elements[0] === document) //if we're anchoring to the pane, we make it have zero height so the normal positioning logic still applies correctly
                {
                    upperBounds.bottom = upperBounds.top;
                }
            }
        }

        var lowerBounds = null;
        if (anchorSettings.bottom != null)
        {
            var ele = new EVUI.Modules.Dom.DomHelper(anchorSettings.bottom);
            if (ele.elements.length > 0 && (ele.elements[0].isConnected === true || ele.elements[0] === window))
            {
                lowerBounds = ele.offset();
                if (ele.elements[0] === window || ele.elements[0] === document) //if we're anchoring to the pane, we make it have zero height so the normal positioning logic still applies correctly
                {
                    upperBounds.top = upperBounds.bottom;
                }
            }
        }

        var leftBounds = null;
        if (anchorSettings.left != null)
        {
            var ele = new EVUI.Modules.Dom.DomHelper(anchorSettings.left);
            if (ele.elements.length > 0 && (ele.elements[0].isConnected === true || ele.elements[0] === window))
            {
                leftBounds = ele.offset();
                if (ele.elements[0] === window || ele.elements[0] === document) //if we're anchoring to the pane, we make it have zero width so the normal positioning logic still applies correctly
                {
                    upperBounds.right = upperBounds.left;
                }
            }
        }

        var rightBounds = null;
        if (anchorSettings.right != null)
        {
            var ele = new EVUI.Modules.Dom.DomHelper(anchorSettings.right);
            if (ele.elements.length > 0 && (ele.elements[0].isConnected === true || ele.elements[0] === window))
            {
                rightBounds = ele.offset();
                if (ele.elements[0] === window || ele.elements[0] === document) //if we're anchoring to the pane, we make it have zero width so the normal positioning logic still applies correctly
                {
                    upperBounds.left = upperBounds.right;
                }
            }
        }

        if (upperBounds != null && lowerBounds != null)
        {
            if (upperBounds.top > lowerBounds.top) //if the top is actually lower than the bottom, flip them so the math below works correctly
            {
                var temp = lowerBounds;
                lowerBounds = upperBounds;
                upperBounds = temp;
            }
        }

        if (rightBounds != null && leftBounds != null) //if the left is actually more to the right than the right, flip them so the math below works correctly
        {
            if (leftBounds.left > rightBounds.left)
            {
                var temp = rightBounds;
                rightBounds = leftBounds;
                leftBounds = temp;
            }
        }

        //use a flag set to determine all the combinations because its easier to keep track of all the possible combinations than writing an else-if tree
        var flags = 0;
        if (upperBounds != null) flags |= 1;
        if (lowerBounds != null) flags |= 2;
        if (leftBounds != null) flags |= 4;
        if (rightBounds != null) flags |= 8;

        switch (flags)
        {
            case 0: //no boundaries, put it in the top-left

                position.top = 0;
                position.left = 0;
                position.right = width;
                position.bottom = height;
                break;

            case 1: //upper bounds only (align directly along the bottom of the top)

                position.top = upperBounds.bottom;
                position.bottom = upperBounds.bottom + height;

                var xBounds = getXAlignmentPosition(upperBounds, currentBounds, width, alignX);
                position.left = xBounds.left;
                position.right = xBounds.right;
                break;

            case 2: //bottom bounds only (align directly along the top of the bottom and as wide as the bottom)

                position.bottom = lowerBounds.top;
                position.top = lowerBounds.top - height;

                var xBounds = getXAlignmentPosition(lowerBounds, currentBounds, width, alignX);
                position.left = xBounds.left;
                position.right = xBounds.right;
                break;

            case 3: //upper and bottom bounds, stretch to fit between top and bottom, then try to apply the x alignment evenly between both top and bottom axes

                position.bottom = lowerBounds.top;
                position.top = upperBounds.bottom;

                var leftYAxisBounds = getXAlignmentPosition(upperBounds, currentBounds, width, alignX);
                var rightYAxisBounds = getXAlignmentPosition(lowerBounds, currentBounds, width, alignX);

                if (alignX === EVUI.Modules.Panes.AnchorAlignment.Left) //align with whatever is further left
                {
                    position.left = Math.min(leftYAxisBounds.left, rightYAxisBounds.left);
                    position.right = position.left + width;
                }
                else if (alignX === EVUI.Modules.Panes.AnchorAlignment.Right) //align with whatever is the most right
                {
                    position.right = Math.max(leftYAxisBounds.right, rightYAxisBounds.right);
                    position.left = position.right - width;
                }
                else if (alignX === EVUI.Modules.Panes.AnchorAlignment.Center) //get the total span between the furthest left and most right edges and get the center between them.
                {
                    var topMost = Math.min(leftYAxisBounds.left, rightYAxisBounds.left);
                    var bottomMost = Math.max(leftYAxisBounds.right, rightYAxisBounds.right);
                    var totalSpan = bottomMost - topMost;
                    var center = topMost + (totalSpan / 2);

                    position.left = center - (width / 2);
                    position.right = position.left + width;
                }
                else if (alignX === EVUI.Modules.Panes.AnchorAlignment.None)
                {
                    position.left = currentBounds.left;
                    position.right = currentBounds.right;
                }
                else //stretch between the furthest extents on both directions
                {
                    position.left = Math.min(leftYAxisBounds.left, rightYAxisBounds.left);
                    position.right = Math.max(leftYAxisBounds.right, rightYAxisBounds.right);
                }

                break;

            case 4: //left bounds only, align to the top right of the left and stretch to be as long as the left

                position.left = leftBounds.right;
                position.right = position.left + width;

                var yBounds = getYAlignmentPosition(leftBounds, currentBounds, height, alignY);
                position.top = yBounds.top;
                position.bottom = yBounds.bottom;
                break;

            case 5: //left and upper bounds, align to the bottom of the top and right of the left, and optionally stretch on either axis if configured to do so

                position.top = upperBounds.bottom;
                position.bottom = (alignY === EVUI.Modules.Panes.AnchorAlignment.Elastic) ? leftBounds.bottom : position.top + height; //if we're stretching, stretch to the bottom of the left edge. Otherwise use the normal hieght.
                position.left = leftBounds.right;
                position.right = (alignX === EVUI.Modules.Panes.AnchorAlignment.Elastic) ? upperBounds.right : position.right + width; //if we're stretching, stretch to the right of the top edge. Otherwise use the width
                break;

            case 6: //left and lower bounds, align to the top of the bottom and right of the left, and optionally stretch on either axis if configured to do so

                position.top = (alignY === EVUI.Modules.Panes.AnchorAlignment.Elastic) ? leftBounds.top : lowerBounds.top - height;
                position.bottom = leftBounds.bottom; //if we're stretching, stretch to the bottom of the left edge. Otherwise use the normal hieght.
                position.left = leftBounds.right;
                position.right = (alignX === EVUI.Modules.Panes.AnchorAlignment.Elastic) ? lowerBounds.right : position.right + width; //if we're stretching, stretch to the right of the top edge. Otherwise use the width
                break;

            case 7: //left, lower, and upper bounds. Align to the right of the left and stretch between the top and bottom.

                position.top = upperBounds.bottom;
                position.left = leftBounds.right;
                position.bottom = lowerBounds.top;
                position.right = (alignX === EVUI.Modules.Panes.AnchorAlignment.Elastic) ? Math.max(upperBounds.right, lowerBounds.right) : position.left + width; //if we're stretching, stretch to the right most edge of the top or bottom
                break;

            case 8: //right bounds only, align to the left of the right edge

                position.right = rightBounds.left;
                position.left = position.right - width;

                var yBounds = getYAlignmentPosition(rightBounds, currentBounds, height, alignY);
                position.top = yBounds.top;
                position.bottom = yBounds.bottom;

                break;
            case 9: //right and upper bounds, align to the left of the right and bottom of the top

                position.right = rightBounds.left;
                position.left = (alignX === EVUI.Modules.Panes.AnchorAlignment.Elastic) ? upperBounds.left : position.right - width;
                position.top = upperBounds.bottom;
                position.bottom = (alignY === EVUI.Modules.Panes.AnchorAlignment.Elastic) ? rightBounds.bottom : position.top + height;
                break;

            case 10: //right and lower bounds, align to the left of the right and top of the bottom

                position.right = rightBounds.left;
                position.left = (alignX === EVUI.Modules.Panes.AnchorAlignment.Elastic) ? lowerBounds.left : rightBounds.left - width;
                position.top = lowerBounds.top - height;
                position.bottom = (alignY === EVUI.Modules.Panes.AnchorAlignment.Elastic) ? position.top - height : rightBounds.bottom;
                break;

            case 11: //right, lower, and upper bounds. Stretch between upper and lower bounds and align to the right side

                position.top = upperBounds.bottom;
                position.right = rightBounds.left;
                position.bottom = lowerBounds.top;
                position.left = (alignX === EVUI.Modules.Panes.AnchorAlignment.Elastic) ? Math.min(upperBounds.left, lowerBounds.left) : rightBounds.left - width; //if we're stretching, stretch to the right most edge of the top or bottom
                break;

            case 12: //right and left bounds. Stretch between right and left and place according to alignment between 

                position.left = leftBounds.right;
                position.right = rightBounds.left;

                var leftYAxisBounds = getYAlignmentPosition(leftBounds, currentBounds, width, alignY);
                var rightYAxisBounds = getYAlignmentPosition(rightBounds, currentBounds, width, alignY);

                if (alignY === EVUI.Modules.Panes.AnchorAlignment.Top) //align with whatever is highest
                {
                    position.top = Math.min(leftYAxisBounds.top, rightYAxisBounds.top);
                    position.bottom = position.top + height;
                }
                else if (alignY === EVUI.Modules.Panes.AnchorAlignment.Bottom) //align with whatever is lowest
                {
                    position.top = Math.min(leftYAxisBounds.bottom, rightYAxisBounds.bottom) - height;
                    position.bottom = position.top - height;
                }
                else if (alignY === EVUI.Modules.Panes.AnchorAlignment.Center) //get the total span between the furthest top and bottom edges and get the center between them.
                {
                    var topMost = Math.min(leftYAxisBounds.top, rightYAxisBounds.top);
                    var bottomMost = Math.max(leftYAxisBounds.bottom, rightYAxisBounds.bottom);
                    var totalSpan = bottomMost - topMost;
                    var center = topMost + (totalSpan / 2);

                    position.top = center - (height / 2);
                    position.bottom = position.bottom + height;
                }
                else if (alignY === EVUI.Modules.Panes.AnchorAlignment.None)
                {
                    position.top = currentBounds.top;
                    position.bottom = currentBounds.bottom;
                }
                else //stretch between the furthest extents on both directions
                {
                    position.top = Math.min(leftYAxisBounds.top, rightYAxisBounds.top);
                    position.bottom = Math.max(leftYAxisBounds.bottom, rightYAxisBounds.bottom);
                }

                break;
            case 13: //right, left, and upper bounds. Stretch between right and left, and align along the bottom of the top

                position.top = upperBounds.bottom;
                position.bottom = (alignY === EVUI.Modules.Panes.AnchorAlignment.Elastic) ? Math.max(leftBounds.bottom, rightBounds.bottom) : position.top + height;
                position.left = leftBounds.right;
                position.right = rightBounds.left;
                break;

            case 14: //right, left, and lower bounds. Stretch between right and left, and align along the top of the bottom

                position.top = (alignY === EVUI.Modules.Panes.AnchorAlignment.Elastic) ? Math.min(leftBounds.top, rightBounds.top) : lowerBounds.top - height;
                position.bottom = lowerBounds.top;
                position.left = leftBounds.right;
                position.right = rightBounds.left;
                break;

            case 15: //stretch in all directions to fit in between all anchors.

                position.top = upperBounds.bottom;
                position.bottom = lowerBounds.top;
                position.left = leftBounds.right;
                position.right = rightBounds.left;

                break;
        }

        return position;

    };

    /**Gets the PopInAnchorAlignment that is appropriate for the given axis. 
    @param {String} alignment A value from the PopInAnchorAlignment enum.
    @param {String} axis Either "x" or "y" signifying the axis to get the corrected 
    @returns {String} */
    var getAnchorAlignment = function (alignment, axis)
    {
        if (typeof alignment !== "string") return (axis === "x") ? EVUI.Modules.Panes.AnchorAlignment.Left : EVUI.Modules.Panes.AnchorAlignment.Top;
        alignment = alignment.toLowerCase();

        switch (alignment)
        {
            case EVUI.Modules.Panes.AnchorAlignment.Bottom:
            case EVUI.Modules.Panes.AnchorAlignment.Top:

                if (axis === "x") //neither top nor bottom is a correct value for the x axis, so return the default.
                {
                    return EVUI.Modules.Panes.AnchorAlignment.Left;
                }
                else
                {
                    return alignment;
                }

                break;
            case EVUI.Modules.Panes.AnchorAlignment.Left:
            case EVUI.Modules.Panes.AnchorAlignment.Right:

                if (axis === "y") //neither left nor right is a correct value for the y axis, so return the default
                {
                    return EVUI.Modules.Panes.AnchorAlignment.Top;
                }
                else
                {
                    return alignment;
                }

            case EVUI.Modules.Panes.AnchorAlignment.Center:
            case EVUI.Modules.Panes.AnchorAlignment.Elastic:
            case EVUI.Modules.Panes.AnchorAlignment.None:
                return alignment; //all apply to both axes and are correct
            default: //we got a bad value, return the default for the specified axis
                return (axis === "x") ? EVUI.Modules.Panes.AnchorAlignment.Left : EVUI.Modules.Panes.AnchorAlignment.Top;
        }
    };

    /**Gets the correct dimensions to place the Pane along the X axis based on the alignment parameter. 
    @param {EVUI.Modules.Dom.ElementBounds} alignmentSideBounds The bounds of the side the pane is being aligned with.
    @param {EVUI.Modules.Dom.ElementBounds} currentBounds The current bounds of the pane.
    @param {Number} width The width of the pane.
    @param {String} alignX The value from the PopInAnchorAlignment enum for the X axis.
    @returns {EVUI.Modules.Dom.ElementBounds}*/
    var getXAlignmentPosition = function (alignmentSideBounds, currentBounds, width, alignX)
    {
        var bounds = new EVUI.Modules.Dom.ElementBounds();

        if (alignX === EVUI.Modules.Panes.AnchorAlignment.Left) //align to the left edge of the anchored side
        {
            bounds.left = alignmentSideBounds.left;
            bounds.right = alignmentSideBounds.left + width;
        }
        else if (alignX === EVUI.Modules.Panes.AnchorAlignment.Right) //align to the right edge of the anchored side
        {
            bounds.left = alignmentSideBounds.right - width;
            bounds.right = alignmentSideBounds.right;
        }
        else if (alignX === EVUI.Modules.Panes.AnchorAlignment.Center) //center the pane on the anchored side
        {
            var center = alignmentSideBounds.left + ((alignmentSideBounds.right - alignmentSideBounds.left) / 2);
            bounds.left = center - (width / 2);
            bounds.right = bounds.left + width;
        }
        else if (alignX === EVUI.Modules.Panes.AnchorAlignment.None) //don't align with the anchored side
        {
            bounds.left = currentBounds.left;
            bounds.right = currentBounds.right;
        }
        else //default to elastic, set the bounds to be the whole length of the anchored side
        {
            bounds.left = alignmentSideBounds.left;
            bounds.right = alignmentSideBounds.right;
        }

        return bounds;
    };

    /**Gets the correct dimensions to place the Pane along the Y axis based on the alignment parameter.
    @param {EVUI.Modules.Dom.ElementBounds} alignmentSideBounds The bounds of the side the pane is being aligned with.
    @param {EVUI.Modules.Dom.ElementBounds} currentBounds The current bounds of the pane.
    @param {Number} height The height of the pane.
    @param {String} alignY The value from the PopInAnchorAlignment enum for the Y axis.
    @returns {EVUI.Modules.Dom.ElementBounds}*/
    var getYAlignmentPosition = function (alignmentSideBounds, currentBounds, height, alignY)
    {
        var bounds = new EVUI.Modules.Dom.ElementBounds();

        if (alignY === EVUI.Modules.Panes.AnchorAlignment.Top) //align to the top edge of the anchored side
        {
            bounds.top = alignmentSideBounds.top;
            bounds.bottom = alignmentSideBounds.top - height;
        }
        else if (alignY === EVUI.Modules.Panes.AnchorAlignment.Bottom) //align to the bottom edge of the anchored side
        {
            bounds.top = alignmentSideBounds.bottom - height;
            bounds.bottom = alignmentSideBounds.bottom;
        }
        else if (alignY === EVUI.Modules.Panes.AnchorAlignment.Center) //center the pane on the anchored side
        {
            var center = alignmentSideBounds.bottom - ((alignmentSideBounds.bottom - alignmentSideBounds.top) / 2);
            bounds.top = center - (height / 2);
            bounds.bottom = bounds.top + height;
        }
        else if (alignY === EVUI.Modules.Panes.AnchorAlignment.None) //do not align with the anchored side
        {
            bounds.top = currentBounds.top;
            bounds.bottom = currentBounds.bottom;
        }
        else //default to elastic, stretch between the top and bottom
        {
            bounds.top = alignmentSideBounds.top;
            bounds.bottom = alignmentSideBounds.bottom;
        }

        return bounds;
    };

    /**Gets the position of a Pane relative to another element.
    @param {InternalPaneEntry} entry The Pane being positioned.
    @param {EVUI.Modules.Dom.DomHelper} elementHelper The root element of the pane.
    @param {EVUI.Modules.Panes.PaneRelativePosition} relativeSettings The instructions for the relative positioning.
    @returns {EVUI.Modules.Panes.PanePosition} */
    var getRelativePosition = function (entry, elementHelper, relativeSettings)
    {
        var relativeBounds = new EVUI.Modules.Panes.PanePosition(EVUI.Modules.Panes.PanePositionMode.RelativePosition);
        var bounds = elementHelper.offset();
        var width = bounds.right - bounds.left;
        var height = bounds.bottom - bounds.top;
        var positionBounds = null;

        //make sure we have some bounds to position around. If it just a point make a 0x0 bounds to do the same logic around.
        if (relativeSettings.relativeElement != null)
        {
            var ele = new EVUI.Modules.Dom.DomHelper(relativeSettings.relativeElement);
            if (ele.elements.length === 0 || ele.elements[0].isConnected === false) return null;

            positionBounds = ele.offset();
        }
        else
        {
            positionBounds = new EVUI.Modules.Dom.ElementBounds();
            positionBounds.left = relativeSettings.x;
            positionBounds.top = relativeSettings.y;
            positionBounds.right = relativeSettings.x;
            positionBounds.bottom = relativeSettings.y;
        }

        //parse the alignment so that the values for each axis are correct (i.e. the user can put "right top" or "top right" and we need to correctly assign "right" to the x axis and "top" to the y axis)
        var axes = getOrientationAlignment(relativeSettings);
        var xOrientation = axes.xOrientation;
        var yOrientation = axes.yOrientation;

        if (xOrientation === EVUI.Modules.Panes.RelativePositionOrientation.Right) //we are putting the left edge of the pane on the right edge of the relative reference
        {
            relativeBounds.left = positionBounds.right;
            relativeBounds.right = positionBounds.right + width;
        }
        else if (xOrientation === EVUI.Modules.Panes.RelativePositionOrientation.Left) //we are putting the right edge of the pane on the left edge of the relative reference
        {
            relativeBounds.left = positionBounds.left - width;
            relativeBounds.right = positionBounds.left;
        }

        if (yOrientation === EVUI.Modules.Panes.RelativePositionOrientation.Bottom) //we are putting the top of the pane along the bottom edge of the relative reference.
        {
            relativeBounds.top = positionBounds.bottom;
            relativeBounds.bottom = positionBounds.bottom + height;
        }
        else if (yOrientation === EVUI.Modules.Panes.RelativePositionOrientation.Top) //we are putting the bottom of the pane along the top edge of the relative reference
        {
            relativeBounds.top = positionBounds.top - height;
            relativeBounds.bottom = positionBounds.top;
        }

        relativeBounds = applyRelativePositionAlignment(positionBounds, relativeBounds, relativeSettings, xOrientation, yOrientation);

        return relativeBounds;
    };

    /**Applies an alignment to the side that the Pane is oriented towards.
    @param {EVUI.Modules.Panes.PanePosition} positionBounds The bounds of the position the pane is being oriented around.
    @param {EVUI.Modules.Dom.ElementBounds} relativeBounds The bounds of the position of the pane relative to the position it is being oriented around.
    @param {EVUI.Modules.Panes.PaneRelativePosition} relativeSettings The settings for the relative posotion.
    @param {String} xOrientation The orientation around the relative element on the x axis.
    @param {String} yOrientation The orientation around the relative element on the y axis.
    @returns {EVUI.Modules.Panes.PanePosition}*/
    var applyRelativePositionAlignment = function (positionBounds, relativeBounds, relativeSettings, xOrientation, yOrientation)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(relativeSettings.alignment) === true) return relativeBounds;

        var positionHeight = positionBounds.bottom - positionBounds.top;
        var positionWidth = positionBounds.right - positionBounds.left;

        switch (relativeSettings.alignment.toLowerCase())
        {
            case EVUI.Modules.Panes.RelativePositionAlignment.Bottom: //aligning the top of the element with the bottom of the relative element

                if (yOrientation === EVUI.Modules.Panes.RelativePositionOrientation.Top) //only applies if we are oriented to the top, if we're oriented to the bottom, there is nothing to do
                {
                    relativeBounds.top += positionHeight;
                    relativeBounds.bottom += positionHeight;
                }

                break;

            case EVUI.Modules.Panes.RelativePositionAlignment.YCenter: //aligning to the center of the Y axis

                if (yOrientation === EVUI.Modules.Panes.RelativePositionOrientation.Bottom) //move the bottom up by half the size of the relative element
                {
                    relativeBounds.top -= positionHeight / 2;
                    relativeBounds.bottom -= positionHeight / 2;
                }
                else if (yOrientation === EVUI.Modules.Panes.RelativePositionOrientation.Top) //move the top down by half the size of the relative element
                {
                    relativeBounds.top += positionHeight / 2
                    relativeBounds.bottom += positionHeight / 2;
                }

                break;

            case EVUI.Modules.Panes.RelativePositionAlignment.Top: //align the bottom of the element with the top of the relative element

                if (yOrientation === EVUI.Modules.Panes.RelativePositionOrientation.Bottom) //only applies if we are oriented at the bottom of the relative element, otherwise there is nothing to do
                {
                    relativeBounds.top -= positionHeight;
                    relativeBounds.bottom -= positionHeight;
                }

                break;

            case EVUI.Modules.Panes.RelativePositionAlignment.Left: //aligning the element on the left side of the relative element

                if (xOrientation === EVUI.Modules.Panes.RelativePositionAlignment.Right) //only applies if we are oriented to the right, otherwise we are already on the left
                {
                    relativeBounds.left -= positionWidth;
                    relativeBounds.right -= positionWidth;
                }

                break;

            case EVUI.Modules.Panes.RelativePositionAlignment.XCenter: //aligning to the center of the x axis of the relative element

                if (xOrientation === EVUI.Modules.Panes.RelativePositionAlignment.Right) //move left by half the width
                {
                    relativeBounds.left -= positionWidth / 2;
                    relativeBounds.right -= positionWidth / 2;
                }
                else if (xOrientation === EVUI.Modules.Panes.RelativePositionOrientation.Left) //move right by half the with
                {
                    relativeBounds.left += positionWidth / 2;
                    relativeBounds.right += positionWidth / 2;
                }
                break;
            case EVUI.Modules.Panes.RelativePositionAlignment.Right: //aligning to the right edge of the relative element

                if (xOrientation === EVUI.Modules.Panes.RelativePositionOrientation.Left) //only applies if we are oriented to the left of the relative element, otherwise we're already on the right
                {
                    relativeBounds.left += positionWidth;
                    relativeBounds.right += positionWidth;
                }

                break;
        }

        return relativeBounds;
    };

    /**Gets the relative orientation axis.
    @param {String} orientation A value from the EVUI.Modules.Pane.RelativePositionOrientation enum indicating which axis is being oriented towards.
    @returns {String}*/
    var getRelativeOrientationAxis = function (orientation)
    {
        if (orientation == null) return null;

        var orientation = orientation.toLowerCase();
        switch (orientation)
        {
            case EVUI.Modules.Panes.RelativePositionOrientation.Bottom:
            case EVUI.Modules.Panes.RelativePositionOrientation.Top:
                return "y";
            case EVUI.Modules.Panes.RelativePositionOrientation.Left:
            case EVUI.Modules.Panes.RelativePositionOrientation.Right:
                return "x";
        }

        return null;
    };

    /**Gets the orientation values regardless of the order they were specified in the orientation string. (i.e. "top left" vs "left top")
    @param {String} relativeSettings The settings for orientation of the pane to its relative element or point.
    @returns {{xOrientation: number, yOrientation:number}} */
    var getOrientationAlignment = function (relativeSettings)
    {
        var orientations = (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(relativeSettings.orientation) == false) ? relativeSettings.orientation.toLowerCase().trim().split(/\s+/) : ["right", "bottom"];
        var xOrientation = (getRelativeOrientationAxis(orientations[0]) === "x") ? orientations[0] : orientations[1];
        if (xOrientation == null) xOrientation = EVUI.Modules.Panes.RelativePositionOrientation.Right;

        var yOrientation = (getRelativeOrientationAxis(orientations[1]) === "y") ? orientations[1] : orientations[0];
        if (yOrientation == null) yOrientation = EVUI.Modules.Panes.RelativePositionOrientation.Bottom;

        return { xOrientation: xOrientation, yOrientation: yOrientation };
    };

    /**Gets the position for a full screen pane.
    @returns {EVUI.Modules.Panes.PanePosition}*/
    var getFullscreenPosition = function ()
    {
        var position = new EVUI.Modules.Panes.PanePosition(EVUI.Modules.Panes.PanePositionMode.Fullscreen);

        var bounds = new EVUI.Modules.Dom.DomHelper(window);
        var width = bounds.outerWidth();
        var height = bounds.outerHeight();

        position.top = window.scrollY;
        position.left = window.scrollX;
        position.bottom = position.top + height;
        position.right = position.left + width;

        return position;
    };

    /**Gets the position of an element after all the classes that will be applied to it have been applied.
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings The settings for showing the pane.
    @param {EVUI.Modules.Dom.DomHelper} ele The root element of the pane.
    @returns {EVUI.Modules.Panes.PanePosition} */
    var getAddClassPosition = function (showSettings, ele)
    {
        var addedClasses = getPositionClasses(showSettings.positionClass);
        var positionClasses = addedClasses.concat([EVUI.Modules.Panes.Constants.CSS_Position, entry.link.paneCSSName]);

        var position = new EVUI.Modules.Panes.PanePosition(EVUI.Modules.Panes.PanePositionMode.PositionClass);
        ele.addClass(positionClasses);

        var bounds = ele.offset();
        position.bottom = bounds.bottom;
        position.left = bounds.left;
        position.right = bounds.right;
        position.top = bounds.top;
        position.classNames = addedClasses;

        ele.removeClass(positionClasses);

        return position;
    };

    /**Gets the position of the element if it were centered in the pane.
    @param {EVUI.Modules.Dom.DomHelper} ele The root element of the Pane.
    @returns {EVUI.Modules.Panes.PanePosition} */
    var getCenteredPosition = function (ele)
    {
        var win = new EVUI.Modules.Dom.DomHelper(window);
        var winWidth = win.outerWidth();
        var winHeight = win.outerHeight();

        var eleOffset = ele.offset();
        var eleWidth = eleOffset.right - eleOffset.left;
        var eleHeight = eleOffset.bottom - eleOffset.top;

        var centerWidth = eleWidth / 2;
        var centerHeight = eleHeight / 2;

        var winCenterWidth = winWidth / 2;
        var winCenterHeight = winHeight / 2;

        var position = new EVUI.Modules.Panes.PanePosition(EVUI.Modules.Panes.PanePositionMode.Centered);
        position.left = winCenterWidth - centerWidth;
        position.right = winCenterWidth + centerWidth;
        position.top = winCenterHeight - centerHeight;
        position.bottom = winCenterHeight + centerWidth;

        return position;
    };

    /**Walks through all the options in the show settings and comes up with the mode to use to position the element. Goes in the following order: 
    position classes > absolute position > relative position > anchored position > document flow > full screen > centered.
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings The settings to use to calculate the position.
    @returns {String} */
    var getPositionMode = function (showSettings)
    {
        if (showSettings == null) return EVUI.Modules.Panes.PanePositionMode.None;

        if (showSettings.positionClass != null) //we have a value for position classes
        {
            if (typeof showSettings.positionClass === "string" && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(showSettings.positionClass) === false)
            {
                return EVUI.Modules.Panes.PanePositionMode.PositionClass; //its a string that will be applied as a class name
            }
            else if (EVUI.Modules.Core.Utils.isArray(showSettings.positionClass) === true)
            {
                if (showSettings.positionClass.filter(function (css) { return typeof css === "string" }).length > 0)
                {
                    return EVUI.Modules.Panes.PanePositionMode.PositionClass; //it is an array of class names
                }
            }
        }

        if (showSettings.absolutePosition != null) //we have a value for absolute position
        {
            if (showSettings.absolutePosition.left !== 0 || showSettings.absolutePosition.top !== 0) //at least one of the x or y values must be non-zero for this mode to apply
            {
                return EVUI.Modules.Panes.PanePositionMode.AbsolutePosition;
            }
        }

        if (showSettings.relativePosition != null) //we have a value for relative position
        {
            if (showSettings.relativePosition.relativeElement != null && showSettings.relativePosition.relativeElement.isConnected === true) 
            {
                return EVUI.Modules.Panes.PanePositionMode.RelativePosition; //the relative element must be part of the DOM to be a valid target to orient around (so we can get its position)
            }
            else if (showSettings.relativePosition.x !== 0 || showSettings.relativePosition.y !== 0)
            {
                return EVUI.Modules.Panes.PanePositionMode.RelativePosition; //if one of the coordinates is non zero value it can be a target for orientation
            }
        }

        if (showSettings.anchors != null) //we have a value for anchors
        {
            if ((showSettings.anchors.bottom != null && (showSettings.anchors.bottom.isConnected === true || showSettings.anchors.bottom === window))
                || (showSettings.anchors.left != null && (showSettings.anchors.left.isConnected === true || showSettings.anchors.left === window))
                || (showSettings.anchors.right != null && (showSettings.anchors.right.isConnected === true || showSettings.anchors.right === window))
                || (showSettings.anchors.top != null && (showSettings.anchors.top.isConnected === true || showSettings.anchors.top === window)))
            {
                return EVUI.Modules.Panes.PanePositionMode.Anchored; //at least one anchor must be non-null and connected to the DOM to be a valid target (so we can get its position)
            }
        }

        if (showSettings.documentFlow != null) //we have a value for document flow
        {
            if (showSettings.documentFlow.relativeElement != null) //the relative element must not be null in order to use document flow mode. It doesn't have to be connected yet.
            {
                return EVUI.Modules.Panes.PanePositionMode.DocumentFlow;
            }
        }

        //full screen mode was set
        if (showSettings.fullscreen === true) return EVUI.Modules.Panes.PanePositionMode.Fullscreen;

        //center mode was set
        if (showSettings.center === true) return EVUI.Modules.Panes.PanePositionMode.Centered;

        //northing worked, not going to do anything with the position other than stick it in the top-left of the view port.
        return EVUI.Modules.Panes.PanePositionMode.None;
    };

    /**Takes the position classes input and makes it into an array of strings (can be a string, a string of space separated classes, or an array of either)
    @param {String|String[]} classes The classes to apply to the Pane.
    @returns {String[]} */
    var getPositionClasses = function (classes)
    {
        var classesArray = [];

        if (EVUI.Modules.Core.Utils.isArray(classes) === true)
        {
            var numClasses = classes.length;
            for (var x = 0; x < numClasses; x++)
            {
                classesArray = classesArray.concat(getPositionClasses(classes[x]));
            }
        }
        else if (typeof classes === "string")
        {
            classesArray = classes.split(/\s+/);
        }

        return classesArray;
    };

    /**Applies the clip settings that are attached to the show settings. If omitted, the default values are used instead (clips to pane.)
    @param {InternalPaneEntry} entry The pane entry being clipped.
    @param {EVUI.Modules.Panes.PanePosition} position The calculated position of where the pane will be placed.
    @param {EVUI.Modules.Panes.PaneClipSettings} clipSettings The current set of clip settings being applied.
    @param {EVUI.Modules.Panes.PaneClipSettings[]} previousClipSettings All of the previous clip settings objects that have been applied (prevents stack overflows).
    @returns {EVUI.Modules.Panes.PanePosition}*/
    var applyClipSettings = function (entry, position, clipSettings, showSettings, previousClipSettings)
    {
        if (previousClipSettings == null) previousClipSettings = [];
        previousClipSettings.push(clipSettings)

        
        var win = new EVUI.Modules.Dom.DomHelper(window)

        if (clipSettings == null) //no clip settings, make the default settings (clip to pane)
        {
            clipSettings = new EVUI.Modules.Panes.PaneClipSettings();
        }

        var bounds = getClipBounds(clipSettings);

        //set some basic clip settings for the fallback if they aren't set already - clipping is the only method that doesn't use a fallback, so this becomes the "final say" in the clip logic.
        if (clipSettings.fallbackClipSettings == null || previousClipSettings.indexOf(clipSettings.fallbackClipSettings) !== -1)
        {
            clipSettings.fallbackClipSettings = new EVUI.Modules.Panes.PaneClipSettings();
            clipSettings.fallbackClipSettings.clipBounds = null;
            clipSettings.fallbackClipSettings.mode = EVUI.Modules.Panes.PaneClipMode.Clip;
            clipSettings.fallbackClipSettings.scrollXWhenClipped = true;
            clipSettings.fallbackClipSettings.scrollYWhenClipped = true;
        }

        clipSettings.mode = getClipMode(clipSettings.mode);
        if (clipSettings.mode === EVUI.Modules.Panes.PaneClipMode.Clip)
        {
            if (isOffScreen(position) === true) return null;
            return clipToBounds(entry, position, bounds, clipSettings);
        }
        else if (clipSettings.mode === EVUI.Modules.Panes.PaneClipMode.Shift)
        {
            if (isOffScreen(bounds) === true) return null;
            return shiftToBounds(entry, position, bounds, clipSettings, showSettings, previousClipSettings);
        }
        else if (clipSettings.mode === EVUI.Modules.Panes.PaneClipMode.Overflow)
        {
            return position;
        }
    };

    /**Determines if a set of bounds lies outside another set of bounds. If the second set is omitted, the pane is used instead.
    @param {EVUI.Modules.Panes.PanePosition|EVUI.Modules.Dom.ElementBounds} position The position to check for being out of bounds.
    @param {EVUI.Modules.Panes.PanePosition|EVUI.Modules.Dom.ElementBounds} bounds Optional. Wither the pane bounds or another arbitrary set of bounds.
    @returns {Boolean} */
    var isOffScreen = function (position, bounds)
    {
        if (bounds == null) bounds = new EVUI.Modules.Dom.DomHelper(window).offset();

        return (isInsideBounds(position.left, position.top, bounds) === false
            && isInsideBounds(position.right, position.top, bounds) === false
            && isInsideBounds(position.left, position.bottom, bounds) === false
            && isInsideBounds(position.right, position.bottom, bounds) === false);
    };

    /**Determines if a point lies inside an arbitrary set of bounds.
    @param {Number} x The x-coordinate to check.
    @param {Number} y The y-coordinate to check.
    @param {EVUI.Modules.Dom.ElementBounds} bounds The bounds to check to see if the point is inside.
    @returns {Boolean} */
    var isInsideBounds = function (x, y, bounds)
    {
        if (x < bounds.left || x > bounds.right) return false;
        if (y < bounds.top || y > bounds.bottom) return false;

        return true;
    };

    /**Clips the Pane to a set of arbitrary bounds.
    @param {InternalPaneEntry} entry The entry representing the Pane to clip.
    @param {EVUI.Modules.Panes.PanePosition} position The calculated position of the Pane.
    @param {EVUI.Modules.Dom.ElementBounds} bounds The bounds to clip the Pane to.
    @param {EVUI.Modules.Panes.PaneClipSettings} clipSettings The instructions for how to clip the Pane.
    @returns {EVUI.Modules.Panes.PanePosition}*/
    var clipToBounds = function (entry, position, bounds, clipSettings)
    {
        var originalWidth = position.right - position.left;
        var originalHeight = position.bottom - position.top;

        var clipped = false;
        if (isOutOfBounds(position, bounds, "left") === true)
        {
            position.left = bounds.left;
            clipped = true;
        }

        if (isOutOfBounds(position, bounds, "right") === true)
        {
            position.right = bounds.right;
            clipped = true;
        }

        if (isOutOfBounds(position, bounds, "top") === true)
        {
            position.top = bounds.top;
            clipped = true;
        }

        if (isOutOfBounds(position, bounds, "bottom") === true)
        {
            position.bottom = bounds.bottom;
            clipped = true;
        }

        if (clipped === true) //we need to clip the height and width of the pane.
        {
            var newWidth = position.right - position.left
            var newHeight = position.bottom - position.top;

            if (newWidth !== originalWidth) //the X dimension changed, flag the entry as being clipped
            {
                position.classNames.push(EVUI.Modules.Panes.Constants.CSS_ClippedX);

                if (clipSettings.scrollXWhenClipped === true) //if the "scroll when clipped" option is set, make a selector class for adding the overflow scrollbar to the pane
                {
                    if (newWidth < originalWidth)
                    {
                        position.classNames.push(EVUI.Modules.Panes.Constants.CSS_ScrollX);

                        var scrollXSelector = getSelector(entry, EVUI.Modules.Panes.Constants.CSS_ClippedX);
                        _settings.stylesheetManager.setRules(_settings.cssSheetName, scrollXSelector, {
                            overflowX: "scroll"
                        });
                    }
                }
            }

            if (newHeight !== originalHeight) //the Y dimension changed, flag the entry as being clipped
            {
                position.classNames.push(EVUI.Modules.Panes.Constants.CSS_ClippedY);

                if (clipSettings.scrollYWhenClipped === true)  //if the "scroll when clipped" option is set, make a selector class for adding the overflow scrollbar to the pane
                {
                    if (newHeight < originalHeight) position.classNames.push(EVUI.Modules.Panes.Constants.CSS_ScrollY);

                    var scrollYSelector = getSelector(entry, EVUI.Modules.Panes.Constants.CSS_ClippedY);
                    _settings.stylesheetManager.setRules(_settings.cssSheetName, scrollYSelector, {
                        overflowY: "scroll"
                    });
                }
            }
        }

        return position;
    };

    /**Shifts a Pane along the X or Y axis so that it fits withins the clipping bounds.
    @param {InternalPaneEntry} entry The entry representing the Pane being shifted.
    @param {EVUI.Modules.Panes.PanePosition} position The calculated position of the Pane.
    @param {EVUI.Modules.Dom.ElementBounds} bounds The clipping bounds.
    @param {EVUI.Modules.Panes.PaneClipSettings} clipSettings The current clip settings being used.
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings The original settings used to display the Pane.
    @param {EVUI.Modules.Panes.PaneClipSettings[]} previousClipSettings The list of previously used clip settings in clipping this element. Used to prevent stack overflows.
    @returns {EVUI.Modules.Panes.PanePosition} */
    var shiftToBounds = function (entry, position, bounds, clipSettings, showSettings, previousClipSettings)
    {
        var shiftedX = false;
        var shiftedY = false;
        var delta = 0;
        var relativePositioned = position.mode === EVUI.Modules.Panes.PanePositionMode.RelativePosition;

        var positionCopy = EVUI.Modules.Core.Utils.shallowExtend({}, position);
        delete positionCopy.mode;
        positionCopy.classNames = position.classNames.slice();
        positionCopy = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.Panes.PanePosition(position.mode), positionCopy);

        if (isOutOfBounds(position, bounds, "left") === true) //out of bounds to the left, move it to the right
        {
            delta = bounds.left - position.left;
            position.left += delta;
            position.right += delta;

            shiftedX = true;

            if (relativePositioned === true && overlaps(position, bounds) === true)
            {
                return flipRelativePosition(entry, positionCopy, bounds, clipSettings, showSettings, previousClipSettings);
            }
        }

        if (isOutOfBounds(position, bounds, "right") === true) //out of bounds to the right, move it to the left
        {
            if (shiftedX === false) 
            {
                delta = position.right - bounds.right;

                position.right -= delta;
                position.left -= delta;
                shiftedX = true;

                if (relativePositioned === true && overlaps(position, bounds) === true)
                {
                    return flipRelativePosition(entry, positionCopy, bounds, clipSettings, showSettings, previousClipSettings);
                }
            }
        }

        if (isOutOfBounds(position, bounds, "top") === true) //top is out of bounds, shift the pane down
        {
            delta = bounds.top - position.top;

            position.top += delta;
            position.bottom += delta;
            shiftedY = true;

            if (relativePositioned === true && overlaps(position, bounds) === true)
            {
                return flipRelativePosition(entry, positionCopy, bounds, clipSettings, showSettings, previousClipSettings);
            }
        }

        if (isOutOfBounds(position, bounds, "bottom") === true) //bottom is out of bounds, shift the pane up
        {
            if (shiftedY === false)
            {
                delta = position.bottom - bounds.bottom;

                position.bottom -= delta;
                position.top -= delta;
                shiftedY = true;

                if (relativePositioned === true && overlaps(position, bounds) === true)
                {
                    return flipRelativePosition(entry, positionCopy, bounds, clipSettings, showSettings, previousClipSettings);
                }
            }
        }

        if (position.mode === EVUI.Modules.Panes.PanePositionMode.Fullscreen && (shiftedX === true || shiftedY === true))
        {
            var winBounds = new EVUI.Modules.Dom.DomHelper(window).offset();
            return clipToBounds(entry, position, winBounds, clipSettings.fallbackClipSettings);
        }
        
        return position;
    };

    /**Flags for indicating which directions and adjustments have been made to the pane in attempts to get it to fit into the area that can contain it. */
    var FlipFlags =
    {
        /**Has not been flipped.*/
        None: 0,
        /**Flipped on the X-axis.*/
        FlippedX: 1,
        /**Flipped on the Y-axis*/
        FlippedY: 2,
        /**Had its alignment changed to fit into the area with the most open space.*/
        ReAligned: 4
    };

    /**In the case that we have a relatively positioned element, we will sometimes want to flip it back over the element if it overflows on one or both axes.
    @param {InnerPaneEntry} entry The Pane being flipped.
    @param {EVUI.Modules.Panes.PanePosition} position The position of the pane.
    @param {EVUI.Modules.Dom.ElementBounds} bounds The clipping bounds.
    @param {EVUI.Modules.Panes.PaneClipSettings} clipSettings The current clip settings.
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings The original show settings used to display the pane.
    @param {EVUI.Modules.Panes.PaneClipSettings[]} previousClipSettings The list of previously used clip settings in clipping this element. Used to prevent stack overflows.
    @param {Number} flags The FlipFlaps indicating the previous flip operations that have been performed on the pane.
    @returns {EVUI.Modules.Panes.PanePosition}*/
    var flipRelativePosition = function (entry, position, bounds, clipSettings, showSettings, previousClipSettings, flags)
    {
        if (flags == null) flags = 0;
        var flippedX = false;
        var flippedY = false;  
        var alignmentAxes = getOrientationAlignment(showSettings.relativePosition);
        var flippedAlignX = null;
        var flippedAlignY = null;
        var alignX = alignmentAxes.xOrientation;
        var alignY = alignmentAxes.yOrientation;
        var flippedOutOfBounds = false;

        var eleBounds = null;
        if (showSettings.relativePosition.relativeElement != null)
        {
            var ele = new EVUI.Modules.Dom.DomHelper(showSettings.relativePosition.relativeElement);
            if (ele.elements.length === 0 || ele.elements[0].isConnected === false) return null;

            eleBounds = ele.offset();
        }
        else
        {
            eleBounds = new EVUI.Modules.Dom.ElementBounds();
            eleBounds.top = showSettings.relativePosition.y;
            eleBounds.left = showSettings.relativePosition.x;
            eleBounds.right = showSettings.relativePosition.y;
            eleBounds.bottom = showSettings.relativePosition.x;
        }

        if (isOffScreen(eleBounds))
        {
            return null;
        }

        if (isOutOfBounds(position, bounds, "right") === true) //overflowing to the right
        {
            if (EVUI.Modules.Core.Utils.hasFlag(flags, FlipFlags.FlippedX) === true) //already flipped it over, we apply some special logic in this case to put the relative pane in the position with the most space
            {
                flippedOutOfBounds = true;
            }
            else
            {
                if (alignX === EVUI.Modules.Panes.RelativePositionOrientation.Left) //left side is aligned to the right side of the relative point, flip over X axis.
                {
                    flippedAlignX = EVUI.Modules.Panes.RelativePositionOrientation.Right;
                    flippedX = true;
                }
                else if (alignX === EVUI.Modules.Panes.RelativePositionOrientation.Right) //the right side is aligned to the left of the relative point, and that right side is outside the bounds. Clipping will result in a 0 width Pane, so this is an error.
                {
                    flippedAlignX = EVUI.Modules.Panes.RelativePositionOrientation.Left;
                    flippedX = true;
                }

                flags |= FlipFlags.FlippedX;
            }
        }

        if (isOutOfBounds(position, bounds, "left") === true) //overflowing to the left
        {
            if (EVUI.Modules.Core.Utils.hasFlag(flags, FlipFlags.FlippedX) === true) //already been flipped, we apply some special logic in this case to put the relative pane in the position with the most space
            {
                flippedOutOfBounds = true;
            }
            else
            {
                if (alignX === EVUI.Modules.Panes.RelativePositionOrientation.Right) //flip over x axis
                {
                    flippedAlignX = EVUI.Modules.Panes.RelativePositionOrientation.Left;
                    flippedX = true;
                }
                else if (alignX === EVUI.Modules.Panes.RelativePositionOrientation.Left) //
                {
                    flippedAlignX = EVUI.Modules.Panes.RelativePositionOrientation.Right;
                    flippedX = true;
                }

                flags |= FlipFlags.FlippedX;
            }
        }

        if (isOutOfBounds(position, bounds, "top") === true)
        {
            if (EVUI.Modules.Core.Utils.hasFlag(flags, FlipFlags.FlippedY) === true) //already been flipped, we apply some special logic in this case to put the relative pane in the position with the most space
            {
                flippedOutOfBounds = true;
            }
            else
            {
                if (alignY === EVUI.Modules.Panes.RelativePositionOrientation.Bottom)
                {
                    flippedAlignY = EVUI.Modules.Panes.RelativePositionOrientation.Top;
                    flippedY = true;
                }
                else if (alignY === EVUI.Modules.Panes.RelativePositionOrientation.Top)
                {
                    flippedAlignY = EVUI.Modules.Panes.RelativePositionOrientation.Bottom;
                    flippedY = true;
                }

                flags |= FlipFlags.FlippedY;
            }
        }

        if (isOutOfBounds(position, bounds, "bottom") === true)
        {
            if (EVUI.Modules.Core.Utils.hasFlag(flags, FlipFlags.FlippedY) === true) //already been flipped, we apply some special logic in this case to put the relative pane in the position with the most space
            {
                flippedOutOfBounds = true;
            }
            else
            {
                if (alignY === EVUI.Modules.Panes.RelativePositionOrientation.Top)
                {
                    flippedAlignY = EVUI.Modules.Panes.RelativePositionOrientation.Bottom;
                    flippedY = true;
                }
                else if (alignY === EVUI.Modules.Panes.RelativePositionOrientation.Bottom)
                {
                    flippedAlignY = EVUI.Modules.Panes.RelativePositionOrientation.Top;
                    flippedY = true;
                }

                flags |= FlipFlags.FlippedY;
            }
        }

        //if we flipped it, re-calculate the flipped position and re-run the flip overflow logic to trigger the fallback clip logic
        if (flippedX === true || flippedY === true)
        {
            var orientation = (flippedX === true) ? flippedAlignX : alignX;
            orientation += " " + ((flippedY === true) ? flippedAlignY : alignY);

            showSettings.relativePosition.orientation = orientation;

            position = getRelativePosition(entry, new EVUI.Modules.Dom.DomHelper(entry.link.pane.element), showSettings.relativePosition, bounds);
            if (position == null) return null;

            return flipRelativePosition(entry, position, bounds, clipSettings, showSettings, previousClipSettings, flags);
        }
        else if (EVUI.Modules.Core.Utils.hasFlag(flags, FlipFlags.ReAligned) === true) //already flipped and re-aligned it, just return whatever we have as its the best we'll do.
        {
            position.classNames.push(EVUI.Modules.Panes.Constants.CSS_Flipped);
            return position;
        }
        else if (flippedOutOfBounds === true) //we flipped it for a second time and its still out of bounds
        {
            var topGap = eleBounds.top - bounds.top;
            var bottomGap = bounds.bottom - eleBounds.bottom;
            var leftGap = eleBounds.left - bounds.left;
            var rightGap = bounds.right - eleBounds.right;

            var width = position.right - position.left;
            var height = position.bottom - position.top;
            var clip = (topGap < height && bottomGap < height && leftGap < width && rightGap < width)


            if ((topGap > leftGap && topGap > rightGap) || (bottomGap > leftGap && bottomGap > rightGap)) //if it's narrower than it was to start with, we'll move it to be above or below the relative element (whichever has more space)
            {
                if (bottomGap >= topGap) //if the gaps are equal, the bottom wins
                {
                    showSettings.relativePosition.orientation = EVUI.Modules.Panes.RelativePositionOrientation.Bottom + " " + ((leftGap >= rightGap) ? EVUI.Modules.Panes.RelativePositionOrientation.Left : EVUI.Modules.Panes.RelativePositionAlignment.Right);
                    showSettings.relativePosition.alignment = (leftGap >= rightGap) ? EVUI.Modules.Panes.RelativePositionAlignment.Rignt : EVUI.Modules.Panes.RelativePositionAlignment.Left;
                }
                else
                {
                    showSettings.relativePosition.orientation = EVUI.Modules.Panes.RelativePositionOrientation.Top + " " + ((leftGap >= rightGap) ? EVUI.Modules.Panes.RelativePositionOrientation.Left : EVUI.Modules.Panes.RelativePositionAlignment.Right);
                    showSettings.relativePosition.alignment = (leftGap >= rightGap) ? EVUI.Modules.Panes.RelativePositionAlignment.Right : EVUI.Modules.Panes.RelativePositionAlignment.Left;
                }
            }
            else if ((leftGap > topGap && leftGap > bottomGap) || (rightGap > topGap && rightGap > bottomGap)) //if it's shorter than it was to start with, we'll move it to be to the left or right of the relative element (whichever has more space)
            {
                if (leftGap >= rightGap)
                {
                    showSettings.relativePosition.orientation = ((topGap >= bottomGap) ? EVUI.Modules.Panes.RelativePositionOrientation.Top : EVUI.Modules.Panes.RelativePositionAlignment.Bottom) + " " + EVUI.Modules.Panes.RelativePositionOrientation.Left;
                    showSettings.relativePosition.alignment = (topGap >= bottomGap) ? EVUI.Modules.Panes.RelativePositionAlignment.Bottom : EVUI.Modules.Panes.RelativePositionAlignment.Top;
                }
                else
                {
                    showSettings.relativePosition.orientation = ((topGap >= bottomGap) ? EVUI.Modules.Panes.RelativePositionOrientation.Top : EVUI.Modules.Panes.RelativePositionAlignment.Bottom) + " " + EVUI.Modules.Panes.RelativePositionOrientation.Right;
                    showSettings.relativePosition.alignment = (topGap >= bottomGap) ? EVUI.Modules.Panes.RelativePositionAlignment.Bottom : EVUI.Modules.Panes.RelativePositionAlignment.Top;
                }
            }
            else
            {
                return applyClipSettings(entry, position, clipSettings.fallbackClipSettings, showSettings, previousClipSettings);
            }

            flags |= FlipFlags.ReAligned;

            position = getRelativePosition(entry, new EVUI.Modules.Dom.DomHelper(entry.link.pane.element), showSettings.relativePosition, bounds);
            if (position == null) return null;

            position = flipRelativePosition(entry, position, bounds, clipSettings, showSettings, previousClipSettings, flags);
            return clipToBounds(entry, position, bounds, clipSettings);
        }
        else if (EVUI.Modules.Core.Utils.hasFlag(flags, FlipFlags.FlippedX) === true || EVUI.Modules.Core.Utils.hasFlag(flags, FlipFlags.FlippedY) === true)
        {
            position.classNames.push(EVUI.Modules.Panes.Constants.CSS_Flipped);
            return position;
        }
        else
        {
            return position;
        }
    };

    /**Determines whether or not one element overlaps the other.
    @param {EVUI.Modules.Dom.ElementBounds} bounds1 The first bounds to check.
    @param {EVUI.Modules.Dom.ElementBounds} bounds2 The second bounds to check.
    @returns {Boolean}*/
    var overlaps = function (bounds1, bounds2)
    {
        if (isInsideBounds(bounds1.left, bounds1.top, bounds2) === true) return true;
        if (isInsideBounds(bounds1.left, bounds1.bottom, bounds2) === true) return true;
        if (isInsideBounds(bounds1.right, bounds1.top, bounds2) === true) return true;
        if (isInsideBounds(bounds1.right, bounds1.bottom, bounds2) === true) return true;

        return false
    };

    /**Gets a valid clip mode.
    @param {String} clipMode Any value from the EVUI.Modules.Pane.PaneClipMode enum. If an invalid value is specified, "shift" is returned.
    @returns {String} */
    var getClipMode = function (clipMode)
    {
        if (typeof clipMode !== "string") return EVUI.Modules.Panes.PaneClipMode.Shift;
        clipMode = clipMode.toLowerCase();

        switch (clipMode)
        {
            case EVUI.Modules.Panes.PaneClipMode.Clip:
            case EVUI.Modules.Panes.PaneClipMode.Overflow:
            case EVUI.Modules.Panes.PaneClipMode.Shift:
                return clipMode;
            default:
                return EVUI.Modules.Panes.PaneClipMode.Shift;
        }
    };

    /**Determines if a side of the position is outside the bounds of the clip bounds.
    @param {EVUI.Modules.Panes.PanePosition} position The calculated position of the Pane.
    @param {EVUI.Modules.Dom.ElementBounds} bounds The clip bounds.
    @param {String} side The side being checked.
    @returns {Boolean} */
    var isOutOfBounds = function (position, bounds, side)
    {
        if (side === "top")
        {
            if (position.top < bounds.top) return true;
        }
        else if (side === "bottom")
        {
            if (position.bottom > bounds.bottom) return true;
        }
        else if (side === "left")
        {
            if (position.left < bounds.left) return true;
        }
        else if (side === "right")
        {
            if (position.right > bounds.right) return true;
        }

        return false;
    };

    var getClipBounds = function (clipSettings)
    {
        if (clipSettings == null) return null;

        var win = new EVUI.Modules.Dom.DomHelper(window);

        var bounds = new EVUI.Modules.Dom.ElementBounds();;
        if (clipSettings.clipBounds == null) //if we have no clip bounds, clip to the pane's current view port
        {
            bounds.left = window.scrollX;
            bounds.right = scrollX + win.outerWidth();
            bounds.top = window.scrollY;
            bounds.bottom = window.scrollY + win.outerHeight();
        }
        else if (EVUI.Modules.Core.Utils.isElement(clipSettings.clipBounds) === true || typeof clipSettings.clipBounds === "string") //if the clip bounds are an element, we get the bounds of that element.
        {
            bounds = new EVUI.Modules.Dom.DomHelper(clipSettings.clipBounds).offset();
        }
        else //otherwise, take the clip bounds that were provided and supplement values from the pane.
        {
            bounds.left = (typeof clipSettings.clipBounds.left !== "number") ? window.scrollX : clipSettings.clipBounds.left;
            bounds.right = (typeof clipSettings.clipBounds.right !== "number") ? window.scrollY : clipSettings.clipBounds.right;
            bounds.bottom = (typeof clipSettings.clipBounds.bottom !== "number") ? window.scrollY + win.outerHeight() : clipSettings.clipBounds.bottom;
            bounds.top = (typeof clipSettings.clipBounds.top !== "number") ? scrollX + win.outerWidth() : clipSettings.clipBounds.top;
        }

        return bounds;
    };

     /******************************************************************************RESIZING/POLLING**************************************************************************************************/

    /**Resizes the pane by adding new CSS classes to it that override the default positioning CSS classes.
    @param {InternalPaneEntry} entry The Pane being resized or moved.
    @param {EVUI.Modules.Panes.PaneResizeMoveArgs} resizeArgs The arguments about how it will be resized.
    @param {EVUI.Modules.Dom.DomHelper} helper An DomHelper wrapping the Pane being manipulated.
    @param {Boolean} resized Whether or not the pane was only resized.
    @param {Boolean} moved Whether or not the pane was only moved.
    @param {DragHandles} dragHandles If the pane was resized, these are the details of the trigger for the resizing via a drag operation.
    @param {EVUI.Modules.Dom.ElementBounds} clipBounds The clipping bounds for the move or resize operation.*/
    var resizePane = function (entry, resizeArgs, helper, resized, moved, dragHandles, clipBounds)
    {
        if (moved === true)
        {
            if (clipBounds != null) //if we're clipping, make sure we shift it back into bounds before actually applying the move CSS
            {
                var clippedBounds = shiftMovedPaneToBounds(entry, resizeArgs, clipBounds);
                if (clippedBounds != null)
                {
                    if (clippedBounds.left === resizeArgs.left && clippedBounds.top === resizeArgs.top) return;

                    resizeArgs.left = clippedBounds.left;
                    resizeArgs.top = clippedBounds.top;
                }
            }

            var movedSelector = getSelector(entry, EVUI.Modules.Panes.Constants.CSS_Moved);

            var rules =
            {
                position: "absolute",
                top: resizeArgs.top + "px",
                left: resizeArgs.left + "px"
            }

            _settings.stylesheetManager.setRules(_settings.cssSheetName, movedSelector, rules);
            helper.addClass(EVUI.Modules.Panes.Constants.CSS_Moved);
            entry.link.lastResizeArgs = resizeArgs;
        }

        if (resized === true)
        {
            var resizedSelector = getSelector(entry, EVUI.Modules.Panes.Constants.CSS_Resized);
            var style = getComputedStyle(entry.link.pane.element);
            var minWidth = style.minWidth;
            var minHeight = style.minHeight;

            if (minWidth != null)
            {
                minWidth = parseFloat(minWidth.replace("px", ""));
                if (isNaN(minWidth) === true) minWidth = null;
            }

            if (minHeight != null)
            {
                minHeight = parseFloat(minHeight.replace("px", ""));
                if (isNaN(minHeight) === true) minHeight = null;
            }

            var minDimension = entry.link.pane.resizeMoveSettings.dragHanldeMargin * 2.5;
            if (minWidth == null || minWidth < minDimension) minWidth = minDimension;
            if (minHeight == null || minHeight < minDimension) minHeight = minDimension;

            var shrankX = false;
            var shrankY = false;

            if (clipBounds != null) //if we're clipping, make sure the resized bounds are within the clip zone 
            {
                var position = new EVUI.Modules.Panes.PanePosition();
                position.bottom = resizeArgs.top + resizeArgs.height;
                position.left = resizeArgs.left;
                position.right = resizeArgs.left + resizeArgs.width;
                position.top = resizeArgs.top;

                if (isOutOfBounds(position, clipBounds, "left") === true)
                {
                    resizeArgs.left = clipBounds.left;
                    resizeArgs.width = position.right - clipBounds.left;
                }

                if (isOutOfBounds(position, clipBounds, "right") === true)
                {
                    resizeArgs.width = clipBounds.right - position.left;
                }

                if (isOutOfBounds(position, clipBounds, "top") === true)
                {
                    resizeArgs.top = clipBounds.top;
                    resizeArgs.height = position.bottom - clipBounds.top;
                }

                if (isOutOfBounds(position, clipBounds, "bottom") === true)
                {
                    resizeArgs.height = clipBounds.bottom - position.top;
                }
            }

            //ensure that we don't shrink beyond the minimum allowable size. If there's one in CSS we use that, if not we use 2.5 times the drag buffer zone so that the drag zones for all sized never overlap.
            //there is an issue here where it can cause a jittering effect on the bottom or right side, we have code below to correct that issue. The problem is the mouse is moving so fast that it gets into
            //a bad state where neither the left nor the width is correct.
            if (minHeight > resizeArgs.height || minWidth > resizeArgs.width)
            {
                if (entry.link.lastResizeArgs != null)
                {
                    if (minHeight > resizeArgs.height)
                    {
                        resizeArgs.height = minHeight;
                        resizeArgs.top = (dragHandles != null) ? dragHandles.originalBounds.top : entry.link.lastResizeArgs.top;
                        shrankY = true;
                    }

                    if (minWidth > resizeArgs.width)
                    {
                        resizeArgs.width = minWidth;
                        resizeArgs.left = (dragHandles != null) ? dragHandles.originalBounds.left : entry.link.lastResizeArgs.left;
                        shrankX = true;
                    }
                }
            }

            //sometimes the above logic gets it "wrong" when the mouse moves very, very fast, so we have to restore the size of the element to be its original size and position to stop the displacement jitter that happens otherwise.
            //it only happens when dragging the top or left hand side of the pane, never the right or bottom. Because this is remembered on the next iteration, it only fires when the problem scenario occurs.
            if (dragHandles != null && entry.link.lastResizeArgs != null)
            {
                if (dragHandles.growX === "left")
                {
                    var right = resizeArgs.left + resizeArgs.width;
                    var oldRight = entry.link.lastResizeArgs.left + entry.link.lastResizeArgs.width;

                    if (right != oldRight) //see if the right shifted either direction to the right or left. If so, restore it to the original position. The left is in flux, but the right must stay the same.
                    {
                        resizeArgs.left = dragHandles.originalBounds.left;
                        resizeArgs.width = dragHandles.originalBounds.right - dragHandles.originalBounds.left;

                        if (shrankX === true) //if it shrank back to the minimum size, don't reset the width
                        {
                            resizeArgs.width = minWidth;
                            resizeArgs.left = dragHandles.originalBounds.right - minWidth;
                        }
                    }
                }

                if (dragHandles.growY === "top") 
                {
                    var bottom = resizeArgs.top + resizeArgs.height;
                    var oldBottom = entry.link.lastResizeArgs.top + entry.link.lastResizeArgs.height;

                    if (bottom != oldBottom) //see if the bottom shifted up or down. If so, restore it to its original position. The top is in flux, but the bottom should never move.
                    {
                        resizeArgs.top = dragHandles.originalBounds.top;
                        resizeArgs.height = dragHandles.originalBounds.top - dragHandles.originalBounds.bottom;

                        if (shrankY === true)  //if it shrank back to the minimum size, don't reset the height
                        {
                            resizeArgs.height = minHeight;
                            resizeArgs.top = dragHandles.originalBounds.bottom - minHeight;
                        }
                    }
                }
            }          

            var rules = {};

            rules.position = "absolute";
            rules.height = resizeArgs.height + "px";
            rules.width = resizeArgs.width + "px";
            rules.top = resizeArgs.top + "px";
            rules.left = resizeArgs.left + "px";

            _settings.stylesheetManager.setRules(_settings.cssSheetName, resizedSelector, rules);
            helper.addClass(EVUI.Modules.Panes.Constants.CSS_Resized);

            entry.link.lastResizeArgs = resizeArgs;
        }

        if (moved === false && resized === false) return false;

        applyTransition(entry, resizeArgs.resizeTransition, EVUI.Modules.Panes.Constants.CSS_Transition_Adjust, helper)

        return true;
    };

    var shiftMovedPaneToBounds = function (entry, resizeArgs, clipBounds)
    {
        var currentPosition = new EVUI.Modules.Panes.PanePosition(EVUI.Modules.Panes.PanePositionMode.AbsolutePosition);
        currentPosition.top = resizeArgs.top;
        currentPosition.left = resizeArgs.left;
        currentPosition.bottom = resizeArgs.top + resizeArgs.height;
        currentPosition.right = resizeArgs.left + resizeArgs.width;

        var observer = new EVUI.Modules.Observers.ObjectObserver(currentPosition);
        shiftToBounds(entry, currentPosition, clipBounds);
        if (observer.getChanges().length > 0) return currentPosition;        

        return null;        
    }

    /******************************************************************************EVENTS**************************************************************************************************/

    /**Clears all the hooked up events from the Pane.
    @param {InternalPaneEntry} entry The Pane having its events unhooked.*/
    var clearEvents = function (entry)
    {
        var numEvents = entry.link.eventBindings.length;
        for (var x = 0; x < numEvents; x++)
        {
            entry.link.eventBindings[x].detach();
        }

        entry.link.eventBindings = [];
    };

    /**Attaches all the automatic events to the Pane. 
    @param {InternalPaneEntry} entry The Pane having its events hooked up.*/
    var hookUpEvents = function (entry)
    {
        if (entry.link.pane.element == null) return;

        clearEvents(entry);

        hookUpExplicitCloseZones(entry);
        hookUpAutoCloseMode(entry);
        hookUpKeydownClose(entry);
        hookUpDrag(entry);
        hookUpResize(entry);
        _settings.hookUpEventHandlers(entry.publicEntry);
    };

    /**Hooks up any child elements of the Pane with the appropriate attribute on them to be auto-close zones for the Pane.
    @param {InternalPaneEntry} entry The Pane having its close zones attached.*/
    var hookUpExplicitCloseZones = function (entry)
    {
        if (entry.link.pane.element == null) return;

        var attributeName = getAttributeName(EVUI.Modules.Panes.Constants.Attribute_Close);

        var closeZones = new EVUI.Modules.Dom.DomHelper("[" + attributeName + "]", entry.link.pane.element);
        var numZones = closeZones.elements.length;
        for (var x = 0; x < numZones; x++)
        {
            var handler = new EVUI.Modules.Panes.PaneEventBinding(attributeName, "click", closeZones.elements[x], function (event)
            {
                var context = new EVUI.Modules.Panes.PaneAutoTriggerContext();
                context.triggerType = EVUI.Modules.Panes.PaneAutoCloseTriggerType.Explicit;
                context.browserEvent = event;
                context.eventBinding = handler;
                context.target = entry.link.wrapper == null ? entry.link.pane : entry.link.wrapper;

                if (typeof entry.link.pane.autoCloseSettings.autoCloseFilter === "function" && entry.link.pane.autoCloseSettings.autoCloseFilter(context) === false) return;

                _self.hidePane(entry.paneID, {
                    context: context,
                });

                event.stopPropagation();
            });

            handler.attach();
            entry.link.eventBindings.push(handler);
        }
    };

    /**Hooks up click listeners on the document that will close the Pane on the next global or exterior click.
    @param {InternalPaneEntry} entry The Pane being hooked to the close events.*/
    var hookUpAutoCloseMode = function (entry)
    {
        if (entry.link.pane.element == null || entry.link.pane.autoCloseSettings == null) return;

        if (entry.link.pane.autoCloseSettings.closeMode === EVUI.Modules.Panes.PaneCloseMode.Click) //a click anywhere will close the Pane
        {
            var handler = new EVUI.Modules.Panes.PaneEventBinding(EVUI.Modules.Panes.PaneCloseMode.Click, "click contextmenu", document, function (event)
            {
                var context = new EVUI.Modules.Panes.PaneAutoTriggerContext();
                context.triggerType = EVUI.Modules.Panes.PaneAutoCloseTriggerType.Click;
                context.browserEvent = event;
                context.eventBinding = handler;
                context.target = entry.link.wrapper == null ? entry.link.pane : entry.link.wrapper;

                handler.detach();
                shouldAutoClose(context, entry, function (shouldClose)
                {
                    if (shouldClose === true)
                    {
                        _self.hidePane(entry.paneID, {
                            context: context
                        }, function ()
                        {
                            if (EVUI.Modules.Core.Utils.hasFlag(entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Visible) === true)
                            {
                                handler.attach();
                            }
                        });
                    }
                    else
                    {
                        handler.attach();
                    }
                });
            });

            handler.attach();
            entry.link.eventBindings.push(handler);
        }
        else if (entry.link.pane.autoCloseSettings.closeMode === EVUI.Modules.Panes.PaneCloseMode.ExteriorClick) //only a click outside the Pane's root element will close the Pane
        {
            var handler = new EVUI.Modules.Panes.PaneEventBinding(EVUI.Modules.Panes.PaneCloseMode.ExteriorClick, "click contextmenu", document, function (event)
            {
                var context = new EVUI.Modules.Panes.PaneAutoTriggerContext();
                context.triggerType = EVUI.Modules.Panes.PaneAutoCloseTriggerType.ExteriorClick;
                context.browserEvent = event;
                context.eventBinding = handler;
                context.target = entry.link.wrapper == null ? entry.link.pane : entry.link.wrapper;

                //make sure the click comes from outside the Pane
                if ((typeof entry.link.pane.autoCloseSettings.autoCloseFilter === "function" && entry.link.pane.autoCloseSettings.autoCloseFilter(context) === true) || //if the filter says it shouldn't be closed, don't hide it
                    EVUI.Modules.Core.Utils.containsElement(event.target, entry.link.pane.element) === true || //or if the element target is contained by the element, don't hide it
                    event.target === entry.link.pane.element) return; //or if the element target is the Pane itself, don't hide it

                handler.detach();
                shouldAutoClose(context, entry, function (shouldClose)
                {
                    if (shouldClose === true)
                    {
                        _self.hidePane(entry.paneID, {
                            context: context
                        }, function ()
                        {
                            if (EVUI.Modules.Core.Utils.hasFlag(entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Visible) === true)
                            {
                                handler.attach();
                            }
                        });
                    }
                    else
                    {
                        handler.attach();
                    }
                });
            });

            handler.attach();
            entry.link.eventBindings.push(handler);
        }
    };

    /**Hooks up an event listener on the document level listening for a keystroke that will close the Pane. 
    @param {InternalPaneEntry} entry The Pane that will be closed.*/
    var hookUpKeydownClose = function (entry)
    {
        if (entry.link.pane.element == null || entry.link.pane.autoCloseSettings == null) return;
        if (entry.link.pane.autoCloseSettings.autoCloseKeys == null || EVUI.Modules.Core.Utils.isArray(entry.link.pane.autoCloseSettings.autoCloseKeys) === false) return;

        var handler = new EVUI.Modules.Panes.PaneEventBinding("autoCloseKey", "keydown", document, function (event)
        {
            if (entry.link.pane.autoCloseSettings.autoCloseKeys == null || EVUI.Modules.Core.Utils.isArray(entry.link.pane.autoCloseSettings.autoCloseKeys) === false) return;
            if (entry.link.pane.autoCloseSettings.autoCloseKeys.indexOf(event.key) === -1) return;

            var context = new EVUI.Modules.Panes.PaneAutoTriggerContext();
            context.triggerType = EVUI.Modules.Panes.PaneAutoCloseTriggerType.KeyDown;
            context.browserEvent = event;
            context.eventBinding = handler;
            context.target = entry.link.wrapper == null ? entry.link.pane : entry.link.wrapper;

            handler.detach();
            shouldAutoClose(context, entry, function (shouldClose)
            {
                if (shouldClose === true)
                {
                    _self.hidePane(entry.paneID, {
                        context: context
                    }, function ()
                    {
                        if (EVUI.Modules.Core.Utils.hasFlag(entry.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Visible) === true)
                        {
                            handler.attach();
                        }
                    });
                }
                else
                {
                    handler.attach();
                }
            });
        });

        handler.attach();
        entry.link.eventBindings.push(handler);
    };

    /**Handles the pseudo-event for determining if the Pane should auto-close given one of the auto-close triggers. Handles both an async and sync case for a handler.
    @param {EVUI.Modules.Panes.PaneAutoTriggerContext} context The context of what caused the automatic closure of the Pane.
    @param {InternalPaneEntry} entry
    @param {Function} callback */
    var shouldAutoClose = function (context, entry, callback)
    {
        if (typeof entry.link.pane.autoCloseSettings.autoCloseFilter !== "function") return callback(true);

        var value = entry.link.pane.autoCloseSettings.autoCloseFilter(context);
        if (EVUI.Modules.Core.Utils.isPromise(value) === true)
        {
            value.then(function (result)
            {
                callback(result);
            }).catch(function(ex)
            {
                EVUI.Modules.Core.Utils.log(ex.stack);
                callback(false);
            });
        }
        else
        {
            callback(value);
        }
    };

    /**Hooks up the drag event handler to a child element of the root Pane element.
    @param {InternalPaneEntry} entry The entry representing the Pane that is having its drag handlers attached.*/
    var hookUpDrag = function (entry)
    {
        if (entry.link.pane.element == null || (entry.link.pane.resizeMoveSettings != null && entry.link.pane.resizeMoveSettings.canDragMove !== true)) return;
        var attributeName = getAttributeName(EVUI.Modules.Panes.Constants.Attribute_Drag);

        var paneRoot = new EVUI.Modules.Dom.DomHelper(entry.link.pane.element);
        var eles = new EVUI.Modules.Dom.DomHelper("[" + attributeName + "]", entry.link.pane.element).elements.slice();
        if (entry.link.pane.element.matches("[" + attributeName + "]") === true)
        {
            eles.unshift(entry.link.pane.element);
        }
        var numEles = eles.length;
        if (numEles === 0) return;

        for (var x = 0; x < numEles; x++)
        {
            var curEle = eles[x];
            var handler = new EVUI.Modules.Panes.PaneEventBinding(attributeName, "mousedown", curEle, function (downEvent)
            {
                _settings.stylesheetManager.ensureSheet(_settings.cssSheetName, { lock: true });
                var startPos = entry.link.pane.currentPosition;
                if (getDragHandles(entry, startPos, downEvent) != null) return;
                entry.link.lastResizeArgs = null;

                var startX = downEvent.clientX;
                var startY = downEvent.clientY;

                var bounds = (entry.link.lastShowSettings.clipSettings != null && entry.link.lastShowSettings.clipSettings.mode === EVUI.Modules.Panes.PaneClipMode.Shift) ? getClipBounds(entry.link.lastShowSettings.clipSettings) : null;

                downEvent.preventDefault();
                downEvent.stopPropagation();

                var dragHandler = function (dragEvent)
                {
                    dragEvent.preventDefault();
                    dragEvent.stopPropagation();

                    var xDelta = dragEvent.clientX - startX;
                    var yDelta = dragEvent.clientY - startY;

                    var resizeArgs = new EVUI.Modules.Panes.PaneResizeMoveArgs();
                    resizeArgs.height = (startPos.bottom - startPos.top);
                    resizeArgs.width = (startPos.right - startPos.left);
                    resizeArgs.top = startPos.top + yDelta;
                    resizeArgs.left = startPos.left + xDelta;
                    resizeArgs.resizeTransition = (entry.link.pane.showSettings.reclacSettings != null) ? entry.link.pane.showSettings.reclacSettings.recalcTransition : null;

                    resizePane(entry, resizeArgs, paneRoot, false, true, null, bounds);
                };

                document.addEventListener("mousemove", dragHandler);
                document.addEventListener("mouseup", function (event)
                {
                    document.removeEventListener("mousemove", dragHandler);
                }, { once: true });
            });

            handler.attach();
            entry.link.eventBindings.push(handler);
        }
    };

    /**Hooks up the resize event handler to the root Pane element.
    @param {InternalPaneEntry} entry The Pane having its grow handler hooked up. */
    var hookUpResize = function (entry)
    {
        if (entry.link.pane.element == null) return;
        var paneRoot = new EVUI.Modules.Dom.DomHelper(entry.link.pane.element);

        var handler = new EVUI.Modules.Panes.PaneEventBinding("dragResize", "mousedown", entry.link.pane.element, function (downEvent)
        {
            _settings.stylesheetManager.ensureSheet(_settings.cssSheetName, { locked: true });
            startPos = entry.link.pane.currentPosition;
            var dragHandles = getDragHandles(entry, startPos, downEvent);
            if (dragHandles == null) return; //see if we were in the grow zone with the mouse event. If not, do nothing.

            var startX = downEvent.clientX;
            var startY = downEvent.clientY;
            entry.link.lastResizeArgs = null;           

            var bounds = (entry.link.lastShowSettings.clipSettings != null && entry.link.lastShowSettings.clipSettings.mode === EVUI.Modules.Panes.PaneClipMode.Shift) ? getClipBounds(entry.link.lastShowSettings.clipSettings) : null;

            downEvent.preventDefault();
            downEvent.stopPropagation();

            var dragHandler = function (dragEvent) //handler for handling mouse move events after the drag event has begun.
            {
                dragEvent.preventDefault();
                dragEvent.stopPropagation();

                var xDelta = dragEvent.clientX - startX;
                var yDelta = dragEvent.clientY - startY;

                var resizeArgs = new EVUI.Modules.Panes.PaneResizeMoveArgs();
                resizeArgs.height = (startPos.bottom - startPos.top);
                resizeArgs.width = (startPos.right - startPos.left);
                resizeArgs.top = startPos.top;
                resizeArgs.left = startPos.left;
                resizeArgs.resizeTransition = (entry.link.pane.showSettings.reclacSettings != null) ? entry.link.pane.showSettings.reclacSettings.recalcTransition : null;

                if (dragHandles.growX === "right")
                {
                    resizeArgs.width += xDelta;
                }
                else if (dragHandles.growX === "left")
                {
                    resizeArgs.width -= xDelta;
                    resizeArgs.left += xDelta;
                }

                if (dragHandles.growY === "bottom")
                {
                    resizeArgs.height += yDelta;
                }
                else if (dragHandles.growY === "top")
                {
                    resizeArgs.height -= yDelta; 
                    resizeArgs.top += yDelta;
                }

                resizePane(entry, resizeArgs, paneRoot, true, false, dragHandles, bounds);
            };

            document.addEventListener("mousemove", dragHandler); //add the drag handler to the document
            document.addEventListener("mouseup", function (event) //remove the drag handler once the mouse button comes back up
            {
                document.removeEventListener("mousemove", dragHandler);
            }, { once: true });
        });

        handler.attach();
        entry.link.eventBindings.push(handler);
    };

    /**Determines if a click was on the outside edges of the Pane and within bounds of the drag area to resize the Pane.
    @param {InternalPaneEntry} entry
    @param {EVUI.Modules.Dom.DomHelper} bounds
    @param {MouseEvent} downEvent
    @returns {DragHandles} */
    var getDragHandles = function (entry, bounds, downEvent)
    {
        //first make sure drag resizing is enabled at all
        if (entry.link.pane.resizeMoveSettings == null) return null;
        if (entry.link.pane.resizeMoveSettings.canResizeBottom === false && entry.link.pane.resizeMoveSettings.canResizeLeft === false && entry.link.pane.resizeMoveSettings.canResizeRight === false && entry.link.pane.resizeMoveSettings.canResizeTop === false) return null;

        var mouseX = downEvent.clientX;
        var mouseY = downEvent.clientY;
        var growMargin = entry.link.pane.resizeMoveSettings.dragHanldeMargin;
        var growBounds = new EVUI.Modules.Dom.ElementBounds();

        //make a new set of bounds that is the inset of the main frame that the mouse position has to be between in order to trigger a grow event.
        growBounds.bottom = bounds.bottom - growMargin;
        growBounds.left = bounds.left + growMargin;
        growBounds.right = bounds.right - growMargin;
        growBounds.top = bounds.top + growMargin;

        var growDimensionX = null;
        var growDimensionY = null;

        if (mouseX >= bounds.left && mouseX <= growBounds.left && entry.link.pane.resizeMoveSettings.canResizeLeft === true) growDimensionX = "left";
        if (mouseX >= growBounds.right && mouseX <= bounds.right && entry.link.pane.resizeMoveSettings.canResizeRight === true)
        {
            var fromLeft = mouseX - bounds.left;
            var fromRight = bounds.right - mouseX;

            if (growDimensionX != null)
            {
                if (fromRight < fromLeft) growDimensionX = "right";
            }
            else
            {
                growDimensionX = "right";
            }
        }

        if (mouseY >= bounds.top && mouseY <= growBounds.top && entry.link.pane.resizeMoveSettings.canResizeTop === true) growDimensionY = "top";
        if (mouseY >= growBounds.bottom && mouseY <= bounds.bottom && entry.link.pane.resizeMoveSettings.canResizeBottom === true)
        {
            var fromTop = mouseX - bounds.left;
            var fromBottom = bounds.right - mouseX;

            if (growDimensionY != null)
            {
                if (fromBottom < fromTop) growDimensionY = "bottom";
            }
            else
            {
                growDimensionY = "bottom";
            }
        }

        //no growing
        if (growDimensionX == null && growDimensionY == null) return null;

        var dragHandles = new DragHandles();
        dragHandles.growX = growDimensionX;
        dragHandles.growY = growDimensionY;
        dragHandles.originalBounds = bounds;

        return dragHandles;
    };

    var DragHandles = function ()
    {
        this.growX = null;
        this.growY = null;
        this.originalBounds = null;
    };

    /**Applies a transition to the Pane.
    @param {InternalPaneEntry} entry The entry representing the pane having it's transition applied.
    @param {EVUI.Modules.Panes.PaneTransition} transition The transition to apply.
    @param {String} selector The class name that will be used to add the selector.
    @param {EVUI.Modules.Dom.DomHelper} element The element helper wrapping the element to get the transition.
    @param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback A callback to call once the operation completes or the function returns without adding a transition.*/
    var applyTransition = function (entry, transition, selector, element, callback)
    {
        if (typeof callback !== "function") callback = function (appliedTransition) { };
        if (entry == null || element == null) return callback(false);

        if (transition != null && transition.css != null) //if we have a transition, apply it instead of simple removing the display property.
        {
            if (transition.keyframes != null)
            {
                _settings.stylesheetManager.setRules(_settings.cssSheetName, transition.keyframes);
            }

            if (typeof transition.css === "string") //if the css is a string, check to see if its a set of properties or selectors
            {
                var match = transition.css.match(/[\:\;]/g);
                if (match == null && match.length === 0) //if the RegEx didn't match, it's (probably) not a rule.
                {
                    selector = transition.css;
                    element.addClass(selector);
                }
            }
            else
            {
                //otherwise make a new style using the provided rules
                _settings.stylesheetManager.setRules(_settings.cssSheetName, getSelector(entry, selector), transition.css);
                element.addClass(selector);
            }

            if (entry.link.transitionTimeoutID !== -1)
            {
                element.removeClass(entry.link.transitionSelector);
                clearTimeout(entry.link.transitionTimeoutID);

                if (typeof entry.link.transitionCallback === "function")
                {
                    entry.link.transitionCallback();
                    entry.link.transitionCallback = null;
                }
            }

            entry.link.transitionCallback = function ()
            {
                entry.link.transitionCallback = null;
                entry.link.transitionTimeoutID = -1;
                entry.link.transitionSelector = null;

                element.removeClass(selector);
                callback(true);
            };

            entry.link.transitionSelector = selector;
            entry.link.transitionTimeoutID = setTimeout(function ()
            {
                if (typeof entry.link.transitionCallback === "function") entry.link.transitionCallback();
            }, transition.duration);
        }
        else //no transition, just show the element
        {
            if (entry.link.transitionTimeoutID !== -1)
            {
                element.removeClass(entry.link.transitionSelector);
                clearTimeout(entry.link.transitionTimeoutID);

                if (typeof entry.link.transitionCallback === "function")
                {
                    entry.link.transitionCallback();
                    entry.link.transitionCallback = null;
                }

                entry.link.transitionSelector = null;
                entry.link.transitionTimeoutID = -1;
            }

            callback(false);
        }
    };

    /******************************************************************************LOADING**************************************************************************************************/

    /**Loads the root element of a Pane.
    @param {InternalPaneEntry} entry The entry representing the pane being loaded.
    @param {EVUI.Modules.Panes.PaneLoadSettings} loadSettings The settings dictating how to load the element.
    @param {EVUI.Modules.Panes.Constants.Fn_LoadCallback} callback The callback to fire once the element has been loaded.*/
    var loadRootElement = function (entry, loadSettings, callback)
    {
        if (typeof callback !== "function") callback = function (success) { };
        if (entry == null || loadSettings == null) return callback(false);

        var mode = getLoadMode(loadSettings);
        if (mode === EVUI.Modules.Panes.PaneLoadMode.None) throw Error("No load mode detected, cannot load root element of " + _settings.objectName + ".");

        if (mode === EVUI.Modules.Panes.PaneLoadMode.ExistingElement)
        {
            entry.link.pane.element = loadSettings.element;
            return callback(true);
        }
        else if (mode === EVUI.Modules.Panes.PaneLoadMode.CSSSelector)
        {
            var ele = new EVUI.Modules.Dom.DomHelper(loadSettings.selector, loadSettings.contextElement);
            if (ele.elements.length === 0) return callback(false);

            entry.link.pane.element = ele.elements[0];
            return callback(true);
        }
        else if (mode === EVUI.Modules.Panes.PaneLoadMode.HTTP)
        {
            return getElementViaHttp(entry, loadSettings, callback)
        }
        else if (mode === EVUI.Modules.Panes.PaneLoadMode.Placeholder)
        {
            return getElementViaPlaceholder(entry, loadSettings, callback);
        }
    };

    /**Determines the mode by which the Pane will be loaded.
    @param {EVUI.Modules.Panes.PaneLoadSettings} loadSettings The settings dictating how to load the element.
    @returns {String}*/
    var getLoadMode = function (loadSettings)
    {
        if (loadSettings.element != null) return EVUI.Modules.Panes.PaneLoadMode.ExistingElement;

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(loadSettings.selector) === false) return EVUI.Modules.Panes.PaneLoadMode.CSSSelector;

        if (loadSettings.httpLoadArgs != null) return EVUI.Modules.Panes.PaneLoadMode.HTTP;

        if (loadSettings.placeholderLoadArgs != null) return EVUI.Modules.Panes.PaneLoadMode.Placeholder;

        return EVUI.Modules.Panes.PaneLoadMode.None;
    };

    /**Loads the element by making a single HTTP request.
    @param {InternalPaneEntry} entry The entry representing the pane being loaded.
    @param {EVUI.Modules.Panes.PaneLoadSettings} loadSettings The settings dictating how to load the element.
    @param {EVUI.Modules.Panes.Constants.Fn_LoadCallback} callback The callback to fire once the element has been loaded.*/
    var getElementViaHttp = function (entry, loadSettings, callback)
    {
        var htmlRequestArgs = new EVUI.Modules.HtmlLoader.HtmlRequestArgs();
        htmlRequestArgs.httpArgs = loadSettings.httpLoadArgs;

        _settings.htmlLoader.loadHtml(htmlRequestArgs, function (html)
        {
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(html) === true)
            {
                EVUI.Modules.Core.Utils.debugReturn(_settings.managerName, "getElementViaHttp", "No HTML was returned from the server, or an error occurred in loading the HTML from the server.");
                return callback(false);
            }

            var contents = new EVUI.Modules.Dom.DomHelper(html);
            if (contents.elements.length === 0)
            {
                EVUI.Modules.Core.Utils.debugReturn(_settings.managerName, "getElementViaHttp", "Could not parse returned HTML into an HTML element.");
                return callback(false);
            }
            else if (contents.elements.length > 1)
            {
                EVUI.Modules.Core.Utils.debugReturn(_settings.managerName, "getElementViaHttp", "Too many elements returned from server, must be exactly one element.");
                return callback(false);
            }
            else
            {
                entry.link.pane.element = contents.elements[0];
                return callback(true);
            }
        });
    };

    /**Loads the element via the placeholder load logic.
    @param {InternalPaneEntry} entry The entry representing the pane being loaded.
    @param {EVUI.Modules.Panes.PaneLoadSettings} loadSettings The settings dictating how to load the element.
    @param {EVUI.Modules.Panes.Constants.Fn_LoadCallback} callback The callback to fire once the element has been loaded.*/
    var getElementViaPlaceholder = function (entry, loadSettings, callback)
    {
        _settings.htmlLoader.loadPlaceholder(loadSettings.placeholderLoadArgs, function (placeholderLoadResult)
        {
            if (placeholderLoadResult.loadedContent == null || placeholderLoadResult.loadedContent.length === 0)
            {
                EVUI.Modules.Core.Utils.debugReturn(_settings.managerName, "getElementViaPlaceholder", "Failed to inject placeholder element.");
                return callback(false);
            }
            else if (placeholderLoadResult.loadedContent.length > 1)
            {
                EVUI.Modules.Core.Utils.debugReturn(_settings.managerName, "getElementViaPlaceholder", "Too many elements returned from server, must be exactly one element.");
                return callback(false);
            }
            else
            {
                entry.link.pane.element = placeholderLoadResult.loadedContent[0];
                callback(true);
            }
        });
    };

    /******************************************************************************UNLOADING**************************************************************************************************/

    /**Unloads the root element of a Pane from the DOM if it was loaded remotely, otherwise it is simply moved and detached from the Pane.
    @param {InternalPaneEntry} entry The entry representing the Pane to have its root element unloaded.
    @returns {Boolean} */
    var unloadRootElement = function (entry)
    {
        if (entry == null) return false;

        var loadMode = getLoadMode(entry.link.lastLoadSettings);
        if (loadMode === EVUI.Modules.Panes.PaneLoadMode.CSSSelector || loadMode === EVUI.Modules.Panes.PaneLoadMode.ExistingElement || loadMode == EVUI.Modules.Panes.PaneLoadMode.None)
        {
            ensureLoadDiv();
            moveToLoadDiv(entry);
            entry.link.pane.element = null;
        }
        else if (loadMode === EVUI.Modules.Panes.PaneLoadMode.HTTP)
        {
            entry.link.pane.element.remove();
            entry.link.pane.element = null;
        }
        else if (loadMode === EVUI.Modules.Panes.PaneLoadMode.Placeholder)
        {
            var placeholderElement = new EVUI.Modules.Dom.DomHelper("[" + EVUI.Modules.HtmlLoader.Constants.Attr_PlaceholderID + "=" + entry.link.lastLoadSettings.placeholderLoadArgs.placeholderID + "]");
            placeholderElement.attr(EVUI.Modules.HtmlLoader.Constants.Attr_ContentLoadState, EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadState.OnDemand);
            placeholderElement.empty();
            entry.link.pane.element = null;
        }

        return true;
    };

    /******************************************************************************HIDING**************************************************************************************************/

    /**Hides the root element of a Pane so that it is no longer visible.
    @param {InternalPaneEntry} entry The entry representing the Pane to be hidden.
    @param {EVUI.Modules.Panes.PaneShowSettings} showSettings The ShowSettings that were last used to show the Pane.
    @param {EVUI.Modules.Panes.PaneTransition} hideTransition The hide transition to apply to the Pane as it disappears.
    @param {Function} callback A callback function that is called once the hide operation is complete.*/
    var hideRootElement = function (entry, showSettings, hideTransition, callback)
    {
        var ele = new EVUI.Modules.Dom.DomHelper(entry.link.pane.element);
        var selector = null;

        applyTransition(entry, hideTransition, EVUI.Modules.Panes.Constants.CSS_Transition_Hide, ele, function ()
        {
            clearEvents(entry);
            removePaneClasses(entry);
            removePaneCSS(entry);
            ele.removeClass(entry.link.transitionSelector);

            var mode = getPositionMode(showSettings);
            if (mode === EVUI.Modules.Panes.PanePositionMode.DocumentFlow)
            {
                ele.hide();
            }
            else
            {
                ensureLoadDiv();
                moveToLoadDiv(entry);
            }

            callback();
        });
    };


    /**Hides the backdrop or moves it back in the z-order if it should not be hidden yet.
    @param {InternalPaneEntry} entry The Pane being closed.
    @param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback The callback to call once the operation*/
    var hideBackdrop = function (entry, callback)
    {
        if (typeof callback !== "function") callback = function (success) { };

        var anyBeingShown = false;
        var anyStillVisible = false;

        var panesWithBackdrop = getPaneEntry(function (paneEntry) //get any panes that have a backdrop currently set on them
        {
            return paneEntry.pane != entry.link.pane &&
                paneEntry.pane.showSettings != null &&
                paneEntry.pane.showSettings.backdropSettings != null &&
                paneEntry.pane.showSettings.backdropSettings.showBackdrop === true
        }, true); 

        if (panesWithBackdrop != null && panesWithBackdrop.length > 0)
        {
            var panesBeingShown = panesWithBackdrop.filter(function (paneEntry) //if any of the panes with a backdrop is in the process of being shown, 
            {
                return (paneEntry.currentPaneAction === EVUI.Modules.Panes.PaneAction.Show || paneEntry.currentPaneAction === EVUI.Modules.Panes.PaneAction.Load)
            }, true);
            
            var panesStillVisible = panesWithBackdrop.filter(function (paneEntry)
            {
                return EVUI.Modules.Core.Utils.hasFlag(paneEntry.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Visible);
            }, true);

            anyBeingShown = panesBeingShown != null && panesBeingShown.length > 0;
            anyStillVisible = panesStillVisible != null && panesStillVisible.length > 0;
        }

        if (anyBeingShown === false && anyStillVisible === false)
        {
             _settings.backdropManager.hideBackdrop(entry.link.paneCSSName, entry.link.lastShowSettings.backdropSettings, function (success)
            {
                callback(success);
            });
        }
        else if (anyStillVisible === true)
        {
             _settings.backdropManager.setBackdropZIndex();
            callback(true);
        }
        else
        {
            callback(true);
        }
    };

    /******************************************************************************STARTUP**************************************************************************************************/

    /**Normalizes the PaneManagerSettings to not have any gaps in them.*/
    var normalizeSettings = function ()
    {
        if (_settings == null || typeof _settings !== "object")
        {
            _settings = new EVUI.Modules.Panes.PaneManagerSettings();
        }
        else
        {
            _settings = EVUI.Modules.Core.Utils.shallowExtend(_settings, new EVUI.Modules.Panes.PaneManagerSettings(), function (prop, source, target) { return target[prop] == null || (typeof target[prop] === "string" && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(target[prop])) }); //guarantee that nothing in the final graph is null
        }
        
        _settings.getPaneEntry = getPaneEntry;
        _settings.getPaneEntryAmbiguously = function (paneOrID, addIfMissing)
        {
            var internalEntry = getPaneAmbiguously(paneOrID, addIfMissing);
            if (internalEntry != null) return internalEntry.publicEntry;
        };
        _settings.cloneLoadSettings = cloneLoadSettings;
        _settings.cloneShowSettings = cloneShowSettings;
        if (_settings.backdropManager == null) _settings.backdropManager = new BackdropManager();

        if (_settings.stylesheetManager == null || typeof _settings.stylesheetManager !== "object")
        {
            _settings.stylesheetManager = EVUI.Modules.Styles.Manager;
        }

         //because these are optional dependencies we make special getters that are effectively "lazy" loaders that won't crash if a dependency is missing
        if (_settings.httpManager == null || typeof _settings.httpManager !== "object")
        {
            Object.defineProperty(_settings, "httpManager", {
                get: function ()
                {
                    return EVUI.Modules.Http.Http;
                },
                configurable: false,
                enumerable: true
            });
        }

        if (_settings.htmlLoader == null || typeof _settings.htmlLoader !== "object")
        {
            Object.defineProperty(_settings, "htmlLoader", {
                get: function ()
                {
                    return EVUI.Modules.HtmlLoader.Manager;
                },
                configurable: false,
                enumerable: true
            });
        }

        if (_settings.manager == null) _settings.manager = _self;
    };

    /**Attaches all global references to the PaneManagerSettings object so that they can be shared by instances 
    @param {EVUI.Modules.Panes.PaneManagerSettings} paneSettings The settings to attach all the global variables to. */
    var attachGlobals = function (paneSettings)
    {
        ensureLoadDiv();
        ensureMeasureDiv();
        ensurePlacehmentDiv();

        paneSettings.backdropManager = _settings.backdropManager;
        paneSettings.loadDiv = _settings.loadDiv;
        paneSettings.measureDiv = _settings.measureDiv;
        paneSettings.placementDiv = _settings.placementDiv;     
    };

    normalizeSettings(); //normalize the settings
    _settings.stylesheetManager.ensureSheet(_settings.cssSheetName, { lock: true }); //add a locked sheet to the style sheet manager
};

/**Override settings for specific implementations of the Pane.
@class*/
EVUI.Modules.Panes.PaneManagerSettings = function ()
{
    /**String. The human-readable name of the object being managed.
    @type {String}*/
    this.objectName = EVUI.Modules.Panes.Constants.Default_ObjectName;

    /**String. The human readable name of the manager, used in error reporting.
    @type {String}*/
    this.managerName = EVUI.Modules.Panes.Constants.Default_ManagerName;

    /**String. The prefix to add to the beginning of all CSS classes.
    @type {String}*/
    this.cssPrefix = EVUI.Modules.Panes.Constants.Default_CssPrefix;

    /**String. The name of the CSS sheet where styles will be dynamically added.
    @type {String}*/
    this.cssSheetName = EVUI.Modules.Styles.Constants.DefaultStyleSheetName;

    /**String. The prefix for all the events that the PaneManager will raise.
    @type {String}*/
    this.eventNamePrefix = EVUI.Modules.Panes.Constants.Default_EventNamePrefix;

    /**String. The prefix for all the attributes used by the PaneManager.
    @type {String}*/
    this.attributePrefix = EVUI.Modules.Panes.Constants.Default_AttributePrefix;

    /**Object. The DIV that all Panes will be placed in to be absolutely positioned on the screen.
    @type {HTMLElement}*/
    this.placementDiv = null;

    /**Object. The DIV that all Panes will be injected into when they are first loaded and will be placed in once they are hidden.
    @type {HTMLElement}*/
    this.loadDiv = null;

    /**Object. The DIV that all Panes will be injected into when they are measured so that their position can be calculated.
    @type {HTMLElement}*/
    this.measureDiv = null;

    /**Object. The backdrop manager that controls the optional backdrop settings.
    @type {BackdropManager}*/
    this.backdropManager = null;

    /**Object. An instance of Http module's HttpManager object.
    @type {EVUI.Modules.Http.HttpManager}*/
    this.httpManager = null;

    /**Object. An instance of the HtmlLoaderController module's HtmlLoaderController object.
    @type {EVUI.Modules.HtmlLoader.HtmlLoaderController}*/
    this.htmlLoader = null;

    /**Object. An instance of the Styles module's StylesheetManager object.
    @type {EVUI.Modules.Styles.StyleSheetManager}*/
    this.stylesheetManager = null;

    /**Object. The manager of the Pane derived type being manipulated.
    @type {EVUI.Modules.Panes.PaneManager}*/
    this.manager = null;

    /**Gets the PaneEventArgs created by the PaneManager and transforms them into a more specific type of event arguments.
    @param {EVUI.Modules.Panes.PaneArgsPackage} argsPackage The object representing the Pane's current operation.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event args made for the event.
    @returns {Any}*/
    this.buildEventArgs = function (argsPackage, paneEventArgs) { return paneEventArgs; };

    /**Processes the event args after the event has handled them. 
    @param {EVUI.Modules.Panes.PaneArgsPackage} argsPackage The object representing the Pane's current operation.
    @param {Any} eventArgs The event arguments created in the buildEventArgs function.*/
    this.processReturnedEventArgs = function (argsPackage, eventArgs) { };

    /**Object. The current arguments that will be used to perform an action on a Pane implementation.
    @type {Object}*/
    this.currentActionArgs = null;

    /**Makes or extends an object at the end of the PaneManager's function for applying the changes made to the Pane.
    @param {PaneCreationResult} paneCreateResult The result of creating the pane.
    @returns {EVUI.Modules.Panes.Pane}*/
    this.makeOrExtendObject = function (paneCreateResult) { return paneCreateResult.pane; };

    /**Gets any additional class names that can be applied to the implementation of the Pane.
    @returns {String[]}*/
    this.getAdditionalClassNames = function () { return [] };

    /**Gets an PaneEntry object or an array of them.
    @param {String|EVUI.Modules.Panes.Constants.Fn_PaneEntrySelector} paneIDOrSelector Either the ID of the Pane to get or a function that will select an array of Panes.
    @param {Boolean} getAllMatches Whether or not to get all the matches if a selector function was used or to return just the first match.
    @returns {EVUI.Modules.Panes.PaneEntry|EVUI.Modules.Panes.PaneEntry[]}*/
    this.getPaneEntry = function (paneIDOrSelector, getAllMatches) { };

    /**Gets a Pane's InternalPaneEntry based off of a string ID, a YOLO pane object, or a real pane object.
     @param {String|EVUI.Modules.Panes.Pane} paneOrID The string ID or Pane object to get.
     @param {Boolean} addIfMissing Whether or not to add the pane if it cannot be found.
     @returns {EVUI.Modules.Panes.PaneEntry} */
    this.getPaneEntryAmbiguously = function (paneOrID, addIfMissing) { };

    /**Interprets an action beginning with a browser event. Return false to process normally.
    @param {EVUI.Modules.Panes.Pane} paneSettings The settings to apply onto an existing pane or be used to create a new pane.
    @param {Event} event The event arguments that started a show/hide/load/unload operation.
    @returns {Boolean}*/
    this.interpretBrowserEvent = function (paneSettings, event) { return false; };

    /**Makes a clone of the Pane's PaneLoadSettings.
    @param {EVUI.Modules.Panes.PaneLoadSettings} loadSettings The load settings to clone.
    @returns {EVUI.Modules.Panes.PaneLoadSettings} */
    this.cloneLoadSettings = function (loadSettings) { return loadSettings; }

    /**Makes a clone of the Pane's PaneShowSettings.
    @param {EVUI.Modules.Panes.PaneShowSettings} loadSettings The show settings to clone.
    @returns {EVUI.Modules.Panes.PaneShowSettings} */
    this.cloneShowSettings = function (showSettings) { return showSettings; }

    /**Attaches any additional event handlers required for an implementation of the Pane.
    @param {EVUI.Modules.Panes.PaneEntry} paneEntry The entry representing the Pane to hook an event to.*/
    this.hookUpEventHandlers = function (paneEntry) { };
};

/**Represents a configurable UI element that can be loaded, placed, stretched, and moved arbitrarily.
@class*/
EVUI.Modules.Panes.Pane = function (id, options)
{
    if (typeof id !== "string") throw Error("Invalid input. Id must be a string.");

    var _id = id;    
    var _options = options;
    var _element = null;
    var _helper = null;

    /**String. The unique ID of this Pane. ID's are case-insensitive.
    @type {String}*/
    this.id = null;
    Object.defineProperty(this, "id",
    {
        get: function () { return id; },
        configurable: false,
        enumerable: true,
    });

    /**Object. The root Element of the Pane. Cannot be reset once it has been assigned to via initialization or a load operation, unload the Pane to reset it.
    @type {Element}*/
    this.element = null;
    Object.defineProperty(this, "element",
    {
        get: function () { return _element; },
        set: function (value)
        {
            if (typeof value === "string")
            {
                value = new EVUI.Modules.Dom.DomHelper(value).first();
            }

            var setObject =
            {
                element: EVUI.Modules.Core.Utils.getValidElement(value),
                paneID: _id,
                setSecret: _options.link.setSecret
            };

            if (typeof _options == null || typeof _options.canSetElement !== "function") throw Error("Failed to set element.");
            if (_options.canSetElement(setObject) === _options.link.setSecret)
            {
                _element = setObject.element;

                if (_element == null)
                {
                    _helper = null;
                }
                else
                {
                    _helper = new EVUI.Modules.Dom.DomHelper(_element);
                }
            }
            else
            {
                throw Error("Failed to set element: The provided value is invalid or the Pane is in an unstable state.");
            }
        },
        configurable: false,
        enumerable: true
    });

    /**Object. Settings for how the Pane's element will be loaded or assigned.
    @type {EVUI.Modules.Panes.PaneLoadSettings}*/
    this.loadSettings = new EVUI.Modules.Panes.PaneLoadSettings();

    /**Object. Settings for how the Pane's element will be positioned and displayed.
    @type {EVUI.Modules.Panes.PaneShowSettings}*/
    this.showSettings = new EVUI.Modules.Panes.PaneShowSettings();

    /**Object. Rules for controlling what will cause the Pane to recalculate its position.
    @type {EVUI.Modules.Panes.PaneRecalcSettings}*/
    this.reclacSettings = new EVUI.Modules.Panes.PaneRecalcSettings();

    /**Object. Settings for controlling how the Pane can be resized in response to user action.
    @type {EVUI.Modules.Panes.PaneResizeMoveSettings}*/
    this.resizeMoveSettings = new EVUI.Modules.Panes.PaneResizeMoveSettings();

    /**Object. Settings for controlling how the Pane can be automatically closed.
    @type {EVUI.Modules.Panes.PaneAutoCloseSettings}*/
    this.autoCloseSettings = new EVUI.Modules.Panes.PaneAutoCloseSettings();

    /**Boolean. Whether or not to unload the Pane from the DOM when it is hidden (only applies to elements that were loaded via HTTP). False by default.
    @type {Boolean}*/
    this.unloadOnHide = false;

    /**Object. Calculates and gets the absolute position of the Pane.
    @type {EVUI.Modules.Dom.ElementBounds}*/
    this.currentPosition = null;
    Object.defineProperty(this, "currentPosition",
    {
        get: function ()
        {
            return (_helper != null) ? _helper.offset() : null;
        },
        configurable: false,
        enumerable: true
    });

    /**Number. Calculates and gets the Z-Index of the Pane.
    @type {Number}*/
    this.currentZIndex = -1;
    Object.defineProperty(this, "currentZIndex",
    {
        get: function ()
        {
            if (_element == null)
            {
                return -1
            }
            else
            {
                var zIndex = parseInt(getComputedStyle(_element).zIndex);
                if (isNaN(zIndex) === true) return -1;
                return zIndex;
            }
        },
        configurable: false,
        enumerable: true
    });

    /**Boolean. Whether or not the internal state of the Pane thinks it is visible or not. This will be true after the show process has completed and false after an unload or hide operation has been completed.
    @type {Boolean}*/
    this.isVisible = false;
    Object.defineProperty(this, "isVisible", {
        get: function () { return EVUI.Modules.Core.Utils.hasFlag(options.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Visible) },
        configurable: false,
        enumerable: true
    });

    /**Boolean. Whether or not the internal state of the Pane thinks it is visible or not. This will be true after the load process has completed, even if the element was set directly before the first load operation.
    @type {Boolean}*/
    this.isLoaded = false;
    Object.defineProperty(this, "isLoaded", {
        get: function () { return EVUI.Modules.Core.Utils.hasFlag(options.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Loaded) },
        configurable: false,
        enumerable: true
    });

    /**Boolean. Whether or not the internal state of the Pane thinks it has been initialized or not. This will be true after the onInitialized events fire. */
    this.isInitialized = false;
    Object.defineProperty(this, "isInitialized", {
        get: function () { return EVUI.Modules.Core.Utils.hasFlag(options.link.paneStateFlags, EVUI.Modules.Panes.PaneStateFlags.Initialized) },
        configurable: false,
        enumerable: true
    });

    /**Any. Any contextual information to attach to the Pane object.
    @type {Any}*/
    this.context = null;

    /**Event that fires before the load operation begins for the Pane and is not yet in the DOM and cannot be manipulated in this stage, however the currentActionArgs.loadSettings can be manipulated to change the way the Pane's root element will be loaded.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneLoadArgs.*/
    this.onLoad = function (paneEventArgs)
    {

    };

    /**Event that fires after the load operation has completed for the Pane and is now in the DOM and can be manipulated in this stage. From this point on the Pane's element property cannot be reset..
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneLoadArgs.*/
    this.onLoaded = function (paneEventArgs)
    {

    };

    /**Event that fires the first time the Pane is shown after being loaded into the DOM, but is not yet visible. After it has fired once, it will not fire again unless the PaneShowArgs.reInitialize property is set to true.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneShowArgs.*/
    this.onInitialize = function (paneEventArgs)
    {

    };

    /**Event that fires at the beginning of the show process and before the calculations for the Pane's location are made. The Pane is still hidden, but is present in the DOM and can be manipulated. In order for the positioning calculations in the next step to be accurate, all HTML manipulation should occur in this event.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneShowArgs.*/
    this.onShow = function (paneEventArgs)
    {

    };

    /**Event that fires after the position of the Pane has been calculated and is available to be manipulated through the calculatedPosition property of the PaneEventArgs. If the calculatedPosition or the showSettings are manipulated, the position will be recalculated (the changes made directly to the position take priority over changes made to the showSettings).
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneShowArgs.*/
    this.onPosition = function (paneEventArgs)
    {

    };

    /**Event that fires once the Pane has been positioned, shown, and had its optional show transition applied and completed. Marks the end of the show process.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneShowArgs.*/
    this.onShown = function (paneEventArgs)
    {

    };

    /**Event that fires before the Pane has been moved from its current location and hidden. Gives the opportunity to change the hideTransition property of the PaneHideArgs and optionally trigger an unload once the Pane has been hidden.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneHideArgs.*/
    this.onHide = function (paneEventArgs)
    {

    };

    /**Event that fires after the Pane has been moved from its current location and is now hidden and the hide transition has completed.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneHideArgs.*/
    this.onHidden = function (paneEventArgs)
    {

    };

    /**Event that fires before the Pane has been (potentially) removed from the DOM and had its element property reset to null.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneUnloadArgs.*/
    this.onUnload = function (paneEventArgs)
    {
    };

    /**Event that fires after the Pane has been (potentially) removed from the DOM and had its element property reset to null. From this point on the Pane's element property is now settable to a new Element.
    @param {EVUI.Modules.Panes.PaneEventArgs} paneEventArgs The event arguments for the Pane operation. The currentActionArgs property will be an instance of PaneUnloadArgs.*/
    this.onUnloaded = function (paneEventArgs)
    {

    };

    /**Returns a copy of the internal eventBindings array.
    @returns {EVUI.Modules.Panes.PaneEventBinding[]}*/
    this.getEventBindings = function ()
    {
        return Object.freeze(_options.link.eventBindings.slice());
    };

    /**Adds an event response to a standard browser event to a child element of the Pane element.
    @param {Element} element The child element of the root pane element to attach an event handler to.
    @param {EVUI.Modules.Dom.Constants.Fn_BrowserEventHandler} handler An event handler to be called when the specified events are triggered.
    @param {String|String[]} event Either a single event name, or an array of event names, or a space delineated string of event names to add.*/
    this.addEventBinding = function (element, event, handler)
    {
        var ele = EVUI.Modules.Core.Utils.getValidElement(element);
        if (ele == null) throw Error("Invalid input. Target element must be an object derived from an Element.");
        if (EVUI.Modules.Core.Utils.containsElement(ele, _options.link.pane.element) === false) throw Error("element is not present or the provided element is not a child of the root element.");
        if (typeof handler !== "function") throw Error("Invalid input. Handler must be a function.");
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(event) === true) throw Error("Invalid input. Event must be a non-whitespace string.");
        
        var binding = new EVUI.Modules.Panes.PaneEventBinding(null, event, ele, handler);
        binding.attach();

        options.link.eventBindings.push(binding);
    };
};

/**Settings for controlling how the Pane will automatically close itself in response to user events.
@class*/
EVUI.Modules.Panes.PaneAutoCloseSettings = function ()
{
    /**String. The trigger for what should close the Pane.
    @type {String}*/
    this.closeMode = EVUI.Modules.Panes.PaneCloseMode.Explicit;

    /**Array. An array of characters/key names ("a", "b", "Escape", "Enter" etc) that will automatically trigger the Pane to be hidden when pressed. Corresponds to the KeyboardEvent.key property.
    @type {String[]}*/
    this.autoCloseKeys = [];

    /**An optional function to use to determine if an auto-close event should hide the Pane. Return false to prevent the Pane from being hidden.
    @param {EVUI.Modules.Panes.PaneAutoTriggerContext} autoTriggerContext The context object generated by the event handler.
    @returns {Boolean}*/
    this.autoCloseFilter = function (autoTriggerContext)
    {
        return true;
    };
};

/**Enum for describing the way the Pane should automatically close.
@enum*/
EVUI.Modules.Panes.PaneCloseMode =
{
    /**The Pane should close on the next click.*/
    Click: "globalClick",
    /**The Pane should close on any click outside its bounds.*/
    ExteriorClick: "exteriorClick",
    /**The pane should only close when explicitly closed.*/
    Explicit: "explicit"
};

Object.freeze(EVUI.Modules.Panes.PaneCloseMode);

/**Object for containing mutually exclusive options for how to load the Pane. A Element reference takes precedent over a CSS selector (where only the first result will be used), which takes precedent over a set of Http load arguments which takes precedence over placeholder load arguments.
@class*/
EVUI.Modules.Panes.PaneLoadSettings = function ()
{
    var _element = null;
    var _contextElement = null;

    /**Object. The Element to show as the Pane.
    @type {Element}*/
    this.element = null;
    Object.defineProperty(this, "element",
    {
        get: function ()
        {
            return _element;
        },
        set: function (value)
        {
            if (value != null)
            {
                if (typeof value === "string")
                {
                    value = new EVUI.Modules.Dom.DomHelper(value).first();
                }

                var ele = EVUI.Modules.Core.Utils.getValidElement(value);
                if (ele == null) throw Error("Invalid input for PaneLoadSettings.element. Must be an object derived from Element.");

                _element = value;
            }
            else
            {
                _element = null;
            }
        },
        configurable: false,
        enumerable: true
    });

    /**String. A CSS selector that is used to go find the Element to show as the Pane. Only the first result is used.
    @type {String}*/
    this.selector = null;

    /**Object. If using a CSS selector to find the root element of a Pane, this is the context limiting element to search inside of.
    @type {Element}*/
    this.contextElement = null;
    Object.defineProperty(this, "contextElement",
    {
        get: function ()
        {
            return _contextElement;
        },
        set: function (value)
        {
            if (value != null)
            {
                if (typeof value === "string")
                {
                    value = new EVUI.Modules.Dom.DomHelper(value).first();
                }

                var ele = EVUI.Modules.Core.Utils.getValidElement(value);
                if (ele == null) throw Error("Invalid input for PaneLoadSettings.element. Must be an object derived from Element.");

                _contextElement = value;
            }
            else
            {
                _contextElement = null;
            }
        },
        configurable: false,
        enumerable: true
    });

    /**Object. HttpRequestArgs for making a Http request to go get the Pane's HTML.
    @type {EVUI.Modules.Http.HttpRequestArgs}*/
    this.httpLoadArgs = null;

    /**Object. PlaceholderLoadArgs for making a series of Http requests to load the Pane as an existing placeholder.
    @type {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs}*/
    this.placeholderLoadArgs = null;
};

/**Indicates the method by which the element for the Pane will be obtained.
@enum*/
EVUI.Modules.Panes.PaneLoadMode =
{
    /**No load mode could be determined.*/
    None: "none",
    /**An existing element reference will be used instead of performing a load operation.*/
    ExistingElement: "existing",
    /**An element will be selected using a CSS selector.*/
    CSSSelector: "css",
    /**An element will be loaded via HTTP.*/
    HTTP: "http",
    /**An element will be loaded as a placeholder.*/
    Placeholder: "placeholder"
};
Object.freeze(EVUI.Modules.Panes.PaneLoadMode);

/**Object for containing a set of mutually exclusive directives for describing how to display and position the Pane. positionClass takes precedent, followed by abosolutePosition, followed by relativePosition, followed by anchors, followed by documentFlow, followed by fullscreen.
@class*/
EVUI.Modules.Panes.PaneShowSettings = function ()
{
    /**String. The name of a CSS class (or an array of CSS classes, or a space-separated CSS classes) that are used to position the Pane.
    @type {String|String[]}*/
    this.positionClass = null;

    /**Object. An absolute position for the Pane to be placed at relative to the current view port.
    @type {EVUI.Modules.Panes.PaneAbsolutePosition}*/
    this.absolutePosition = null;

    /**Object. A description for how to position the Pane relative to a x,y point or relative to the edges of another Element.
    @type {EVUI.Modules.Panes.PaneRelativePosition}*/
    this.relativePosition = null;

    /**Object. A description of other elements to anchor the Pane to and stretch it between its top/bottom or left/right bounding elements.
    @type {EVUI.Modules.Panes.PaneAnchors}*/
    this.anchors = null;

    /**Object. A description of how to insert the Pane into the DOM relative to another element.
    @type {EVUI.Modules.Panes.PaneDocumentFlow}*/
    this.documentFlow = null;

    /**Object. Rules for describing the bounds and overflow behavior of the Pane.
    @type {EVUI.Modules.Panes.PaneClipSettings}*/
    this.clipSettings = null;

    /**Boolean. Whether or not to full screen the Pane to cover the entire current view port.
    @type {Boolean}*/
    this.fullscreen = false;

    /**Whether or not to explicitly position the Pane so that it is centered on the screen's current view port.
    @type {Boolean}*/
    this.center = false;

    /**Object. Contains the details of the CSS transition to use to show the Pane (if a transition is desired). If omitted, the Pane is positioned then shown by manipulating the display property directly.
    @type {EVUI.Modules.Panes.PaneTransition}*/
    this.showTransition = null;

    /**Object. Contains the details of the CSS transition to use to hide the Pane (if a transition is desired). If omitted, the Pane is positioned then shown by manipulating the display property directly.
    @type {EVUI.Modules.Panes.PaneTransition}*/
    this.hideTransition = null;

    /**Boolean. Whether or not to include the height and width when positioning the element (when it is not clipped).
    @type {Boolean}*/
    this.setExplicitDimensions = false;

    /**Object. The settings for a backdrop to appear when the Pane is being displayed.
    @type {EVUI.Modules.Panes.PaneBackdropSettings}*/
    this.backdropSettings = null;
};

/**Object for describing how the Pane should be inserted into the document flow relative to another element.
@class*/
EVUI.Modules.Panes.PaneDocumentFlow = function ()
{
    var _relativeElement = null;

    /**Object. The Element (or CSS selector of the Element) that the Pane will be inserted into the document flow relative to.
    @type {Element|String}*/
    this.relativeElement = null;
    Object.defineProperty(this, "relativeElement",
    {
        get: function () { return _relativeElement; },
        set: function (value)
        {
            if (value != null)
            {
                if (typeof value === "string")
                {
                    _relativeElement = value;
                }
                else
                {
                    var ele = EVUI.Modules.Core.Utils.getValidElement(value);
                    if (ele == null) throw Error("Invalid input for PaneDocumentFlow.element. Must be a string or an object derived from an Element..");

                    _relativeElement = ele;
                }
            }
            else
            {
                _relativeElement = null;
            }
        },
        configurable: false,
        enumerable: true
    });

    /**String. A value from EVUI.Modules.Pane.PaneDocumentFlowMode indicating whether or not to append, prepend, or insert before/after the relative element. Appends the Pane as a child to the reference element by default.
    @type {String}*/
    this.mode = EVUI.Modules.Panes.PaneDocumentFlowMode.Append;
};

/**Object for describing the dimensions that the Pane should fit inside of and what to do when it overflows those bounds.
@class*/
EVUI.Modules.Panes.PaneClipSettings = function ()
{
    var _clipBounds = null;

    /**String. A value from the EVUI.Modules.Pane.PaneClipMode enum indicating the behavior when the Pane spills outside of the clipBounds. Defaults to "overflow".
    @type {String}*/
    this.mode = EVUI.Modules.Panes.PaneClipMode.Overflow;

    /**Object. An Element (or CSS selector of an Element) or an ElementBounds object describing the bounds to which the pane will attempt to fit inside. If omitted, the pane's current view port is used.
    @type {Element|EVUI.Modules.Dom.ElementBounds|String}*/
    this.clipBounds = null;
    Object.defineProperty(this, "clipBounds",
    {
        get: function () { return _clipBounds; },
        set: function (value)
        {
            if (value != null)
            {
                if (typeof value.top === "number" && typeof value.bottom === "number" && typeof value.left === "number" && typeof value.right === "number")
                {
                    _clipBounds = value;
                }
                else if (typeof value === "string")
                {
                    _clipBounds = value;
                }
                else
                {
                    var ele = EVUI.Modules.Core.Utils.getValidElement(value);
                    if (ele == null) throw Error("Invalid input for PaneDocumentFlow.element. Must be a string, ElementBounds, or an object derived from an Element..");

                    _clipBounds = ele;
                }
            }
            else
            {
                _clipBounds = null;
            }
        },
        configurable: false,
        enumerable: true
    });

    /**Boolean. Whether or not scrollbars should appear on the X-axis when the Pane has been clipped.
    @type {Boolean}*/
    this.scrollXWhenClipped = false;

    /**Boolean. Whether or not scrollbars should appear on the Y-axis when the Pane has been clipped.
    @type {Boolean}*/
    this.scrollYWhenClipped = false;
};

/**Enum for indicating the behavior of the Pane when it overflows its clipBounds.
@enum*/
EVUI.Modules.Panes.PaneClipMode =
{
    /**When the calculated position of the Pane overflows the clipBounds, it will not be cropped to stay within the clipBounds and will overflow to the outside of the clip bounds.*/
    Overflow: "overflow",
    /**When the calculated position of the Pane overflows the clipBounds, it will be clipped to the maximum dimensions of the clipBounds on the overflowing axes.*/
    Clip: "clip",
    /**When the calculated position of the Pane overflows the clipBounds, it will be shifted in the opposite directions as the overflow to fit within the clipBounds.*/
    Shift: "shift",
};
Object.freeze(EVUI.Modules.Panes.PaneClipMode);

/**Enum for describing the relationship between the relativeElement and Pane in a PaneDocumentFlow object.
@enum*/
EVUI.Modules.Panes.PaneDocumentFlowMode =
{
    /**The Pane is already in the correct position.*/
    Current: "current",
    /**The Pane will be appended under the relativeElment as a child element.*/
    Append: "append",
    /**The Pane will be prepended under the relativeElment as a child element.*/
    Prepend: "prepend",
    /**The Pane will be added before the relativeElment as a sibling element.*/
    Before: "before",
    /**The Pane will be added after the relativeElment as a sibling element.*/
    After: "after"
};
Object.freeze(EVUI.Modules.Panes.PaneDocumentFlowMode);

/**Object for containing the absolute location of the Pane relative to the current view port.
@class*/
EVUI.Modules.Panes.PaneAbsolutePosition = function (options)
{
    var _options = options;
    var _top = 0;
    var _left = 0;

    /**Number. The Y-Coordinate of the top edge of the Pane.*/
    this.top = 0;
    Object.defineProperty(this, "top",
    {
        get: function ()
        {
            if (_options != null)
            {
                var position = new EVUI.Modules.Dom.DomHelper(options.link.pane.element).offset();
                if (position != null) return position.top;
                return -1;
            }
            else
            {
                return _top;
            }
        },
        set: function (value)
        {
            if (_options == null)
            {
                if (typeof value !== "number") throw Error("Must be a number.");
                _top = value;
            }
        }
    });

    /**Number. The X-Coordinate of the left edge of the Pane.*/
    this.left = 0;
    Object.defineProperty(this, "left",
    {
        get: function ()
        {
            if (_options != null)
            {
                var position = new EVUI.Modules.Dom.DomHelper(options.link.pane.element).offset();
                if (position != null) return position.left;
                return -1;
            }
            else
            {
                return _left;
            }
        },
        set: function (value)
        {
            if (_options == null)
            {
                if (typeof value !== "number") throw Error("Must be a number.");
                _left = value;
            }
        }
    });
};

/**Object for containing the relative location of the Pane relative to a given point or reference Element.
@class*/
EVUI.Modules.Panes.PaneRelativePosition = function ()
{
    var _relativeElement = null;

    /**Number. The X-Coordinate to align the Pane to if it is not being aligned with an Element.
    @type {Number}*/
    this.x = 0;

    /**Number. The Y-Coordinate to align the Pane to if it is not being aligned with an Element.
    @type {Number}*/
    this.y = 0;

    /**String. The orientation of the Pane relative to the point or element. "bottom right" by default. If only "left" or "right" is specified, "bottom" is implied; if only "bottom" or "top" is specified, "right" is implied..
    @type {String}*/
    this.orientation = EVUI.Modules.Panes.RelativePositionOrientation.Bottom + " " + EVUI.Modules.Panes.RelativePositionOrientation.Right;

    /**String. The alignment of the Pane relative to the side of the point or element.
    @type {String}*/
    this.alignment = EVUI.Modules.Panes.RelativePositionAlignment.None;

    /**Object. An Element (or CSS selector of an Element) to be used as a point or reference for the Pane to be placed next to. Defers to an x,y point specification.
    @type {Element|String}*/
    this.relativeElement = null;
    Object.defineProperty(this, "relativeElement",
    {
        get: function () { return _relativeElement; },
        set: function (value)
        {
            if (value != null)
            {
                if (typeof value === "string")
                {
                    _relativeElement = value;
                }
                else
                {
                    var ele = EVUI.Modules.Core.Utils.getValidElement(value);
                    if (ele == null) throw Error("Invalid input for RelativePosition.relativeElement. Must be a string or an object derived from an Element.");

                    _relativeElement = ele;
                }
            }
            else
            {
                _relativeElement = null;
            }
        },
        configurable: false,
        enumerable: true
    });
};

/**Object for describing how the Pane will recalculate its position.
@class*/
EVUI.Modules.Panes.PaneRecalcSettings = function ()
{
    /**String. Controls how the Pane will recalculate itself in response to the browser pane resizing. Must be a value from PaneResizeResponseMode.
    @type {String}*/
    this.paneResizeResponse = EVUI.Modules.Panes.PaneResizeResponseMode.None;

    /**Boolean. Whether or not the position of the Pane should be continuously recalculated based on a set interval. Beware of performance implications when using this option.
    @type {Boolean}*/
    this.poll = false;

    /**Number. The number of milliseconds to wait between each recalculation of the Pane's position. Shorter intervals come at a higher performance penalty.
    @type {Number}*/
    this.pollInterval = 150;

    /**Object. The transition to apply when the Pane is resized or moved.
    @type {EVUI.Modules.Panes.PaneTransition}*/
    this.recalcTransition = null;
};

/**Controls how the Pane will recalculate itself in response to the browser pane resizing.
@ennum*/
EVUI.Modules.Panes.PaneResizeResponseMode =
{
    /**The Pane will not resize in response to the browser pane resizing.*/
    None: "none",
    /**The Pane will resize in response to the browser pane resizing on every triggering of the event.*/
    RealTime: "realtime",
    /**The Pane will resize in response to the browser pane resizing after a short delay once the browser has stopped resizing.*/
    OnComplete: "oncomplete"
};
Object.freeze(EVUI.Modules.Panes.PaneResizeResponseMode)

/**Enum set for orientations of a Pane relative to a point or element. Any combination of left/right and top/bottom is valid.
@enum*/
EVUI.Modules.Panes.RelativePositionOrientation =
{
    /**The Pane's right edge will be against the left edge of the relative element or point.*/
    Left: "left",
    /**The Pane's left edge will be against the right edge of the relative element or point.*/
    Right: "right",
    /**The Pane's bottom edge will be against the top edge of the relative element or point.*/
    Top: "top",
    /**The Pane's top edge will be against the bottom edge of the relative element or point.*/
    Bottom: "bottom"
};
Object.freeze(EVUI.Modules.Panes.RelativePositionOrientation);

/**Controls the alignment of the Pane along the X or Y axis when it is positioned relative to an Element.
@enum*/
EVUI.Modules.Panes.RelativePositionAlignment =
{
    /**The axis will not be aligned and will keep its calculated value.*/
    None: "none",
    /**The element will be aligned with the left side of the relative element.*/
    Left: "left",
    /**The element will be aligned with the right side of the relative element.*/
    Right: "right",
    /**The element will be aligned on the center of the x-axis of the relative element.*/
    XCenter: "xcenter",
    /**The element will be aligned on the center of the y-axis of the relative element..*/
    YCenter: "ycenter",
    /**The element will be aligned with the top side of the relative element.*/
    Top: "top",
    /**The element will be aligned with the bottom side of the relative element.*/
    Bottom: "bottom"
};
Object.freeze(EVUI.Modules.Panes.RelativePositionAlignment);

/**Object for containing the elements that a Pane can have its sides be anchored to.
@class*/
EVUI.Modules.Panes.PaneAnchors = function ()
{
    var _top = null;
    var _left = null;
    var _bottom = null;
    var _right = null;

    /**Object. The Element (or CSS selector of the Element) above the Pane whose bottom edge will be the boundary of the top of the Pane.
    @type {Element|String}*/
    this.top = null;
    Object.defineProperty(this, "top",
    {
        get: function () { return _top; },
        set: function (value)
        {
            if (value != null)
            {
                if (typeof value === "string")
                {
                    _top = value;
                }
                else if (value === document || value === window)
                {
                    _top = value;
                }
                else
                {
                    var ele = EVUI.Modules.Core.Utils.getValidElement(value);
                    if (ele == null) throw Error("Invalid input for PaneAnchors.top. Must be a string or an object derived from an Element.");

                    _top = ele;
                }
            }
            else
            {
                _top = null;
            }
        },
        configurable: false,
        enumerable: true
    });


    /**Object. The Element (or CSS selector of the Element) to the Left of the Pane whose right edge will be the boundary of the left side of the Pane.
    @type {Element|String}*/
    this.left = null;
    Object.defineProperty(this, "left",
    {
        get: function () { return _left; },
        set: function (value)
        {
            if (value != null)
            {
                if (typeof value === "string")
                {
                    _left = value;
                }
                else if (value === document || value === window)
                {
                    _left = value;
                }
                else
                {
                    var ele = EVUI.Modules.Core.Utils.getValidElement(value);
                    if (ele == null) throw Error("Invalid input for PaneAnchors.left. Must be a string or an object derived from an Element.");

                    _left = ele;
                }
            }
            else
            {
                _left = null;
            }
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The Element (or CSS selector of the Element) below the Pane whose top edge will be the boundary for the bottom side of the Pane.
    @type {Element|String}*/
    this.bottom = null;
    Object.defineProperty(this, "bottom",
    {
        get: function () { return _bottom; },
        set: function (value)
        {
            if (value != null)
            {
                if (typeof value === "string")
                {
                    _bottom = value;
                }
                else if (value === document || value === window)
                {
                    _bottom = value;
                }
                else
                {
                    var ele = EVUI.Modules.Core.Utils.getValidElement(value);
                    if (ele == null) throw Error("Invalid input for PaneAnchors.bottom. Must be a string or an object derived from an Element.");

                    _bottom = ele;
                }
            }
            else
            {
                _bottom = null;
            }
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The Element (or CSS selector of the Element) to the right of the Pane whose left edge will be the boundary for the right side of the Pane.
    @type {Element|String}*/
    this.right = null;
    Object.defineProperty(this, "right",
    {
        get: function () { return _right; },
        set: function (value)
        {
            if (value != null)
            {
                if (typeof value === "string")
                {
                    _right = value;
                }
                else if (value === document || value === window)
                {
                    _right = value;
                }
                else
                {
                    var ele = EVUI.Modules.Core.Utils.getValidElement(value);
                    if (ele == null) throw Error("Invalid input for PaneAnchors.right. Must be a string or an object derived from an Element.");

                    _right = ele;
                }
            }
            else
            {
                _right = null;
            }
        },
        configurable: false,
        enumerable: true
    });

    /**The alignment to give the X axis when it is not anchored explicitly to a left or right element. Must be a value from EVUI.Modules.Pane.PopInAnchorAlignment.
    @type {String}*/
    this.alignX = EVUI.Modules.Panes.AnchorAlignment.Elastic;

    /**The alignment to give the Y axis when it is not anchored explicitly to a top or bottom element. Must be a value from EVUI.Modules.Pane.PopInAnchorAlignment.
    @type {String}*/
    this.alignY = EVUI.Modules.Panes.AnchorAlignment.Elastic;
};

/**Controls the alignment along the X or Y axis when it would otherwise be ambiguous when only anchored to elements on the opposite axis.
@enum*/
EVUI.Modules.Panes.AnchorAlignment =
{
    /**The axis will not be aligned and will keep its current value.*/
    None: "none",
    /**The anchored element will stretch along the axis to either fit between two opposite anchors or along the same axis of the element it is anchored to (if only one element on the axis is an anchor point).*/
    Elastic: "elastic",
    /**The anchored element will be on the left most edge of top and bottom anchors (whichever is furthest to the left).*/
    Left: "left",
    /**The anchored element will be on the right most edge of top and bottom anchors (whichever is furthest to the right).*/
    Right: "right",
    /**The anchored element will be in the center of an anchored side, or in the "best fit" center of two non-congruent opposite sides.*/
    Center: "center",
    /**The anchored element will be on the top most edge of the left and right anchors (whichever is higher).*/
    Top: "top",
    /**The anchored element will be on the bottom most edge of the left and right anchors (whichever is lower).*/
    Bottom: "bottom"
};
Object.freeze(EVUI.Modules.Panes.AnchorAlignment);

/**A read-only look at a Pane's current state.
@class*/
EVUI.Modules.Panes.PaneEntry = function (paneLink)
{
    if (paneLink == null || typeof paneLink !== "object") throw Error("A PaneEntry cannot exist without a link to its parent PaneManager.")
    var _link = paneLink;
    var _bindingsCopy = paneLink.eventBindings.slice();

    /**Object. The Pane object being managed.
    @type {EVUI.Modules.Panes.Pane}*/
    this.pane = null;
    Object.defineProperty(this, "pane",
    {
        get: function ()
        {
            return _link.pane;
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The wrapper object that the PaneManagerSettings object created for a custom implementation of the PaneManager.
    @type {Object}*/
    this.wrapper = null;
    Object.defineProperty(this, "wrapper",
        {
            get: function ()
            {
                return _link.wrapper;
            },
            configurable: false,
            enumerable: true
        });

    /**Object. The EventStream doing the work for the Pane's operations.
    @type {EVUI.Modules.EventStream.EventStream}*/
    this.eventStream = null;
    Object.defineProperty(this, "eventStream",
    {
        get: function ()
        {
            return _link.eventStream;
        },
        configurable: false,
        enumerable: true
    });


    /**Number. Bit flags indicating the current state of the Pane (initialized, loaded, etc).
    @type {Number}*/
    this.paneStateFlags = EVUI.Modules.Panes.PaneStateFlags.None;
    Object.defineProperty(this, "paneStateFlags",
    {
        get: function ()
        {
            return _link.paneStateFlags;
        },
        configurable: false,
        enumerable: true
    });

    /**String. The current operation the pane is performing (loading, unloading, hiding, showing, etc).
    @type {String}*/
    this.currentPaneAction = EVUI.Modules.Panes.PaneAction.None;
    Object.defineProperty(this, "currentPaneAction",
    {
        get: function ()
        {
            return _link.paneAction;
        },
        configurable: false,
        enumerable: true
    });


    /**Array. An array of all the elements and their event handlers that have been attached in response to the automatically attached event handlers.
    @type {EVUI.Modules.Panes.PaneEventBinding[]}*/
    this.eventBindings = [];
    Object.defineProperty(this, "eventBindings",
    {
        get: function ()
        {
            if (bindingsEqual() === false)
            {
                _bindingsCopy = _link.eventBindings.slice();
                Object.freeze(_bindingsCopy);
            }

            return _bindingsCopy
        },
        configurable: false,
        enumerable: true
    });


    /**The class name that will be added to the root element of the Pane (or other components within the Pane's root element) so it can be identified via CSS.
    @type {String}*/
    this.paneCSSName = null;
    Object.defineProperty(this, "paneCSSName",
    {
        get: function ()
        {
            return _link.paneCSSName;
        },
        configurable: false,
        enumerable: true
    });

    this.lastCalculatedPosition = null;
    Object.defineProperty(this, "lastCalcualtedPosition", {
        get: function () { return _link.lastCalculatedPosition; },
        configurable: false,
        enumerable: true       
    })

    /**Determines if the bindings collections are still the same. */
    var bindingsEqual = function ()
    {
        if (_bindingsCopy.length !== _link.eventBindings.length) return false;

        var numBindings = _bindingsCopy.length;
        for (var x = 0; x < numBindings; x++)
        {
            if (_bindingsCopy[x] !== _link.eventBindings[x]) return false;
        }

        return true;
    };
};

/**Object that represents an automatically generated event handler binding in response to a special attribute's presence on an element.
@class*/
EVUI.Modules.Panes.PaneEventBinding = function (attr, event, element, handler)
{
    var _attribute = attr;
    var _event = event;
    var _handler = handler;
    var _element = element;
    var _active = null;
    var _helper = (element != null) ? new EVUI.Modules.Dom.DomHelper(_element) : null;

    /**String. The name of the attribute the is configured to cause an event binding.
    @type {String}*/
    this.attribute = null;
    Object.defineProperty(this, "attribute",
    {
        get: function () { return _attribute; },
        configurable: false,
        enumerable: true
    });

    /**String. The name of the event that is being bound (i.e. "onclick").*/
    this.event = null;
    Object.defineProperty(this, "event",
    {
        get: function () { return _event; },
        configurable: false,
        enumerable: true
    });

    /**Function. The event handling function.
    @type {Function}*/
    this.handler = null;
    Object.defineProperty(this, "handler",
    {
        get: function () { return _handler; },
        configurable: false,
        enumerable: true
    });

    /**Object. The reference to the Element that has the event handler attached to it.
    @type {Element}*/
    this.element = null;
    Object.defineProperty(this, "element",
    {
        get: function () { return _element; },
        configurable: false,
        enumerable: true
    });

    /**Boolean. Whether or not the handler is currently attached and responding to events.
    @type {Boolean}*/
    this.active = true;
    Object.defineProperty(this, "active",
    {
        get: function () { return _active; },
        configurable: false,
        enumerable: true
    });

    /**Detaches the event handler from the element so that it is no longer executed.*/
    this.detach = function ()
    {
        if (_active === false) return;

        _helper.off(_event, _handler);
        _active = false;
    };

    /**Attaches the event handler to the element.*/
    this.attach = function ()
    {
        if (_active === true) return;

        _helper.on(_event, _handler);
        _active = true;
    };
};

/**The context argument for when an automatic event is triggered from a Pane.
@class*/
EVUI.Modules.Panes.PaneAutoTriggerContext = function ()
{
    /**The type of event that triggered the automatic closure of the Pane. Must be a value from the PaneAutoCloseTriggerType enum.
    @type {String}*/
    this.triggerType = EVUI.Modules.Panes.PaneAutoCloseTriggerType.None;

    /**Object. The event binding triggering the event.
    @type {EVUI.Modules.Panes.PaneEventBinding}*/
    this.eventBinding = null;

    /**Object. The browser's event arguments.
    @type {Event}*/
    this.browserEvent = null;

    /**Object. The Pane or Pane implementation that is the target of the event.
    @type {Object}*/
    this.target = null;
};

/**Enum for describing the type of auto-close method that is being used to automatically close the Pane.
@enum*/
EVUI.Modules.Panes.PaneAutoCloseTriggerType =
{
    /**Default. No trigger type.*/
    None: "none",
    /**The BantPane is being closed due to a click event anywhere in the document.*/
    Click: "globalClick",
    /**The Pane is being closed due to a click outside of itself somewhere in the document.*/
    ExteriorClick: "exteriorClick",
    /**The Pane is being closed due to a keydown event.*/
    KeyDown: "keydown",
    /**The Pane is being closed due to one of its close handles being clicked on.*/
    Explicit: "explicit"
};
Object.freeze(EVUI.Modules.Panes.PaneAutoCloseTriggerType);

/**Object for describing a hide/show transition for a Pane. If omitted, hide and show operations are done via a inlined display: none to be hidden and a restoration of it's previous display value to be shown. This object is used to generate a transition class at runtime that is applied to the Pane's root element after the OnShow/OnHidde events and will delay the OnShown/OnHidden events by the specified duration.
@class*/
EVUI.Modules.Panes.PaneTransition = function ()
{
    /**Object or String. Either class names, a string of CSS rules (without a selector), or an object of key-value pairs of CSS properties to generate a runtime CSS class for.
    @type {Object|String}*/
    this.css = null;

    /**String. CSS definition for a keyframe animation to apply. Note that the keyframe animation's name must appear in the PaneTransition.css property in order to be applied.
    @type {String}*/
    this.keyframes = null;

    /**The duration (in milliseconds) of the transition so that the OnShown/OnHidden events are only fired once the transition is complete.
    @type {Number}*/
    this.duration = 0;
};

/**Object for containing information about how the Pane can be resized in response to user action.
@class*/
EVUI.Modules.Panes.PaneResizeMoveSettings = function ()
{
    /**Boolean. Whether or not the Pane can be moved around via a click and drag operation after the addition of the evui-w-drag-handle attribute to an element on or inside the root element of the Pane. False by default. */
    this.canDragMove = false;

    /**Boolean. Whether or not the top portion of the Y axis can be resized. False by default.
    @type {Boolean}*/
    this.canResizeTop = false;

    /**Boolean. Whether or not the bottom portion of the Y axis can be resized. False by default.
    @type {Boolean}*/
    this.canResizeBottom = false;

    /**Boolean. Whether or not the left portion of the X axis can be resized. False by default.
    @type {Boolean}*/
    this.canResizeLeft = false;

    /**Boolean. Whether or not the right portion of the X axis can be resized. False by default.
    @type {Boolean}*/
    this.canResizeRight = false;

    /**Number. The width in pixels of the margin around the edges of the Pane's root element that will be the clickable zone for triggering a resize operation (in pixels). 15 by default.
    @type {Numner}*/
    this.dragHanldeMargin = 15;

    /**Boolean. Whether or not the dimensions of any resized elements in a Pane will be restored to their original size when the Pane is hidden. True by default.
    @type {Boolean}*/
    this.restoreDefaultOnHide = true;
};

/**Object for configuring a full-screen backdrop to be placed behind a Pane.
@class*/
EVUI.Modules.Panes.PaneBackdropSettings = function ()
{
    /**Boolean. Whether or not to show a backdrop.
    @type {Boolean}*/
    this.showBackdrop = false;

    /**Object or String. Either class names, a string of CSS rules (without a selector), or an object of key-value pairs of CSS properties to generate a runtime CSS class for.
    @type {Object|String}*/
    this.backdropCSS = null;

    /**Object. The transition effect to apply when showing the backdrop.
    @type {EVUI.Modules.Panes.PaneTransition}*/
    this.backdropShowTransition = null;

    /**Object. The transition effect to apply when showing the backdrop.
    @type {EVUI.Modules.Panes.PaneTransition}*/
    this.backdropHideTransition = null;

    /**Number. The opacity of the backdrop. 75% by default.
    @type {Number}*/
    this.backdropOpacity = 0.75;

    /**String. The color of the backdrop. #000000 by default.
    @type {Number}*/
    this.backdropColor = "#000000";
};

/**Event arguments for all of the Pane events.
@class */
EVUI.Modules.Panes.PaneEventArgs = function (entry, currentArgs)
{
    if (entry == null || currentArgs == null) throw Error("Invalid arguments.")

    /**Object. The metadata about the state of the Pane.
    @type {InnerPaneEntry}*/
    var _entry = entry;

    /**Object. The current arguments for the event.
    @type {Object}*/
    var _currentArgs = currentArgs;

    /**The Pane that is having an action performed on it.
    @type {EVUI.Modules.Panes.Pane}*/
    this.pane = null;
    Object.defineProperty(this, "pane",
    {
        get: function () { return _entry.link.pane; },
        configurable: false,
        enumerable: true
    });

    /**String. The unique key current step in the EventStream.
    @type {String}*/
    this.key = null;

    /**Function. Pauses the EventStream, preventing the next step from executing until resume is called.*/
    this.pause = function () { };

    /**Function. Resumes the EventStream, allowing it to continue to the next step.*/
    this.resume = function () { };

    /**Function. Cancels the EventStream and aborts the execution of the Pane operation.*/
    this.cancel = function () { }

    /**Function. Stops the EventStream from calling any other event handlers with the same key.*/
    this.stopPropagation = function () { };

    /**Object. The position of the Pane that has been calculated in using the currentShowSettings.
    @type {EVUI.Modules.Panes.PanePosition}*/
    this.calculatedPosition = null;
    Object.defineProperty(this, "calculatedPosition",
    {
        get: function () { return _entry.link.lastCalculatedPosition; },
        configurable: false,
        enumerable: true
    });

    /**Object. The PaneHide/Show/Load/Unload Arguments being used for the operation.
    @type {EVUI.Modules.Panes.PaneShowArgs|EVUI.Modules.Panes.PaneHideArgs|EVUI.Modules.Panes.PaneLoadArgs|EVUI.Modules.Panes.PaneUnloadArgs}*/
    this.currentActionArgs = null;
    Object.defineProperty(this, "currentActionArgs", {
        get: function () { return _currentArgs },
        configurable: false,
        enumerable: true
    });

    /**Object. Any state value to carry between events.
    @type {Object}*/
    this.context = {};
};

/**Flags for describing the current state of a Pane.
@enum*/
EVUI.Modules.Panes.PaneStateFlags =
{
    /**No flags. Pane is not initialized, loaded, or visible.*/
    None: 0,
    /**Whether or not the Pane has been initialized.*/
    Initialized: 1,
    /**Whether or not the Pane has been loaded into the DOM.*/
    Loaded: 2,
    /**Whether or not the Pane is currently visible.*/
    Visible: 4,
    /**Whether or not the Pane has had its position calculated.*/
    Positioned: 8
};
Object.freeze(EVUI.Modules.Panes.PaneStateFlags);

/**Enum for describing the current action of the Pane.
@enum*/
EVUI.Modules.Panes.PaneAction =
{
    /**Pane is at rest.*/
    None: "none",
    /**Pane is in the process of being shown.*/
    Show: "show",
    /**Pane is in the process of being hidden.*/
    Hide: "hide",
    /**Pane is in the process of being loaded.*/
    Load: "load",
    /**Pane is in the process of being unloaded.*/
    Unload: "unload"    
};
Object.freeze(EVUI.Modules.Panes.PaneAction);

/**Describes the calculated position of a Pane in absolute coordinates. 
@class*/
EVUI.Modules.Panes.PanePosition = function (mode)
{
    var _mode = mode;

    /**String. A value from EVUI.Modules.Pane.PanePositionMode indicating the method used to calculate the coordinates of the Pane's root element.
    @type {String}*/
    this.mode = EVUI.Modules.Panes.PanePositionMode.None;
    Object.defineProperty(this, "mode",
    {
        get: function () { return _mode; },
        configurable: false,
        enumerable: true
    });

    /**Array. An array of strings indicating the class names that will be applied to the Pane's root element.
    @type {String[]}*/
    this.classNames = [];

    /**Number. The top edge of the Pane's root element. Only populated if the mode is absolute, relative, or anchor. 
    @type {Number}*/
    this.top = 0;

    /**Number. The left edge of the Pane's root element. Only populated if the mode is absolute, relative, or anchor.
    @type {Number}*/
    this.left = 0;

    /**Number. The bottom edge of the Pane's root element. Only populated if the mode is absolute, relative, or anchor.
    @type {Number}*/
    this.bottom = 0;

    /**Number. The right edge of the Pane's root element. Only populated if the mode is absolute, relative, or anchor.
    @type {Number}*/
    this.right = 0;

    /**Number. The z-index of the Pane's root element.
    @type {Number}*/
    this.zIndex = 0;
};

/**The mode by which the Pane will be positioned.
@enum*/
EVUI.Modules.Panes.PanePositionMode =
{
    /**Pane has no positioning logic and will appear in the top-left corner of the view port.*/
    None: "none",
    /**Pane has had CSS classes applied to it that dictate its positioning.*/
    PositionClass: "css",
    /**Pane has been placed according to a set of absolute coordinates.*/
    AbsolutePosition: "absolute",
    /**Pane has been placed relative to a point or element.*/
    RelativePosition: "relative",
    /**Pane is anchored between other elements and will stretch to fit between them.*/
    Anchored: "anchor",
    /**Pane is part of the regular document flow.*/
    DocumentFlow: "docflow",
    /**Pane will take up the entire screen or clipping bounds.*/
    Fullscreen: "fullscreen",
    /**Pane will be centered in the middle of the view port.*/
    Centered: "centered"
};
Object.freeze(EVUI.Modules.Panes.PanePositionMode);

/**Global instance of the PaneManager, used for creating and manipulating HTML components that are dynamically inserted and removed from the DOM. Highly configurable, but has no preset default behaviors.
@type {EVUI.Modules.Panes.PaneManager}*/
EVUI.Modules.Panes.Manager = null;
(function ()
{
    var ctor = EVUI.Modules.Panes.PaneManager;
    var manager = null;

    Object.defineProperty(EVUI.Modules.Panes, "Manager", {
        get: function ()
        {
            if (manager == null) manager = new ctor(ctor);
            return manager;
        },
        enumerable: true,
        configurable: false
    });
})();

/**Arguments for showing a Pane.
@class*/
EVUI.Modules.Panes.PaneShowArgs = function ()
{
    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    Object.defineProperty(this, "type", {
        get: function () { return EVUI.Modules.Panes.PaneArgumentType.Show; },
        configurable: false,
        enumerable: false
    });

    /**Any. Any contextual information to pass into the Pane show logic.
    @type {Any}*/
    this.context = null;

    /**Object. The PaneLoadSettings to use if the Pane has not already been loaded.
    @type {EVUI.Modules.Panes.PaneLoadArgs}*/
    this.loadArgs = null;

    /**Object. The PaneShowSettings to use to show the Pane.
    @type {EVUI.Modules.Panes.PaneShowSettings}*/
    this.showSettings = null;

    /**Whether or not to re-initialize the Pane upon showing it.
    @type {Boolean}*/
    this.reInitialize = false;
};

/**Arguments for loading a Pane.
@class*/
EVUI.Modules.Panes.PaneLoadArgs = function ()
{
    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    Object.defineProperty(this, "type", {
        get: function () { return EVUI.Modules.Panes.PaneArgumentType.Show; },
        configurable: false,
        enumerable: false
    });

    /**Any. Any contextual information to pass into the Pane load logic.
    @type {Any}*/
    this.context = null;

    /**Object. The PaneLoadSettings to use if the Pane has not already been loaded.
    @type {EVUI.Modules.Panes.PaneLoadSettings}*/
    this.loadSettings = null;

    /**Boolean. Whether or not to re-load the Pane.
    @type {Boolean}*/
    this.reload = false;
};

/**Arguments for hiding a Pane. 
@class*/
EVUI.Modules.Panes.PaneHideArgs = function ()
{
    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    Object.defineProperty(this, "type", {
        get: function () { return EVUI.Modules.Panes.PaneArgumentType.Hide; },
        configurable: false,
        enumerable: false
    });

    /**Any. Any contextual information to pass into the Pane hide logic.
    @type {Any}*/
    this.context = null;

    /**Object. The hide transition to use to hide the Pane.
    @type {EVUI.Modules.Panes.PaneTransition}*/
    this.paneHideTransition = null;

    /**Arguments to use to optionally unload the Pane once it is hidden.
    @type {EVUI.Modules.Panes.PaneUnloadArgs}*/
    this.unloadArgs = null;
};

/**Arguments for unloading a Pane.
@class*/
EVUI.Modules.Panes.PaneUnloadArgs = function ()
{
    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    Object.defineProperty(this, "type", {
        get: function () { return EVUI.Modules.Panes.PaneArgumentType.Unload; },
        configurable: false,
        enumerable: false
    });

    /**Any. Any contextual information to pass into the Pane hide logic.
    @type {Any}*/
    this.context = null;

    /**Boolean. Whether or not to remove the Pane from the DOM once it has been unloaded.
    @type {Boolean}*/
    this.remove = false;
};

/**Arguments for resizing a Pane.
@class*/
EVUI.Modules.Panes.PaneResizeMoveArgs = function ()
{
    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    Object.defineProperty(this, "type", {
        get: function () { return EVUI.Modules.Panes.PaneArgumentType.MoveResize; },
        configurable: false,
        enumerable: false
    });

    /**Number. The new height of the Pane.
    @type {Number}*/
    this.height = -1;

    /**Number. The new width of the Pane.
    @type {Number}*/
    this.width = -1;

    /**Number. The new top position of the Pane.
    @type {Number}*/
    this.top = -1;

    /**Number. The new left position of the Pane.
    @type {Number}*/
    this.left = -1;

    /**Number. The transition to apply to the Pane when it is resized.
    @type {EVUI.Modules.Panes.PaneTransition}*/
    this.resizeTransition = null;
};

/**A collection of all the possible arguments used to perform an operation on a Pane.
@class*/
EVUI.Modules.Panes.PaneArgsPackage = function (context)
{
    /**String. The original action that was issued. Must be a value from the PaneAction enum.
    @type {String}*/
    this.action = null;

    /**String. The current action being performed. Must be a value from the PaneAction enum.
    @type {String}*/
    this.currentAction = null;

    /**Object. The Pane driving the operation.
    @type {EVUI.Modules.Panes.Pane}*/
    this.pane = null;

    /**Object. The implementation of Pane that is wrapping the Pane.
    @type {Any}*/
    this.wrapper = null;

    /**Object. The arguments being used to show/load the Pane
    @type {EVUI.Modules.Panes.PaneShowArgs} */
    this.showArgs = null;

    /**Object. The arguments being used to load the Pane
    @type {EVUI.Modules.Panes.PaneLoadArgs} */
    this.loadArgs = null;

    /**Object. The arguments being used to hide the Pane.
    @type {EVUI.Modules.Panes.PaneHideArgs}*/
    this.hideArgs = null;

    /**Object. The arguments being used to hide the Pane.
    @type {EVUI.Modules.Panes.PaneUnloadArgs}*/
    this.unloadArgs = null;

    /**Object. The arguments passed into the PaneManagerSettings at the beginning of the operation.
    @type {EVUI.Modules.Panes.PaneArgsPackage}*/
    this.foreignArgs = null;

    /**Any. The contextual information provided by the user about the operation.
    @type {Any}*/
    this.context = context;

    /**Object. The last calculated position of the Pane.
    @type {EVUI.Modules.Panes.PanePosition}*/
    this.lastCalculatedPosition = null;
};

/**Enum for indicating what type of arguments object the PaneEventArgs.currentArguments property is.
@enum*/
EVUI.Modules.Panes.PaneArgumentType =
{
    /**Arguments are PaneShowArgs.*/
    Show: "show",
    /**Arguments are PaneHideArgs.*/
    Hide: "hide",
    /**Arguments are PaneLoadArgs.*/
    Load: "load",
    /**Arguments are PaneUnloadArgs.*/
    Unload: "unload",
    /**Arguments are PaneMoveResizeArgs.*/
    MoveResize: "moveResize"
};
Object.freeze(EVUI.Modules.Panes.PaneArgumentType);

EVUI.Modules.Panes.PaneManagerServices = function ()
{
    /**Object. The HttpManager used to make web requests from the PaneManager.
    @type {EVUI.Modules.Http.HttpManager}*/
    this.httpManager = null;

    /**Object. The HtmlLoaderController used by the PaneManager to load and inject HTML partials.
    @type {EVUI.Modules.HtmlLoader.HtmlLoader}*/
    this.htmlLoader = null;

    /**Object. The StylesheetManager used by the PaneManager to do runtime CSS manipulation.
    @type {EVUI.Modules.Styles.StyleSheetManager}*/
    this.stylesheetManager = null;
};

/**Global instance of the PaneManager, used for creating and manipulating HTML components that are dynamically inserted and removed from the DOM. Highly configurable, but has no preset default behaviors.
@type {EVUI.Modules.Panes.PaneManager}*/
$evui.panes = null;
Object.defineProperty($evui, "panes", {
    get: function () { return EVUI.Modules.Panes.Manager },
    enumerable: true
});

Object.freeze(EVUI.Modules.Panes);

/**Adds a Pane to the PaneManager.
@param {EVUI.Modules.Panes.Pane} yoloPane A YOLO object representing a Pane object. This object is copied onto a real Pane object is then discarded.
@returns {EVUI.Modules.Panes.Pane}*/
$evui.addPane = function (yoloPane)
{
    return $evui.panes.addPane(yoloPane);
};

/**Shows (and loads, if necessary or if a reload is requested) a Pane asynchronously. Provides a callback that is called call once the Pane operation has completed successfully or otherwise.
@param {EVUI.Modules.Panes.Pane|String} paneOrID Either a YOLO Pane object to extend into the existing Pane, the real Pane reference, or the string ID of the Pane to show.
@param {EVUI.Modules.Panes.PaneShowArgs|EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} paneShowArgs Optional.  The arguments for showing the Pane, or the callback. If omitted or passed as a function, the Pane's existing show/load settings are used instead.
@param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback Optional. A callback that is called once the operation completes.*/
$evui.showPane = function (paneOrID, paneShowArgs, callback)
{
    return $evui.panes.showPane(paneOrID, paneShowArgs, callback);
};

/**Awaitable. (and loads, if necessary or if a reload is requested) a Pane asynchronously.
@param {EVUI.Modules.Panes.Pane|String} paneOrID Either a YOLO Pane object to extend into the existing Pane, the real Pane reference, or the string ID of the Pane to show.
@param {EVUI.Modules.Panes.PaneShowArgs} paneShowArgs Optional. The arguments for showing the Pane. If omitted, the Pane's existing show/load settings are used instead.
@returns {Promise<Boolean>}*/
$evui.showPaneAsync = function (paneOrID, paneShowArgs)
{
    return $evui.panes.showPaneAsync(paneOrID, paneShowArgs);
};

/**Hides (and unloads if requested) a Pane asynchronously. Provides a callback that is called call once the Pane operation has completed successfully or otherwise.
@param {EVUI.Modules.Panes.Pane|String} paneOrID Either a YOLO Pane object to extend into the existing Pane, the real Pane reference, or the string ID of the Pane to hide.
@param {EVUI.Modules.Panes.PaneHideArgs|EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} paneHideArgs Optional. The arguments for hiding a Pane or the callback. If omitted or passed as a function, the Pane's existing hide/unload settings are used instead.
@param {EVUI.Modules.Panes.Constants.Fn_PaneOperationCallback} callback Optoinal. A callback that is called once the operation completes.*/
$evui.hidePane = function (paneOrID, paneHideArgs, callback)
{
    return $evui.panes.hidePane(paneOrID, paneHideArgs, callback);
};

/**Awaitable. Hides (and unloads if requested) a Pane asynchronously. Provides a callback that is called call once the Pane operation has completed successfully or otherwise.
@param {EVUI.Modules.Panes.Pane|String} paneOrID Either a YOLO Pane object to extend into the existing Pane, the real Pane reference, or the string ID of the Pane to hide.
@param {EVUI.Modules.Panes.PaneHideArgs} paneHideArgs Optional. The arguments for hiding a Pane. If omitted, the Pane's existing hide/unload settings are used instead. 
@returns {Promise<Boolean>}*/
$evui.hidePaneAsync = function (paneOrID, paneHideArgs)
{
    return $evui.panes.hidePaneAsync(paneOrID, paneHideArgs);
};

/*#ENDWRAP(Pane)#*/


/********************************************************PopIns.js********************************************************/
/*Copyright 2022 Richard H Stannard

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.PopIn|PopIn)#*/
/*#REPLACE(EVUI.Modules.PopIn|PopIn)#*/

/**Core module containing the Initialization and Utility functionality that is shared by all other modules.
@module*/
EVUI.Modules.PopIns = {};

/*#MODULEDEF(PopIn|"1.0";|"PopIn")#*/
/*#VERSIONCHECK(EVUI.Modules.PopIn|PopIn)#*/

EVUI.Modules.PopIns.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
    Panes: Object.freeze({ version: "1.0", required: true })
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.PopIns.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();

Object.freeze(EVUI.Modules.PopIns.Dependencies);

EVUI.Modules.PopIns.Constants = {};

/**Function for selecting a PaneEntry object. Return true to select the PaneEntry parameter as part of the result set.
@param {EVUI.Modules.PopIns.PopIn} popIn The PaneEntry providing metadata about a PopIn object.
@returns {Boolean}*/
EVUI.Modules.PopIns.Constants.Fn_PopInSelector = function (popIn) { return true; }

/**Function for reporting whether or not a PopIn was successfully Loaded.
@param {Boolean} success Whether or not the load operation completed successfully.*/
EVUI.Modules.PopIns.Constants.Fn_LoadCallback = function (success) { };

/**Function for reporting whether or not an operation PopIn was successful.
@param {Boolean} success Whether or not the operation completed successfully.*/
EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback = function (success) { };

EVUI.Modules.PopIns.Constants.CSS_Position = "evui-position";
EVUI.Modules.PopIns.Constants.CSS_ClippedX = "evui-clipped-x";
EVUI.Modules.PopIns.Constants.CSS_ClippedY = "evui-clipped-y";
EVUI.Modules.PopIns.Constants.CSS_ScrollX = "evui-scroll-x";
EVUI.Modules.PopIns.Constants.CSS_ScrollY = "evui-scroll-y"
EVUI.Modules.PopIns.Constants.CSS_Flipped = "evui-flipped";
EVUI.Modules.PopIns.Constants.CSS_Moved = "evui-moved";
EVUI.Modules.PopIns.Constants.CSS_Resized = "evui-resized";
EVUI.Modules.PopIns.Constants.CSS_Transition_Show = "evui-transition-show";
EVUI.Modules.PopIns.Constants.CSS_Transition_Hide = "evui-transition-hide";

/**String. The name of the ID attribute for the PopIn, used to look up a definition of a PopIn.
@type {String}*/
EVUI.Modules.PopIns.Constants.Attribute_ID = "evui-pop-id";

/**String. The name of the attribute that signifies which element should receive initial focus when the PopIn is displayed.
@type {String}*/
EVUI.Modules.PopIns.Constants.Attribute_Focus = "evui-pop-focus";

/**String. The name of the attribute that signifies that a click event on the Element should close the PopIn.
@type {String}*/
EVUI.Modules.PopIns.Constants.Attribute_Close = "evui-pop-close";

/**String. The name of the attribute on an element that triggers the showing of a PopIn what the URL to get the PopIn's HTML from is (Requires EVUI.Modules.Http).
@type {String}*/
EVUI.Modules.PopIns.Constants.Attribute_SourceURL = "evui-pop-src";

/**String. The name of the attribute on an element that triggers the showing of a PopIn of what placeholder to load for the PopIn's HTML (Requires EVUI.Modules.HtmlLoaderController).
@type {String}*/
EVUI.Modules.PopIns.Constants.Attribute_PlaceholderID = "evui-pop-placeholder-id";

/**String. The name of the attribute on an element that triggers the showing or hiding of a PopIn whether or not the PopIn should be unloaded when it is hidden.
@type {String}*/
EVUI.Modules.PopIns.Constants.Attribute_UnloadOnHide = "evui-pop-unload";

/**String. The name of the attribute on an element that triggers the showing or hiding of a PopIn that is used to indicate special behavior as defined by a consumer of the PopIn.
@type {String}*/
EVUI.Modules.PopIns.Constants.Attribute_Context = "evui-pop-cxt";

/**String. The name of the attribute on an element that triggers the showing of a PopIn what CSS selector to use to find the element to show as the PopIn. Only the first result will be used.
@type {String}*/
EVUI.Modules.PopIns.Constants.Attribute_Selector = "evui-pop-selector";

/**String. The name of the attribute that specifies which sides of the PopIn can be used to resize the PopIn. Specify any combination of "left", "right", "top", or "bottom". Only sides which are not anchored can be resized.
@type {String}*/
EVUI.Modules.PopIns.Constants.Attribute_ResizeHandles = "evui-pop-resize-handles";

/**String. The name of the attribute which specifies how wide the handle should be on the edges of the PopIn should be to start a resize operation in pixels.
@type {String}*/
EVUI.Modules.PopIns.Constants.Attribute_ResizeHandleWidth = "evui-pop-resize-handle-width"

EVUI.Modules.PopIns.Constants.Attribute_LeftAnchor = "evui-pop-anchor-left";

EVUI.Modules.PopIns.Constants.Attribute_RightLeftAnchor = "evui-pop-anchor-right";

EVUI.Modules.PopIns.Constants.Attribute_TopAnchor = "evui-pop-anchor-top";

EVUI.Modules.PopIns.Constants.Attribute_BottomAnchor = "evui-pop-anchor-bottom";

EVUI.Modules.PopIns.Constants.Default_ObjectName = "PopIn";
EVUI.Modules.PopIns.Constants.Default_ManagerName = "PopInManager";
EVUI.Modules.PopIns.Constants.Default_CssPrefix = "evui-pop";
EVUI.Modules.PopIns.Constants.Default_EventNamePrefix = "evui.pop";
EVUI.Modules.PopIns.Constants.Default_AttributePrefix = "evui-pop";

Object.freeze(EVUI.Modules.PopIns.Constants);

/**Class for managing PopIn object.
@class*/
EVUI.Modules.PopIns.PopInManager = function (services)
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.PopIns.Dependencies);

    var _self = this; //self-reference for closures

    /**The internal PaneManager of the PopInManager.
    @type {EVUI.Modules.Panes.PaneManager}*/
    var _manager = null;

    /**The settings overrides for the PopInManager.
    @type {EVUI.Modules.Panes.PaneManagerSettings}*/
    var _settings = null;

    /**Adds a PopIn to the WidowManager.
    @param {EVUI.Modules.PopIns.PopIn} popIn A YOLO object representing a PopIn object. This object is copied onto a real PopIn object is then discarded.
    @returns {EVUI.Modules.PopIns.PopIn}*/
    this.addPopIn = function (popIn)
    {
        if (popIn == null) throw Error(_settings.objectName + " cannot be null.");
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(popIn.id) === true) throw Error(_settings.objectName + "must have an id that is a non-whitespace string.");

        var existing = _settings.getPaneEntry(popIn.id);
        if (existing != null) throw Error("A " + _settings.objectName + " with an id of \"" + popIn.id + "\" already exists.");

        _manager.addPane(getDefaultPane(popIn));

        existing = _settings.getPaneEntry(popIn.id);
        return existing.wrapper;
    };

    /**Removes a PopIn from the PopInManager. Does not unload the PopIn's element from the DOM.
    @param {EVUI.Modules.PopIns.PopIn|String} popInOrID
    @returns {Boolean}*/
    this.removePopIn = function (popInOrID)
    {
        return _manager.removePane(popInOrID);
    };

    /**Gets a PopInEntry object based on its ID or a selector function.
    @param {EVUI.Modules.PopIns.Constants.Fn_PopInSelector|String} popInIDOrSelector A selector function to select a PopIn object (or multiple PopInEntry objects) or the ID of the PopIn to get the PopInEntry for.
    @param {Boolean} getAllMatches If a selector function is provided, all the PopInEntries that satisfy the selector are included. Otherwise a single PopInEntry object is returned. False by default.
    @returns {EVUI.Modules.PopIns.PopIn|EVUI.Modules.PopIns.PopIn[]} */
    this.getPopIn = function (popInIDOrSelector, getAllMatches)
    {
        var entries = null;

        if (typeof popInIDOrSelector === "function")
        {
            entries = _settings.getPaneEntry(function () { return true; }, true).map(function (entry) { return entry.wrapper; }).filter(popInIDOrSelector);
            if (getAllMatches !== true && entries != null) return entries[0];
            return entries;
        }
        else
        {
            entries = _settings.getPaneEntry(popInIDOrSelector, getAllMatches);
        }

        if (entries == null) return null;

        if (EVUI.Modules.Core.Utils.isArray(entries) === false)
        {
            return entries.wrapper;
        }
        else
        {
            return entries.map(function (entry) { return entry.wrapper; })
        }
    };

    /**Shows (and loads, if necessary or if a reload is requested) a PopIn asynchronously. Provides a callback that is called once the PopIn operation has completed successfully or otherwise.
    @param {EVUI.Modules.PopIns.PopIn|String} popInOrID Either a YOLO PopIn object to extend into the existing PopIn, the real PopIn reference, or the string ID of the PopIn to show.
    @param {EVUI.Modules.PopIns.PopInShowArgs|EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback} popInShowArgs Optional.  The arguments for showing the PopIn, or the callback. If omitted or passed as a function, the PopIn's existing show/load settings are used instead.
    @param {EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback} callback Optional. A callback that is called once the operation completes.*/
    this.showPopIn = function (popInOrID, popInShowArgs, callback)
    {
        var entry = getPopInAmbiguously(popInOrID, true);

        var windowShowArgs = new EVUI.Modules.Panes.PaneShowArgs();
        windowShowArgs.showSettings = _settings.cloneShowSettings(entry.window.showSettings);
        windowShowArgs.loadArgs = new EVUI.Modules.Panes.PaneLoadArgs();
        windowShowArgs.loadArgs.loadSettings = _settings.cloneLoadSettings(entry.window.loadSettings);

        if (typeof popInShowArgs === "function")
        {
            callback = popInShowArgs;
            popInShowArgs = null;
        }
        else if (popInShowArgs != null && typeof popInShowArgs === "object")
        {
            popInShowArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInShowArgs(windowShowArgs), popInShowArgs, ["type"]);
            if (popInShowArgs.showSettings != null)
            {
                popInShowArgs.showSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInShowSettings(windowShowArgs.showSettings), popInShowArgs.showSettings);
            }
            else
            {
                popInShowArgs.showSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInShowSettings(windowShowArgs.showSettings), entry.wrapper.showSettings);
            }


            if (popInShowArgs.loadArgs != null && popInShowArgs.loadArgs.loadSettings != null)
            {
                popInShowArgs.loadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInLoadArgs(windowShowArgs.loadArgs), popInShowArgs.loadArgs, ["type"]);
                popInShowArgs.loadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInLoadSettings(windowShowArgs.loadArgs.loadSettings), popInShowArgs.loadArgs.loadSettings);
            }
            else
            {
                popInShowArgs.loadArgs = new EVUI.Modules.PopIns.PopInLoadArgs(windowShowArgs.loadArgs);
                popInShowArgs.loadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInLoadSettings(windowShowArgs.loadArgs.loadSettings), entry.wrapper.loadSettings, ["type"]);;
            }
        }
        else
        {
            popInShowArgs = null;
        }

        if (popInShowArgs == null)
        {
            popInShowArgs = new EVUI.Modules.PopIns.PopInShowArgs(windowShowArgs);
            popInShowArgs.showSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInShowSettings(windowShowArgs.showSettings), entry.wrapper.showSettings);
            popInShowArgs.loadArgs = new EVUI.Modules.PopIns.PopInLoadArgs(windowShowArgs.loadArgs);
            popInShowArgs.loadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInLoadSettings(windowShowArgs.loadArgs.loadSettings), entry.wrapper.loadSettings);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(popInShowArgs);

        _manager.showPane(entry.window.id, windowShowArgs, callback);
    };

    /**Awaitable. (and loads, if necessary or if a reload is requested) a PopIn asynchronously.
    @param {EVUI.Modules.PopIns.PopIn|String} popInOrID Either a YOLO PopIn object to extend into the existing PopIn, the real PopIn reference, or the string ID of the PopIn to show.
    @param {EVUI.Modules.PopIns.PopInShowArgs} popInShowArgs Optional.  A YOLO object representing the arguments for showing the PopIn. If omitted, the PopIn's existing show/load settings are used instead.
    @returns {Promise<Boolean>}*/
    this.showPopInAsync = function (popInOrID, popInShowArgs)
    {
        return new Promise(function (resolve)
        {
            _self.showPopIn(popInOrID, popInShowArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Hides (and unloads if requested) a PopIn asynchronously. Provides a callback that is called call once the PopIn operation has completed successfully or otherwise.
    @param {EVUI.Modules.PopIns.PopIn|String} popInOrID Either a YOLO PopIn object to extend into the existing PopIn, the real PopIn reference, or the string ID of the PopIn to hide.
    @param {EVUI.Modules.PopIns.PopInHideArgs|EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback} popInHideArgs Optional. A YOLO object representing arguments for hiding a PopIn or a callback. If omitted or passed as a function, the PopIn's existing hide/unload settings are used instead.
    @param {EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback} callback Optional. A callback that is called once the operation completes.*/
    this.hidePopIn = function (popInOrID, popInHideArgs, callback)
    {
        var entry = getPopInAmbiguously(popInOrID);

        var windowHideArgs = new EVUI.Modules.Panes.PaneHideArgs();
        windowHideArgs.unloadArgs = new EVUI.Modules.Panes.PaneUnloadArgs();

        if (typeof popInHideArgs === "function")
        {
            callback = popInHideArgs;
            popInHideArgs = null;
        }
        else if (popInHideArgs != null && typeof popInHideArgs === "object")
        {
            popInHideArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInHideArgs(windowHideArgs), popInHideArgs, ["type"]);
            popInHideArgs.unloadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInUnloadArgs(windowHideArgs.unloadArgs, popInHideArgs.unloadArgs));
        }
        else
        {
            popInHideArgs = null;
        }


        if (popInHideArgs == null)
        {
            popInHideArgs = new EVUI.Modules.PopIns.PopInHideArgs(windowHideArgs);
            popInHideArgs.unloadArgs = new EVUI.Modules.PopInUnloadArgs(windowHideArgs.unloadArgs);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(popInHideArgs);
        _manager.hidePane(entry.window.id, windowHideArgs, callback);
    };

    /**Awaitable. Hides (and unloads if requested) a PopIn asynchronously.
    @param {EVUI.Modules.PopIns.PopIn|String} popInOrID Either a YOLO PopIn object to extend into the existing PopIn, the real PopIn reference, or the string ID of the PopIn to hide.
    @param {EVUI.Modules.PopIns.PopInHideArgs} popInHideArgs Optional. A YOLO object representing the arguments for hiding a PopIn. If omitted, the PopIn's existing hide/unload settings are used instead.
    @returns {Promise<Boolean>}*/
    this.hidePopInAsync = function (popInOrID, popInHideArgs)
    {
        return new Promise(function (resolve)
        {
            _self.hidePopIn(popInOrID, popInHideArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Hides all visible PopIns asynchronously. Provides a callback function that is called once all the visible PopIns have been hidden.
    @param {EVUI.Modules.PopIns.PopInHideArgs} popInHideArgs Optional. A YOLO object representing the arguments for hiding a PopIn. If omitted, the PopIn's existing hide/unload settings are used instead.
    @param {EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback} callback The callback that is called once all the PopIn's hide operations have completed.*/
    this.hideAllPopIns = function (popInHideArgs, callback)
    {
        if (typeof callback !== "function") callback = function () { };
        var allVisible = this.getPopIn(function (dd) { return dd.isVisible; });
        var numVisible = allVisible.length;
        var numHidden = 0;

        if (numVisible === 0) return callback(true);

        for (var x = 0; x < numVisible; x++)
        {
            this.hidePopIn(allVisible[x], popInHideArgs, function ()
            {
                numHidden++;
                if (numHidden === numVisible)
                {
                    return callback(true);
                }
            });
        }
    };

    /**Awaitable. Hides all PopIns asynchronously.
    @param {EVUI.Modules.PopIns.PopInHideArgs} windowHideArgs Optional. A YOLO object representing the arguments for hiding a PopIn. If omitted, the PopIn's existing hide/unload settings are used instead.
    @returns {Promise<Boolean>} */
    this.hideAllPopInsAsync = function (windowHideArgs)
    {
        return new Promise(function (resolve)
        {
            _self.hideAllPopIns(windowHideArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Asynchronously loads a PopIn. Provides a callback that is called after the operation has completed successfully or otherwise.
    @param {EVUI.Modules.PopIns.PopIn|String} popInOrID Either a YOLO PopIn object to extend into the existing PopIn, the real PopIn reference, or the string ID of the PopIn to load.
    @param {EVUI.Modules.PopIns.PopInLoadArgs|EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback} popInLoadArgs Optional. A YOLO object representing arguments for loading a PopIn or a callback. If omitted or passed as a function, the PopIn's existing load settings are used instead.
    @param {EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback} callback Optional. A callback to call once the operation completes.*/
    this.loadPopIn = function (popInOrID, popInLoadArgs, callback)
    {
        var entry = getPopInAmbiguously(popInOrID, false);

        var windowLoadArgs = new EVUI.Modules.Panes.PaneLoadArgs();
        windowLoadArgs.loadSettings = _settings.cloneLoadSettings(entry.window.loadSettings);

        if (typeof popInLoadArgs === "function")
        {
            callback = popInLoadArgs;
            popInLoadArgs = null;
        }
        else if (popInLoadArgs != null && typeof popInLoadArgs === "object")
        {
            popInLoadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInLoadArgs(windowLoadArgs), popInLoadArgs, ["type"]);
            if (popInLoadArgs.loadSettings != null)
            {
                popInLoadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInLoadSettings(windowLoadArgs.loadSettings), popInLoadArgs.loadSettings);
            }
            else
            {
                popInLoadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInLoadSettings(windowLoadArgs.loadSettings), entry.wrapper.loadSettings);
            }
        }
        else
        {
            popInLoadArgs = null;
        }

        if (popInLoadArgs == null)
        {
            popInLoadArgs = new EVUI.Modules.PopIns.PopInLoadArgs(windowLoadArgs);
            popInLoadArgs.loadSettings = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInLoadSettings(windowLoadArgs.loadSettings), entry.wrapper.loadSettings);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(popInLoadArgs);
        _manager.loadPane(entry.window.id, windowLoadArgs, callback);
    };

    /**Awaitable. Asynchronously loads a PopIn.
    @param {EVUI.Modules.PopIns.PopIn|String} popInOrID Either a YOLO PopIn object to extend into the existing PopIn, the real PopIn reference, or the string ID of the PopIn to load.
    @param {EVUI.Modules.PopIns.PopInLoadArgs} popInLoadArgs Optional. A YOLO object representing arguments for loading a PopIn.
    @returns {Promise<Boolean>}*/
    this.loadPopInAsync = function (popInOrID, popInLoadArgs)
    {
        return new Promise(function (resolve)
        {
            _self.loadPopIn(popInOrID, popInLoadArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Asynchronously unloads a PopIn, which disconnects the PopIn's element and removes it from the DOM if it was loaded remotely. Provides a callback that is called after the operation has completed successfully or otherwise.
    @param {EVUI.Modules.PopIns.PopIn|String} popInOrID Either a YOLO PopIn object to extend into the existing PopIn, the real PopIn reference, or the string ID of the PopIn to unload.
    @param {EVUI.Modules.PopIns.PopInUnloadArgs|EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback} popInUnloadArgs Optional. A YOLO object representing arguments for unloading a PopIn or a callback. If omitted or passed as a function, the PopIn's existing unload settings are used instead.
    @param {EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback} callback Optional. A callback to call once the operation completes.*/
    this.unloadPopIn = function (popInOrID, popInUnloadArgs, callback)
    {
        var entry = getPopInAmbiguously(popInOrID);
        var windowUnloadArgs = new EVUI.Modules.Panes.PaneUnloadArgs();

        if (typeof popInUnloadArgs === "function")
        {
            callback = popInUnloadArgs;
            popInUnloadArgs = null;
        }
        else if (popInUnloadArgs != null && typeof popInUnloadArgs === "object")
        {
            popInUnloadArgs = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.PopIns.PopInUnloadArgs(windowUnloadArgs), popInUnloadArgs);
        }
        else
        {
            popInUnloadArgs = null;
        }

        if (popInUnloadArgs == null)
        {
            popInUnloadArgs = new EVUI.Modules.PopIns.PopInUnloadArgs(windowUnloadArgs);
        }

        _settings.currentActionArgs = makeCurrentActionArgs(popInUnloadArgs);
        _manager.unloadPane(entry.window.id, windowUnloadArgs, callback);
    };

    /**Awaitable. Asynchronously unloads a PopIn, which disconnects the PopIn's element and removes it from the DOM if it was loaded remotely.
    @param {EVUI.Modules.PopIns.PopIn|String} popInOrID Either a YOLO PopIn object to extend into the existing PopIn, the real PopIn reference, or the string ID of the PopIn to unload.
    @param {EVUI.Modules.PopIns.PopInUnloadArgs} popInUnloadArgs Optional. A YOLO object representing arguments for unloading a PopIn. If omitted the PopIn's existing unload settings are used instead.
    @returns {Promise<Boolean>}*/
    this.unloadPopInAsync = function (popInOrID, popInUnloadArgs)
    {
        return new Promise(function (resolve)
        {
            _self.unloadPopIn(popInOrID, popInUnloadArgs, function (success)
            {
                resolve(success);
            });
        });
    };

    /**Makes or extends an object at the end of the PaneManager's function for applying the changes made to the Pane.
   @param {PaneCreationResult} windowCreateResult The result of creating the window.
   @returns {EVUI.Modules.Panes.Pane}*/
    var makeOrExtendObject = function (createResult)
    {
        var popIn = createResult.window.popIn;
        delete createResult.window.popIn;

        return makeOrExtendPopIn(popIn, createResult.window, createResult.exists);
    };

    /**Builds the PopInEventArgs to use in the EventStream.
    @param {EVUI.Modules.Panes.PaneArgsPackage} argsPackage The argument data from the PaneManager about the current state of the PopIn.
    @param {EVUI.Modules.Panes.PaneEventArgs} windowEventArgs The PaneEventArgs that were created for the event.
    @returns {EVUI.Modules.PopIns.PopInEventArgs} */
    var buildEventArgs = function (argsPackage, windowEventArgs)
    {
        if (argsPackage.foreignArgs == null)
        {
            argsPackage.foreignArgs = createForeignArgs(argsPackage);
        }

        var args = null;
        if (windowEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Hide)
        {
            args = argsPackage.foreignArgs.hideArgs;
        }
        else if (windowEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Load)
        {
            args = argsPackage.foreignArgs.loadArgs;
        }
        else if (windowEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Show)
        {
            args = argsPackage.foreignArgs.showArgs;
        }
        else if (windowEventArgs.currentActionArgs.type === EVUI.Modules.Panes.PaneArgumentType.Unload)
        {
            args = argsPackage.foreignArgs.unloadArgs;
        }

        var popInEventArgs = new EVUI.Modules.PopIns.PopInEventArgs(argsPackage, args);
        popInEventArgs.cancel = windowEventArgs.cancel;
        popInEventArgs.key = windowEventArgs.key;
        popInEventArgs.pause = windowEventArgs.pause;
        popInEventArgs.resume = windowEventArgs.resume;
        popInEventArgs.stopPropagation = windowEventArgs.stopPropagation;
        popInEventArgs.context = windowEventArgs.context;

        return popInEventArgs;
    };

    /**Makes the foreign arguments for injecting into a PopInEventArgs object from the PaneManager.
    @param {EVUI.Modules.PopIns.PopInShowArgs|EVUI.Modules.PopIns.PopInHideArgs|EVUI.Modules.PopIns.PopInLoadArgs|EVUI.Modules.PopIns.PopInUnloadArgs} popInArgs
    @returns {EVUI.Modules.Panes.PaneArgsPackage}.*/
    var makeCurrentActionArgs = function (popInArgs)
    {
        var currentActionArgs = new EVUI.Modules.Panes.PaneArgsPackage();
        if (popInArgs.type === EVUI.Modules.PopIns.PopInArgumentType.Hide)
        {
            currentActionArgs.hideArgs = popInArgs;
            currentActionArgs.unloadArgs = popInArgs.unloadArgs;
        }
        else if (popInArgs.type === EVUI.Modules.PopIns.PopInArgumentType.Show)
        {
            currentActionArgs.showArgs = popInArgs;
            currentActionArgs.loadArgs = popInArgs.loadArgs;
        }
        else if (popInArgs.type === EVUI.Modules.PopIns.PopInArgumentType.Load)
        {
            currentActionArgs.loadArgs = popInArgs;
        }
        else if (popInArgs.type === EVUI.Modules.PopIns.PopInArgumentType.Unload)
        {
            currentActionArgs.unloadArgs = popInArgs;
        }

        return currentActionArgs;
    };

    /**Makes the "foreign" arguments for the PaneManager if it does not have them already.
    @param {EVUI.Modules.Panes.PaneArgsPackage} argsPackage The state of the PopIn as reported by the Panemanager.
    @returns {EVUI.Modules.Panes.WidowArgsPackage}*/
    var createForeignArgs = function (argsPackage)
    {
        var foreignArgs = new EVUI.Modules.Panes.PaneArgsPackage();
        if (argsPackage.hideArgs != null)
        {
            foreignArgs.hideArgs = new EVUI.Modules.PopIns.PopInHideArgs(argsPackage.hideArgs);
            foreignArgs.hideArgs.unloadArgs = new EVUI.Modules.PopIns.PopInUnloadArgs(argsPackage.hideArgs.unloadArgs);
        }

        if (argsPackage.showArgs != null)
        {
            foreignArgs.showArgs = new EVUI.Modules.PopIns.PopInShowArgs(argsPackage.showArgs);
            foreignArgs.showArgs.showSettings = new EVUI.Modules.PopIns.PopInShowSettings(argsPackage.showArgs.showSettings);
            foreignArgs.showArgs.loadArgs = new EVUI.Modules.PopIns.PopInLoadArgs(argsPackage.showArgs.loadArgs);
            foreignArgs.showArgs.loadArgs.loadSettings = new EVUI.Modules.PopIns.PopInLoadSettings(argsPackage.showArgs.loadArgs.loadSettings);
        }

        if (argsPackage.loadArgs != null)
        {
            foreignArgs.loadArgs = new EVUI.Modules.PopIns.PopInLoadArgs(argsPackage.loadArgs);
            foreignArgs.loadArgs.loadSettings = new EVUI.Modules.PopIns.PopInLoadSettings(argsPackage.loadArgs.loadSettings);
        }

        if (argsPackage.unloadArgs != null)
        {
            foreignArgs.unloadArgs = new EVUI.Modules.PopIns.PopInUnloadArgs(argsPackage.unloadArgs);
        }

        return foreignArgs;
    };

    /**Makes or extends a PopIn object. Preserves all object references between runs and extends new properties onto the existing objects if they exist. 
    @param {EVUI.Modules.PopIns.PopIn} yoloPopIn A YOLO object representing a PopIn.
    @returns {EVUI.Modules.PopIns.PopIn} */
    var makeOrExtendPopIn = function (yoloPopIn, pane, exists)
    {
        var popInToExtend = null;
        if (exists === true)
        {
            var preExisting = _settings.getPaneEntry(yoloPopIn.id);
            popInToExtend = preExisting.wrapper;
        }
        else
        {
            popInToExtend = new EVUI.Modules.PopIns.PopIn(pane);
        }

        var safeCopy = EVUI.Modules.Core.Utils.shallowExtend({}, yoloPopIn);
        delete safeCopy.id;
        if (exists === true && yoloPopIn.element === pane.element) delete safeCopy.element; //if the popIn already exists and this is the same reference, don't set it again. Otherwise, let it blow up.
        delete safeCopy.currentPosition;
        delete safeCopy.currentZIndex;
        delete safeCopy.isVisible;
        delete safeCopy.isInitialized;
        delete safeCopy.isLoaded;

        EVUI.Modules.Core.Utils.shallowExtend(popInToExtend, safeCopy, ["showSettings", "loadSettings", "autoCloseSettings", "resizeMoveSettings"]);
        popInToExtend.showSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.PopIns.PopInShowSettings(pane.showSettings), popInToExtend.showSettings, yoloPopIn.showSettings);
        popInToExtend.loadSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.PopIns.PopInLoadSettings(pane.loadSettings), popInToExtend.loadSettings, yoloPopIn.loadSettings);
        popInToExtend.autoCloseSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.PopIns.PopInAutoCloseSettings(pane.autoCloseSettings), popInToExtend.autoCloseSettings, yoloPopIn.autoCloseSettings);
        popInToExtend.resizeMoveSettings = EVUI.Modules.Core.Utils.makeOrExtendObject(new EVUI.Modules.PopIns.PopInResizeMoveSettings(pane.resizeMoveSettings), popInToExtend.resizeMoveSettings, yoloPopIn.resizeMoveSettings)
        return popInToExtend;
    };

    /**Gets a PopIn object from ambiguous input.
    @param {EVUI.Modules.PopIns.PopIn|String|Event} popInOrID Either a YOLO object representing a PopIn object, a string ID of a PopIn, or browser Event args triggering a PopIn action.
    @param {Boolean} addIfMissing Whether or not to add the PopIn record if it is not already present.
    @returns {EVUI.Modules.Panes.PaneEntry} */
    var getPopInAmbiguously = function (popInOrID, addIfMissing)
    {
        if (popInOrID == null || (typeof popInOrID !== "string" && typeof popInOrID !== "object")) throw Error("Invalid input: " + _settings.objectName + " or string id expected.");

        if (popInOrID instanceof Event)
        {
            var entry = _settings.getPaneEntryAmbiguously(popInOrID, addIfMissing);
            return entry;
        }

        var fakePane = {};
        if (typeof popInOrID === "string")
        {
            fakePane = getDefaultPane({ id: popInOrID });
        }
        else
        {
            fakePane.id = popInOrID.id;
            fakePane.popIn = popInOrID;
        }

        return _settings.getPaneEntryAmbiguously(fakePane, addIfMissing);
    };

    /**Gets a YOLO Pane object with all the default properties for a PopIn's backing Pane.
    @param {EVUI.Modules.PopIns.PopIn} popIn The popIn to use as a wrapper for the Pane.
    @returns {EVUI.Modules.Panes.Pane}*/
    var getDefaultPane = function (popIn)
    {
        if (typeof popIn.id === "string")
        {
            var existing = _settings.getPaneEntry(popIn.id);
            if (existing != null && existing.window != null)
            {
                var fake = EVUI.Modules.Core.Utils.shallowExtend({}, existing.window);

                fake.popIn = popIn;
                return fake;
            }
        }

        var window =
        {
            id: popIn.id,
            autoCloseSettings:
            {
                closeMode: EVUI.Modules.Panes.PaneCloseMode.Explicit,
            },
            clipSettings:
            {
                clipMode: EVUI.Modules.PopIns.PopInClipMode.Overflow,
            },            
            popIn: popIn
        };

        return window;
    };

    /**Interprets a browser event for a PopIn operation.
    @param {EVUI.Modules.Panes.Pane} pane The YOLO Pane being created to extend onto a real record.
    @param {Event} browserEvent The event from the browser.
    @returns {EVUI.Modules.Panes.Pane}*/
    var interpretBrowserEvent = function (pane, browserEvent)
    {
        EVUI.Modules.Core.Utils.shallowExtend(pane, getDefaultPane({ id: pane.id }));
        if (pane.showSettings == null) pane.showSettings = {};
        if (pane.resizeMoveSettings == null) pane.resizeMoveSettings = {};

        var attributes = EVUI.Modules.Core.Utils.getElementAttributes(browserEvent.currentTarget);

        var center = attributes.getValue(EVUI.Modules.PopIns.Constants.Attribute_Center);
        var fullscreen = attributes.getValue(EVUI.Modules.PopIns.Constants.Attribute_Fullscreen);
        var drag = attributes.getValue(EVUI.Modules.PopIns.Constants.Attribute_Drag);
        var resizeHandles = attributes.getValue(EVUI.Modules.PopIns.Constants.Attribute_ResizeHandles);
        var resizeHadleWidth = attributes.getValue(EVUI.Modules.PopIns.Constants.Attribute_ResizeHandleWidth);
        var top = attributes.getValue(EVUI.Modules.PopIns.Constants.Attribute_Top);
        var left = attributes.getValue(EVUI.Modules.PopIns.Constants.Attribute_Left);
        var classes = attributes.getValue(EVUI.Modules.PopIns.Constants.Attribute_Classes);

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(fullscreen) === false)
        {
            fullscreen = fullscreen.toLowerCase();

            if (fullscreen === "false")
            {
                pane.showSettings.fullscreen = false;
            }
            else if (fullscreen === "true")
            {
                pane.showSettings.fullscreen = true;
            }
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(center) === false)
        {
            center = center.toLowerCase();

            if (center === "false")
            {
                pane.showSettings.center = false;
            }
            else if (center === "true")
            {
                pane.showSettings.center = true;
            }
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(left) === false)
        {
            if (pane.showSettings.absolutePosition == null) pane.showSettings.absolutePosition = {};
            left = parseFloat(left, left.toLowerCase().replace("px", ""));
            if (isNaN(left) === false) pane.showSettings.absolutePosition.left = left;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(top) === false)
        {
            if (pane.showSettings.absolutePosition == null) pane.showSettings.absolutePosition = {};
            top = parseFloat(top, top.toLowerCase().replace("px", ""));
            if (isNaN(left) === false) pane.showSettings.absolutePosition.top = top;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(classes) === false)
        {
            pane.showSettings.positionClass = classes;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(drag) === false)
        {
            drag = drag.toLowerCase();

            if (drag === "true")
            {
                pane.resizeMoveSettings.canDragMove = true;
            }
            else if (drag === "false")
            {
                pane.resizeMoveSettings.canDragMove = false;
            }
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(resizeHandles) === false)
        {
            resizeHandles = resizeHandles.toLowerCase();

            pane.resizeMoveSettings.canResizeLeft = false;
            pane.resizeMoveSettings.canResizeRight = false;
            pane.resizeMoveSettings.canResizeTop = false;
            pane.resizeMoveSettings.canResizeBottom = false;

            if (resizeHandles.indexOf("left") !== -1) pane.resizeMoveSettings.canResizeLeft = true;
            if (resizeHandles.indexOf("right") !== -1) pane.resizeMoveSettings.canResizeRight = true;
            if (resizeHandles.indexOf("top") !== -1) pane.resizeMoveSettings.canResizeTop = true;
            if (resizeHandles.indexOf("bottom") !== -1) pane.resizeMoveSettings.canResizeBottom = true;
        }

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(resizeHadleWidth) === false)
        {
            resizeHadleWidth = parseFloat(resizeHadleWidth, resizeHadleWidth.toLowerCase().replace("px", ""));
            if (isNaN(resizeHadleWidth) === false && resizeHadleWidth >= 0) pane.resizeMoveSettings.resizeHadleWidth = resizeHadleWidth;
        }

        return true;
    };

    /**Adds additional event handlers to the PopIn.
    @param {EVUI.Modules.Panes.PaneEntry} windowEntry The window to add the event to.*/
    var hookUpEventHandlers = function (windowEntry)
    {
        setHighestZOrder(windowEntry);
    };

    /**Adds additional event handlers to the PopIn.
    @param {EVUI.Modules.Panes.PaneEntry} windowEntry The window to add the event to.*/
    var setHighestZOrder = function (windowEntry)
    {
        windowEntry.window.addEventBinding(windowEntry.window.element, "mousedown", function (eventArgs)
        {
            var curZIndex = windowEntry.window.currentZIndex;
            if (curZIndex >= EVUI.Modules.Panes.Constants.GlobalZIndex) return;

            EVUI.Modules.Panes.Constants.GlobalZIndex++;

            curZIndex = EVUI.Modules.Panes.Constants.GlobalZIndex;
            var selector = "." + windowEntry.windowCSSName + "." + EVUI.Modules.PopIns.Constants.CSS_Position;

            EVUI.Modules.Styles.Manager.ensureSheet(_settings.cssSheetName, { lock: true });
            EVUI.Modules.Styles.Manager.setRules(_settings.cssSheetName, selector, { zIndex: curZIndex });
        });
    };

    _settings = new EVUI.Modules.Panes.PaneManagerSettings();
    _settings.attributePrefix = EVUI.Modules.PopIns.Constants.Default_AttributePrefix;
    _settings.cssPrefix = EVUI.Modules.PopIns.Constants.Default_CssPrefix;
    _settings.cssSheetName = EVUI.Modules.Styles.Constants.DefaultStyleSheetName;
    _settings.eventNamePrefix = EVUI.Modules.PopIns.Constants.Default_EventNamePrefix;
    _settings.managerName = EVUI.Modules.PopIns.Constants.Default_ManagerName;
    _settings.objectName = EVUI.Modules.PopIns.Constants.Default_ObjectName;
    _settings.makeOrExtendObject = makeOrExtendObject;
    _settings.buildEventArgs = buildEventArgs;
    _settings.interpretBrowserEvent = interpretBrowserEvent;
    _settings.hookUpEventHandlers = hookUpEventHandlers

    if (services == null || typeof services !== "object") services = new EVUI.Modules.PopIns.PopInControllerServices();
    if (services.paneManager == null || typeof services.paneManager !== "object")
    {
        services.paneManager = EVUI.Modules.Panes.Manager;
    }

    _settings.httpManager = services.httpManager;
    _settings.stylesheetManager = services.stylesheetManager;
    _settings.htmlLoader = services.htmlLoader;

    _manager = new services.paneManager.createNewPaneManager(_settings);

    /**Global event that fires before the load operation begins for any PopIn and is not yet in the DOM and cannot be manipulated in this stage, however the currentActionArgs.loadSettings can be manipulated to change the way the PopIn's root element will be loaded.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInLoadArgs.*/
    this.onLoad = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onLoad", targetPath: "onLoad" });

    /**Global even that fires after the load operation has completed for any PopIn and is now in the DOM and can be manipulated in this stage. From this point on the PopIn's element property cannot be reset..
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInLoadArgs.*/
    this.onLoaded = function (windowEventArgs) { };;
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onLoaded", targetPath: "onLoaded" });

    /**Global event that fires the first time any PopIn is shown after being loaded into the DOM, but is not yet visible. After it has fired once, it will not fire again unless the PopInShowArgs.reInitialize property is set to true.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInShowArgs.*/
    this.onInitialize = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onInitialize", targetPath: "onInitialize" });

    /**Global event that fires at the beginning of the show process and before the calculations for any PopIn's location are made. The PopIn is still hidden, but is present in the DOM and can be manipulated. In order for the positioning calculations in the next step to be accurate, all HTML manipulation should occur in this event.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInShowArgs.*/
    this.onShow = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onShow", targetPath: "onShow" });

    /**Global event that fires after the position of any PopIn has been calculated and is available to be manipulated through the calculatedPosition property of the PopInEventArgs. If the calculatedPosition or the showSettings are manipulated, the position will be recalculated (the changes made directly to the position take priority over changes made to the showSettings).
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInShowArgs.*/
    this.onPosition = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onPosition", targetPath: "onPosition" });

    /**Global event that fires once any PopIn has been positioned, shown, and had its optional show transition applied and completed. Marks the end of the show process.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInShowArgs.*/
    this.onShown = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onShown", targetPath: "onShown" });

    /**Global event that fires before any PopIn has been moved from its current location and hidden. Gives the opportunity to change the hideTransition property of the PopInHideArgs and optionally trigger an unload once the PopIn has been hidden.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInHideArgs.*/
    this.onHide = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onHide", targetPath: "onHide" });

    /**Global event that fires after any PopIn has been moved from its current location and is now hidden and the hide transition has completed.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInHideArgs.*/
    this.onHidden = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onHidden", targetPath: "onHidden" });

    /**Global event that fires before any PopIn has been (potentially) removed from the DOM and had its element property reset to null.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInUnloadArgs.*/
    this.onUnload = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onUnload", targetPath: "onUnload" });

    /**Global event that fires after any PopIn has been (potentially) removed from the DOM and had its element property reset to null. From this point on the PopIn's element property is now settable to a new Element.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInUnloadArgs.*/
    this.onUnloaded = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _manager, { sourcePath: "onUnloaded", targetPath: "onUnloaded" });
}

/**Represents a UI component that behaves like a standard, centered popIn popIn with an optional backdrop by default.
 @class*/
EVUI.Modules.PopIns.PopIn = function (pane)
{
    if (pane == null) throw Error("Invalid input. Must wrap a Pane.");

    /**Object. The PopIn being wrapped by the PopIn.
    @type {EVUI.Modules.Panes.Pane}*/
    var _window = pane;

    /**String. The unique ID of this PopIn. ID's are case-insensitive.
    @type {String}*/
    this.id = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "id", targetPath: "id", settings: { set: false } });

    /**Object. The root Element of the PopIn. Cannot be reset once it has been assigned to via initialization or a load operation, unload the PopIn to reset it.
    @type {Element}*/
    this.element = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "element", targetPath: "element" });

    /**Boolean. Whether or not to unload the PopIn from the DOM when it is hidden (only applies to elements that were loaded via HTTP). False by default.
    @type {Boolean}*/
    this.unloadOnHide = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "unloadOnHide", targetPath: "unloadOnHide" });

    /**Object. Calculates and gets the absolute position of the PopIn.
    @type {EVUI.Modules.Dom.ElementBounds}*/
    this.currentPosition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "currentPosition", targetPath: "currentPosition", settings: { set: false } });

    /**Number. Calculates and gets the Z-Index of the PopIn.
    @type {Number}*/
    this.currentZIndex = -1;
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "currentZIndex", targetPath: "currentZIndex", settings: { set: false } });

    /**Boolean. Whether or not the internal state of the PopIn thinks it is visible or not. This will be true after the show process has completed and false after an unload or hide operation has been completed.
    @type {Boolean}*/
    this.isVisible = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "isVisible", targetPath: "isVisible", settings: { set: false } });

    /**Boolean. Whether or not the internal state of the PopIn thinks it is visible or not. This will be true after the load process has completed, even if the element was set directly before the first load operation.
    @type {Boolean}*/
    this.isLoaded = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "isLoaded", targetPath: "isLoaded", settings: { set: false } });

    /**Boolean. Whether or not the internal state of the PopIn thinks it has been initialized or not. This will be true after the onInitialized events fire. */
    this.isInitialized = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "isInitialized", targetPath: "isInitialized", settings: { set: false } });

    /**Object. Show settings for the PopIn.
    @type {EVUI.Modules.PopIns.PopInShowSettings}*/
    this.showSettings = null;

    /**Object. Settings for loading the PopIn.
    @type {EVUI.Modules.PopIns.PopInLoadSettings}*/
    this.loadSettings = null;

    /**Object. Settings for controlling what should automatically close the PopIn.
    @type {EVUI.Modules.PopIns.PopInAutoCloseSettings}*/
    this.autoCloseSettings = null;

    /**Object. Settings for controller how the PopIn should resize and move itself.
    @type {EVUI.Modules.PopIns.PopInResizeMoveSettings}*/
    this.resizeMoveSettings = null;

    /**Any. Any contextual information to attach to the PopIn object.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "context", targetPath: "context" });

    /**Event that fires before the load operation begins for the PopIn and is not yet in the DOM and cannot be manipulated in this stage, however the currentActionArgs.loadSettings can be manipulated to change the way the PopIn's root element will be loaded.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInLoadArgs.*/
    this.onLoad = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "onLoad", targetPath: "onLoad" });

    /**Event that fires after the load operation has completed for the PopIn and is now in the DOM and can be manipulated in this stage. From this point on the PopIn's element property cannot be reset..
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInLoadArgs.*/
    this.onLoaded = function (windowEventArgs) { };;
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "onLoaded", targetPath: "onLoaded" });

    /**Event that fires the first time the PopIn is shown after being loaded into the DOM, but is not yet visible. After it has fired once, it will not fire again unless the PopInShowArgs.reInitialize property is set to true.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInShowArgs.*/
    this.onInitialize = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "onInitialize", targetPath: "onInitialize" });

    /**Event that fires at the beginning of the show process and before the calculations for the PopIn's location are made. The PopIn is still hidden, but is present in the DOM and can be manipulated. In order for the positioning calculations in the next step to be accurate, all HTML manipulation should occur in this event.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInShowArgs.*/
    this.onShow = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "onShow", targetPath: "onShow" });

    /**Event that fires after the position of the PopIn has been calculated and is available to be manipulated through the calculatedPosition property of the PopInEventArgs. If the calculatedPosition or the showSettings are manipulated, the position will be recalculated (the changes made directly to the position take priority over changes made to the showSettings).
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInShowArgs.*/
    this.onPosition = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "onPosition", targetPath: "onPosition" });

    /**Event that fires once the PopIn has been positioned, shown, and had its optional show transition applied and completed. Marks the end of the show process.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInShowArgs.*/
    this.onShown = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "onShown", targetPath: "onShown" });

    /**Event that fires before the PopIn has been moved from its current location and hidden. Gives the opportunity to change the hideTransition property of the PopInHideArgs and optionally trigger an unload once the PopIn has been hidden.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInHideArgs.*/
    this.onHide = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "onHide", targetPath: "onHide" });

    /**Event that fires after the PopIn has been moved from its current location and is now hidden and the hide transition has completed.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInHideArgs.*/
    this.onHidden = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "onHidden", targetPath: "onHidden" });

    /**Event that fires before the PopIn has been (potentially) removed from the DOM and had its element property reset to null.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInUnloadArgs.*/
    this.onUnload = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "onUnload", targetPath: "onUnload" });

    /**Event that fires after the PopIn has been (potentially) removed from the DOM and had its element property reset to null. From this point on the PopIn's element property is now settable to a new Element.
    @param {EVUI.Modules.PopIns.PopInEventArgs} windowEventArgs The event arguments for the PopIn operation. The currentActionArgs property will be an instance of PopInUnloadArgs.*/
    this.onUnloaded = function (windowEventArgs) { };
    EVUI.Modules.Core.Utils.wrapProperties(this, _window, { sourcePath: "onUnloaded", targetPath: "onUnloaded" });

    /**Returns a copy of the internal eventBindings array.
    @returns {EVUI.Modules.Panes.PaneEventBinding[]}*/
    this.getEventBindings = function ()
    {
        return _window.getEventBindings();
    };

    /**Adds an event response to a standard browser event to a child element of the PopIn element.
    @param {Element} element The child element of the root pane element to attach an event handler to.
    @param {EVUI.Modules.Dom.Constants.Fn_BrowserEventHandler} handler An event handler to be called when the specified events are triggered.
    @param {String|String[]} event Either a single event name, or an array of event names, or a space delineated string of event names to add.*/
    this.addEventBinding = function (element, event, handler)
    {
        return _window.addEventBinding(element, event, handler);
    };
};

/**The settings and options for showing a PopIn.
@class*/
EVUI.Modules.PopIns.PopInShowSettings = function (showSettings)
{
    /**The show settings being set by the PopInShowSettings.
    @type {EVUI.Modules.Panes.PaneShowSettings}*/
    var _showSettings = (showSettings == null || typeof showSettings !== "object") ? new EVUI.Modules.Panes.PaneShowSettings() : showSettings;
    if (_showSettings.clipSettings == null) _showSettings.clipSettings = new EVUI.Modules.Panes.PaneClipSettings();
    if (_showSettings.anchors == null) _showSettings.anchors = new EVUI.Modules.Panes.PaneAnchors();

    /**Object. The Element (or CSS selector of the Element) above the Pane whose bottom edge will be the boundary of the top of the Pane.
    @type {Element|String}*/
    this.topAnchor = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings.anchors, { sourcePath: "topAnchor", targetPath: "top" });

    /**Object. The Element (or CSS selector of the Element) to the Left of the Pane whose right edge will be the boundary of the left side of the Pane.
    @type {Element|String}*/
    this.leftAnchor = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings.anchors, { sourcePath: "leftAnchor", targetPath: "left" });

    /**Object. The Element (or CSS selector of the Element) below the Pane whose top edge will be the boundary for the bottom side of the Pane.
    @type {Element|String}*/
    this.bottomAnchor = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings.anchors, { sourcePath: "bottomAnchor", targetPath: "bottom" });

    /**Object. The Element (or CSS selector of the Element) to the right of the Pane whose left edge will be the boundary for the right side of the Pane.
    @type {Element|String}*/
    this.rightAnchor = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings.anchors, { sourcePath: "rightAnchor", targetPath: "right" });

    /**The alignment to give the X axis when it is not anchored explicitly to a left or right element. Must be a value from EVUI.Modules.Pane.PopInAnchorAlignment.
    @type {String}*/
    this.anchorAlignX = EVUI.Modules.PopIns.PopInAnchorAlignment.Elastic;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings.anchors, { sourcePath: "anchorAlignX", targetPath: "alignX" });

    /**The alignment to give the Y axis when it is not anchored explicitly to a top or bottom element. Must be a value from EVUI.Modules.Pane.PopInAnchorAlignment.
    @type {String}*/
    this.anchorAlignY = EVUI.Modules.PopIns.PopInAnchorAlignment.Elastic;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings.anchors, { sourcePath: "anchorAlignY", targetPath: "alignY" });

    /**Object. Contains the details of the CSS transition to use to show the PopIn (if a transition is desired). If omitted, the PopIn is positioned then shown by manipulating the display property directly.
    @type {EVUI.Modules.PopIns.PopInTransition}*/
    this.showTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings.anchors, { sourcePath: "showTransition", targetPath: "showTransition" })

    /**Object. Contains the details of the CSS transition to use to hide the PopIn (if a transition is desired). If omitted, the PopIn is positioned then shown by manipulating the display property directly.
    @type {EVUI.Modules.PopIns.PopInTransition}*/
    this.hideTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "hideTransition", targetPath: "hideTransition" })

    /**Object. An Element (or CSS selector of an Element) or an ElementBounds object describing the bounds to which the PopIn will attempt to fit inside. If omitted, the PopIn's current view port is used.
    @type {Element|EVUI.Modules.Dom.ElementBounds|String}*/
    this.clipBounds = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "clipBounds", targetPath: "clipSettings.clipBounds" })

    this.clipMode = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "clipMode", targetPath: "clipSettings.clipMode" });

    /**Boolean. Whether or not to include the height and width when positioning the element (when it is not clipped).
    @type {Boolean}*/
    this.setExplicitDimensions = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _showSettings, { sourcePath: "setExplicitDimensions", targetPath: "setExplicitDimensions" })
};

/**Event arguments for the events exposed when hiding, showing, loading, or unloading a PopIn.
@class*/
EVUI.Modules.PopIns.PopInEventArgs = function (argsPackage, currentArgs)
{
    if (argsPackage == null || currentArgs == null) throw Error("Invalid arguments.")

    /**Object. The metadata about the state of the PopIn.
    @type {EVUI.Modules.Panes.PaneArgsPackage}*/
    var _argsPackage = argsPackage;

    /**The current event args for the operation.
    @type {Any}*/
    var _currentArgs = currentArgs;

    /**The PopIn that is having an action performed on it.
    @type {EVUI.Modules.Panes.PopIn}*/
    this.popIn = null;
    Object.defineProperty(this, "popIn",
        {
            get: function () { return _argsPackage.wrapper; },
            configurable: false,
            enumerable: true
        });

    /**String. The unique key current step in the EventStream.
    @type {String}*/
    this.key = null;

    /**Function. Pauses the EventStream, preventing the next step from executing until resume is called.*/
    this.pause = function () { };

    /**Function. Resumes the EventStream, allowing it to continue to the next step.*/
    this.resume = function () { };

    /**Function. Cancels the EventStream and aborts the execution of the PopIn operation.*/
    this.cancel = function () { }

    /**Function. Stops the EventStream from calling any other event handlers with the same key.*/
    this.stopPropagation = function () { };

    /**Object. The position of the PopIn that has been calculated in using the currentShowSettings.
    @type {EVUI.Modules.Panes.PanePosition}*/
    this.calculatedPosition = null;
    Object.defineProperty(this, "calculatedPosition",
        {
            get: function () { return _argsPackage.lastCalculatedPosition; },
            configurable: false,
            enumerable: true
        });

    /**Object. The PaneHide/Show/Load/Unload Arguments being used for the operation.
    @type {EVUI.Modules.PopIns.PopInShowArgs|EVUI.Modules.PopIns.PopInHideArgs|EVUI.Modules.PopIns.PopInLoadArgs|EVUI.Modules.PopIns.PopInUnloadArgs}*/
    this.currentActionArgs = null;
    Object.defineProperty(this, "currentActionArgs", {
        get: function () { return _currentArgs },
        configurable: false,
        enumerable: true
    });

    /**Object. Any state value to carry between events.
    @type {Object}*/
    this.context = {};
};

/**Arguments for loading a PopIn.
 @class*/
EVUI.Modules.PopIns.PopInLoadArgs = function (windowLoadArgs)
{
    /**The internal PaneLoadArgs being manipulated.
    @type {EVUI.Modules.Panes.PaneLoadArgs}*/
    var _loadArgs = (windowLoadArgs == null || typeof windowLoadArgs !== "object") ? new EVUI.Modules.Panes.PaneLoadArgs() : windowLoadArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _loadArgs, [{ sourcePath: "type", targetPath: "type" }]);

    /**Any. Any contextual information to pass into the PopIn load logic.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _loadArgs, [{ sourcePath: "context", targetPath: "context" }]);

    /**Object. The PaneLoadSettings to use if the PopIn has not already been loaded.
    @type {EVUI.Modules.PopIns.PopInLoadSettings}*/
    this.loadSettings = null;

    /**Boolean. Whether or not to re-load the PopIn.
    @type {Boolean}*/
    this.reload = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _loadArgs, [{ sourcePath: "reload", targetPath: "reload" }]);
};

/**Arguments for showing a PopIn.
@class*/
EVUI.Modules.PopIns.PopInShowArgs = function (windowShowArgs)
{
    /**The internal settings being set by the wrapper object.
    @type {EVUI.Modules.Panes.PaneShowArgs}*/
    var _windowShowArgs = (windowShowArgs == null || typeof windowShowArgs !== "object") ? new EVUI.Modules.Panes.PaneShowArgs() : windowShowArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowShowArgs, { sourcePath: "type", targetPath: "type", settings: { set: false } });

    /**Any. Any contextual information to pass into the PopIn show logic.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowShowArgs, { sourcePath: "context", targetPath: "context" });

    /**Object. The show settings for the PopIn.
    @type {EVUI.Modules.PopIns.PopInShowSettings}*/
    this.showSettings = null;

    /**Object. The load arguments for loading the PopIn if it has not already been loaded.
    @type {EVUI.Modules.PopIns.PopInLoadArgs}*/
    this.loadArgs = null;

    /**Whether or not to re-initialize the PopIn upon showing it.
    @type {Boolean}*/
    this.reInitialize = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowShowArgs, { sourcePath: "reInitialize", targetPath: "reInitialize" });
};

/**Arguments for hiding a PopIn.
@class*/
EVUI.Modules.PopIns.PopInHideArgs = function (windowHideArgs)
{
    /**The internal settings being set by the wrapper object.
    @type {EVUI.Modules.Panes.PaneHideArgs}*/
    var _windowHideArgs = (windowHideArgs == null || typeof windowHideArgs !== "object") ? new EVUI.Modules.Panes.PaneHideArgs() : windowHideArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowHideArgs, { sourcePath: "type", targetPath: "type", settings: { set: false } });

    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowHideArgs, { sourcePath: "context", targetPath: "context" });

    /** */
    this.popInHideTransition = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowHideArgs, { sourcePath: "popInHideTransition", targetPath: "windowHideTransition" });

    this.unloadArgs = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowHideArgs, { sourcePath: "unloadArgs", targetPath: "unloadArgs" });
};

/**Arguments for unloading a PopIn.
@class*/
EVUI.Modules.PopIns.PopInUnloadArgs = function (windowUnloadArgs)
{
    /**The internal settings being set by the wrapper object.
    @type {EVUI.Modules.Panes.PaneUnloadArgs}*/
    var _windowUnloadArgs = (windowUnloadArgs == null || typeof windowUnloadArgs !== "object") ? new EVUI.Modules.Panes.PaneUnloadArgs() : windowUnloadArgs;

    /**String. The type of arguments contained within the object.
    @type {String}*/
    this.type = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowUnloadArgs, { sourcePath: "type", targetPath: "type", settings: { set: false } });

    /**Any. Any contextual information to pass into the PopIn hide logic.
    @type {Any}*/
    this.context = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowUnloadArgs, { sourcePath: "context", targetPath: "context" });

    /**Boolean. Whether or not to remove the PopIn from the DOM once it has been unloaded.
    @type {Boolean}*/
    this.remove = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowUnloadArgs, { sourcePath: "remove", targetPath: "remove" });
};

/**Represents a transition effect that can be applied to a PopIn when its position or size changes.
@class*/
EVUI.Modules.PopIns.PopInTransition = function ()
{
    /**Object or String. Either class names, a string of CSS rules (without a selector), or an object of key-value pairs of CSS properties to generate a runtime CSS class for.
    @type {Object|String}*/
    this.css = null;

    /**String. CSS definition for a keyframe animation to apply. Note that the keyframe animation's name must appear in the PaneTransition.css property in order to be applied.
    @type {String|Object}*/
    this.keyframes = null;

    /**The duration (in milliseconds) of the transition so that the OnShown/OnHidden events are only fired once the transition is complete.
    @type {Number}*/
    this.duration = 0;
};

/**Settings and options for loading a PopIn.
@class */
EVUI.Modules.PopIns.PopInLoadSettings = function (windowLoadSettings)
{
    var _windowLoadSettings = (windowLoadSettings == null || typeof windowLoadSettings !== "object") ? new EVUI.Modules.Panes.PaneLoadSettings() : windowLoadSettings;

    /**Object. The Element to show as the PopIn.
    @type {Element}*/
    this.element = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowLoadSettings, { sourcePath: "element", targetPath: "element" });

    /**String. A CSS selector that is used to go find the Element to show as the PopIn. Only the first result is used.
    @type {String}*/
    this.selector = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowLoadSettings, { sourcePath: "selector", targetPath: "selector" });

    /**Object. If using a CSS selector to find the root element of a PopIn, this is the context limiting element to search inside of.
    @type {Element}*/
    this.contextElement = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowLoadSettings, { sourcePath: "contextElement", targetPath: "contextElement" });

    /**Object. HttpRequestArgs for making a Http request to go get the PopIn's HTML.
    @type {EVUI.Modules.Http.HttpRequestArgs}*/
    this.httpLoadArgs = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowLoadSettings, { sourcePath: "httpLoadArgs", targetPath: "httpLoadArgs" });

    /**Object. PlaceholderLoadArgs for making a series of Http requests to load the PopIn as an existing placeholder.
    @type {EVUI.Modules.HtmlLoader.HtmlPlaceholderLoadArgs}*/
    this.placeholderLoadArgs = null;
    EVUI.Modules.Core.Utils.wrapProperties(this, _windowLoadSettings, { sourcePath: "placeholderLoadArgs", targetPath: "placeholderLoadArgs" });
};


/**Object for containing information about how the Pane can be resized in response to user action.
@class*/
EVUI.Modules.PopIns.PopInResizeMoveSettings = function (resizeMoveSettings)
{
    var _resizeMoveSettings = (resizeMoveSettings == null || typeof resizeMoveSettings !== "object") ? new EVUI.Modules.Panes.PaneResizeMoveSettings() : resizeMoveSettings;

    /**Boolean. Whether or not the top portion of the Y axis can be resized. True by default.
    @type {Boolean}*/
    this.canResizeTop = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _resizeMoveSettings, { sourcePath: "canResizeTop", targetPath: "canResizeTop" });

    /**Boolean. Whether or not the bottom portion of the Y axis can be resized. True by default.
    @type {Boolean}*/
    this.canResizeBottom = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _resizeMoveSettings, { sourcePath: "canResizeBottom", targetPath: "canResizeBottom" });

    /**Boolean. Whether or not the left portion of the X axis can be resized. True by default.
    @type {Boolean}*/
    this.canResizeLeft = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _resizeMoveSettings, { sourcePath: "canResizeLeft", targetPath: "canResizeLeft" });

    /**Boolean. Whether or not the right portion of the X axis can be resized. True by default.
    @type {Boolean}*/
    this.canResizeRight = false;
    EVUI.Modules.Core.Utils.wrapProperties(this, _resizeMoveSettings, { sourcePath: "canResizeRight", targetPath: "canResizeRight" });

    /**Number. The width in pixels of the margin around the edges of the Pane's root element that will be the clickable zone for triggering a resize operation (in pixels). 15 by default.
    @type {Numner}*/
    this.dragHanldeMargin = 15;
    EVUI.Modules.Core.Utils.wrapProperties(this, _resizeMoveSettings, { sourcePath: "dragHanldeMargin", targetPath: "dragHanldeMargin" });

    /**Boolean. Whether or not the dimensions of any resized elements in a Pane will be restored to their original size when the Pane is hidden. True by default.
    @type {Boolean}*/
    this.restoreDefaultOnHide = true;
    EVUI.Modules.Core.Utils.wrapProperties(this, _resizeMoveSettings, { sourcePath: "restoreDefaultOnHide", targetPath: "restoreDefaultOnHide" });
};


/**Controls the alignment along the X or Y axis when it would otherwise be ambiguous when only anchored to elements on the opposite axis.
@enum*/
EVUI.Modules.PopIns.PopInAnchorAlignment =
{
    /**The axis will not be aligned and will keep its current value.*/
    None: "none",
    /**The anchored element will stretch along the axis to either fit between two opposite anchors or along the same axis of the element it is anchored to (if only one element on the axis is an anchor point).*/
    Elastic: "elastic",
    /**The anchored element will be on the left most edge of top and bottom anchors (whichever is furthest to the left).*/
    Left: "left",
    /**The anchored element will be on the right most edge of top and bottom anchors (whichever is furthest to the right).*/
    Right: "right",
    /**The anchored element will be in the center of an anchored side, or in the "best fit" center of two non-congruent opposite sides.*/
    Center: "center",
    /**The anchored element will be on the top most edge of the left and right anchors (whichever is higher).*/
    Top: "top",
    /**The anchored element will be on the bottom most edge of the left and right anchors (whichever is lower).*/
    Bottom: "bottom"
};
Object.freeze(EVUI.Modules.PopIns.PopInAnchorAlignment);

/**Enum for indicating what type of arguments object the PopInEventArgs.currentArguments property is.
@enum*/
EVUI.Modules.PopIns.PopInArgumentType =
{
    /**Arguments are PopInShowArgs.*/
    Show: "show",
    /**Arguments are PopInHideArgs.*/
    Hide: "hide",
    /**Arguments are PopInLoadArgs.*/
    Load: "load",
    /**Arguments are PopInUnloadArgs.*/
    Unload: "unload",
    /**Arguments are PopInMoveResizeArgs.*/
    MoveResize: "moveResize"
};
Object.freeze(EVUI.Modules.PopIns.PopInArgumentType);

/**Enum for indicating the behavior of the PopIn when it overflows its clipBounds.
@enum*/
EVUI.Modules.PopIns.PopInClipMode =
{
    /**When the calculated position of the PopIn overflows the clipBounds, it will not be cropped to stay within the clipBounds and will overflow to the outside of the clip bounds.*/
    Overflow: "overflow",
    /**When the calculated position of the PopIn overflows the clipBounds, it will be clipped to the maximum dimensions of the clipBounds on the overflowing axes.*/
    Clip: "clip",
    /**When the calculated position of the PopIn overflows the clipBounds, it will be shifted in the opposite directions as the overflow to fit within the clipBounds.*/
    Shift: "shift",
};
Object.freeze(EVUI.Modules.PopIns.PopInClipMode);

/**Object to inject the standard dependencies used by the PopInController into it via its constructor.
@class*/
EVUI.Modules.PopIns.PopInControllerServices = function ()
{
    /**Object. An instance of Http module's HttpManager object.
    @type {EVUI.Modules.Http.HttpManager}*/
    this.httpManager = null;

    /**Object. An instance of the HtmlLoaderController module's HtmlLoaderController object.
    @type {EVUI.Modules.HtmlLoader.HtmlLoaderController}*/
    this.htmlLoader = null;

    /**Object. An instance of the Styles module's StylesheetManager object.
    @type {EVUI.Modules.Styles.StyleSheetManager}*/
    this.stylesheetManager = null;

    /**Object. An instance of the Panes module's PaneManager object.
    @type {EVUI.Modules.Panes.PaneManager}*/
    this.panesManager = null;
};

/**Global instance of the PopInManager, used for creating and using simple popIns that are positioned relative to a point or another element.
@type {EVUI.Modules.PopIns.PopInManager}*/
EVUI.Modules.PopIns.Manager = null;
(function ()
{
    var ctor = EVUI.Modules.PopIns.PopInManager;
    var manager = null;

    Object.defineProperty(EVUI.Modules.PopIns, "Manager", {
        get: function ()
        {
            if (manager == null) manager = new ctor();
            return manager;
        },
        enumerable: true,
        configurable: false
    });
})();

Object.freeze(EVUI.Modules.PopIns);

delete $evui.popIns;

/**Global instance of the PopInManager, used for creating and using simple popIns that are positioned relative to a point or another element.
@type {EVUI.Modules.PopIns.PopInManager}*/
$evui.popIns = null;
Object.defineProperty($evui, "popIns", {
    get: function () { return EVUI.Modules.PopIns.Manager; },
    enumerable: true
});

/**Adds a PopIn to the WidowManager.
@param {EVUI.Modules.PopIns.PopIn} yoloPopIn A YOLO object representing a PopIn object. This object is copied onto a real PopIn object is then discarded.
@returns {EVUI.Modules.PopIns.PopIn}*/
$evui.addPopIn = function (yoloPopIn)
{
    return $evui.popIns.addPopIn(yoloPopIn);
};

/**Shows (and loads, if necessary or if a reload is requested) a PopIn asynchronously. Provides a callback that is called call once the PopIn operation has completed successfully or otherwise.
@param {EVUI.Modules.PopIns.PopIn|String} popInOrID Either a YOLO PopIn object to extend into the existing PopIn, the real PopIn reference, or the string ID of the PopIn to show.
@param {EVUI.Modules.PopIns.PopInShowArgs|EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback} popInShowArgs Optional. A YOLO object representing the arguments for showing the PopIn, or the callback. If omitted or passed as a function, the PopIn's existing show/load settings are used instead.
@param {EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback} callback Optional. A callback that is called once the operation completes.*/
$evui.showPopIn = function (popInOrID, popInShowArgs, callback)
{
    return $evui.popIns.showPopIn(popInOrID, popInShowArgs, callback);
};

/**Awaitable. (and loads, if necessary or if a reload is requested) a PopIn asynchronously.
@param {EVUI.Modules.PopIns.PopIn|String} popInOrID Either a YOLO PopIn object to extend into the existing PopIn, the real PopIn reference, or the string ID of the PopIn to show.
@param {EVUI.Modules.PopIns.PopInShowArgs} popInShowArgs Optional.  A YOLO object representing the arguments for showing the PopIn. If omitted, the PopIn's existing show/load settings are used instead.
@returns {Promise<Boolean>}*/
$evui.showPopInAsync = function (popInOrID, popInShowArgs)
{
    return $evui.popIns.showPopInAsync(popInOrID, popInShowArgs);
};

/**Hides (and unloads if requested) a PopIn asynchronously. Provides a callback that is called call once the PopIn operation has completed successfully or otherwise.
@param {EVUI.Modules.PopIns.PopIn|String} popInOrID Either a YOLO PopIn object to extend into the existing PopIn, the real PopIn reference, or the string ID of the PopIn to hide.
@param {EVUI.Modules.PopIns.PopInHideArgs|EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback} popInHideArgs Optional.  A YOLO object representing the arguments for hiding a PopIn or the callback. If omitted or passed as a function, the PopIn's existing hide/unload settings are used instead.
@param {EVUI.Modules.PopIns.Constants.Fn_PopInOperationCallback} callback Optional. A callback that is called once the operation completes.*/
$evui.hidePopIn = function (popInOrID, popInHideArgs, callback)
{
    return $evui.popIns.hidePopIn(popInOrID, popInHideArgs, callback);
};

/**Awaitable. Hides (and unloads if requested) a PopIn asynchronously. Provides a callback that is called call once the PopIn operation has completed successfully or otherwise.
@param {EVUI.Modules.PopIns.PopIn|String} popInOrID Either a YOLO PopIn object to extend into the existing PopIn, the real PopIn reference, or the string ID of the PopIn to hide.
@param {EVUI.Modules.PopIns.PopInHideArgs} popInHideArgs Optional.  A YOLO object representing the arguments for hiding a PopIn. If omitted, the PopIn's existing hide/unload settings are used instead.
@returns {Promise<Boolean>}*/
$evui.hidePopInAsync = function (popInOrID, popInHideArgs)
{
    return $evui.popIns.hidePopInAsync(popInOrID, popInHideArgs);
};

/*#ENDWRAP(PopIn)#*/


/********************************************************Styles.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.Styles|Styles)#*/
/*#REPLACE(EVUI.Modules.Styles|Styles)#*/

/**Module for building and manipulating stylesheets at runtime without resorting to injecting a string of CSS into a style tag.
@module*/
EVUI.Modules.Styles = {};

/*#MODULEDEF(Styles|"1.0";|"Styles")#*/
/*#VERSIONCHECK(EVUI.Modules.Styles|Styles)#*/

EVUI.Modules.Styles.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true })
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.Styles.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();

Object.freeze(EVUI.Modules.Styles.Dependencies);

EVUI.Modules.Styles.Constants = {};
EVUI.Modules.Styles.Constants.DefaultStyleSheetName = "evui-style-default";

/**Utility for programmatically manipulating stylesheets.
@class*/
EVUI.Modules.Styles.StyleSheetManager = function ()
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Styles.Dependencies);

    //instance of the style parser used to parse raw CSS into a JSON object that can more easily be digested.
    var _parser = new EVUI.Modules.Styles.StyleParser();

    //keywords defining sets of rules that need to stay aggregated together in order to be applied properly
    var _aggregationSets = ["@keyframes"];

    /**Internal list of StylesheetEntry objects representing programmatically added stylesheets.
    @type {StylesheetEntry[]}*/
    var _stylesheets = [];

    /**Creates and/or adds a stylesheet to the internal list of managed stylesheets and adds it and the provided rules to the DOM..
    @param {String} sheetName The name used to identify the stylesheet.
    @param {EVUI.Modules.Styles.StyleSheetRule[]|EVUI.Modules.Styles.StyleSheetRule|String|CSSStyleSheet} rules Either an array of YOLO StyleSheetRules, or a single YOLO StyleSheetRule, any string of valid CSS, or a pre-existing CSSStyleSheet object.
    @returns {Boolean}*/
    this.addStyleSheet = function (sheetName, rules)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(sheetName) === true) throw new Error("Sheet name cannot be null or whitespace.");

        var existing = getStylesheetEntry(sheetName);
        if (existing === true) throw Error("A stylesheet with the name \"" + sheetName + " already exists.");

        var isExistingSheet = rules instanceof CSSStyleSheet;

        var flatRules = processRules(rules, true);

        var styleSheet = null;
        if (isExistingSheet === false)
        {
            styleSheet = makeStyleSheetElement().sheet;
        }
        else
        {
            styleSheet = rules;

        }

        var entry = new StyleSheetEntry();
        entry.lock = (rules.lock === true) ? true : false;
        entry.name = sheetName;
        entry.styleSheet = styleSheet;

        _stylesheets.push(entry);

        if (isExistingSheet === false)
        {
            if (flatRules == null) return true;
            applyRulesList(entry, flatRules.slice());
        }
        else
        {
            entry.rules = flatRules;
            ensureSheetInDom(entry);
        }  

        return translateRuleEntries(entry.rules);
    };

    /**Removes a style sheet (and all of its rules) from the page.
    @param {String} sheetName The name of the sheet to remove.
    @returns {Boolean}*/
    this.removeStyleSheet = function (sheetName)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(sheetName) === true) throw new Error("Sheet name cannot be null or whitespace.");

        var existing = getStylesheetEntry(sheetName);
        if (existing == null || existing.lock === true) return false;        

        var index = _stylesheets.indexOf(existing);
        if (index !== -1) _stylesheets.splice(index, 1);

        if (existing.styleSheet.ownerNode != null) existing.styleSheet.ownerNode.remove();
        return true;
    };

    /**Sets or adds CSS rules. To remove a rule from a selector, set its value to a string of "null", i.e. " h1{display: null}" to remove the display property from a style applying to h1.
    Note that selectors for rules nested in at-rules are accessed by their "flat" path name, i.e. the style block inside of @page { @media (condition) { h1 { display: none; }}} would be accessed via "@page @media (condition) h1".
    @param {String} sheetName The name of the sheet to change the CSS rules of. If the sheet with the name does not already exist, one is created.
    @param {EVUI.Modules.Styles.StyleSheetRule[]|EVUI.Modules.Styles.StyleSheetRule|String|String[]|CSSStyleSheet} selectorOrRules Either a "flat" CSS selector or an array of "flat" CSS selectors, an array of YOLO StyleSheetRules, or a single YOLO StyleSheetRule, any string of valid CSS, or a pre-existing CSSStyleSheet object.
    @param {String|Object} rules If the previous parameter was a selector, these are the rules to apply to the selector, either as a CSS string of rules applied to a single selector or an object with camel-cased property names that correspond to CSS property names.
    @returns {EVUI.Modules.Styles.StyleSheetRule[]}*/
    this.setRules = function (sheetName, selectorOrRules, rules)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(sheetName) === true) throw new Error("Sheet name cannot be null or whitespace.");
        var ambiguousRules = null;

        if (typeof rules === "string" || (rules != null && typeof rules === "object"))
        {
            if (typeof selectorOrRules !== "string" && EVUI.Modules.Core.Utils.isArray(selectorOrRules) === false) throw Error("Invalid input. Selector missing for provided rules string or an array of strings.");

            ambiguousRules = new EVUI.Modules.Styles.StyleSheetRule();
            ambiguousRules.selector = selectorOrRules;
            ambiguousRules.rules = rules; //this can either be an object or a string, the code below can handle either case
        }
        else
        {
            ambiguousRules = selectorOrRules;
        }

        var existing = getStylesheetEntry(sheetName);
        if (existing == null)
        {
            this.addStyleSheet(sheetName, ambiguousRules);
            return;
        }

        //figure out what to do with the ambiguous rules and turn them into a flat list of selector and rule objects representing all our new or changed rules
        var newRules = processRules(ambiguousRules);
        var numNewRules = newRules.length;
        var rulesToAdd = [];
        var addedRules = [];

        for (var x = 0; x < numNewRules; x++)
        {
            var curNewRule = newRules[x];

            var curExisting = getExistingRule(existing, curNewRule.selector);
            if (curExisting != null) //the rule is an existing rule, we go update the existing rule in the CSS
            {
                //merge the new rules onto the old rules
                var merged = {};
                var flat = null;
                if (curExisting.selectors.filter(function (selector) { return isAggregatedNonCascadingSet(selector) }).length > 0) //if we have an aggregated rule that does not cascade, don't merge and flatten it
                {
                    merged = curNewRule.rules;
                    flat = [curNewRule];
                }
                else //otherwise, flatten and merge it
                {
                    merged[curExisting.selector] = merge(curNewRule.rules, curExisting.rules);
                    flat = makeFlatRulesList(merged);
                }

                var index = getCssRuleIndex(existing, curExisting); //see if we still have the rule on the css object
                if (index === -1)
                {
                    rulesToAdd.push(curNewRule); //we do not, add it
                }
                else //we do, go remove the old rule and re-add the new rule.
                {
                    var updated = updateRules(flat, index, existing, curExisting);
                    if (updated != null) addedRules = addedRules.concat(updated);
                }
            }
            else //not an existing rule, add it
            {
                rulesToAdd.push(curNewRule);
            }
        }

        //add all the new rules and we are done
        var added = applyRulesList(existing, rulesToAdd);
        return translateRuleEntries(addedRules.concat(added));
    };

    /**Removes all CSS rules from the sheet with the given name that match the provided selectors.
    Note that selectors for rules nested in at-rules are accessed by their "flat" path name, i.e. the style block inside of @page { @media (condition) { h1 { display: none; }}} would be accessed via "@page @media (condition) h1".
    @param {String} sheetName The name given to the StyleSheetManager of the sheet to remove the rules from.
    @param {String|String[]} selector The "flat" selector or array of selectors of the rules to remove.
    @returns {EVUI.Modules.Styles.StyleSheetRule[]} */
    this.removeRules = function (sheetName, selector)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(sheetName) === true) throw new Error("Sheet name cannot be null or whitespace.");
        var existingSheet = getStylesheetEntry(sheetName);        

        if (existingSheet == null) return false;

        var selectors = getSelectors(selector);
        var numSelectors = selectors.length;
        var removed = [];

        for (var x = 0; x < numSelectors; x++)
        {
            var curSelector = selectors[x];
            var existing = getExistingRule(existingSheet, curSelector);
            if (existing != null)
            {
                var index = getCssRuleIndex(existingSheet, existing);
                if (index !== -1)
                {
                    existingSheet.styleSheet.deleteRule(index);

                    var ruleIndex = existingSheet.rules.indexOf(existing);
                    if (ruleIndex !== -1) existingSheet.rules.splice(ruleIndex, 1);

                    removed.push(existing);
                }
            }
        }

        return translateRuleEntries(removed);
    };

    /**Gets all the rules from a managed style sheet entry, or gets all the rules from a managed style sheet entry with the given selector(s).
    Note that selectors for rules nested in at-rules are accessed by their "flat" path name, i.e. the style block inside of @page { @media (condition) { h1 { display: none; }}} would be accessed via "@page @media (condition) h1".
    @param {String} sheetName The name given to the StyleSheetManager of the sheet to get the rules from.
    @param {String|String[]} selector The "flat" selector or array of selectors of the rules to get.
    @returns {EVUI.Modules.Styles.StyleSheetRule[]} */
    this.getRules = function (sheetName, selector)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(sheetName) === true) throw new Error("Sheet name cannot be null or whitespace.");

        var existingSheet = getStylesheetEntry(sheetName);
        if (existingSheet == null) return null;

        if (typeof selector === "string" || EVUI.Modules.Core.Utils.isArray(selector))
        {
            var selectors = getSelectors(selector);
            var numSelectors = selectors.length;

            var matches = [];
            for (var x = 0; x < numSelectors; x++)
            {
                var curSelector = selectors[x];

                var existing = getExistingRule(existingSheet, curSelector);
                if (existing != null)
                {
                    matches.push(existing);
                }
            }

            return translateRuleEntries(matches);
        }
        else
        {
            return translateRuleEntries(existingSheet.rules);
        }

        return rules;
    };

    /**Ensures that a style sheet being managed will be active in the DOM with all of its rules intact. If the sheet has been removed from the DOM, it is cloned from its latest state and re-inserted.
    @param {String} sheetName The name of the style sheet given to the StyleSheetManager of the sheet to restore.
    @param {EVUI.Modules.Styles.StyleSheetRule[]|EVUI.Modules.Styles.StyleSheetRule|String|String[]|CSSStyleSheet} existingSheet If the sheet does not exist, these are the rules to use when creating the sheet. The rules can be a YOLO StyleSheetRule, an array of YOLO StyleSheetRules, a string of CSS or an array of strings of CSS, or a pre-existing CSS style sheet.
    @returns {EVUI.Modules.Styles.StyleSheetRule[]}*/
    this.ensureSheet = function (sheetName, existingSheet)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(sheetName) === true) throw new Error("Sheet name cannot be null or whitespace.");

        var sheetEntry = getStylesheetEntry(sheetName);
        if (sheetEntry == null)
        {
            return this.addStyleSheet(sheetName, existingSheet);
        }

        ensureSheetInDom(sheetEntry);

        return this.getRules(sheetName);
    };

    /**Syncs the contents of the DOM with the in-memory set of rules in the StyleSheetManager or vice-versa.
    @param {String} sheetName The name of the style sheet given to the StyleSheetManager of the sheet to sync.
    @param {String} syncMode The value from the SyncMode enum indicating which way to sync. Can either sync the DOM onto the in-memory copy, or reset the DOM to match the in-memory copy (default).
    @returns {EVUI.Modules.Styles.StyleSheetRule[]}*/
    this.sync = function (sheetName, syncMode)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(sheetName) === true) throw new Error("Sheet name cannot be null or whitespace.");

        if (typeof syncMode !== "string") return false;

        var existingSheet = getStylesheetEntry(sheetName);
        if (existingSheet == null) return false;

        if (syncMode === EVUI.Modules.Styles.SyncMode.FromSheet)
        {
            if (existingSheet.lock === true) throw Error("Cannot sync the contents of a locked sheet with those of the DOM.");

            existingSheet.rules = processExistingSheet(existingSheet);
            return translateRuleEntries(existingSheet.rules);
        }
        else
        {
            while (existingSheet.styleSheet.cssRules.length > 0)
            {
                existingSheet.styleSheet.deleteRule(0);
            }

            var rules = existingSheet.rules;

            existingSheet.rules = [];
            var rules = applyRulesList(existingSheet, rules);
            return translateRuleEntries(rules);
        }
    };

    /**Translates an array of RuleEntry into an array of StyleSheetRules.
    @param {RuleEntry[]} ruleEntries An array of RuleEntry to translate.
    @returns {EVUI.Modules.Styles.StyleSheetRule[]} */
    var translateRuleEntries = function (ruleEntries)
    {
        if (ruleEntries == null) return null;

        var rules = [];

        var numEntries = ruleEntries.length;
        for (var x = 0; x < numEntries; x++)
        {
            var curEntry = ruleEntries[x];

            var rule = new EVUI.Modules.Styles.StyleSheetRule();
            rule.selector = curEntry.selector;
            rule.rules = deepClone(curEntry.rules); //make a copy of the internal object so that when we expose it no one can mess with it and cause problems down the line with things getting out of sync

            rules.push(rule);
        }

        return rules;
    };

    /**Takes a string or an array of string based selectors and turns them into an array of singleton flat selectors.
    @param {String|String[]} compositeSelector Any "flat" css selector or an array of "flat" css selectors.
    @returns {String[]} */
    var getSelectors = function (compositeSelector)
    {
        var selectorArray = [];

        if (typeof compositeSelector !== "string") //our selector is not a string, see if it's an array (the only other valid option)
        {
            if (EVUI.Modules.Core.Utils.isArray(compositeSelector) === true) //we have an array. Break each one down and build a composite list of all of them.
            {
                var numSelectors = compositeSelector.length;

                for (var x = 0; x < numSelectors; x++)
                {
                    var selectors = getSelectors(compositeSelector[x]);
                    if (selectors != null) selectorArray = selectorArray.concat(selectors);
                }

                return selectorArray;
            }
        }
        else
        {
            var firstCommaIndex = getFirstComma(compositeSelector); //because CSS selectors can be "multiple selectors" that are comma separated, we sniff out the first un-escaped comma and use that to determine if we need to break the selector down into multiple selectors.
            if (firstCommaIndex === -1)
            {
                selectorArray.push(compositeSelector); //no comma, no extra work to do.
            }
            else //we have an unescaped comma, time to do some gymnastics to get an array of our special "flat" selectors. The general formula is that everything before the comma separated selector list is a prefix (i.e. @page, @media (condition), etc) that needs to be prepended to each selector thats separated by a comma. 
            {
                var selectorPrefix = "";
                var commaSeparatedSelectors = null;

                compositeSelector = _parser.getNormalizedSelctor(compositeSelector); //first, run the normalization algorithm over the selector to get it into the normalized format so we can make assumptions about its structure that will always be true.

                var whitespaceRegex = new RegExp(/\s/);
                var specialCharacterRegex = new RegExp(/[\>\\~\+]|\|{2}/g);

                compositeSelector = compositeSelector.replace(/\s[\>\\~\+\.]\s|\s\|{2}\s/g, function (match) { return match.trim(); }); //"mash" all the comma separated selectors, their combinators, and everything else we would normally separate with a space into a single space-less string segment
                firstCommaIndex = getFirstComma(compositeSelector); //since we have now changed the length of the string, we need to find that comma index again

                for (var x = firstCommaIndex; x > 0; x--) //now it gets odd - walking BACKWARDS from the first comma, keep walking until we encounter the first whitespace character. That will be the end of our prefix.
                {
                    if (whitespaceRegex.test(compositeSelector[x]) === true)
                    {                        
                        if (x > 0 && specialCharacterRegex.test(compositeSelector[x - 1]) === true) //not whitespace. Is the character that comes before it another combinator? The regex should have caught this, but you never know.
                        {
                            if (x > 1 && compositeSelector[x - 2] === "\\") x--; //is it an ESCAPED combinator? if so, step backwards another character
                            continue; //keep going, we haven't found our valid non-whitespace yet.
                        }

                        //we found the end of the prefix. Chop the string in two and we're done walking the string.
                        selectorPrefix = compositeSelector.substring(0, x);
                        commaSeparatedSelectors = compositeSelector.substr(x);
                        break;
                    }
                }

                //never found a non-whitespace character, so we have no prefix.
                if (commaSeparatedSelectors == null) commaSeparatedSelectors = compositeSelector;
                
                selectorArray = commaSeparatedSelectors.split(",");

                //walk each separated selector and prepend the prefix, then normalize it back into the standard format.
                var numSelectors = selectorArray.length;
                for (var x = 0; x < numSelectors; x++)
                {
                    selectorArray[x] = _parser.getNormalizedSelctor(selectorPrefix + selectorArray[x]);
                }
            }
        }

        return selectorArray;
    }

    /**Gets the index of the first non-escaped comma in the string.
    @param {String} compositeSelector The selector we are looking for a comma in.
    @returns {Number} */
    var getFirstComma = function (compositeSelector)
    {
        var firstCommaIndex = compositeSelector.indexOf(",");
        var isEscaped = (firstCommaIndex > 0 && compositeSelector[firstCommaIndex - 1] === "\\");
        while (isEscaped === true)
        {
            firstCommaIndex = compositeSelector.indexOf(",", firstCommaIndex + 1);
            if (firstCommaIndex === -1) break;

            isEscaped = (firstCommaIndex > 0 && compositeSelector[firstCommaIndex - 1] === "\\");
        }

        return firstCommaIndex;
    };

    /**Updates a rule in a style sheet by deleting the old rule and inserting a new one (or multiple new ones) in its place at the same index.
    @param {RuleEntry[]} flatRules The flattened list of rules to replace the existing rule with.
    @param {Number} index The index of the rule in the style sheet to remove.
    @param {StyleSheetEntry} sheetEntry The existing sheet reference we will be drawing rules from.
    @returns {RuleEntry[]} */
    var updateRules = function (flatRules, index, sheetEntry, existing)
    {
        if (flatRules == null || flatRules.length === 0) return [];

        var updatedRules = [];
        var deleted = false;
        var rulesUpdated = 0;

        var numFlat = flatRules.length;
        for (var x = 0; x < numFlat; x++)
        {
            var curRule = flatRules[x];

            var ruleText = makeRuleStringFromRuleEntry(curRule);
            var existingRule = (existing != null) ? existing : getExistingRule(sheetEntry, curRule.selector);
            var updated = false;

            if (existingRule == null || (existingRule.cssRuleText !== ruleText || existingRule.cssRule == null || existingRule.cssRule.parentStyleSheet == null))
            {
                try
                {
                    if (deleted === false)
                    {
                        sheetEntry.styleSheet.deleteRule(index); //remove the original rule
                        deleted = true;
                    }

                    var newIndex = sheetEntry.styleSheet.insertRule(ruleText, index + rulesUpdated);
                    updated = true;
                    rulesUpdated++;
                }
                catch (ex)
                {
                    EVUI.Modules.Core.Utils.log("Failed to update rule \"" + ruleText + "\" : " + ex.message);
                    continue;
                }
            }

            if (existingRule == null) //no existing rule, add the new rule to the entry and the return list
            {
                curRule.cssRule = sheetEntry.styleSheet.cssRules[newIndex];
                sheetEntry.rules.push(curRule);
                updatedRules.push(curRule);
            }
            else //we had an existing rule, update it and use it instead of replacing it with a new reference and add it to the return list
            {
                if (updated === true)
                {
                    existingRule.cssRule = sheetEntry.styleSheet.cssRules[newIndex];
                    existingRule.selectors = curRule.selectors;
                    existingRule.selectorsSplit = curRule.selectorsSplit;
                    existingRule.rules = curRule.rules;
                    existingRule.cssRuleText = ruleText;

                    updatedRules.push(existingRule)
                }
            }
        }

        return updatedRules;
    };

    /**Gets an existing rule from the sheet entry's list of existing rules based on its normalized selector.
    @param {StyleSheetEntry} sheetEntry The sheet to look for the pre-existing rule in.
    @param {String} selector A single, flat, normalized selector to match up with the other normalized selectors.
    @returns {RuleEntry} */
    var getExistingRule = function (sheetEntry, selector)
    {
        if (sheetEntry == null || EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(selector) === true) return null;

        var numRules = sheetEntry.rules.length;
        for (var x = 0; x < numRules; x++)
        {
            var curRule = sheetEntry.rules[x];
            if (curRule.selector === selector) return curRule;
        }

        return null;
    };

    /**Gets the index of an existing rule in the style sheet.
    @param {StyleSheetEntry} styleSheetEntry The sheet we are looking in.
    @param {any} ruleEntry The rule we are trying to find.
    @returns {Number} */
    var getCssRuleIndex = function (styleSheetEntry, ruleEntry)
    {
        if (styleSheetEntry == null || ruleEntry == null) return -1;

        if (ruleEntry.cssRule != null)
        {
            var numRules = styleSheetEntry.styleSheet.cssRules.length;
            for (var x = 0; x < numRules; x++)
            {
                if (styleSheetEntry.styleSheet.cssRules[x] === ruleEntry.cssRule) return x;
            }
        }

        return -1;
    };

    /**Turns an ambiguous object that could potentially contain rules into an array RuleEntries representing all the "flat" rules that could be parsed out of the input.
    @param {EVUI.Modules.Styles.StyleSheetRule[]|EVUI.Modules.Styles.StyleSheetRule|String|String[]|CSSStyleSheet} ambiguousRulesObject Any one of a bunch of different possible options that could potentially contain CSS rules to parse.
    @param {Boolean} adding Whether or not we are explicitly adding a new style sheet entry.
    @returns {RuleEntry[]} */
    var processRules = function (ambiguousRulesObject, adding)
    {
        if (ambiguousRulesObject instanceof CSSStyleSheet && adding === true) //if we're adding an existing CSS sheet, we have to do a bunch of special treatment to it to properly normalize it and make it work correctly
        {
            return processExistingSheet(ambiguousRulesObject);
        }
        else //otherwise we process the rule object like normal
        {
            var parsedRules = getRulesArray(ambiguousRulesObject); //gets an array of plain objects keyed by selectors (that are broken apart into singleton selectors) that drill down to individual CSS rules.
            var rulesObj = mergeRules(parsedRules); //merge the entire array of objects into a single object that contains all rules for all selectors and correctly overwrites values for duplicate selectors and
            var flatRules = makeFlatRulesList(rulesObj); //walk the object and make flat rules out of the nested object hierarchy that contains the "flat" selector and the set of rules associated with it.

            return flatRules;
        }
    };

    /**Processes an existing CSSStyleSheet into an array of RuleEntries representing a list of the "flat" selectors that could be derived from the CSS sheet. Resolves multiple selectors and duplicate selectors into aggregate objects so no duplicates or multi-selectors appear.
    @param {CSSStyleSheet} cssStyleSheet The style sheet to create a rule set for.
    @returns {RuleEntry[]}*/
    var processExistingSheet = function (cssStyleSheet)
    {
        var dummyEntry = new StyleSheetEntry(); //we need a StyleSheetEntry to make all the supporting functions work, but we don't have one yet when this is called, so we make a fake one to pass around as if it were real
        dummyEntry.styleSheet = cssStyleSheet;
        dummyEntry.rules = [];

        var rulesToRemove = {}; //a mapping of flat selector to an array of CSSRules that tells us what rules need to be removed and merged into a single rule.

        var x = 0
        while (x < cssStyleSheet.cssRules.length) //process all the rules in the sheet. This list will grow as we split rules and merge them into the sheet.
        {
            var rulesToApply = [];
            var curRule = cssStyleSheet.cssRules[x];
            var parsed = _parser.parse(curRule.cssText); //turn the current rule into a plain object and make a flat list of selectors out of the object
            var flat = makeFlatRulesList(parsed);

            var numFlat = flat.length;
            for (var y = 0; y < numFlat; y++) //for every flat rule, assign the corresponding CSS rule (multiple flats from the same rule will share the same CSSRule)
            {
                var curFlat = flat[y];
                curFlat.cssRule = curRule;

                var existing = getExistingRule(dummyEntry, curFlat.selector); //see if this rule hasn't already been added, if it has, don't add it and instead add it to the list of rules to merge and add as a single rule.
                if (existing != null)
                {
                    if (rulesToRemove[existing.selector] == null) rulesToRemove[existing.selector] = [existing];
                    rulesToRemove[existing.selector].push(curFlat);
                    x++; //mark that we processed the rule
                }
                else //otherwise we are going to add it to the list of rules to update in the sheet
                {
                    rulesToApply.push(curFlat);
                }
            }

            //update the sheet with the flat rules and increment the number of rules processed by the number of rules modified
            var updated = updateRules(rulesToApply, x, dummyEntry);
            x += (updated == null) ? 0 : updated.length;
        }

        //now that we have flattened the entire sheet, it can still have duplicate rules in it that mess up the update logic, so we remove them and replace them with the correct aggregate of all the rules with the same selector
        for (var selector in rulesToRemove)
        {
            var aggregateRule = {};

            var rules = rulesToRemove[selector];
            var numToRemove = rules.length;
            var firstIndex = -1;
            for (var x = 0; x < numToRemove; x++)
            {
                merge(rules[x].rules, aggregateRule) //merge the rules onto the aggregate rule to mimic CSS's rule overwriting behavior

                var removalIndex = getCssRuleIndex(dummyEntry, rules[x]); //ge the index of the rule to remove and remove it if it is still in the style sheet
                if (removalIndex !== -1)
                {
                    if (firstIndex === -1) firstIndex = removalIndex;
                    dummyEntry.styleSheet.deleteRule(removalIndex);
                }
            }

            //now, get the original existing rule that is in the managed list of rules and update its rules object to be the aggregate rule before replacing the rule in the style sheet with the new aggregate rule
            var existing = getExistingRule(dummyEntry, selector);
            if (firstIndex !== -1)
            {
                existing.rules = aggregateRule;
                var newRuleText = makeRuleStringFromRuleEntry(existing);

                try
                {
                    var index = dummyEntry.styleSheet.insertRule(newRuleText, firstIndex);
                    existing.cssRule = dummyEntry.styleSheet.cssRules[index];
                }
                catch (ex)
                {
                    EVUI.Modules.Core.Utils.log("Failed to add rule \"" + newRuleText + "\":" + ex.message);

                    var existingIndex = dummyEntry.rules.indexOf(existing);
                    if (existingIndex !== -1) dummyEntry.rules.splice(existingIndex, 1);
                }
            }
        }

        //finally done, now with a unqie flat set of rules that are in sync with the sheet and the managed rule list.
        return dummyEntry.rules;
    }

    /**Turns ambiguous input into an array of plain objects representing hierarchies of CSS properties and selectors.
    @param {String|String[]|EVUI.Modules.Styles.StyleSheetRule|EVUI.Modules.Styles.StyleSheetRule[]|CSSStyleSheet} ambiguousRuleSet Any number of a bunch of different formats.
    @returns {Object[]}*/
    var getRulesArray = function (ambiguousRuleSet)
    {
        if (ambiguousRuleSet == null) return null;

        var rules = [];
        if (typeof ambiguousRuleSet === "string") //we have a CSS string, parse it into an object
        {
           rules.push(_parser.parse(ambiguousRuleSet));
        }
        else if (typeof ambiguousRuleSet === "object") //otherwise we have an object of some sorts
        {
            if (EVUI.Modules.Core.Utils.isArray(ambiguousRuleSet) === true) //it's an array, loop over its contents and call this function again to turn whatever may be inside the array into more parsed objects.
            {
                var numRules = ambiguousRuleSet.length;
                for (var x = 0; x < numRules; x++)
                {
                    var curRule = getRulesArray(ambiguousRuleSet[x]);
                    if (curRule == null) continue;

                    rules = rules.concat(curRule);
                }
            }
            else if (ambiguousRuleSet instanceof CSSStyleSheet) //its a style sheet, turn all its rules into objects by parsing each one
            {
                var numRules = ambiguousRuleSet.cssRules.length;
                for (var x = 0; x < numRules; x++)
                {
                    rules.push(_parser.parse(ambiguousRuleSet.cssRules[x].cssText));
                }
            }
            else if ((typeof ambiguousRuleSet.selector === "string" || EVUI.Modules.Core.Utils.isArray(ambiguousRuleSet.selector) === true) && ambiguousRuleSet.rules != null) //we have a YOLO of a StyleSheetRule object.
            {
                var selectors = getSelectors(ambiguousRuleSet.selector); //break up the selector into its normalized components
                var parsedRules = null;
                var ruleObj = {};
                var numSelectors = selectors.length;
                for (var x = 0; x < numSelectors; x++)
                {
                    var selector = selectors[x];
                    
                    if (parsedRules == null && typeof ambiguousRuleSet.rules === "string") //if the rules were a string, only parse it once
                    {
                        parsedRules = _parser.parse(ambiguousRuleSet.rules);
                        ruleObj[selector] = parsedRules;
                    }
                    else if (typeof ambiguousRuleSet.rules === "object") //if the rules are an object, clone it so overwriting different rules don't bleed into each other due to sharing references.
                    {
                        if (EVUI.Modules.Core.Utils.isArray(ambiguousRuleSet.rules)) //the rules are an array of some sort. Drawing the line here, it can get a lot more complicated trying to figure out what to do from this point, so we stop here and can revist at a late date
                        {
                            throw Error("A rule object with a selector cannot have an array as its set of rules.");
                        }
                        else
                        {
                            if (ruleObj[selector] != null) //duplicate selector, merge the new rules into the clone
                            {
                                merge(deepClone(parsedRules != null ? parsedRules : ambiguousRuleSet.rules), ruleObj[selector]);
                            }
                            else //otherwise just clone the rules
                            {
                                ruleObj[selector] = deepClone(parsedRules != null ? parsedRules : ambiguousRuleSet.rules);
                            }
                        }
                    }

                    rules.push(ruleObj)
                }
            }
        }

        return rules;
    };

    /**Merges one object into another.
    @param {Object} source The object with the properties to merge onto the target.
    @param {Object} target The object to receive the properties from the source.
    @param {Object[]} parentage Array of previously processed objects to stop an infinite recursive loop.
    @returns {Object}*/
    var merge = function (source, target, parentage)
    {
        if (parentage == null) parentage = [source];

        for (var prop in source)
        {
            var sourceValue = source[prop];
            var targetValue = target[prop];

            if (sourceValue != null && typeof sourceValue === "object") //we have a child object, merge recursively
            {
                if (targetValue == null) //object doesn't exist on target, just add it
                {
                    target[prop] = sourceValue;
                }
                else if (typeof targetValue === "object") //if the target already has an object, merge the two together
                {
                    if (parentage.indexOf(sourceValue) !== -1) continue; //if the parent is in the chain of objects that are being merged, we're in an endless loop and need to not recurse anymore
                    parentage.push(sourceValue);

                    merge(sourceValue, targetValue, parentage.slice());

                    parentage = [];
                }
            }
            else //not an object, just assign it
            {
                if (typeof sourceValue !== "string") //if the source value is EXPLICITLY null, delete it from the target
                {
                    if (typeof sourceValue === "number")
                    {
                        target[prop] = sourceValue.toString();
                    }
                    else
                    {
                        if (sourceValue === null) delete target[prop];
                    }
                }
                else if (sourceValue.toLowerCase() === "null") //if the source value is EXPLICITLY the string "null" delete it from the target.
                {
                    delete target[prop];
                }
                else //otherwise just assign it
                {
                    target[prop] = sourceValue;
                }
            }          
        }

        return target;
    };

    /**A super simple deep clone function for cloning plain objects.
    @param {Object} source The object with the properties to merge onto the target.
    @param {Object} target The object to receive the properties from the source.
    @param {Object[]} parentage Array of previously processed objects to stop an infinite recursive loop.
    @returns {Object}*/
    var deepClone = function (source, target, parentage)
    {
        if (source == null) return target;
        if (target == null) target = {};
        if (parentage == null) parentage = [source];

        for (var prop in source)
        {
            var sourceValue = source[prop];
            if (sourceValue == null) continue;

            if (typeof sourceValue === "object")
            {
                if (parentage.indexOf(sourceValue) !== -1)
                {
                    target[prop] = source;
                }

                parentage.push(source);
                target[prop] = deepClone(sourceValue, EVUI.Modules.Core.Utils.isArray(sourceValue) ? [] : {}, parentage);

                parentage = [];
            }
            else
            {
                target[prop] = sourceValue;
            }
        }

        return target;
    };

    /**Merges a list of objects into each other to form a composite object of the union of all their properties.
    @param {Object[]} rulesArray All of the rule objects to merge into a single object.
    @returns {Object}*/
    var mergeRules = function (rulesArray)
    {
        var merged = {};
        var numRules = rulesArray.length;
        for (var x = 0; x < numRules; x++)
        {
            merge(rulesArray[x], merged);
        }

        return merged;
    };

    /**Takes an object of CSS rules (and nested rules) and turns it into an array of "flat" selectors.
    @param {any} rulesObj The aggregate of all the rules to merge into a flat list of objects.
    @returns {RuleEntry[]}*/
    var makeFlatRulesList = function (rulesObj)
    {
        var rules = [];

        for (var prop in rulesObj)
        {
            var flattended = makeFlatSelectors(rulesObj, prop);
            if (flattended != null) rules = rules.concat(flattended);
        }

        return rules;
    };

    /**Takes an array of RuleEntry and applies them to a style sheet.
    @param {StyleSheetEntry} styleSheet The stylesheet entry containing both the rules and the style sheet to add them to.
    @param {RuleEntry[]} flatRulesList The rules to add to the style sheet.
    @returns {RuleEntry}*/
    var applyRulesList = function (styleSheet, flatRulesList)
    {
        var rulesAdded = [];

        for (var x = 0; x < flatRulesList.length; x++)
        {
            var curRule = flatRulesList[x];

            var rule = makeRuleStringFromRuleEntry(curRule);

            try
            {
                var index = styleSheet.styleSheet.insertRule(rule, styleSheet.styleSheet.cssRules.length);
                curRule.cssRule = styleSheet.styleSheet.cssRules[index];
                curRule.cssRuleText = rule;

                styleSheet.rules.push(curRule);
                rulesAdded.push(curRule);
            }
            catch (ex)
            {
                EVUI.Modules.Core.Utils.log("Failed to add rule \"" + rule + "\":" + ex.message);
            }
        }

        return rulesAdded;
    };

    /** Walks an aggregate object recursively to produce an array of RuleEntry objects with the base "flat" selectors we used for managing all the style entries.
    @param {Object} rulesObj A merged, aggregate rule object with keys of normalized css selector segments and properties of sub-objects of more selectors or actual object keys.
    @param {String} prop The property of the rules object that is being drilled into.
    @param {String} selector The current flattened aggregate selector.
    @param {String[]} selectors The chain of selectors from the root to the current object.
    @returns {RuleEntry[]}*/
    var makeFlatSelectors = function (rulesObj, prop, selector, selectors)
    {
        if (selectors == null) selectors = [];
        selectors.push(prop);

        var nextObj = rulesObj[prop];

        var rules = [];

        if (selector == null)
        {
            selector = prop;
        }
        else
        {
            selector = selector + " " + prop
        }

        if (isAggregatedNonCascadingSet(prop) === true)
        {
            var ruleEntry = new RuleEntry();
            ruleEntry.rules = nextObj;
            ruleEntry.selector = selector;
            ruleEntry.selectors = selectors;

            return [ruleEntry];
        }        

        for (var innerProp in nextObj)
        {
            var innerValue = nextObj[innerProp]
            if (innerValue == null) continue;

            if (typeof innerValue !== "object") //the inner value is finally not an object, we stop drilling as we are at the CSS rule set at the bottom of the rule hierarchy
            {
                var ruleEntry = new RuleEntry();
                ruleEntry.rules = nextObj;
                ruleEntry.selector = selector;
                ruleEntry.selectors = selectors;

                return [ruleEntry];
            }
            else //we have a sub object. continue drilling.
            {
                var innerRules = makeFlatSelectors(nextObj, innerProp, selector, selectors.slice());
                if (innerRules != null)
                {
                    rules = rules.concat(innerRules);
                }
            }
        }

        return rules;

    };

    /**Determines whether or not the CSS rule can be broken down into sub-rules or must be treated as a set (i.e., @keyframes) that does not follow the normal cascading rules everything else does.
    @param {String} selector The selector segment to test for the aggregation property.
    @returns {Boolean} */
    var isAggregatedNonCascadingSet = function (selector)
    {
        var numAggregationSets = _aggregationSets.length;
        for (var x = 0; x < numAggregationSets; x++)
        {
            if (EVUI.Modules.Core.Utils.stringStartsWith(_aggregationSets[x], selector) === true) return true;
        }

        return false;
    }

    /**Makes sure that a CSSStyleSheet is applied in the DOM. If it is not, a clone of it is made and inserted into the DOM so the CSS rules persist the deletion of their parent object.
    @param {StyleSheetEntry} styleSheet The entry to revive if it has been removed. */
    var ensureSheetInDom = function (styleSheet)
    {
        if (styleSheet.styleSheet.ownerNode == null) //this will be null if the sheet has been cut out of the DOM. We can't re-attach it, so we have to make a new style sheet and clone our rule set.
        {
            var clone = makeSheetClone(styleSheet);
            styleSheet.styleSheet = clone;
        }
        else //is part of the DOM
        {
            if (styleSheet.styleSheet.ownerNode.isConnected === false) document.head.appendChild(syleSheet.ownerNode); //but it's an orphan, re-attach
            if (styleSheet.disabled === true) styleSheet.disabled = false; //flip the disabled flag if it got flipped on somehow.
        }
    };

    /**Applies all the in-memory properties in the manager to the newly cloned style sheet.
    @param {StyleSheetEntry} styleSheet The entry to clone the sheet of. */
    var makeSheetClone = function (styleSheet)
    {
        var styleElement = makeStyleSheetElement();

        var rules = styleSheet.rules;
        styleSheet.rules = [];
        applyRulesList(styleSheet, rules); //adding rules builds the styleSheet's rule index, so we clear it and rebuild it
        styleSheet.styleSheet = styleElement.sheet;         
    };

    /**Creates a style element and appends it to the head.
    @returns {HTMLStyleElement}*/
    var makeStyleSheetElement = function ()
    {
        var styleElement = document.createElement("style");
        document.head.appendChild(styleElement);

        return styleElement;
    };

    /**Gets a sheet name based on its name in a case-insensitive search.
    @param {any} name The name of the style sheet to get.
    @returns {StyleSheetEntry}*/
    var getStylesheetEntry = function (name)
    {
        var numSheets = _stylesheets.length;
        var lowerSheetName = name.toLowerCase();

        for (var x = 0; x < numSheets; x++)
        {
            var curSheet = _stylesheets[x];
            if (curSheet.name.toLowerCase() === lowerSheetName) return curSheet;
        }

        return null;
    };

    /**Turns a RuleEntry into a valid CSS string we can insert into a style sheet without it crashing.
    @param {RuleEntry} ruleEntry The rule to translate into a CSS string.
    @returns {String}*/
    var makeRuleStringFromRuleEntry = function (ruleEntry)
    {
        if (ruleEntry == null) return "";

        var selector = ""; //the nested selector
        var postFix = ""; //all the close brackets needed

        var numSelectors = ruleEntry.selectors.length;
        if (numSelectors === 1 && ruleEntry.selectorsSplit === false) //if we have never split the selector, split it apart into its component pieces so making the nested rule is easier.
        {
            ruleEntry.selectors = _parser.breakUpSelector(ruleEntry.selector);
            numSelectors = ruleEntry.selectors.length;

            ruleEntry.selectorsSplit = true;
        }

        for (var x = 0; x < numSelectors; x++) //make the outer nested part from the flat selector
        {
            if (x > 0)
            {
                selector = selector + " { " + ruleEntry.selectors[x];
                postFix += "}"
            }
            else
            {
                selector = ruleEntry.selectors[x];
            }
        }

        //var rules = "{";
        //var capitalLettersRegex = new RegExp(/(?!^)[A-Z]/g);

        //for (var prop in ruleEntry.rules) //turn every camelCase property into a snake-case CSS property.
        //{
        //    var snakeCased = prop.replace(capitalLettersRegex, function (match) { return "-" + match.toLowerCase() }).toLowerCase();
        //    rules += snakeCased + ":" + ruleEntry.rules[prop] + "; ";
        //}

        //rules += "}";

        var rules = rulesToString(ruleEntry.rules);

        return selector + rules + postFix;
    };

    /**Recursively turns a CSS rule object (or aggregated rule object) into an appropriate CSS string.
    @param {Object} rulesObj An object of rules or nested rules.
    @returns {String}*/
    var rulesToString = function (rulesObj)
    {
        var rules = "{";
        var capitalLettersRegex = new RegExp(/(?!^)[A-Z]/g);

        for (var prop in rulesObj) //turn every camelCase property into a snake-case CSS property.
        {
            var snakeCased = prop.replace(capitalLettersRegex, function (match) { return "-" + match.toLowerCase() }).toLowerCase();
            var curRule = rulesObj[prop];

            if (curRule != null && typeof curRule === "object")
            {
                rules += snakeCased + " " + rulesToString(curRule);
            }
            else
            {
                rules += snakeCased + ":" + curRule + "; ";
            }
        }

        rules += "}"

        return rules;
    }

    /**Internal entry for pairing a name to a stylesheet object.
    @class*/
    var StyleSheetEntry = function ()
    {
        /**String. The user-given name of the stylesheet.
        @type {String}*/
        this.name = null;

        /**Object. The DOM stylesheet object that contains the rules for the stylesheet.
        @type {CSSStyleSheet}*/
        this.styleSheet = null;

        /**Boolean. Whether or not to lock the style sheet and prevent it from being removed from the internal list of style sheets.
        @type {Boolean}*/
        this.lock = false;

        /**Array. An array of StyleSheetRule representing all the rules added to the sheet through the StyleSheetManager.
        @type {RuleEntry[]}*/
        this.rules = [];
    };

    /**Represents an entry of a programmatically added rule.
    @class*/
    var RuleEntry = function ()
    {
        /**String. The aggregated selector used to target the CSS rules.
        @type {String}*/
        this.selector = null;

        /**Object. The rules object.
        @type {Object}*/
        this.rules = null;

        /**Array. The array of nested selectors that were used to target the CSS rules.
        @type {String[]}*/
        this.selectors = [];

        /**Object. The matching CSSRule that exists on a stylesheet.
        @type {CSSRule}*/
        this.cssRule = null;

        /**String. The text of the CSS rule that was injected into the style sheet.
        @type {String}*/
        this.cssRuleText = null;

        /**Boolean. Whether or not the selector has already been split into segments.
        @type {Boolean}*/
        this.selectorsSplit = false;
    };

    this.addStyleSheet(EVUI.Modules.Styles.Constants.DefaultStyleSheetName, { lock: true });
};

/**Represents a CSS Selector and the Rules associated with it.
@class*/
EVUI.Modules.Styles.StyleSheetRule = function ()
{
    /**String. Any CSS selector.
    @type {String}*/
    this.selector = null;

    /**String. A string of CSS rules separated by semicolons or an object where the key is the css property name and the value is the value of the property. If an object is used, camelCase or PascalCase property names will be snake cased in the final CSS string.
    @type {String|Object}*/
    this.rules = null;
};

/**Utility class for taking a string of arbitrary CSS and turning it into a JSON object.
@class*/
EVUI.Modules.Styles.StyleParser = function ()
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.Styles.Dependencies);

    var _snakeCaseToCamelCaseRegex = new RegExp(/(?!^)(\-)([A-Z])/ig);
    var _openCurlyRegex = new RegExp(/\{/g);
    var _closeCurlyRegex = new RegExp(/\}/g);
    var _isTagNameRegex = new RegExp(/[#\.\[\]]/g);
    var _whitespaceRegex = new RegExp(/\s+/g)
    var _combinatorsRegex = new RegExp(/[\>\\~\+]|\|{2}/g);

    /**Parses a string of CSS into an object.
    @param {any} css Any string of valid CSS. Can be a single rule, a selector/nested selector, or an entire stylesheet.
    @returns {Object}*/
    this.parse = function (css)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(css) === true) return null;

        var session = new ParseSession();
        session.rawCSS = removeComments(css);
        session.openMatches = getMatches(_openCurlyRegex, session.rawCSS, true);
        session.closeMatches = getMatches(_closeCurlyRegex, session.rawCSS, true);


        if (session.openMatches.length === 0 && session.closeMatches.length === 0) return makeRulesFromString(session.rawCSS);

        return walk(session, {});
    };

    /**Takes a single, isolated selector (something like "@page @media (someCondition) h1" and not "@page @media (someCondition) h1, h2, div") and breaks it into its nested components if it is a nested selector. Does not respect commas in selectors.
    @param {String} selector The potentially nested selector to break apart.
    @returns {Stirng[]}*/
    this.breakUpSelector = function (selector)
    {
        var whitespace = getMatches(_whitespaceRegex, selector);
        if (whitespace.length === 0) return [selector];

        var atSelectors = getMatches(new RegExp(/\@/g), selector, true);
        var parensSelectors = getMatches(new RegExp(/\)/g), selector, true);

        var index = 0;
        var atIndex = 0;
        var parenIndex = 0;
        var selectors = [];

        while (index < selector.length)
        {
            var firstAt = atSelectors[atIndex];
            var nextAt = atSelectors[atIndex + 1];
            var nextCloseParens = parensSelectors[parenIndex]

            if (firstAt == null && nextAt == null && nextCloseParens == null) //found no tokens to base nesting off of, we are done
            {
                if (selectors.length > 0)
                {
                    selectors.push(selector.substring(index));
                    return selectors;
                }
                else
                {
                    return [selector];
                }
            }
            else if (firstAt != null && nextAt != null) //we have one @selector
            {
                var selectorSegment = selector.substring(firstAt.index, nextAt.index); //snip the selector from the index to the end of the last )
                selectors.push(selectorSegment);

                atIndex++;
                index = nextAt.index + nextAt.length;
            }
            else
            {
                if (nextCloseParens != null) //and it has conditions after it 
                {
                    var selectorSegment = selector.substring(firstAt.index, nextCloseParens.index + 1); //snip the selector from the index to the end of the last )
                    selectors.push(selectorSegment);

                    parenIndex++;
                    index = nextCloseParens.index + 2;
                }
                else //we have no parenthesis, look for another nested @selctor
                {
                    //var nextWhitespace = null;
                    //var numWhitespace = whitespace.length;
                    //for (var x = 0; x < numWhitespace; x++)
                    //{
                    //    var curWhitespace = whitespace[x];
                    //    if (curWhitespace.index > index)
                    //    {
                    //        nextWhitespace = curWhitespace;
                    //        break;
                    //    }
                    //}

                    //if (nextWhitespace != null) //cut to the next whitespace
                    //{
                    //    selectors.push(selector.substring(firstAt.index, nextWhitespace.index));
                    //    index = nextWhitespace.index + 1;
                    //}
                    //else //cut to the end of the sting, we are done
                    //{
                        selectors.push(selector.substring(firstAt.index));
                        return selectors;
                    //}                    
                }

                atIndex++;
            }
        }

        return selectors;
    };

    /**Normalizes a single, isolated selector (something like "@page @media (someCondition) h1" and not "@page @media (someCondition) h1, h2, div") so that it is formatted consistently no matter the input format. 
    Case-corrects tag names and other non-case sensitive selector components to be lower case (but leaves case-sensitive selectors untouched), and spaces out combinator selectors so that they are always separated by a space on both sides.
    @param {String} selector The selector to normalize.
    @returns {String} */
    this.getNormalizedSelctor = function (selector)
    {
        return normalizeSelector(selector);
    };

    /**Cleans all the CSS comments out of a string of CSS.
    @param {String} css The CSS to remove comments from.
    @returns {String}*/
    var removeComments = function (css)
    {
        var cleanCSS = "";
        var index = 0;
        var length = css.length;
        var editedString = false;

        while (index < length)
        {
            var commentStart = css.indexOf("/*", index);
            var commentEnd = css.indexOf("*/", index);

            if (commentStart === -1 || commentEnd === -1) break;

            editedString = true;
            cleanCSS += css.substring(index, commentStart);
            index = commentEnd + 2;
        }

        if (editedString === true)
        {
            cleanCSS += css.substring(index);
            return cleanCSS;
        }
        else
        {
            return css;
        }
    };

    /**Gets all the matches for a regex in a string, optionally avoiding sequences that begin with the escape character "\"
    @param {RegExp} regex The regular expression to run.
    @param {String} str The string to run the regex over
    @param {any} ignoreEscapes Whether or not to ignore matches that begin with "\"
    @returns {Match[]}*/
    var getMatches = function (regex, str, ignoreEscapes)
    {
        if (typeof str !== "string" || regex == null) return null;

        var matches = [];

        var allMatches = str.matchAll(regex);
        var nextMatch = allMatches.next();
        while (nextMatch.done === false)
        {
            var precedingChar = (nextMatch.value.index > 0) ? str[nextMatch.value.index - 1] : "";
            if (ignoreEscapes === true && precedingChar !== "\\") //because fuck figuring out the regex for "match any curly brace that is NOT preceded by a '\'"
            {
                var match = new Match(nextMatch.value.index, nextMatch.value[0], nextMatch.value[0].length);
                matches.push(match);
            }
            else if (ignoreEscapes !== true)
            {
                var match = new Match(nextMatch.value.index, nextMatch.value[0], nextMatch.value[0].length);
                matches.push(match);
            }

            nextMatch = allMatches.next();
        }

        return matches;
    };

    /**Walks the CSS string and parses it into a JSON object.
    @param {ParseSession} session The metadata about the operation in progress.
    @returns {Object}*/
    var walk = function (session, curObj)
    {
        var totalLength = session.rawCSS.length;

        while (session.index < totalLength)
        {
            var nextOpen = session.openMatches[session.openIndex];
            var secondOpen = session.openMatches[session.openIndex + 1];
            var nextClose = session.closeMatches[session.closeIndex];

            if (nextOpen == null) break; //end of graph
            if (nextClose == null) break; //something wrong, it was left open

            if (nextOpen.index > session.index) //the next open brace is between our last open brace and our next one
            {
                if (secondOpen != null && secondOpen.index < nextClose.index) //the second open brace is before the next close brace, we are outside a nested block
                {
                    var selector = session.rawCSS.substring(session.index != 0 ? session.index + 1 : 0, nextOpen.index).trim(); //the selector will be the gap between our current position and the next curly brace

                    session.openIndex++;
                    session.index = nextOpen.index;

                    var selectors = selector.split(",");
                    var numSelectors = selectors.length;
                    for (var x = 0; x < numSelectors; x++) //split the selector if it was a multi-selector
                    {
                        var curSelector = normalizeSelector(selectors[x]);

                        var existing = curObj[curSelector]; //if we already have the object, just re-read properties onto it
                        if (existing != null)
                        {
                            curObj[curSelector] = walk(session, existing);
                        }
                        else //otherwise start with a new object
                        {
                            curObj[curSelector] = walk(session, {});
                        }
                    }
                }
                else if (session.index === nextClose.index) //if the index and the close index are the same, we're at the end of a nested block and need to break out of the loop
                {
                    session.closeIndex++;
                    session.index++;
                    break;
                }
                else //otherwise we're inside of a block and just need to parse out the actual CSS properties into an object
                {
                    var selector = session.rawCSS.substring(session.index != 0 ? session.index + 1 : 0, nextOpen.index).trim();
                    if (selector.length > 0)
                    {
                        var selectors = selector.split(",");
                        var numSelectors = selectors.length;
                        var newObj = makeRulesFromString(session.rawCSS.substring(nextOpen.index + 1, nextClose.index)); //make the new object once

                        for (var x = 0; x < numSelectors; x++)
                        {
                            var curSelector = normalizeSelector(selectors[x]);
                            if (x > 0) newObj = EVUI.Modules.Core.Utils.shallowExtend({}, newObj);

                            var existing = curObj[curSelector];
                            if (existing != null)
                            {
                                curObj[curSelector] = EVUI.Modules.Core.Utils.shallowExtend(existing, newObj); //extend the new object onto the existing if it's already there
                            }
                            else
                            {
                                curObj[curSelector] = newObj; //otherwise set the object
                            }
                        }
                        
                        session.index = nextClose.index + 1;
                    }
                    else //we a rule string without a selector
                    {
                        return makeRulesFromString(session.rawCSS.substring(nextOpen.index + 1, nextClose.index));
                    }

                    session.openIndex++;
                    session.closeIndex++;
                }
            }
            else
            {
                break;
            }
        }

        return curObj;
    };

    /**Makes a rules object from a segment of CSS that is not surrounded by curly braces.
    @param {String} css The CSS to make into an object.
    @returns {Object}*/
    var makeRulesFromString = function (css)
    {  
        var ruleGraph = {};
        var rules = css.split(";");
        var numRules = rules.length;
        for (var x = 0; x < numRules; x++)
        {
            var curRule = rules[x];
            var firstColonIndex = curRule.indexOf(":");
            if (firstColonIndex === -1) continue;

            var key = curRule.substring(0, firstColonIndex).toLowerCase().trim();
            var value = curRule.substring(firstColonIndex + 1).trim();

            key = key.replace(_snakeCaseToCamelCaseRegex, function (match) { return match[1].toUpperCase(); });
            ruleGraph[key] = value;
        }

        return ruleGraph;
    };

    /**Normalizes the selector so that it is formatted consistently no matter the input format. Case-corrects tag names and other non-case sensitive selector components to be lower case (but leaves case-sensitive selectors untouched), and spaces out combinator selectors so that they are always separated by a space on both sides.
    @param {String} selector The selector to normalize.
    @returns {String} */
    var normalizeSelector = function (selector)
    {
        if (typeof selector !== "string") return null;

        //make sure parentheses are always flanked by a space, and make sure all commas are formatted the way they would be in grammatically correct English.
        selector = selector.replace(/\)|\(/g, function (match) { return match === ")" ? ") " : " (" }).replace(/\,|\s\,|\,\s/g, ", ");

        var normalizedSelector = "";
        var subSelectors = selector.trim().split(_whitespaceRegex); //break the whole string apart based on whitespace
        var numSubSelectors = subSelectors.length;

        for (var x = 0; x < numSubSelectors; x++) //then re-assemble it while case-normalizing the segments that need to be case normalized and leaving the case-sensitive parts of the selector alone.
        {
            var curSubSelector = subSelectors[x];
            var combinatorMatches = getMatches(_combinatorsRegex, curSubSelector, true);   //get all the combinator selectors in the current segment          

            var numCombinators = combinatorMatches.length;
            if (numCombinators === 0) //no combinators, just normalize the case of the segment
            {
                normalizedSelector = normalizeCase(curSubSelector, (x === 0), normalizedSelector);
            }
            else //we have combinators, we want each one flanked by a space on both sides.
            {
                var index = 0;
                for (var y = 0; y < numCombinators; y++)
                {
                    var curCombinator = combinatorMatches[y];
                    var curCombinatorMatch = curSubSelector.substring(index, curCombinator.index); //grab everything from the index to the combinator

                    index = curCombinator.index + curCombinator.length;

                    normalizedSelector = normalizeCase(curCombinatorMatch, (x === 0), normalizedSelector); //normalize the case of this segment
                    normalizedSelector = normalizedSelector + " " + curCombinator.match; //flank it with spaces
                }

                normalizedSelector = normalizeCase(curSubSelector.substring(index), false, normalizedSelector); //nromalize the rest of the string
            }
        }

        return normalizedSelector.replace(_whitespaceRegex, " "); //finally, remove any duplicate spaces that may have been injected into the string from wrinkes in the logic above.
    };

    /**Normalizes the case of tag names and other case-insensitive parts of a selector, but leaves case-sensitive parts of the selector in their original case.
    @param {any} selector The selector to case normalize.
    @param {any} isFirst Whether or not it is the first part of a selector string.
    @param {any} normalizedSelector A pre-existing normalized selector to append the results to.
    @returns {String} */
    var normalizeCase = function (selector, isFirst, normalizedSelector)
    {
        var caseSensitiveMatches = getMatches(_isTagNameRegex, selector, true);

        var numMatches = caseSensitiveMatches.length;
        if (numMatches > 0)
        {
            var curMatch = caseSensitiveMatches[0];
            var normalized = selector.substring(0, curMatch.index).toLocaleLowerCase();

            normalizedSelector = normalizedSelector + ((isFirst === true) ? normalized : " " + normalized) + selector.substring(curMatch.index);
        }
        else
        {
            var normalized = selector.toLocaleLowerCase();
            normalizedSelector = normalizedSelector + ((isFirst === true) ? normalized : " " + normalized);
        }

        return normalizedSelector;
    }

    /**Represents a parsing of CSS in progress. */
    var ParseSession = function ()
    {
        /**Number. The current index the parser is at in the rawCss.
        @type {Number}*/
        this.index = 0;

        /**The raw CSS string.
        @type {String}*/
        this.rawCSS = null;

        /**Array. All of the open curly brace locations.
        @type {Match[]}*/
        this.openMatches = null;

        /**Array. All of the close curly brace locations.
        @type {Match[]}*/
        this.closeMatches = null;

        /**Number. The index of the current open curly brace in the openMatches array.
        @type {Number}*/
        this.openIndex = 0;

        /**Number. The index of the current close curly brace in the closeMatches array.
        @type {Number}*/
        this.closeIndex = 0;
    };

    /**Represents a Regex match.
    @class*/
    var Match = function (index, match, length)
    {
        /**Number. The index of the match in the source string.
        @type {Number}*/
        this.index = (typeof index !== "number") ? 0 : index;

        /**String. The matching part of the string.
        @type {String}*/
        this.match = (typeof match !== "string") ? null : match;

        /**Number. The length of the match.
        @type {Number}*/
        this.length = (typeof length !== "number") ? 0 : length;
    };
};

/**Parameters object for the $evui.css function. Different combinations of parameters produce different operations. All operations except for sheet removal return an array of the effected StyleSheetRules.
@class*/
EVUI.Modules.Styles.CSSOptions = function ()
{
    /**String. The name of the sheet to add rules to, get rules from, or remove entirely. If omitted the DefaultStyleSheetName is used from the module's Constants table.
    @type {String}*/ 
    this.sheetName = null;

    /**String or Array. Either a CSS selector or an array of CSS selectors to set rules on or to remove entirely. Note that selectors for rules nested in at-rules are accessed by their "flat" path name, i.e. the style block inside of @page { @media (condition) { h1 { display: none; }}} would be accessed via "@page @media (condition) h1".
    @type {String|String[]}*/
    this.selector = null;

    /**String or Object or Array. A set of rules to add, change, or remove. 
     
    Can be:
    1. A full CSSStyleSheet object, or an array of CSSStyleSheet objects.
    2. A single, or an array of, StyleSheetRule objects.
    3. A string of CSS with multiple selectors, or an array of strings of CSS with multiple selectors.
    4. A string of CSS rules without a selector, or an array of strings of CSS rules without selectors.
    5. A "style" object or an array of "style" objects (an object with css properties as camelCased property names).

    To remove a rule from a selector's rule set, specify its value as the string "null".
    @type {String|String[]|EVUI.Modules.Styles.StyleSheetRule|EVUI.Modules.Styles.StyleSheetRule[]|CSSStyleSheet|CSSStyleSheet[]}*/
    this.rules = null;

    /**Whether or not to remove any rules with a matching selector, or if no selector is provided, the entire rule sheet with the given sheetName.
    @type {Boolean}*/
    this.remove = false;
};

/**Enum for describing the way to sync the internal entries of the StyleSheetManager and one of the CSSStyleSheets it manages.
@enum*/
EVUI.Modules.Styles.SyncMode =
{
    /**Indicates that the internal rules array will be cleared and re-set to match the current state of the style sheet.*/
    FromSheet: "fromSheet",
    /**Indicates that the style sheet will have its rules cleared and be synced to the interal rules array.*/
    ToSheet: "toSheet"
};
Object.freeze(EVUI.Modules.Styles.SyncMode);

/**Global instance of HttpEventStream, a utility used for making HTTP requests in a sequence.
@type {EVUI.Modules.Styles.StyleSheetManager}*/
EVUI.Modules.Styles.Manager = null;
(function ()
{
    var styleSheetManager = null;
    var ctor = EVUI.Modules.Styles.StyleSheetManager;

    Object.defineProperty(EVUI.Modules.Styles, "Manager",
    {
        get: function ()
        {
            if (styleSheetManager == null)
            {
                styleSheetManager = new ctor();
            }

            return styleSheetManager;
        },
        enumerable: true,
        configurable: false
    });
})();

delete $evui.styles;

/**Gets the global instance of HttpEventStream, a utility used for making HTTP requests in a sequence.
@type {EVUI.Modules.Styles.StyleSheetManager}*/
$evui.styles = null;
Object.defineProperty($evui, "styles",
{
    get: function ()
    {
        return EVUI.Modules.Styles.Manager;
    },
    enumerable: true
});

/**Gets, sets, or removes a set of CSS rules from the a style sheet that has previously been added to the $evui.styles StyleSheetManager.
@param {EVUI.Modules.Styles.CSSOptions|String} cssOrOptions Either a YOLO CSSOptions object or a string of raw CSS.
@returns {EVUI.Modules.Styles.StyleSheetRule[]} */
$evui.css = function (cssOrOptions)
{
    if (cssOrOptions == null) return null;
    if (typeof cssOrOptions === "string")
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(cssOrOptions) === true) return;
        return $evui.styles.setRules(EVUI.Modules.Styles.Constants.DefaultStyleSheetName, cssOrOptions);
    }
    else if (typeof cssOrOptions === "object")
    {
        var sheetName = EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(cssOrOptions.sheetName) === true ? EVUI.Modules.Styles.Constants.DefaultStyleSheetName : cssOrOptions.sheetName;
        var selector = (EVUI.Modules.Core.Utils.isArray(cssOrOptions.selector) === true || EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(cssOrOptions.selector) === false) ? cssOrOptions.selector : null;
        var rules = (cssOrOptions.rules != null && (typeof cssOrOptions.rules === "object" || EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(cssOrOptions.rules) === false)) ? cssOrOptions.rules : null;
        var remove = (typeof cssOrOptions.remove !== "boolean") ? false : cssOrOptions.remove;

        if (remove === true)
        {
            if (selector != null)
            {
                return $evui.styles.removeRules(sheetName, selector);
            }
            else
            {
                var existingRules = $evui.styles.getRules(sheetName);
                var removed = $evui.styles.removeStyleSheet(sheetName);

                if (removed === true) return existingRules;
                return null;
            }
        }

        if (selector == null)
        {
            if (rules != null)
            {
                return $evui.styles.setRules(sheetName, rules);
            }
            else
            {
                return $evui.styles.getRules(sheetName);
            }
        }
        else
        {
            if (rules != null)
            {
                if (rules instanceof CSSStyleSheet)
                {
                    return $evui.styles.setRules(sheetName, rules);
                }
                else if (EVUI.Modules.Core.Utils.isArray(rules) === true && rules.length > 0 && rules[0].selector != null)
                {
                    return $evui.styles.setRules(sheetName, rules);
                }
                else
                {
                    return $evui.styles.setRules(sheetName, selector, rules);
                }                
            }
            else
            {
                return $evui.styles.getRules(sheetName, selector);
            }
        }
    }
};

Object.freeze(EVUI.Modules.Styles.Constants);
Object.freeze(EVUI.Modules.Styles);

/*#ENDWRAP(Styles)#*/


/********************************************************TreeView.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.TreeView|TreeView)#*/
/*#REPLACE(EVUI.Modules.TreeView|TreeView)#*/

/**Module for data-driven TreeViews.
@module*/
EVUI.Modules.TreeView = {};

/*#MODULEDEF(TreeView|"1.0";|"TreeView")#*/
/*#VERSIONCHECK(EVUI.Modules.TreeView|TreeView)#*/

EVUI.Modules.TreeView.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
    Binding: Object.freeze({ version: "1.0", required: true }),
    Styles: Object.freeze({version: "1.0", required: true}),
    EventStream: Object.freeze({ version: "1.0", required: true }),
    Dom: Object.freeze({ version: "1.0", required: true })
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.TreeView.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();

Object.freeze(EVUI.Modules.TreeView.Dependencies);

EVUI.Modules.TreeView.Constants = {};

EVUI.Modules.TreeView.Constants.Attr_ExpandOn = "evui-tree-node-expand-on";
EVUI.Modules.TreeView.Constants.Attr_CollapseOn = "evui-tree-node-collapse-on";
EVUI.Modules.TreeView.Constants.Attr_ToggleOn = "evui-tree-node-toggle-on";
EVUI.Modules.TreeView.Constants.Attr_Depth = "evui-tree-node-depth";
EVUI.Modules.TreeView.Constants.Attr_NodeId = "evui-tree-node-id";
EVUI.Modules.TreeView.Constants.Attr_Ordinal = "evui-tree-node-ordinal";
EVUI.Modules.TreeView.Constants.Attr_TreeId = "evui-tree-id";

EVUI.Modules.TreeView.Constants.CSS_NodeInterior = "evui-tree-node-interior";
EVUI.Modules.TreeView.Constants.CSS_ChildNodeList = "evui-tree-node-children";
EVUI.Modules.TreeView.Constants.CSS_TreeViewNode = "evui-tree-node";
EVUI.Modules.TreeView.Constants.CSS_TreeViewRootNode = "evui-tree-root-node";
EVUI.Modules.TreeView.Constants.CSS_TreeView = "evui-tree";
EVUI.Modules.TreeView.Constants.CSS_TreeViewRoot = "evui-tree-root";
EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Hidden = "evui-tree-node-children-hidden";
EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Visible = "evui-tree-node-children-visible";
EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Expanding = "evui-tree-node-children-expanding"
EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Collapsing = "evui-tree-node-children-collapsing"

EVUI.Modules.TreeView.Constants.Event_OnBuild = "evui.treenode.build";
EVUI.Modules.TreeView.Constants.Event_OnBuildChildren = "evui.treenode.build.children";
EVUI.Modules.TreeView.Constants.Event_OnChildrenBuilt = "evui.treenode.built.children";
EVUI.Modules.TreeView.Constants.Event_OnBuilt = "evui.treenode.built";

EVUI.Modules.TreeView.Constants.Event_OnExpand = "evui.treenode.expand";
EVUI.Modules.TreeView.Constants.Event_OnExpanded = "evui.treenode.expanded";

EVUI.Modules.TreeView.Constants.Event_OnCollapse = "evui.treenode.collapse";
EVUI.Modules.TreeView.Constants.Event_OnCollapsed = "evui.treenode.collapsed";

/**
 * 
 * @param {EVUI.Modules.TreeView.TreeViewEventArgs} treeViewEventArgs
 */
EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler = function (treeViewEventArgs) { };

/**Function definition for the predicate function used to select TreeViews from the TreeViewController.
@param {EVUI.Modules.TreeView.TreeView} treeView The current TreeView.
@returns {Boolean} */
EVUI.Modules.TreeView.Constants.Fn_TreeViewSelector = function (treeView) { };

/**Function definition for the predicate function used to select TreeViewNodes from the TreeView.
@param {EVUI.Modules.TreeView.TreeViewNode} node The current TreeViewNode.
@returns {Boolean} */
EVUI.Modules.TreeView.Constants.Fn_TreeViewNodeSelector = function (node) { };

/**A function called that is passed the source object for a TreeViewNode that returns an Array of children to make into child TreeViewNodes.
@param {{}} source The source object being used as the basis for the TreeViewNode.
@returns {[]}*/
EVUI.Modules.TreeView.Constants.Fn_ChildListGetter = function (source) { }

Object.freeze(EVUI.Modules.TreeView.Constants);


/**Controller for managing TreeViews and their behavior.
@class*/
EVUI.Modules.TreeView.TreeViewController = function (services)
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.TreeView.Dependencies);

    /**Array of all the TreeViews being managed by this controller.
    @type {TreeViewEntry[]}*/
    var _treeViews = [];
    var _nodeIDCounter = 0; //ID counter for TreeViewNodes
    var _operationCounter = 0; //ID counter for operation sessions
    var _nodeExclusions = ["element", "id", "parentNode", "childNodes", "depth", "index", "treeView"]; //properties to not copy from a parameter object onto a TreeViewNode (they are read only)
    var _treeViewExclusions = ["id", "nodes", "rootListElement", "rootNode", "element", ]; //properties to not copy from a parameter object onto a TreeView (they are read only)
    var _eventExclusions = ["onExpand", "onExpanded", "onCollapse", "onCollaposed", "onBuild", "onBuilt", "onBuildChildren", "onChildrenBuilt"]; //event names to not copy onto an internal data model object (TreeViewEntry/TreeViewNodeEntry) when they are attached to an incoming parameter
    var _classesSet = false; //whether or not the CSS classes that control the expansion and collapse of tree view nodes have been set.

    /**Object. The service collection containing the dependencies used by the TreeViewController.
    @type {EVUI.Modules.TreeView.TreeViewControllerServices}*/
    var _services = services;

    /**Creates and adds a TreeView to the controller's list of managed TreeViews.
    @param {String|EVUI.Modules.TreeView.AddTreeViewArgs|EVUI.Modules.TreeView.TreeView} makeTreeViewArgsOrId Either the string name of the TreeView to make, a YOLO TreeView object describing the tree, or a YOLO AddTreeViewArgs object describing the tree.
    @param {EVUI.Modules.TreeView.AddTreeViewNodeArgs|EVUI.Modules.TreeView.TreeViewNode} rootNodeArgs Optional. Arguments for making the root TreeViewNode of the TreeView. Can either be a YOLO TreeViewNode or a YOLO AddTreeViewNodeArgs object.
    @returns {EVUI.Modules.TreeView.TreeView} */
    this.addTreeView = function (makeTreeViewArgsOrId, rootNodeArgs)
    {
        var tvArgsType = typeof makeTreeViewArgsOrId;
        if (makeTreeViewArgsOrId == null || (tvArgsType !== "string" && tvArgsType !== "object")) throw Error("Invalid parameters, string or object expected.");

        var treeId = (typeof makeTreeViewArgsOrId === "string") ? makeTreeViewArgsOrId : makeTreeViewArgsOrId.id;
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(treeId) === true) throw Error("TreeView id must be a string.");

        var existing = getTreeViewById(treeId);
        if (existing != null) throw Error("A TreeView with an id of \"" + existing + "\" already exists.");

        var tvEntry = makeTreeViewAmbiguously(makeTreeViewArgsOrId, rootNodeArgs);
        if (tvEntry != null) _treeViews.push(tvEntry);

        return tvEntry.treeView;
    };

    /**Gets a TreeView or TreeViews from the TreeViewController.
    @param {String|EVUI.Modules.TreeView.Constants.Fn_TreeViewSelector} treeViewIdOrPredicate Either the string ID of a TreeView to get, or a predicate function used to select TreeViews from the controller's collection of TreeViews.
    @param {Boolean} getAllMatches Optional. Whether or not to return all the matches that satisfied the predicate function. If omitted only the first TreeView to satisfy the predicate is returned.
    @returns {TreeView|TreeView[]} */
    this.getTreeView = function (treeViewIdOrPredicate, getAllMatches)
    {
        var result = [];
        if (typeof treeViewIdOrPredicate === "string")
        {
            var entry = getTreeViewById(treeViewIdOrPredicate);
            if (entry != null) return entry.treeView;
        }
        else if (typeof treeViewIdOrPredicate === "function")
        {
            var result = (getAllMatches === true) ? [] : null;
            var numTrees = _treeViews.length;
            for (var x = 0; x < numTrees; x++)
            {
                var curTree = _treeViews[x];
                if (treeViewIdOrPredicate(curTree.treeView) === true)
                {
                    if (getAllMatches === true)
                    {
                        result.push(curTree.treeView);
                    }
                    else
                    {
                        return curTree.treeView;
                    }
                }
            }

            return result;
        }
        else
        {
            return null;
        }
    };

    /**Removes and optionally disposes of one of the TreeViews being managed by this controller.
    @param {String} treeViewId The ID of the TreeView to remove.
    @param {Boolean} dispose LOptional. Whether or not to dispose of and destroy the TreeView once it has been removed. False by default.
    @returns {Boolean} */
    this.removeTreeView = function (treeViewId, dispose)
    {
        var existing = getTreeViewById(treeViewId);
        if (existing == null) return false;

        if (dispose === true) disposeTreeView(existing);

        var index = _treeViews.indexOf(existing);
        if (index !== -1) _treeViews.splice(index, 1);

        return true;
    };

    /**Gets a TreeViewEntry based on it's ID.
    @param {String} treeViewId The ID of the TreeViewEntry to get.
    @returns {TreeViewEntry} */
    var getTreeViewById = function (treeViewId)
    {
        if (typeof treeViewId !== "string") return null;

        var numTrees = _treeViews.length;
        var lowerId = treeViewId.toLowerCase();

        for (var x = 0; x < numTrees; x++)
        {
            var curTree = _treeViews[x];
            if (curTree.treeViewId.toLowerCase() === lowerId) return curTree;
        }

        return null;
    };

    /**Makes a TreeViewEntry based on ambiguous input that can be one of several different combinations of things.
    @param {String|EVUI.Modules.TreeView.AddTreeViewArgs|EVUI.Modules.TreeView.TreeView} makeTreeViewArgsOrId Either a string ID for the TreeViewEntry, YOLO AddTreeVuewArgs for adding a tree, or a YOLO TreeView object.
    @param {EVUI.Modules.TreeView.AddTreeViewNodeArgs|EVUI.Modules.TreeView.TreeViewNode} rootNodeArgs The arguments used to define the root node of the TreeView.
    @returns {TreeViewEntry}*/
    var makeTreeViewAmbiguously = function (makeTreeViewArgsOrId, rootNodeArgs)
    {
        if (makeTreeViewArgsOrId == null && rootNodeArgs == null) return null;

        var treeViewId = null;
        var makeTreeViewArgs = new EVUI.Modules.TreeView.AddTreeViewArgs();
        var makeRootNodeArgs = new EVUI.Modules.TreeView.AddTreeViewNodeArgs();
        var hadTreeViewArgs = false;
        var hadNodeArgs = false;

        if (typeof makeTreeViewArgsOrId === "string") //we were handed an ID
        {
            treeViewId = makeTreeViewArgsOrId;
            makeTreeViewArgs.id = treeViewId;
            makeTreeViewArgs.element = getValidRootElement(); //get a "valid" element, which in this case will be a document fragment.
        }
        else //we were handed some sort of parameter object
        {
            hadTreeViewArgs = true;
            treeViewId = makeTreeViewArgsOrId.id;

            //extend the arguments object the user gave us onto the official object we're using to build the tree view, but don't include any properties that belong on Nodes and not Trees.
            EVUI.Modules.Core.Utils.shallowExtend(makeTreeViewArgs, makeTreeViewArgsOrId, ["nodes", "rootNode"].concat(_nodeExclusions));
            makeTreeViewArgs.element = getValidRootElement(makeTreeViewArgsOrId.element);

             //we have a definition of the root node, copy its properties onto the official object we will use to make the real node
            if (makeTreeViewArgsOrId.rootNode != null && typeof makeTreeViewArgsOrId.rootNode === "object")
            {
                hadNodeArgs = true;
                EVUI.Modules.Core.Utils.shallowExtend(makeRootNodeArgs, makeTreeViewArgsOrId.rootNode, _nodeExclusions);
            }
        }

        //make sure our rootNodeArgs is an actual object, even if it has just the default values
        if (rootNodeArgs == null) rootNodeArgs = new EVUI.Modules.TreeView.AddTreeViewNodeArgs();

        if (hadTreeViewArgs === false) //if we had no tree view args, populate the official "make tree view" object with values from the root node args
        {
            EVUI.Modules.Core.Utils.shallowExtend(makeTreeViewArgs, rootNodeArgs, _eventExclusions.concat(_nodeExclusions));
            makeTreeViewArgs.element = getValidRootElement(rootNodeArgs.element);
        }
        else
        {
            //if (makeTreeViewArgsOrId.rootNode != null && typeof makeTreeViewArgsOrId.rootNode === "object")
            //{
            //    EVUI.Modules.Core.Utils.shallowExtend(makeRootNodeArgs, makeTreeViewArgsOrId.rootNode, _nodeExclusions);
            //}
            //else
            //{
            //    EVUI.Modules.Core.Utils.shallowExtend(rootNodeArgs, makeTreeViewArgs, _eventExclusions.concat(_nodeExclusions));
            //    makeTreeViewArgs.element = getValidElement(makeTreeViewArgs.element);
            //}

            if (hadNodeArgs === false) //if our main parameter object did not have any root node args, populate them with values from the TreeView arguments since there is overlap between them
            {
                EVUI.Modules.Core.Utils.shallowExtend(rootNodeArgs, makeTreeViewArgs, _eventExclusions.concat(_nodeExclusions));
                makeTreeViewArgs.element = getValidRootElement(makeTreeViewArgs.element);
            }
        }

        //finally, make the real backing object for the tree view
        var tvEntry = new TreeViewEntry();
        tvEntry.element = makeTreeViewArgs.element;
        tvEntry.treeViewId = treeViewId;
        tvEntry.treeView = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.TreeView.TreeView(tvEntry), makeTreeViewArgs, _treeViewExclusions); //make the actual tree view then pass all non read only properties provided in the parameters onto it
        tvEntry.rootNode = makeTreeViewNodeAmbiguously(rootNodeArgs, tvEntry); //use the real or synthesized rootNodeArgs to make the root node of the TreeView (which must always be not null)
        tvEntry.className = getTreeViewClassName(tvEntry.treeViewId);
        
        return tvEntry;
    };

    /**Invokes a function to build, expand, collapse, toggle, or dispose of a tree view node from a TreeView object.
    @param {String} action The NodeAction being performed.
    @param {TreeViewEntry} treeViewEntry The TreeView invoking the command.
    @param {Number|TreeViewNodeEntry} nodeOrId Either the ID of the TreeViewNodeEntry that is the target of the operation, or the TreeViewNodeEntry itself.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|EVUI.Modules.TreeView.BuildTreeViewNodeArgs} actionArgs The expand/collapse/build args to go along with the action.
    @param {Function} callback The function to call once the action operation completes (regardless if it was successful, failed, skipped, or canceled).*/
    var invokeFromTreeView = function (action, treeViewEntry, nodeOrId, actionArgs, callback)
    {
        if (typeof nodeOrId === "function") //callback is the 3rd argument, re-assign it to the right argument and clear out the current one
        {
            callback = nodeOrId;
            nodeOrId = null;
        }
        else if (typeof actionArgs === "function") //callback is the 4th argument, again do the re-assign and clear of the current one
        {
            callback = actionArgs;
            actionArgs = null;
        }
        else if (typeof callback !== "function") //NO callback was provided, so just supply a dummy one.
        {
            callback = function (success) { };
        }

        //figure out the TreeViewNodeEntry to take the action being invoked from the tree view.
        var node = null;
        if (typeof nodeOrId === "number") //we have a node's id
        {
            node = getNodeById(treeViewEntry, nodeOrId);
            if (node == null) throw Error("No node with an id of " + nodeOrId + " exists in TreeView " + treeViewEntry.treeViewId);
        }
        else if (nodeOrId != null && typeof nodeOrId === "object") //we have an object, which could possibly be the actual node, or just an object with an ID.
        {
            if (typeof nodeOrId.nodeId === "number") //has an ID
            {
                if (EVUI.Modules.Core.Utils.instanceOf(nodeOrId, TreeViewNodeEntry) === true) //is an actual TreeViewNodeEntry, we have what we're looking for.
                {
                    node = nodeOrId;
                }
                else //not a usable object, use it's ID to go find the actual object we need to use
                {
                    node = getNodeById(treeViewEntry, nodeOrId.id);
                    if (node == null) throw Error("No node with an id of " + nodeOrId.id + " exists in TreeView " + treeViewEntry.treeViewId);
                }
            }
            else //still an object, but not with anything we can use to locate the node. Assume the "node" argument is the action args and just use the rootNode of the tree as our target node
            {
                if (actionArgs == null)
                {
                    actionArgs = nodeOrId;
                    node = treeViewEntry.rootNode;
                }
            }
        }
        else //bogus input, just use the rootNode 
        {
            node = treeViewEntry.rootNode;
        }

        //finally, trigger our action
        if (action === NodeAction.Build)
        {
            triggerBuild(node, actionArgs, callback);
        }
        else if (action === NodeAction.Collapse)
        {
            triggerCollapse(node, actionArgs, callback);
        }
        else if (action === NodeAction.Expand)
        {
            triggerExpand(node, actionArgs, callback);
        }
        else if (action === NodeAction.Toggle)
        {
            triggerToggle(node, actionArgs, callback);
        }
        else if (action === NodeAction.Dispose)
        {
            disposeTreeViewNode(node);
        }
        else
        {
            throw Error("Invalid action.");
        }
    };



    /**Issues the command to build a node (or the entire tree view) from a TreeView object.
    @param {TreeViewEntry} treeViewEntry The TreeView invoking the command.
    @param {Number|TreeViewNodeEntry} nodeOrId Either the ID of the TreeViewNodeEntry that is the target of the operation, or the TreeViewNodeEntry itself.
    @param {EVUI.Modules.TreeView.BuildTreeViewNodeArgs} buildArgs The build args to go along with the action.
    @param {Function} callback The function to call once the action operation completes (regardless if it was successful, failed, skipped, or canceled).*/
    var buildFromTreeView = function (treeViewEntry, nodeOrId, buildArgs, callback)
    {
        invokeFromTreeView(NodeAction.Build, treeViewEntry, nodeOrId, buildArgs, callback);
    };

    /**Issues the command to build a node (or the entire tree view) from a TreeView object.
    @param {TreeViewEntry} treeViewEntry The TreeView invoking the command.
    @param {Number|TreeViewNodeEntry} nodeOrId Either the ID of the TreeViewNodeEntry that is the target of the operation, or the TreeViewNodeEntry itself.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs} expandArgs The expand args to go along with the action.
    @param {Function} callback The function to call once the action operation completes (regardless if it was successful, failed, skipped, or canceled).*/
    var expandFromTreeView = function (treeViewEntry, nodeOrId, expandArgs, callback)
    {
        invokeFromTreeView(NodeAction.Expand, treeViewEntry, nodeOrId, expandArgs, callback);
    };

    /**Issues the command to build a node (or the entire tree view) from a TreeView object.
    @param {TreeViewEntry} treeViewEntry The TreeView invoking the command.
    @param {Number|TreeViewNodeEntry} nodeOrId Either the ID of the TreeViewNodeEntry that is the target of the operation, or the TreeViewNodeEntry itself.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs} collapseArgs The collapse args to go along with the action.
    @param {Function} callback The function to call once the action operation completes (regardless if it was successful, failed, skipped, or canceled).*/
    var collapseFromTreeView = function (treeViewEntry, nodeOrId, collapseArgs, callback)
    {
        invokeFromTreeView(NodeAction.Collapse, treeViewEntry, nodeOrId, collapseArgs, callback);
    };

    /**Issues a command to dispose of either an entire TreeView or just a node on the TreeView.
    @param {TreeViewEntry} treeViewEntry The TreeView that is either being disposed of or the TreeView that contains the node being disposed.
    @param {Number|TreeViewNodeEntry} nodeOrId The TreeViewNode being disposed.*/
    var disposeFromTreeView = function (treeViewEntry, nodeOrId)
    {
        if (nodeOrId == treeViewEntry)
        {
            disposeTreeView(treeViewEntry); 
        }
        else
        {
            invokeFromTreeView(NodeAction.Dispose, treeViewEntry, nodeOrId);
        }
    };

    /**Issues a command to toggle a node's expanded/collapsed state from a TreeView.
    @param {TreeViewEntry} treeViewEntry The TreeView invoking the command.
    @param {Number|TreeViewNodeEntry} nodeOrId Either the ID of the TreeViewNodeEntry that is the target of the operation, or the TreeViewNodeEntry itself.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs} buildArgs The collapse args to go along with the action.
    @param {Function} callback The function to call once the action operation completes (regardless if it was successful, failed, skipped, or canceled).*/
    var toggleFromTreeView = function(treeViewEntry, nodeOrId, expandCollapseArgs, callback)
    {
        invokeFromTreeView(NodeAction.Toggle, treeViewEntry, nodeOrId, expandCollapseArgs, callback);
    };

    /**Triggers a build operation that will re-bind the user's Binding for the TreeNode and then build the node's child list of nodes if it has one.
    @param {TreeViewNodeEntry} nodeEntry The TreeViewNodeEntry that will be built.
    @param {EVUI.Modules.TreeView.BuildTreeViewNodeArgs} buildArgs The arguments that describe the options for the build operation.
    @param {Function} callback The function to call once the action operation completes (regardless if it was successful, failed, skipped, or canceled).*/
    var triggerBuild = function (nodeEntry, buildArgs, callback)
    {
        if (typeof buildArgs === "function")
        {
            callback = buildArgs;
            buildArgs = null;
        }

        if (typeof callback !== "function") callback = function () { };
        buildArgs = getBuildArgs(nodeEntry, buildArgs);

        var opSession = new OperationSession();
        opSession.action = NodeAction.Build;
        opSession.buildArgs = buildArgs;
        opSession.callback = callback;
        opSession.nodeEntry = nodeEntry;
        opSession.context = (buildArgs.context == null) ? {} : buildArgs.context;

        var callbackItem = new CallbackEntry();
        callbackItem.callback = callback;
        callbackItem.operationSession = opSession;

        opSession.callback = callbackItem;

        queueOperationSession2(nodeEntry, opSession);
    };

    /**Triggers an expand operation that will re-build the user's Binding for the TreeNode, then build/re-build it's child list, then expand the node so that it's children are visible.
    @param {TreeViewNodeEntry} nodeEntry The TeeeViewNodeEntry that will be expanded.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs} expandCollapseArgs The arguments that contain the options for the expand operation.
    @param {Function} callback The function to call once the action operation completes (regardless if it was successful, failed, skipped, or canceled).*/
    var triggerExpand = function (nodeEntry, expandCollapseArgs, callback)
    {
        if (typeof expandCollapseArgs === "function")
        {
            callback = expandCollapseArgs;
            expandCollapseArgs = null;
        }

        if (typeof callback !== "function") callback = function () { };
        if (expandCollapseArgs == null) expandCollapseArgs = new EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs();
        expandCollapseArgs.buildArgs = getBuildArgs(nodeEntry, expandCollapseArgs.buildArgs);

        var opSession = new OperationSession();
        opSession.action = NodeAction.Expand;
        opSession.expandCollapseArgs = expandCollapseArgs;
        opSession.buildArgs = expandCollapseArgs.buildArgs;
        opSession.callback = callback;
        opSession.nodeEntry = nodeEntry;

        //get the context object, which can be in both the build args or the expand args. Take the one that is "most specific" to the operation (expand) and fall back to the less specific one (build)
        if (expandCollapseArgs.context != null)
        {
            opSession.context = expandCollapseArgs.context;
        }
        else if (expandCollapseArgs.buildArgs.context != null)
        {
            opSession.context = expandCollapseArgs.buildArgs.context;
        }
        else //no context found, just supply a dummy object
        {
            opSession.context = {};
        }

        var callbackItem = new CallbackEntry();
        callbackItem.callback = callback;
        callbackItem.operationSession = opSession;

        opSession.callback = callbackItem;

        queueOperationSession2(nodeEntry, opSession);
    }

    /**Triggers a collapse operation that will hide node's list of children.
    @param {TreeViewNodeEntry} nodeEntry The TreeViewNodeEntry that will have its child list collapsed.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs} expandCollapseArgs The arguments that contain the details for the collapse operation.
    @param {Function} callback The function to call once the action operation completes (regardless if it was successful, failed, skipped, or canceled).*/
    var triggerCollapse = function (nodeEntry, expandCollapseArgs, callback)
    {
        if (typeof expandCollapseArgs === "function")
        {
            callback = expandCollapseArgs;
            expandCollapseArgs = null;
        }

        if (typeof callback !== "function") callback = function () { };
        if (expandCollapseArgs == null) expandCollapseArgs = new EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs();



        var opSession = new OperationSession();
        opSession.action = NodeAction.Collapse;
        opSession.expandCollapseArgs = expandCollapseArgs;
        opSession.callback = callback;
        opSession.nodeEntry = nodeEntry;

        //get the context object, which should be in the expand/collapse args for a collapse operation
        if (expandCollapseArgs.context != null)
        {
            opSession.context = expandCollapseArgs.context;
        }
        else if (expandCollapseArgs.buildArgs != null && expandCollapseArgs.buildArgs.context != null) //if for some reason there are build args for a collapse operation (which won't be used) and the collapse args didn't have a context, get it from the build args
        {
            opSession.context = expandCollapseArgs.buildArgs.context;
        }
        else //otherwise just supply a dummy object.
        {
            opSession.context = {};
        }

        var callbackItem = new CallbackEntry();
        callbackItem.callback = callback;
        callbackItem.operationSession = opSession;

        opSession.callback = callbackItem;

        queueOperationSession2(nodeEntry, opSession);
    };

    /**Toggles the behavior of the TreeViewNode to do the opposite of its current operation or state.
    @param {TreeViewNodeEntry} nodeEntry The node being acted upon.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs} expandCollapseArgs The arguments for the expand/collapse operation.
    @param {Function} callback A callback function to execute once the operation completes.*/
    var triggerToggle = function (nodeEntry, expandCollapseArgs, callback)
    {
        if (nodeEntry.operation != null) //if we're in the middle of doing an expand or collapse, do the opposite
        {
            if (nodeEntry.operation.action === NodeAction.Expand)
            {
                return triggerCollapse(nodeEntry, expandCollapseArgs, callback)
            }
            else if (nodeEntry.operation.action === NodeAction.Collapse)
            {
                return triggerExpand(nodeEntry, expandCollapseArgs, callback)
            }
        }

        //if we weren't in the middle of either operation, use the visibility flag to determine which action to take
        if (nodeEntry.expanded === true)
        {
            return triggerCollapse(nodeEntry, expandCollapseArgs, callback);
        }
        else
        {
            return triggerExpand(nodeEntry, expandCollapseArgs, callback);
        }
    };

    /**Creates a BuildTreeViewNodeArgs object based on a YOLO build args object, or fills in the build args with values from the node that is being built. This ensures that the logic downstream can always just use the build args for performing build operations regardless if the user supplied them or not.
    @param {TreeViewNodeEntry} nodeEntry The node being built.
    @param {EVUI.Modules.TreeView.BuildTreeViewNodeArgs} buildArgs A YOLO build args object.
    @returns {EVUI.Modules.TreeView.BuildTreeViewNodeArgs}*/
    var getBuildArgs = function (nodeEntry, buildArgs)
    {
        if (buildArgs == null) buildArgs = new EVUI.Modules.TreeView.BuildTreeViewNodeArgs();
        if (buildArgs.bindingTemplate == null) buildArgs.bindingTemplate = nodeEntry.bindingTemplate;
        if (buildArgs.buildMode == null) buildArgs.buildMode = EVUI.Modules.TreeView.TreeViewNodeBuildMode.Update;
        if (buildArgs.childListName == null) buildArgs.childListName = nodeEntry.childListName;
        if (buildArgs.options == null) buildArgs.options = nodeEntry.options;
        if (buildArgs.optionsMode == null) buildArgs.optionsMode = nodeEntry.optionsMode;
        if (buildArgs.source == null) buildArgs.source = nodeEntry.source;

        return buildArgs;
    }

    /**Calculates the correct action to take when a TreeViewNode is told to perform an operation. This takes into consideration the current state and operation of the node and acts appropriately to eliminate race conditions by "switching gears" between the different operations available.
    @param {TreeViewNodeEntry} nodeEntry The node being asked to perform an operation.
    @param {OperationSession} opSession The new operation session to evaluate.*/
    var queueOperationSession2 = function (nodeEntry, opSession)
    {
        if (opSession == null) return;

        //figure out what the correct action is to take with the new operation session
        var actionSequence = getActionSequence(nodeEntry, opSession);
        if (actionSequence == null) return;        

        if (actionSequence.cancelCurrent === true) //was given an "opposite" command to its current action - stop current operation and begin a new one
        {
            return cancelOperation(nodeEntry, opSession);
        }
        else if (actionSequence.continueAfter === true) //was given an command that can wait for the current operation to finish before starting and still do what the user expects
        {
            return continueAfter(nodeEntry, opSession)
        }
        else if (actionSequence.skip === true) //was issued a redundant command, perform no action but call its callback at the appropriate time.
        {
            return skipOperation(nodeEntry, opSession);
        }
        else //otherwise, begin the operation
        {
            startOperation(opSession, actionSequence);
        }
    };

    /**Begins an operation for a TreeViewNode to perform by setting the state of the node and building and kicking off the appropriate event stream.
    @param {OperationSession} opSession The metadata about the operation to perform.
    @param {ActionSequence} actionSequence The metadata about the sequence of actions that will be performed.*/
    var startOperation = function (opSession, actionSequence)
    {
        //set the previously completed node state to roll back to in the event of a cancellation of the operation
        opSession.nodeEntry.previousCompletedNodeState = opSession.nodeEntry.nodeState;

        //set the "action state" of the node so the user/downstream logic knows what the node is beginning to do
        if (opSession.action === NodeAction.Build)
        {
            opSession.nodeEntry.nodeState = EVUI.Modules.TreeView.TreeViewNodeState.Building;
        }
        else if (opSession.action === NodeAction.Expand)
        {
            opSession.nodeEntry.nodeState = EVUI.Modules.TreeView.TreeViewNodeState.Expanding;
        }
        else if (opSession.action === NodeAction.Collapse)
        {
            opSession.nodeEntry.nodeState = EVUI.Modules.TreeView.TreeViewNodeState.Collapsing;
        }

        buildEventStream(opSession, actionSequence);

        opSession.nodeEntry.operation = opSession;
        opSession.eventStream.execute();
    };

    /**Cancels the current operation and queues up the next operation as a continuation to execute once the current operation's cancellation is complete.
    @param {TreeViewNodeEntry} nodeEntry The node that is having its current operation canceled.
    @param {OperationSession} nextOpSession The operation session that caused the cancellation of the current operation and will begin once the current operation's cancellation is complete.*/
    var cancelOperation = function (nodeEntry, nextOpSession)
    {
        nodeEntry.operation.canceled = true;        

        //if we already have a continuation, we need to roll up all the callbacks from the other continuations into a single callback stack to make sure that every callback from all the operations we're canceling get called when the next operation finishes.
        var curContinuation = nodeEntry.operation.continuation;
        while (curContinuation != null)
        {
            if (curContinuation.callbackStack.indexOf(curContinuation.callback) === -1) curContinuation.callbackStack.push(curContinuation.callback);
            nextOpSession.callbackStack = nextOpSession.callbackStack.concat(curContinuation.callbackStack);
            curContinuation = curContinuation.continuation;
        }

        //now that everything has been rolled up into the next operation, we can set it up as the "continuation" of the canceled operation that will get launched in finishOperation()
        nodeEntry.operation.continuation = nextOpSession;
        nextOpSession.isContinuation = true;

        if (nodeEntry.operation.eventStream == null || nodeEntry.operation.eventStream.isWorking() === false) //if the operation being canceled hasn't started yet we can just "finish" it and kick off the continuation
        {
            finishOperation(nodeEntry.operation);
        }
        else //otherwise we cancel the operation (asynchronously) and wait for the final step to call finishOperation, but reset the state first so incoming commands don't do the wrong thing
        {
            nodeEntry.operation.eventStream.cancel();
            restorePreviousNodeState(nodeEntry);
        }
    };

    /**Sets up the operation session to begin once the current operation completes.
    @param {TreeViewNodeEntry} nodeEntry The node that is having its next operation queued.
    @param {OperationSession} nextOpSession The operation session to queue.*/
    var continueAfter = function (nodeEntry, nextOpSession)
    {
        //tack the continuation onto the last continuation already attached to the node entry so it fires at after the others have finished
        var lastContinuation = getLastContinuationOpSession(nodeEntry);
        if (lastContinuation == null)
        {
            nodeEntry.operation.continuation = nextOpSession;
        }
        else
        {
            lastContinuation.continuation = nextOpSession;
        }

        nextOpSession.isContinuation = true;
    };

    /**Either queues a callback to be called or immediately calls a callback based on a redundant operation being issues (i.e. collapse when the node is already collapsed).
    @param {TreeViewNodeEntry} nodeEntry The node who is being issued a redundant command.
    @param {OperationSession} nextOpSession The redundant operation.*/
    var skipOperation = function (nodeEntry, nextOpSession)
    {
        if (nodeEntry.operation == null) //node was at a state of rest and was issued a command that would not change its state
        {
            finishOperation(nextOpSession);
        }
        else //node is in the middle of performing an operation, call the callback once it finishes
        {
            nodeEntry.operation.callbackStack.push(nextOpSession.callback);
        }
    };

    /**Walks down the chain of continuations for a given TreeViewNodeEntry and returns the last one.
    @param {TreeViewNodeEntry} nodeEntry The node to get the last continuation for.
    @returns {OperationSession}*/
    var getLastContinuationOpSession = function (nodeEntry)
    {
        if (nodeEntry.operation == null) return null;

        var next = nodeEntry.operation;
        while (next != null)
        {
            var continuation = next.continuation;
            if (continuation == null) break;

            next = continuation;
        }

        return next;
    };

    /**Completes an operation and either calls the operation's callback, or invokes the next continuation operation.
    @param {OperationSession} opSession The operation to complete.
    @param {Function} callback A callback function to call once the operation has been completed.*/
    var finishOperation = function (opSession, callback)
    {
        if (typeof callback !== "function") callback = function () { };

        opSession.nodeEntry.operation = null;
        opSession.callbackStack.push(opSession.callback); //the callback for the op session isn't in it's own stack, so we add it here

        if (opSession.continuation != null) //if we have another action we're doing after this one, add this operation's callback stack to the next one and kick off the next operation
        {
            if (opSession.canceled === true)
            {
                restorePreviousNodeState(opSession.nodeEntry);
            }

            opSession.continuation.callbackStack = opSession.continuation.callbackStack.concat(opSession.callbackStack);
            queueOperationSession2(opSession.nodeEntry, opSession.continuation);
            return callback();
        }

        //sort all the callbacks in the order in which they were added so they fire in the order the user expects them to
        opSession.callbackStack.sort(function (a, b) { return a.operationSession.operationId - b.operationSession.operationId });

        var callbacks = [];
        var numCallbacks = opSession.callbackStack.length;
        for (var x = 0; x < numCallbacks; x++)
        {
            callbacks.push(opSession.callbackStack[x].callback);
        }

        var exeArgs = new EVUI.Modules.Core.AsyncSequenceExecutionArgs();
        exeArgs.functions = callbacks;

        EVUI.Modules.Core.AsyncSequenceExecutor.execute(exeArgs, function ()
        {
            if (opSession.canceled === true)
            {
                restorePreviousNodeState(opSession.nodeEntry);
            }

            callback();
        })
    };

    /**Reverts the nodeState of a tree view back to it's current state in the event of a cancellation.
    @param {TreeViewNodeEntry} nodeEntry The node whose operation was canceled.*/
    var restorePreviousNodeState = function (nodeEntry)
    {
        if (nodeEntry.previousCompletedNodeState === EVUI.Modules.TreeView.TreeViewNodeState.None) return;

        nodeEntry.nodeState = nodeEntry.previousCompletedNodeState;
        nodeEntry.previousCompletedNodeState = EVUI.Modules.TreeView.TreeViewNodeState.None;
    };

    /**Adds all the steps and configuration settings for the EventStream that will execute the operation.
    @param {OperationSession} opSession The operation to execute.
    @param {ActionSequence} actionSequence The details of the actions that the EventStream will execute.*/
    var buildEventStream = function (opSession, actionSequence)
    {
        opSession.eventStream = new EVUI.Modules.EventStream.EventStream();
        opSession.eventStream.context = opSession.nodeEntry.node;

        opSession.eventStream.onCancel = function ()
        {
            opSession.canceled = true;
            opSession.eventStream.seek("finishOperation");
        };

        opSession.eventStream.onError = function ()
        {
            opSession.canceled = true;
            opSession.eventStream.seek("finishOperation");
        };

        opSession.eventStream.processInjectedEventArgs = function (eventStreamArgs)
        {
            var treeViewArgs = new EVUI.Modules.TreeView.TreeViewEventArgs(opSession.nodeEntry);
            treeViewArgs.cancel = function () { return eventStreamArgs.cancel(); };
            treeViewArgs.key = eventStreamArgs.key;
            treeViewArgs.pause = function () { return eventStreamArgs.pause(); };
            treeViewArgs.resume = function () { return eventStreamArgs.resume(); };
            treeViewArgs.stopPropagation = function () { return eventStreamArgs.stopPropagation(); };
            treeViewArgs.context = opSession.context;      

            return treeViewArgs;
        };

        opSession.eventStream.processReturnedEventArgs = function (treeViewArgs)
        {
            opSession.context = treeViewArgs.context;
        };

        var numActions = actionSequence.actions.length;
        for (var x = 0; x < numActions; x++)
        {
            var action = actionSequence.actions[x];

            if (action === NodeAction.Build)
            {
                getBuildSteps(opSession);
            }
            else if (action === NodeAction.Collapse)
            {
                getCollapseSteps(opSession);
            }
            else if (action === NodeAction.Expand)
            {
                getExpandSteps(opSession);
            }
        }

        addFinalStep(opSession);
    };

    /**Adds the steps to the EventStream that will execute a build operation.
    @param {OperationSession} opSession The operation session being executed.*/
    var getBuildSteps = function (opSession)
    {
        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            key: EVUI.Modules.TreeView.Constants.Event_OnBuild,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                opSession.nodeEntry.nodeState = EVUI.Modules.TreeView.TreeViewNodeState.Building;

                if (typeof opSession.nodeEntry.node.onBuild === "function")
                {
                    return opSession.nodeEntry.node.onBuild(eventArgs);
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            key: EVUI.Modules.TreeView.Constants.Event_OnBuild,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.treeViewEntry.treeView.onBuild === "function")
                {
                    return opSession.nodeEntry.treeViewEntry.treeView.onBuild(eventArgs);
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            key: "buildNode",
            handler: function (jobEventArgs)
            {              
                if (canContinue(opSession) === false) return jobEventArgs.resolve();
                if (opSession.nodeEntry === opSession.nodeEntry.treeViewEntry.rootNode)
                {
                    onBuildRootNode(opSession, function (success)
                    {
                        if (isRecursiveBuildOperation(opSession) == true)
                        {
                            setChildNodeList(opSession.nodeEntry);
                        }

                        jobEventArgs.resolve();
                    });
                }
                else
                {
                    onBuildNode(opSession, function (success)
                    {
                        if (isRecursiveBuildOperation(opSession) === true)
                        {
                            setChildNodeList(opSession.nodeEntry);
                        }

                        jobEventArgs.resolve();
                    });
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            key: EVUI.Modules.TreeView.Constants.Event_OnBuildChildren,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.node.onBuildChildren === "function")
                {
                    return opSession.nodeEntry.node.onBuildChildren(eventArgs);
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            key: EVUI.Modules.TreeView.Constants.Event_OnBuildChildren,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.treeViewEntry.treeView.onBuildChildren === "function")
                {
                    return opSession.nodeEntry.treeViewEntry.treeView.onBuildChildren(eventArgs);
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            key: "buildChildren",
            handler: function (jobEventArgs)
            {
                if (canContinue(opSession) === false) return jobEventArgs.resolve();

                var showAfterBuild = false;
                var canRecurse = isRecursiveBuildOperation(opSession);
                if (opSession.nodeEntry.options.noTopNode === true && opSession.nodeEntry.parentNodeEntry == null) //if there's no top node the children need to be expanded by default, otherwise the tree is invisible
                {
                    showAfterBuild = true;
                }               

                var newNodeState = EVUI.Modules.TreeView.TreeViewNodeState.Collapsed;
                if (opSession.action === NodeAction.Expand && showAfterBuild === true) newNodeState = EVUI.Modules.TreeView.TreeViewNodeState.Expanded;
                if (opSession.nodeEntry.expanded === true) newNodeState = EVUI.Modules.TreeView.TreeViewNodeState.Expanded;

                if (canRecurse === true)
                {
                    bindChildNodeList(opSession.nodeEntry, function (listBound)
                    {
                        if (showAfterBuild === true)
                        {
                            onExpandNode(opSession, function ()
                            {
                                opSession.nodeEntry.nodeState = EVUI.Modules.TreeView.TreeViewNodeState.Expanded;
                                jobEventArgs.resolve();
                            });
                        }
                        else
                        {
                            opSession.nodeEntry.nodeState = newNodeState;
                            jobEventArgs.resolve();
                        }
                    });
                }
                else
                {
                    opSession.nodeEntry.nodeState = newNodeState;
                    jobEventArgs.resolve();
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            key: EVUI.Modules.TreeView.Constants.Event_OnChildrenBuilt,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.node.onChildrenBuilt === "function")
                {
                    return opSession.nodeEntry.node.onChildrenBuilt(eventArgs);
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            key: EVUI.Modules.TreeView.Constants.Event_OnChildrenBuilt,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.treeViewEntry.treeView.onChildrenBuilt === "function")
                {
                    return opSession.nodeEntry.treeViewEntry.treeView.onChildrenBuilt(eventArgs);
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            key: EVUI.Modules.TreeView.Constants.Event_OnBuilt,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.node.onBuilt === "function")
                {
                    return opSession.nodeEntry.node.onBuilt(eventArgs);
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            key: EVUI.Modules.TreeView.Constants.Event_OnBuilt,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.treeViewEntry.treeView.onBuilt === "function")
                {
                    return opSession.nodeEntry.treeViewEntry.treeView.onBuilt(eventArgs);
                }
            }
        });
    };

    /**Adds the final step to the EventStream that will invoke the callback or start the next operation if the operation has a continuation operation.
    @param {OperationSession} opSession The operation session having the final step added to its EventStream.*/
    var addFinalStep = function (opSession)
    {
        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            key: "finishOperation",
            handler: function (jobEventArgs)
            {
                onFinishOperation(opSession, function ()
                {
                    jobEventArgs.resolve();
                });
            }
        });
    };

    /**Determines whether or not a given operation will recursively build all of the nodes underneath itself.
    @param {OperationSession} opSession The operation session in progress.
    @returns {Boolean}*/
    var isRecursiveBuildOperation = function (opSession)
    {
        var canRecurse = false;
        if (opSession.buildArgs.recursive === true)
        {
            canRecurse = true;
        }
        else if (opSession.action === NodeAction.Expand) //expanding always builds the child nodes if the expandMode has been set to one of the "build" options
        {
            if (opSession.nodeEntry.options.expandMode === EVUI.Modules.TreeView.TreeViewNodeBuildMode.Rebuild) canRecurse = true;
            if (opSession.nodeEntry.options.expandMode === EVUI.Modules.TreeView.TreeViewNodeBuildMode.Update) canRecurse = true;
        }
        else if (opSession.nodeEntry.options.noTopNode === true && opSession.nodeEntry.parentNodeEntry == null) //we need to build the child nodes in a "no root node" scenario 
        {
            canRecurse = true;
        }
        else if (opSession.nodeEntry.options.lazy !== true) //if the lazy setting is NOT true, we are immediately building nodes and not waiting for the direct parent to expand before building.
        {
            var parentNode = opSession.nodeEntry.parentNodeEntry;
            if (parentNode == null) //the only node with no parent node is the root
            {
                canRecurse = true; //build everything if we started at the top node
            }
            else //this is a child node of some other node, only build if its direct parent is expanding
            {
                var parentOpSession = parentNode.operation;
                if (parentOpSession != null && parentOpSession.action === NodeAction.Expand) //only recurse if the direct parent is expanding
                {
                    canRecurse = true;
                }
            }
        }

        return canRecurse;
    };

    /**INvokes the logic that will perform the bind step of the operation on the user's settings for their binding of the TreeViewNode's contents.
    @param {OperationSession} opSession The operation in progress.
    @param {Function} callback The callback to call once the user's bind operation is complete.*/
    var onBuildNode = function (opSession, callback)
    {     
        executeUserBinding(opSession.nodeEntry, function (bindingBound)
        {
            callback(bindingBound);
        });
    };

    /**Builds the root TreeViewNodeEntry of the TreeView.
    @param {OperationSession} opSession The operation in progress that required that a root node be built.
    @param {Function} callback A callback function to call once the build operation is complete.*/
    var onBuildRootNode = function (opSession, callback)
    {
        opSession.nodeEntry.treeViewEntry.element = getValidRootElement(opSession.nodeEntry.treeViewEntry.element);

        //see if the tree view has a list node at all - if not, make one
        if (opSession.nodeEntry.treeViewEntry.rootListNode == null)
        {
            opSession.nodeEntry.treeViewEntry.rootListNode = makeChildListNode(opSession.nodeEntry, false);

            opSession.nodeEntry.treeViewEntry.rootListNode.classList.remove(EVUI.Modules.TreeView.Constants.CSS_ChildNodeList);

            opSession.nodeEntry.treeViewEntry.rootListNode.classList.add(EVUI.Modules.TreeView.Constants.CSS_TreeView);
            opSession.nodeEntry.treeViewEntry.rootListNode.classList.add(EVUI.Modules.TreeView.Constants.CSS_TreeViewRoot);
            opSession.nodeEntry.treeViewEntry.rootListNode.classList.add(opSession.nodeEntry.treeViewEntry.className);
            opSession.nodeEntry.treeViewEntry.rootListNode.classList.add(EVUI.Modules.TreeView.Constants.CSS_ChildNodeList);

            opSession.nodeEntry.treeViewEntry.element.appendChild(opSession.nodeEntry.treeViewEntry.rootListNode);
        }

        //see if the root node has a root element - make one, but don't attach it just yet. Normally for any other node the binder would take care of this, but because we're not doing a binding for the first node we just manually make it
        if (opSession.nodeEntry.rootElement == null)
        {
            //make the root node's LI and decorate it with the appropriate attributes to mark it as the root node
            opSession.nodeEntry.rootElement = document.createElement("li");
            opSession.nodeEntry.rootElement.classList.add(EVUI.Modules.TreeView.Constants.CSS_TreeViewNode);
            opSession.nodeEntry.rootElement.classList.add(EVUI.Modules.TreeView.Constants.CSS_TreeViewRootNode);
            opSession.nodeEntry.rootElement.setAttribute(EVUI.Modules.TreeView.Constants.Attr_NodeId, opSession.nodeEntry.nodeId.toString());
            opSession.nodeEntry.rootElement.setAttribute(EVUI.Modules.TreeView.Constants.Attr_Depth, "0");
            opSession.nodeEntry.rootElement.setAttribute(EVUI.Modules.TreeView.Constants.Attr_Ordinal, "0");

            //make the div that the user's content will be injected into
            opSession.nodeEntry.bindingElement = document.createElement("div");
            opSession.nodeEntry.bindingElement.classList.add(EVUI.Modules.TreeView.Constants.CSS_NodeInterior);

            opSession.nodeEntry.rootElement.append(opSession.nodeEntry.bindingElement);
            opSession.nodeEntry.treeViewEntry.rootListNode.append(opSession.nodeEntry.rootElement);

            if (opSession.nodeEntry.options.noTopNode === true)
            {
                opSession.nodeEntry.treeViewEntry.rootListNode.prepend(opSession.nodeEntry.rootElement);
                opSession.nodeEntry.rootElement.remove();
            }
        }

        //if we have no top node, we have to do a bit of trickery - we leave the rootNode's rootElement detached from the DOM (so it's not null, which reduces the amount of special case crap we'll have to do for it)
        //then we assign the listNode of the root element to be the actual wrapping list for the whole tree. If we nest inside the rootElement's list, we'll be indented one extra level and it won't look right without special CSS handling
        //which we don't want the user to have to do
        if (opSession.nodeEntry.options.noTopNode === true)
        {
            if (opSession.nodeEntry.listElement == null) opSession.nodeEntry.listElement = opSession.nodeEntry.treeViewEntry.rootListNode;
        }

        opSession.nodeEntry.treeViewEntry.treeState = EVUI.Modules.TreeView.TreeViewState.Ready;

        //once the setup for the root node is done, build it like a normal node
        onBuildNode(opSession, function (success)
        {
            callback(success);
        });
    };

    /**Adds the event stream steps for an expand operation. Also adds the "build" steps as part of the expand operation.
    @param {OperationSession} opSession The operation in progress.*/
    var getExpandSteps = function (opSession)
    {
        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            key: EVUI.Modules.TreeView.Constants.Event_OnExpand,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.node.onExpand === "function")
                {
                    return opSession.nodeEntry.node.onExpand(eventArgs);
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            key: EVUI.Modules.TreeView.Constants.Event_OnExpand,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.treeViewEntry.treeView.onExpand === "function")
                {
                    return opSession.nodeEntry.treeViewEntry.treeView.onExpand(eventArgs);
                }
            }
        });

        //expanding always involves building, so we add the build steps in the middle of the expand sequence.
        getBuildSteps(opSession);

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            key: "expandNode",
            handler: function (jobArgs)
            {
                if (canContinue(opSession) === false) return jobArgs.resolve();
                onExpandNode(opSession, function (success)
                {
                    opSession.nodeEntry.nodeState = EVUI.Modules.TreeView.TreeViewNodeState.Expanded;
                    jobArgs.resolve();
                });
            }
        })

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            key: EVUI.Modules.TreeView.Constants.Event_OnExpanded,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.node.onExpanded === "function")
                {
                    return opSession.nodeEntry.node.onExpanded(eventArgs);
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            key: EVUI.Modules.TreeView.Constants.Event_OnExpanded,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.treeViewEntry.treeView.onExpanded === "function")
                {
                    return opSession.nodeEntry.treeViewEntry.treeView.onExpanded(eventArgs);
                }
            }
        });
    };

    /**Performs the actual mechanics of showing a TreeViewNodeEntry's child list.
    @param {OperationSession} opSession The operation in progress.
    @param {Function} callback The callback to call once the expand operation has completed.*/
    var onExpandNode = function (opSession, callback)
    {
        if (opSession.nodeEntry.listElement == null) //no list element === no children, no work can be done
        {
            return callback(true);
        }

        var dh = new EVUI.Modules.Dom.DomHelper(opSession.nodeEntry.listElement);

        dh.removeClass(EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Hidden); //take off the class that creates the appearance of a collapsed list
        dh.addClass(EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Visible); //add the marker class that indicates an expanded child list
        opSession.nodeEntry.expanded = true;

        //get the transition effect to apply to the expansion of the child list. First see if the arguments has one, then fall back to the options's default transition
        var transition = (opSession.expandCollapseArgs == null) ? null : opSession.expandCollapseArgs.transition;
        if (transition == null) transition = opSession.nodeEntry.options.expandTransition;

        //apply the transition and don't continue until it is complete (if there was one).
        applyTransition(opSession.nodeEntry, transition, EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Expanding, dh, function (success)
        {
            callback(true)
        });
    };

    /**Performs the actual mechanics of hiding a TreeViewNodeEntry's child list.
    @param {OperationSession} opSession The operation in progress.
    @param {Function} callback The callback to call once the collapse operation has completed.*/
    var onCollapseNode = function (opSession, callback)
    {
        if (opSession.nodeEntry.listElement == null) //no list element === no children, no work to do
        {
            return callback(true);
        }

        var dh = new EVUI.Modules.Dom.DomHelper(opSession.nodeEntry.listElement);

        dh.removeClass(EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Visible); //remove the marker class for a visible list
        dh.addClass(EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Hidden); //add the class that actually hides the child list
        opSession.nodeEntry.expanded = false;

        //get the transition effect to apply to the expansion of the child list. First see if the arguments has one, then fall back to the options's default transition
        var transition = opSession.expandCollapseArgs.transition;
        if (transition == null) transition = opSession.nodeEntry.options.collapseTransition;

        //apply the transition and don't continue until it is complete (if there was one).
        applyTransition(opSession.nodeEntry, transition, EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Collapsing, dh, function (success)
        {
            callback(true)
        });
    };


    /**Applies a transition to the Pane.
    @param {TreeViewNodeEntry} entry The entry representing the pane having it's transition applied.
    @param {EVUI.Modules.TreeView.TreeViewNodeTransition} transition The transition to apply.
    @param {String} selector The class name that will be used to add the selector.
    @param {EVUI.Modules.Dom.DomHelper} element The element helper wrapping the element to get the transition.
    @param {Function} callback A callback to call once the operation completes or the function returns without adding a transition.*/
    var applyTransition = function (entry, transition, selector, element, callback)
    {
        if (typeof callback !== "function") callback = function (appliedTransition) { };
        if (entry == null || element == null) return callback(false);

        if (transition != null && transition.css != null) //if we have a transition, apply it instead of simple removing the display property.
        {
            if (transition.keyframes != null)
            {
                _services.stylesheetManager.setRules(EVUI.Modules.Styles.Constants.DefaultStyleSheetName, transition.keyframes);
            }

            if (typeof transition.css === "string") //if the css is a string, check to see if its a set of properties or selectors
            {
                var match = transition.css.match(/[\:\;]/g);
                if (match == null && match.length === 0) //if the RegEx didn't match, it's (probably) not a rule.
                {
                    selector = transition.css;
                    element.addClass(selector);
                }
            }
            else
            {
                var className = "." + entry.treeViewEntry.className + "." + ((entry.expanded === true) ? EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Expanding : EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Collapsing);

                //otherwise make a new style using the provided rules
                _services.stylesheetManager.setRules(EVUI.Modules.Styles.Constants.DefaultStyleSheetName, className, transition.css);
                element.addClass(selector);
            }

            if (entry.transitionTimeoutID !== -1)
            {
                element.removeClass(entry.transitionSelector);
                clearTimeout(entry.transitionTimeoutID);

                if (typeof entry.transitionCallback === "function")
                {
                    entry.transitionCallback();
                    entry.transitionCallback = null;
                }
            }

            entry.transitionCallback = function ()
            {
                entry.transitionCallback = null;
                entry.transitionTimeoutID = -1;
                entry.transitionSelector = null;

                element.removeClass(selector);
                callback(true);
            };

            entry.transitionSelector = selector;
            entry.transitionTimeoutID = setTimeout(function ()
            {
                if (typeof entry.transitionCallback === "function") entry.transitionCallback();
            }, transition.duration);
        }
        else //no transition, just show the element
        {
            if (entry.transitionTimeoutID !== -1)
            {
                element.removeClass(entry.transitionSelector);
                clearTimeout(entry.transitionTimeoutID);

                if (typeof entry.transitionCallback === "function")
                {
                    entry.transitionCallback();
                    entry.transitionCallback = null;
                }

                entry.transitionSelector = null;
                entry.transitionTimeoutID = -1;
            }

            callback(false);
        }
    };

    /**Performs the final steps that always apply when the EventStream for a given operation ends, regardless of success or failure.
    @param {OperationSession} opSession The operation in progress.
    @param {Function} callback A callback to call once all the other callbacks are called.*/
    var onFinishOperation = function (opSession, callback)
    {
        finishOperation(opSession, function ()
        {
            callback();
        });
    }

    /**Adds the CSS rules to the default style sheet required for the showing and hiding of child node lists. */
    var buildExpandCollapseCSSRules = function ()
    {
        if (_classesSet === true) return;
        _classesSet = true;

        //the hide class reduces the height to zero and hides the overflow, which allows for a transition to be applied whereas doing a display:none would not
        _services.stylesheetManager.setRules(EVUI.Modules.Styles.Constants.DefaultStyleSheetName, "." + EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Hidden, { height: "0px", overflow: "hidden" });

        //the show class simply nulls out the height from the show class so it returns to its original height
        _services.stylesheetManager.setRules(EVUI.Modules.Styles.Constants.DefaultStyleSheetName, "." + EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Visible, { height: null });
    };

    /**Adds the steps for collapsing a node's child list to the EventStream.
    @param {OperationSession} opSession The operation in progress.*/
    var getCollapseSteps = function (opSession)
    {
        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            key: EVUI.Modules.TreeView.Constants.Event_OnCollapse,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                opSession.nodeEntry.nodeState = EVUI.Modules.TreeView.TreeViewNodeState.Collapsing;

                if (typeof opSession.nodeEntry.node.onCollapse === "function")
                {
                    return opSession.nodeEntry.node.onCollapse(eventArgs);
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            key: EVUI.Modules.TreeView.Constants.Event_OnCollapse,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.treeViewEntry.treeView.onCollapse === "function")
                {
                    return opSession.nodeEntry.treeViewEntry.treeView.onCollapse(eventArgs);
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.Job,
            key: "expandNode",
            handler: function (jobArgs)
            {
                if (canContinue(opSession) === false) return jobArgs.resolve();
                onCollapseNode(opSession, function (success)
                {
                    opSession.nodeEntry.nodeState = EVUI.Modules.TreeView.TreeViewNodeState.Collapsed;
                    jobArgs.resolve();
                });
            }
        })

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.Event,
            key: EVUI.Modules.TreeView.Constants.Event_OnCollapseed,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.node.onCollapseed === "function")
                {
                    return opSession.nodeEntry.node.onCollapseed(eventArgs);
                }
            }
        });

        opSession.eventStream.addStep({
            type: EVUI.Modules.EventStream.EventStreamStepType.GlobalEvent,
            key: EVUI.Modules.TreeView.Constants.Event_OnCollapseed,
            handler: function (eventArgs)
            {
                if (canContinue(opSession) === false) return;
                if (typeof opSession.nodeEntry.treeViewEntry.treeView.onCollapseed === "function")
                {
                    return opSession.nodeEntry.treeViewEntry.treeView.onCollapseed(eventArgs);
                }
            }
        });
    };

    /**Determines whether or not an operation in progress can continue or should be skipped over and aborted.
    @param {OperationSession} opSession The operation in progress.
    @returns {Boolean} */
    var canContinue = function (opSession)
    {
        if (opSession.canceled === true) return false;
        if (opSession.nodeEntry.nodeState === EVUI.Modules.TreeView.TreeViewNodeState.Disposed) return false;

        return true;
    };

    /**Gets all the children for a given TreeViewNodeEntry's source object.
    @param {TreeViewNodeEntry} nodeEntry The TreeViewNodeEntry to get the children for.
    @returns {[]} */
    var getChildren = function (nodeEntry)
    {
        if (nodeEntry.childListName == null) return null;

        var childListNameType = typeof nodeEntry.childListName;
        if (childListNameType === "string" || childListNameType === "symbol")
        {
            return (nodeEntry.source != null) ? EVUI.Modules.Core.Utils.getValue(nodeEntry.childListName, nodeEntry.source) : null;
        }
        else if (childListNameType === "function")
        {
            try
            {
                return nodeEntry.childListName(nodeEntry.source)
            }
            catch (ex)
            {
                EVUI.Modules.Core.Utils.log("Failed to get child list: ");
                EVUI.Modules.Core.Utils.log(ex);
                return null;
            }
        }
        else
        {
            return null;
        }
    };

    /**Performs the data binding for the wrapper elements for the user's DOM nodes.
    @param {TreeViewNodeEntry} nodeEntry The node to build the child list for.
    @param {Function} callback A callback function to call once the binding operation is complete.*/
    var bindChildNodeList = function(nodeEntry, callback)
    {
        //make the internal list of TreeViewNodeEntries representing the children we will stamp out nodes for
        var newChildren = setChildNodeList(nodeEntry);
        var numChildren = newChildren.length;

        //set the dummy "stubs" that are the anchor for the child list data binding sites
        setStubList(nodeEntry);

        if (numChildren === 0) //no children, get rid of the child list element as it is not needed anymore
        {
            if (nodeEntry.listElement != null)
            {
                nodeEntry.listElement.remove();
                nodeEntry.listElement = null;
            }

            return callback(true);
        }

        //have children, but not a list element. Go make it and add it to the end of the current node's wrapper so we have a place to stick the child nodes
        if (nodeEntry.listElement == null)
        {
            nodeEntry.listElement = makeChildListNode(nodeEntry, true);
            nodeEntry.rootElement.append(nodeEntry.listElement);
        }

        //make a quick lookup table for the nodes based on their ID's so we can quickly go look them up in onStubListItemBound without looping over a potentially large list of nodes over and over
        var childNodeDic = EVUI.Modules.Core.Utils.toDictionary(nodeEntry.childNodeEntries, function (item) { return item.nodeId });

        var context = new StubBindingContext();
        context.childNodes = childNodeDic;
        context.parentNodeEntry = nodeEntry;

        //if we can safely trigger an update for the current binding (i.e. it exists and we're not in a state where the options disallows it), use the binder's update functionality
        if (nodeEntry.childListBinding != null || (nodeEntry.childListBinding != null && nodeEntry.options.expandMode !== EVUI.Modules.TreeView.TreeViewNodeBuildMode.Rebuild))
        {
            context.reBinding = true;

            nodeEntry.childListBinding.update({
                bindingContext: context,
                bindingSource: nodeEntry.childListStubs,
            },function (binding)
            {
                //once complete with the update of the node entry scaffold for the user's bindings, go through and build each user binding in the child list. This will put the user's content in the right order in the tree view that reflects the data model
                var numToBind = nodeEntry.childNodeEntries.length;
                var numBound = 0;
                var commonCallback = function ()
                {
                    numBound++;
                    if (numBound === numToBind)
                    {
                        callback(true);
                    }
                }

                for (var x = 0; x < numToBind; x++)
                {
                    triggerBuild(nodeEntry.childNodeEntries[x], null, function ()
                    {
                        commonCallback();
                    });
                }
            });
        }
        else //otherwise we have no binding or are set to force a (slower) rebuild
        {
            _services.bindingController.bind({
                element: nodeEntry.listElement,
                source: nodeEntry.childListStubs,
                htmlContent: "<li " + getNodeAttributeString() + " ><div class=\"" + EVUI.Modules.TreeView.Constants.CSS_NodeInterior + "\"></div></li>",
                insertionMode: EVUI.Modules.Binding.BindingInsertionMode.Append,
                bindingContext: context,
                onBind: function (eventArgs)
                {
                    if (EVUI.Modules.Core.Utils.isArray(eventArgs.binding.source) === true) //if the source object for the binding is an array, it's the binding that holds the slots for all the user bindings
                    {
                        nodeEntry.childListBinding = eventArgs.binding;
                    }
                },
                onBound: function (eventArgs)
                {
                    eventArgs.pause();

                    //for every part of the binding scaffold bound, go fire off the user's binding for that slot in the tree
                    onStubListItemBound(eventArgs.context, eventArgs.binding, function ()
                    {
                        eventArgs.resume();
                    });                    
                }
            }, function ()
            {
                callback(true);
            });
        }        
    };

    /**Gets a string of all the standard attributes to attach to the node exterior wrappers for the user's content. These are to allow CSS selectors to target nodes based on their hierarchy or ordinals.
    @returns {String}*/
    var getNodeAttributeString = function ()
    {
        var attributes = EVUI.Modules.TreeView.Constants.Attr_NodeId + "=\"{{nodeId}}\" ";
        attributes += EVUI.Modules.TreeView.Constants.Attr_Depth + "=\"{{depth}}\" ";
        attributes += EVUI.Modules.TreeView.Constants.Attr_Ordinal + "=\"{{ordinal}}\" ";

        return attributes;
    };

    /**Binds or updates the Binding that is binding the user's content to it's respective node.
    @param {TreeViewNodeEntry} nodeEntry The node entry having its binding built.
    @param {Function} callback A callback to call once the user's binding has completed.*/
    var executeUserBinding = function (nodeEntry, callback)
    {
        //if we're expanding and have previously bound node but are in manual mode, do not execute the binding.
        if (nodeEntry.operation != null && nodeEntry.operation.action === NodeAction.Expand && nodeEntry.binding != null && nodeEntry.options.expandMode === EVUI.Modules.TreeView.TreeViewNodeBuildMode.Manual)
        {
            return callback(true);
        }

        //remove any event handlers already added so we don't add redundant ones and cause a memory leak
        detachUserEvents(nodeEntry);

        if (nodeEntry.binding != null && nodeEntry.options.expandMode !== EVUI.Modules.TreeView.TreeViewNodeBuildMode.Rebuild) //if there's already a binding, we just update it
        {
            if (nodeEntry.bindingTemplate != null && (typeof nodeEntry.bindingTemplate === "string"
                || nodeEntry.binding.templateName !== nodeEntry.bindingTemplate.templateName
                || nodeEntry.bindingTemplateChanged === true)) //if the template has been changed, apply it to the binding
            {
                nodeEntry.binding.applyBindingTemplate(nodeEntry.bindingTemplate);
            }

            //trigger the update
            nodeEntry.binding.update(nodeEntry.source, function (binding)
            {
                if (binding.bindingCompletionState === EVUI.Modules.Binding.BindingCompletionState.Success || binding.bindingCompletionState === EVUI.Modules.Binding.BindingCompletionState.Queued)
                {
                    attachAllUserEvents(nodeEntry);
                    if (nodeEntry.childListBinding != null && EVUI.Modules.Core.Utils.isOrphanedNode(nodeEntry.childListBinding.element) === true)
                    {
                        nodeEntry.rootElement.append(nodeEntry.childListBinding.element);
                    }

                    return callback(true);
                }
                else
                {
                    return callback(false);
                }
            });
        }
        else //no binding yet, make a fresh one
        {
            nodeEntry.bindingTemplate.insertionMode = EVUI.Modules.Binding.BindingInsertionMode.Append; //we will always append, no matter what the user tells us to do

            _services.bindingController.bind(nodeEntry.bindingTemplate, { bindingSource: nodeEntry.source, bindingTarget: nodeEntry.bindingElement }, function (binding)
            {
                nodeEntry.binding = binding;
                if (binding.bindingCompletionState === EVUI.Modules.Binding.BindingCompletionState.Success || binding.bindingCompletionState === EVUI.Modules.Binding.BindingCompletionState.Queued)
                {
                    attachAllUserEvents(nodeEntry);
                    if (nodeEntry.childListBinding != null && EVUI.Modules.Core.Utils.isOrphanedNode(nodeEntry.childListBinding.element) === true)
                    {
                        nodeEntry.rootElement.append(nodeEntry.childListBinding.element);
                    }

                    return callback(true);
                }
                else
                {
                    return callback(false);
                }
            });
        }
    };

    /**Attaches all of the user events indicated by the use of the expanOn, collapseOn, and toggleOn attributes and, if those are not present, attaches an automatic expand/collapse event handler.
    @param {TreeViewNodeEntry} nodeEntry The node having its events attached.*/
    var attachAllUserEvents = function (nodeEntry)
    {
        if (nodeEntry == null || nodeEntry.binding == null) return;

        //go attach any and all events indicated by the use of the special attributes
        var numExpand = attachUserEvents(nodeEntry, EVUI.Modules.TreeView.Constants.Attr_ExpandOn);
        var numCollapse = attachUserEvents(nodeEntry, EVUI.Modules.TreeView.Constants.Attr_CollapseOn);
        var numToggle = attachUserEvents(nodeEntry, EVUI.Modules.TreeView.Constants.Attr_ToggleOn);

        //if none were attached and auto-toggle is true, rig up a handler on the root bound content's wrapping element.
        if (numExpand === 0 && numCollapse === 0 && numToggle === 0 && nodeEntry.options.autoToggle === true)
        {
            var handler = function (eventArgs)
            {
                triggerToggle(nodeEntry);
            };

            nodeEntry.binding.element.addEventListener("click", handler);

            //make a binding entry for it so we can detach it later in the event of a re-bind or disposal
            var entry = new EventHandlerBinding();
            entry.element = nodeEntry.binding.element;
            entry.eventName = "click";
            entry.handler = handler;

            nodeEntry.eventBindings.push(entry);
        }
    };

    /**Attaches the event handlers for a given action given the attribute value for the action to take. 
    @param {TreeViewNodeEntry} nodeEntry The node being processed for expand/collapse/toggle operations.
    @returns {Number}*/
    var attachUserEvents = function (nodeEntry, attributeName)
    {
        if ((attributeName !== EVUI.Modules.TreeView.Constants.Attr_CollapseOn &&
            attributeName !== EVUI.Modules.TreeView.Constants.Attr_ExpandOn &&
            attributeName !== EVUI.Modules.TreeView.Constants.Attr_ToggleOn) ||
            EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(attributeName) === true)
        {
            return 0;
        }

        var matches = new EVUI.Modules.Dom.DomHelper(nodeEntry.bindingElement, "[" + attributeName + "]");

        var numEntries = 0;
        var numMatches = matches.elements.length;
        for (var x = 0; x < numMatches; x++)
        {
            var curMatch = matches.elements[x];
            var userEvents = curMatch.getAttribute(attributeName);
            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(userEvents) === true) continue;

            userEvents = userEvents.trim().split(/\s+/);

            var numEvents = userEvents.length;
            for (var y = 0; y < numEvents; y++)
            {
                var eventName = userEvents[x];
                var handler = null;
                if (attributeName === EVUI.Modules.TreeView.Constants.Attr_CollapseOn)
                {
                    handler = function (eventArgs)
                    {
                        triggerCollapse(nodeEntry);
                    };
                }
                else if (attributeName === EVUI.Modules.TreeView.Constants.Attr_ExpandOn)
                {
                    handler = function (eventArgs)
                    {
                        triggerExpand(nodeEntry);
                    };
                }
                else if (attributeName === EVUI.Modules.TreeView.Constants.Attr_ToggleOn)
                {
                    handler = function (eventArgs)
                    {
                        triggerToggle(nodeEntry);
                    };
                }

                curMatch.addEventListener(eventName, handler);

                //add it to our registry of attached handlers so we can detach it later if we re-bind the node or dispose it so we don't cause redundant handlers or memory leaks
                var entry = new EventHandlerBinding();
                entry.element = curMatch;
                entry.eventName = eventName;
                entry.handler = handler;

                numEntries = nodeEntry.eventBindings.push(entry)
            }
        }

        return numEntries;
    };

    /**De-registers all event handlers with a given user binding.
    @param {TreeViewNodeEntry} nodeEntry The node entry to remove the event handlers from.*/
    var detachUserEvents = function (nodeEntry)
    {
        var numBindings = nodeEntry.eventBindings.length
        for (var x = 0; x < numBindings; x++)
        {
            var curEvent = nodeEntry.eventBindings[x];
            curEvent.element.removeEventListener(curEvent.eventName, curEvent.handler);
        }

        nodeEntry.eventBindings.splice(0, numBindings);
    };

    /**When a binding stub's binding is complete, this associates the resulting DOM node's area for the user's binding and triggers the execution of the user's binding.
    @param {StubBindingContext} context The contextual information about the stub item being bound.
    @param {EVUI.Modules.Binding.Binding} binding The Binding that was just produced for the binding stub.
    @param {Function} callback A callback function to call once the user's binding has been bound or updated.*/
    var onStubListItemBound = function (context, binding, callback)
    {
        if (EVUI.Modules.Core.Utils.isArray(binding.source) === true) //if the source of the binding is the array, it means all the children are done
        {
            //its possible that a node build was canceled and should be removed from the final DOM content/model. If so we need to update the tree again so that the nodes have the correct ordinal attribute on them 
            var numToDispose = context.nodesToDispose.length;
            if (numToDispose === 0) return callback();

            for (var x = 0; x < numToDispose; x++)
            {
                var nodeToDispose = context.nodesToDispose[x];
                disposeTreeViewNode(nodeToDispose);
            }

            //detach the onBound event handler that would otherwise trigger the re-binding of the user's binding, which we don't want in this case
            var onBound = context.parentNodeEntry.binding.onBound;
            context.parentNodeEntry.binding.onBound = null;

            setStubList(context.parentNodeEntry);

            context.parentUpdateOnly = true;
            return context.parentNodeEntry.binding.update(function (binding)
            {
                context.parentNodeEntry.binding.onBound = onBound;
                callback();
            });
        }

        var childNode = context.childNodes[binding.source.nodeId];
        if (childNode == null) return callback();

        if (context.reBinding == false) //first time bind, a new node
        {
            //the 0th (and only) item in the boundContent array is the recently stamped-out container for the user's binding and thenode's child list, which we make into the root element of the node 
            childNode.rootElement = binding.getBoundContent()[0]; 
            childNode.bindingElement = childNode.rootElement.firstChild; 

            //now that the location for the user's binding exists, execute the user's binding in its new slot
            triggerBuild(childNode, null, function (disposeNode)
            {
                if (disposeNode === true) context.nodesToDispose.push(childNode);
                callback();
            });
        }
        else //re-binding an existing node because something about it's binding stub changed that necessitated re-merging the HMTL
        {
            var boundContent = binding.getBoundContent();

            //re-associate all the elements with the child node
            childNode.rootElement = boundContent[0];
            childNode.bindingElement = childNode.rootElement.firstChild;
            childNode.binding.element = childNode.bindingElement;

            //then go re-attach all the bound content to get the node back into the state it was before
            var childBoundContent = childNode.binding.getBoundContent();
            var numBoundContent = childBoundContent != null ? childBoundContent.length : 0;
            for (var x = 0; x < numBoundContent; x++)
            {
                childNode.binding.element.append(childBoundContent[x]);
            }

            callback();
        }
    };

    /**Makes the root list node for the tree view child list based on the listElementType setting. 
    @param {TreeViewNodeEntry} nodeEntry The TreeViewNodeEntry that needs a child list made for it.
    @returns {Element}*/
    var makeChildListNode = function (nodeEntry, hide)
    {
        var root = null;

        if (nodeEntry.options.listElementType === EVUI.Modules.TreeView.TreeViewListElementType.Ordered)
        {
            root = document.createElement("ol");
        }
        else if (nodeEntry.options.listElementType === EVUI.Modules.TreeView.TreeViewListElementType.Unordered)
        {
            root = document.createElement("ul");
        }
        else
        {
            root = document.createElement("ul")
        }

        root.classList.add(EVUI.Modules.TreeView.Constants.CSS_ChildNodeList);
        if (hide === true) root.classList.add(EVUI.Modules.TreeView.Constants.CSS_ChildNodeList_Hidden);

        return root;
    };

    /**Builds the internal array of childNodeEntries for the given TreeViewNodeEntry.
     *
     * @param {TreeViewNodeEntry} nodeEntry
     */
    var setChildNodeList = function (nodeEntry)
    {
        var children = getChildren(nodeEntry); //get the node's child source objects as per the user's setting
        var hadChildren = (children != null && EVUI.Modules.Core.Utils.isArray(children) === true);
        var numChildren = (hadChildren === true) ? children.length : 0;        

        if (nodeEntry.childList == null && hadChildren === true) //had no children before, but do have them now
        {
            nodeEntry.childList = children;
            nodeEntry.childListObserver = new EVUI.Modules.Observers.ArrayObserver(children);

            nodeEntry.childListChanged = true;
            nodeEntry.treeViewEntry.nodesChanged = true;
        }
        else //either has no children, or had children and now has no children
        {
            if (nodeEntry.childList != null && (hadChildren === false || numChildren === 0)) //had children, but no longer has children
            {
                //dispose of all the child nodes - disposing of a node alters the childNodeEntries list's length, so we keep getting rid of the 0th node until we run out
                while (nodeEntry.childNodeEntries.length > 0)
                {
                    disposeTreeViewNode(nodeEntry.childNodeEntries[0]);
                }

                //clear out the medadata for the children
                nodeEntry.childList = null;
                nodeEntry.childListObserver = null;
                nodeEntry.childListChanged = true;
                nodeEntry.treeViewEntry.nodesChanged = true;

                return nodeEntry.childNodeEntries;
            }
            else if (nodeEntry.childList != null)//had children before, has children now, make sure the internal array of childNodeEntries matches the bound list.
            {
                return syncChildNodeList(nodeEntry, children);
            }
        }

        //if we get here it had no children before, so we have new childNodeEntires for each new child. Make a "fake" template node that has all the properties of it's parent node to use to stamp out child nodes.
        var fakeNode = EVUI.Modules.Core.Utils.shallowExtend({}, nodeEntry.node, ["options"]);
        for (var x = 0; x < numChildren; x++)
        {
            var childNodeSource = children[x];

            //the only difference in the child nodes is their source object - beyond that they are clones of their parent.
            fakeNode.source = childNodeSource;

            var childNodeEntry = makeTreeViewNodeAmbiguously(fakeNode, nodeEntry.treeViewEntry, nodeEntry);
            nodeEntry.childNodeEntries.push(childNodeEntry);
            nodeEntry.treeViewEntry.nodes.push(childNodeEntry);
        }

        nodeEntry.childListChanged = true;
        nodeEntry.treeViewEntry.nodesChanged = true;

        return nodeEntry.childNodeEntries;
    };

    /**Makes the "stubList" of objects that the data binder uses for the tree node exteriors.
    @param {TreeViewNodeEntry} nodeEntry The TreeViewNodeEntry having its child stub list built.*/
    var setStubList = function (nodeEntry)
    {
        if (nodeEntry == null) return;

        var numChildren = nodeEntry.childNodeEntries.length;
        if (numChildren === 0) return;

        nodeEntry.childListStubs.splice(0, nodeEntry.childListStubs.length);

        var depth = getDepth(nodeEntry);
        nodeEntry.depth = depth;

        for (var x = 0; x < numChildren; x++)
        {
            var curChild = nodeEntry.childNodeEntries[x];
            curChild.depth = depth + 1;

            curChild.bindingStub.depth = curChild.depth;
            curChild.bindingStub.nodeId = curChild.nodeId;
            curChild.bindingStub.ordinal = x;

            nodeEntry.childListStubs.push(curChild.bindingStub);
        }
    };

    /**Takes an existing child node list and syncs its contents with the child node list matching the changed contents of the user's source list.
    @param {TreeViewNodeEntry} nodeEntry The TreeViewNodeEntry having its childNode's list synced.
    @param {[]} newChildren The array of child objects provided by the user.
    @returns {TreeViewNodeEntry[]} */
    var syncChildNodeList = function (nodeEntry, newChildren)
    {
        var numChildren = newChildren == null ? 0 : newChildren.length;
        var numExisting = nodeEntry.childList.length;
        var longer = numExisting > numChildren ? numExisting : numChildren;
        var changes = [];

        if (newChildren === nodeEntry.childList) //same reference, just get the change list and update the internal state
        {
            changes = nodeEntry.childListObserver.getChanges(true);
        }
        else //different list, make the current list the same as the new list so we can properly diff it
        {
            
            for (var x = 0; x < longer; x++)
            {
                nodeEntry.childList[x] = newChildren[x];
            }

            changes = nodeEntry.childListObserver.getChanges();

            //re-set the list and make a new observer
            nodeEntry.childList = newChildren;
            nodeEntry.childListObserver = new EVUI.Modules.Observers.ArrayObserver(newChildren);

            nodeEntry.childListChanged = true;
            nodeEntry.treeViewEntry.nodesChanged = true;
        }

        //placeholder for a dummy node to use to make new nodes with (we do this in the loop so we don't needlessly clone a huge object)
        var fakeNode = null; 
        var numChanges = changes.length;
        var childNodes = []; //make a dummy list of node entries to sync with the existing list
        var removals = []; //make a list to hold any indexes we need to splice out of the "official" list

        if (numChanges > 0 || numExisting != numChildren)
        {
            nodeEntry.childListChanged = true;
            nodeEntry.treeViewEntry.nodesChanged = true;
        }

        for (var x = 0; x < numChanges; x++)
        {
            var curChange = changes[x];
            if (curChange.changeType === EVUI.Modules.Observers.ArrayChangeType.Added) //node added, put it at the index where it is in the new child list
            {
                if (fakeNode == null) fakeNode = EVUI.Modules.Core.Utils.shallowExtend({}, nodeEntry.node, ["options"]); //lazily clone a fake node from the parent node to give the child node its properties
                fakeNode.source = curChange.value; //set the source so that it has the right source object when it is made.

                var newEntry = makeTreeViewNodeAmbiguously(fakeNode, nodeEntry.treeViewEntry, nodeEntry); //make the actual node entry for the array
                childNodes[curChange.newIndex] = newEntry;
            }
            else if (curChange.changeType === EVUI.Modules.Observers.ArrayChangeType.Moved || curChange.changeType === EVUI.Modules.Observers.ArrayChangeType.Shifted) //a shift or a move requires us to just set the element at the new index.
            {
                var entry = nodeEntry.childNodeEntries[curChange.oldIndex];
                childNodes[curChange.newIndex] = entry;
            }
            else if (curChange.changeType === EVUI.Modules.Observers.ArrayChangeType.Removed) //removed node, add it to the removals list to remove after the sync is done
            {
                removals.push(nodeEntry.childNodeEntries[curChange.oldIndex]);
            }
            else //otherwise just set it at the new index
            {
                if (newIndex < 0) continue;

                var entry = nodeEntry.childNodeEntries[curChange.oldIndex];
                childNodes[curChange.newIndex] = entry;
            }
        }


        //now go change the contents of the actual child node array to match the partially synced list.
        for (var x = 0; x < longer; x++)
        {
            var newChild = childNodes[x];
            if (newChild != null)
            {
                nodeEntry.childNodeEntries[x] = newChild
            }
        }

        //remove the removals last because they impact the indexes of the other child nodes.
        var numRemovals = removals.length;
        for (var x = 0; x < numRemovals; x++)
        {
            disposeTreeViewNode(removals[x])
        }        

        return nodeEntry.childNodeEntries; //now the array of node entries should be in sync with the array of new source objects.
    };

   

    /**Disposes of a TreeViewNodeEntry by removing it from the DOM, its parent, and removing all objects from memory to release all the resources that were used by the node.
    @param {TreeViewNodeEntry} treeViewNode The node to dispose.*/
    var disposeTreeViewNode = function (treeViewNode)
    {
        if (treeViewNode == null) return;

        detachUserEvents(treeViewNode);

        if (treeViewNode.binding != null) treeViewNode.binding.dispose();
        if (treeViewNode.rootElement != null) treeViewNode.rootElement.remove();

        var numChildren = treeViewNode.childNodeEntries.length;
        var hadChildren = false;
        while (numChildren > 0)
        {
            hadChildren = true;
            numChildren--;

            var curChild = treeViewNode.childNodeEntries[x];
            disposeTreeViewNode(curChild);
        }

        var parentNode = treeViewNode.parentNodeEntry;
        if (parentNode != null)
        {
            var index = parentNode.childNodeEntries.indexOf(treeViewNode);
            if (index !== -1) parentNode.childNodeEntries.splice(index, 1);

            index = parentNode.childListStubs.indexOf(treeViewNode.bindingStub);
            if (index !== -1) parentNode.childListStubs.splice(index, 1);

            parentNode.childListChanged = true;
            parentNode.treeViewEntry.nodesChanged = true;
        }
        else
        {
            //we always need to have a root node, so we clone a dummy one from the current state of the node
            treeViewNode.treeViewEntry.rootNode = makeTreeViewNodeAmbiguously(treeViewNode.node, treeViewNode.treeViewEntry, null);
        }

        var treeViewIndex = treeViewNode.treeViewEntry.nodes.indexOf(treeViewNode);
        if (treeViewIndex !== -1)
        {
            treeViewNode.treeViewEntry.nodes.splice(treeViewIndex, 1);
            treeViewNode.treeViewEntry.nodesChanged = true;
        }

        if (hadChildren === true)
        {
            if (treeViewNode.childListBinding != null) treeViewNode.childListBinding.dispose();

            treeViewNode.childList = null;
            treeViewNode.childListName = null;
            treeViewNode.childListObserver = null;
            treeViewNode.childListStubs = [];
            treeViewNode.childNodeEntries = [];
            treeViewNode.childListBinding = null;

            nodeEntry.childListChanged = true;
            nodeEntry.treeViewEntry.nodesChanged = true;
        }

        treeViewNode.binding = null;
        treeViewNode.bindingElement = null;
        treeViewNode.bindingStub = null;
        treeViewNode.bindingTemplate = null;
        treeViewNode.continuations = null;
        treeViewNode.listElement = null;
        treeViewNode.node = null;
        treeViewNode.nodeState = EVUI.Modules.TreeView.TreeViewNodeState.Disposed;
        treeViewNode.options = null;
        treeViewNode.operation = null;
        treeViewNode.source = null;
        treeViewNode.treeViewEntry = null;

        treeViewNode.childListChanged = true;
        treeViewNode.optionsChanged = true;
        treeViewNode.bindingTemplateChanged = true;
    };

    /**Disposes of an entrie TreeView.
    @param {TreeViewEntry} treeViewEntry The TreeView to dispose.*/
    var disposeTreeView = function (treeViewEntry)
    {
        //kick off the recursive disposal process by disposing of the root node
        if (treeViewEntry.rootNode != null) disposeTreeViewNode(treeViewEntry.rootNode);

        treeViewEntry.element = null;

        if (treeViewEntry.rootListNode != null)
        {
            treeViewEntry.rootListNode.remove();
            treeViewEntry.rootListNode = null;
        }

        treeViewEntry.nodes.splice(0, treeViewEntry.nodes.length);
        treeViewEntry.nodesChanged = true;

        treeViewEntry.treeState = EVUI.Modules.TreeView.TreeViewState.Disposed;
    }

    /**Gets a TreeViewNodeEntry from a TreeViewEntry based on its ID.
    @param {TreeViewEntry} treeViewEntry The TreeView that contains the node.
    @param {Number} nodeId The ID of the node to get.
    @returns {TreeViewNodeEntry} */
    var getNodeById = function (treeViewEntry, nodeId)
    {
        var numNodes = treeViewEntry.nodes.length;
        for (var x = 0; x < numNodes; x++)
        {
            var curNode = treeViewEntry.nodes[x];
            if (curNode.nodeId === nodeId) return curNode;
        }

        return null;
    };

    /**Makes a TreeViewNodeEntry based on ambiguous input.
    @param {EVUI.Modules.TreeView.AddTreeViewNodeArgs|EVUI.Modules.TreeView.TreeViewNode} addNodeArgs Either a YOLO tree view node or a YOLO AddTreeNodeArgs object that will be used as the basis for making the new node.
    @param {TreeViewEntry} treeViewEntry The parent tree view that will own the new node.
    @param {TreeViewNodeEntry} parentNodeEntry The parent node that will own the new node. All nodes but the root node will have a parent.
    @returns {TreeViewNodeEntry} */
    var makeTreeViewNodeAmbiguously = function (addNodeArgs, treeViewEntry, parentNodeEntry)
    {
        var tvNodeEntry = new TreeViewNodeEntry();
        tvNodeEntry.treeViewEntry = treeViewEntry;
        tvNodeEntry.bindingTemplate = addNodeArgs.bindingTemplate;
        tvNodeEntry.childListName = addNodeArgs.childListName
        tvNodeEntry.node = new EVUI.Modules.TreeView.TreeViewNode(tvNodeEntry);
        tvNodeEntry.nodeState = EVUI.Modules.TreeView.TreeViewNodeState.None;
        tvNodeEntry.parentNodeEntry = parentNodeEntry;
        tvNodeEntry.source = addNodeArgs.source; //this needs to be an object but we don't enforce it here because it could be changed in an event during the binding process.

        var options = addNodeArgs.options;
        var optionsMode = addNodeArgs.optionsMode;

        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(optionsMode) === true) //no options mode, go get the options mode from its parent
        {
            if (parentNodeEntry != null && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(parentNodeEntry.node.optionsMode) === false)
            {
                optionsMode = parentNodeEntry.node.optionsMode;
            }

            if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(optionsMode) === true) //still no options mode, set the share mode to the default.
            {
                optionsMode = EVUI.Modules.TreeView.TreeViewOptionsShareMode.TreeShared;
            }
        }

        if (optionsMode === EVUI.Modules.TreeView.TreeViewOptionsShareMode.Cloned)
        {
            if (options == null)
            {
                if (parentNodeEntry != null && parentNodeEntry.options != null)
                {
                    options = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.TreeView.TreeViewOptions(), parentNodeEntry.options);
                }
                else
                {
                    options = EVUI.Modules.TreeView.TreeViewOptions();
                }
            }
            else
            {
                if (EVUI.Modules.Core.Utils.instanceOf(options, EVUI.Modules.TreeView.TreeViewOptions) === false)
                {
                    options = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.TreeView.TreeViewOptions(), options);
                }
            }
        }
        else if (optionsMode === EVUI.Modules.TreeView.TreeViewOptionsShareMode.TreeShared)
        {
            if (parentNodeEntry == null && treeViewEntry.rootNode == null)
            {
                options = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.TreeView.TreeViewOptions(), options);
            }
            else
            {
                var numNodes = treeViewEntry.nodes.length;
                for (var x = 0; x < numNodes; x++)
                {
                    var curNode = treeViewEntry.nodes[x];
                    if (curNode.optionsChanged === false)
                    {
                        options = curNode.options;
                        break;
                    }
                }
            }
        }
        else if (optionsMode === EVUI.Modules.TreeView.TreeViewOptionsShareMode.PeerNodeShared)
        {
            var peer = null;

            if (parentNodeEntry != null)
            {
                var numPeers = parentNodeEntry.childNodeEntries.length;
                for (var x = 0; x < numPeers; x++)
                {
                    var curPeer = parentNodeEntry.childNodeEntries[x];
                    if (curPeer.optionsChanged === false)
                    {
                        peer = curPeer;
                        break;
                    }
                }
            }

            if (peer != null)
            {
                options = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.TreeView.TreeViewOptions(), peer.options);
            }
            else
            {
                options = new EVUI.Modules.TreeView.TreeViewOptions();
            }
        }
        else
        {
            options = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.TreeView.TreeViewOptions(), options);
        }

        if (options == null)
        {
            options = new EVUI.Modules.TreeView.TreeViewOptions();
        }


        tvNodeEntry.options = options;
        EVUI.Modules.Core.Utils.shallowExtend(tvNodeEntry.node, addNodeArgs, _nodeExclusions.concat(["source", "options"]));

        return tvNodeEntry;
    };

    /**Gets a usable element to use as the root of a TreeView.
     * @param {Element|DocumentFragment|String} ele Either an Element reference, a DocumentFragment, or a CSS selector to use to be/find the root element of the tree.
    @returns {Element|DocumentFragment}*/
    var getValidRootElement = function (ele)
    {        
        if (EVUI.Modules.Core.Utils.isElement(ele) === true) return ele;
        if (ele != null && ele.nodeType === Node.DOCUMENT_FRAGMENT_NODE) return ele;
        if (typeof ele === "string")
        {
            var domHelper = new EVUI.Modules.Dom.DomHelper(ele);
            if (domHelper.elements.length > 0)
            {
                return domHelper.elements[0];
            }
        }

        if (EVUI.Modules.Core.Utils.isDomHelper(ele) === true && ele.elements.length > 0) return ele.elements[0];
        return document.createDocumentFragment();
    };

    /**Figures out the "right" thing to do given the current state of a node, its progress in whatever it is currently doing, and what it has just been asked to do.
    @param {TreeViewNodeEntry} nodeEntry The node impacted by the incoming operation.
    @param {OperationSession} opSession The incoming operation session being evaluated.
    @returns {ActionSequence} */
    var getActionSequence = function (nodeEntry, opSession)
    {
        var actionSequence = new ActionSequence();
        actionSequence.primaryAction = opSession.action;

        var nodeState = opSession.nodeEntry.nodeState;

        if (nodeState === EVUI.Modules.TreeView.TreeViewNodeState.None) //node isn't doing anything, do whatever was requested
        {
            actionSequence.actions.push(opSession.action);            
        }
        else if (nodeState === EVUI.Modules.TreeView.TreeViewNodeState.Building) //in the process of building itself
        {
            if (opSession.action === NodeAction.Expand) //expansion can be executed after a manual build
            {
                actionSequence.continueAfter = true;
                actionSequence.actions.push(NodeAction.Expand);
            }
            else if (opSession.action == NodeAction.Build) //already building, but told to build again. Something may have changed, so do the new build and cancel the current one.
            {
                actionSequence.cancelCurrent = true;
                actionSequence.actions.push(NodeAction.Build);
            }
            else //anything else (a collapse) can be executed after build finishes, so it becomes a continuation
            {
                actionSequence.continueAfter = true;
                actionSequence.actions.push(opSession.action);
            }
        }
        else if (nodeState === EVUI.Modules.TreeView.TreeViewNodeState.Collapsed) //collapsed and at rest
        {
            if (opSession.action === NodeAction.Expand)  //can freely expand from this state
            {
                actionSequence.actions.push(NodeAction.Expand);
            }
            else if (opSession.action === NodeAction.Collapse) //redundant command - asked to collapse when collapsed. Do nothing but call callback
            {
                actionSequence.skip = true;
            }
            else //anything else (build) can  be done with a collapsed node
            {
                actionSequence.actions.push(opSession.action);
            }
        }
        else if (nodeState === EVUI.Modules.TreeView.TreeViewNodeState.Collapsing) //in the process of collapsing
        {
            if (opSession.action === NodeAction.Expand) //asked to perform the opposite action - cancel the current and begin expanding or resoring the expanded state
            {
                actionSequence.cancelCurrent = true;
                actionSequence.actions.push(NodeAction.Expand);
            }
            else if (opSession.action === NodeAction.Collapse) //redundant command - do nothing but call callback
            {
                actionSequence.skip = true;
            }
            else if (opSession.action === NodeAction.Build) //can build after collapsing, so it becomes a continuation
            {
                actionSequence.continueAfter = true;
                actionSequence.actions.push(NodeAction.Build);
            }
            else //this shouldn't ever get hit
            {
                actionSequence.actions.push(opSession.action);
            }
        }
        else if (nodeState === EVUI.Modules.TreeView.TreeViewNodeState.Expanded) //expanded and at rest
        {
            if (opSession.action === NodeAction.Expand) //already expanded, no work to do
            {
                actionSequence.skip = true;
                actionSequence.actions.push(NodeAction.Expand);
            }
            else if (opSession.action === NodeAction.Collapse)
            {
                actionSequence.actions.push(NodeAction.Collapse);
            }
            else //anything else can be executed normally
            {
                actionSequence.actions.push(opSession.action);
            }
        }
        else if (nodeState === EVUI.Modules.TreeView.TreeViewNodeState.Expanding) //in the middle of an expand operation
        {
            if (opSession.action === NodeAction.Expand || opSession.action === NodeAction.Build) //if we're expanding and we get a command to expand (or build) again we go ahead and do it as it will trigger another build even though its technicallty redundant
            {
                actionSequence.continueAfter = true;
                actionSequence.actions.push(NodeAction.Build);
            }
            else if (opSession.action === NodeAction.Collapse) //opposite action, cancel current
            {
                actionSequence.cancelCurrent = true;
                actionSequence.actions.push(NodeAction.Collapse);
            }
            else //otherwise execute like normal
            {
                actionSequence.actions.push(opSession.action);
            }
        }

        return actionSequence;
    };

    /**Gets the number of parent nodes directly above this node up to the root node.
    @param {TreeViewNodeEntry} treeNodeEntry The node to get the depth of.
    @returns {Number} */
    var getDepth = function (treeNodeEntry)
    {
        var depth = 0;
        var parentNode = treeNodeEntry.parentNodeEntry;
        while (parentNode != null)
        {
            depth++;
            parentNode = parentNode.parentNodeEntry;
        }

        return depth;
    };

    /**Generates a CSS class name for a TreeView based on its id.
    @param {String} treeViewId The ID of the tree view to turn into a snake-cased CSS class name.
    @returns {String} */
    var getTreeViewClassName = function (treeViewId)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(treeViewId) === true) return null;
        var snakeCaseChars = new RegExp(/\s+/g);

        var snakeCaseName = treeViewId.trim().replace(snakeCaseChars, function (match)
        {
            if (match != "" && match.trim() === "")
            {
                return "-";
            }
            else
            {
                return "";
            }            
        });

        var name = "evui-tree-" + snakeCaseName;

        //make sure the user isn't making a tree view with a name that is one of the special decorator classes
        for (var prop in EVUI.Modules.TreeView.Constants)
        {
            if (EVUI.Modules.TreeView.Constants[prop] === name) throw Error(name + " is a reserved TreeView Constant.");
        }

        return name;
    };

    /**Ensures that all the required services for the TreeViewController are present.*/
    var ensureServices = function ()
    {
        if (_services == null || typeof _services !== "object") _services = new EVUI.Modules.TreeView.TreeViewControllerServices();

        if (_services.bindingController == null || typeof _services.bindingController !== "object")
        {
            _services.bindingController = EVUI.Modules.Binding.Binder;
        }

        if (_services.stylesheetManager == null || typeof _services.stylesheetManager !== "object")
        {
            _services.stylesheetManager = EVUI.Modules.Styles.Manager;
        }
    }

    /**Represents a grouping of instructions on what action a TreeViewNodeEntry should take when a new operation is queued.
    @class*/
    var ActionSequence = function ()
    {
        /**String. The Action being queued. Must be a value from NodeAction.
        @type {String}*/
        this.primaryAction = NodeAction.None;

        /**Boolean. Whether or not to cancel the current operation.
        @type {Boolean}*/
        this.cancelCurrent = false;

        /**Boolean. Whether or not to skip performing the current operation and just call its callback instead.
        @type {Boolean}*/
        this.skip = false;

        /**Boolean. Whether or not the current operation should be continued once the one in progress completes.
        @type {Booleab}*/
        this.continueAfter = false;

        /**Array. An array of NodeActions indicating the actions that the TreeViewNodeEntry will take. */
        this.actions = [];
    };

    /**Context object that holds contextual information about a BindingStub that was just bound by the internal Binding for holding user bindings.
    @class*/
    var StubBindingContext = function ()
    {
        /**Object. Dictionary of child nodes keyed based on their ID's.
        @type {{}}*/
        this.childNodes = {};

        /**Array. An array of TreeViewNodeEntries that are to be disposed, used during a child node list sync operation. 
        @type {TreeViewNodeEntry[]}*/
        this.nodesToDispose = [];

        /**Object. The parent TreeViewNodeEntry to the node being bound.
        @type {TreeViewNodeEntry}*/
        this.parentNodeEntry = null;

        /**Boolean. Whether or not this is not the first time that this binding bas been bound.
        @type {Boolean}*/
        this.reBinding = false;
    };

    /**The internal entry for a TreeView that contains the data and functionality exposed by the TreeView object.
    @class*/
    var TreeViewEntry = function ()
    {
        /**Object. The TreeView that this entry was injected into.
        @type {EVUI.Modules.TreeView.TreeView}*/
        this.treeView = null;

        /**String. The ID the user gave to this TreeView.
        @type {String}*/
        this.treeViewId = null;

        /**Object. The root node on the TreeView.
        @type {TreeViewNodeEntry}*/
        this.rootNode = null;

        /**Array. The array of all nodes contained by this TreeView.
        @type {TreeViewNodeEntry[]}*/
        this.nodes = [];

        /**Element. The direct parent element to this TreeView that it is inserted inside of.
        @type {Element}*/
        this.element = null;

        /**Boolean. Whether or not the nodes collection was modified and needs to be rebuilt in the public facing node array.
        @type {Boolean}*/
        this.nodesChanged = false;

        /**String. The current state of the TreeView. Must be a value from TreeViewState.
        @type {String}*/
        this.treeState = EVUI.Modules.TreeView.TreeViewState.None;

        /**String. The CSS class name for this TreeView.
        @type {String}*/
        this.className = null;

        /**Element. The wrapping UL or OL that contains the entire TreeView.
        @type {Element}*/
        this.rootListNode = null;

        /**Triggers the building of a node on the TreeView.*/
        this.build = buildFromTreeView;

        /**Triggers the expansion of a Node on the TreeView.*/
        this.expand = expandFromTreeView;

        /**Triggers the collapsing of a Node on the TreeView.*/
        this.collapse = collapseFromTreeView;

        /**Triggers the disposal of a Node on the TreeView. */
        this.dispose = disposeFromTreeView;

        /**Triggers a toggle operation of a Node on the TreeView. */
        this.toggle = toggleFromTreeView;

        /**Gets a valid element for the root node of the TreeView based on ambiguous user input.*/
        this.getValidElement = getValidRootElement;
    };

    /**Object that is injected into a TreeViewNode and is used internally to perform all operations on TreeViewNodes.
    @class*/
    var TreeViewNodeEntry = function ()
    {
        /**Object. The Options object for the node.
        @type {EVUI.Modules.TreeView.TreeViewOptions}*/
        this.options = new EVUI.Modules.TreeView.TreeViewOptions();

        /**Object. The TreeViewNode this entry was injected into and is serving as the backing source of information for.
        @type {EVUI.Modules.TreeView.TreeViewNode}*/
        this.node = null;

        /**Number. The ID of the node.
        @type {Number}*/
        this.nodeId = _nodeIDCounter++;

        /**Object. The TreeView that owns this node.
        @type {TreeViewEntry}*/
        this.treeViewEntry = null;

        /**Number. The number of nodes hierarchically above this node in the TreeView.
        @type {Number}*/
        this.depth = 0;

        /**Object. The BindingTemplate used by the user's binding. 
        @type {EVUI.Modules.Binding.BindingTemplate}*/
        this.bindingTemplate = null;

        /**String|Function. Either the property name of the child list in the user's source object, or a function that returns a list of child objects to make child nodes for.
        @type {String|Function}*/
        this.childListName = null;

        /**Object. The parent node that contains this node.
        @type {TreeViewNodeEntry}*/
        this.parentNodeEntry = null;

        /**Array. The list of child nodes under this node.
        @type {TreeViewNodeEntry[]}*/
        this.childNodeEntries = [];

        /**Object. The Binding made from the user's BindingTemplate.
        @type {EVUI.Modules.Binding.Binding}*/
        this.binding = null;

        /**Element. The root element of the node that contains the user and system generated content for the node.
        @type {Element}*/
        this.rootElement = null;

        /**Element. The slot in the rootElement that is available for use by the user's binding.
        @type {Element}*/
        this.bindingElement = null;

        /**Element. If this node has children, this is the reference to the UL or OL that the children's HTML is contained by.
        @type {Element}*/
        this.listElement = null;

        /**Array. The children from the user's source object that currently have a childNodeEntry.
        @type {Object[]}*/
        this.childList = null;

        /**Object. The ArrayObserver watching the user's childList for changes.
        @type {EVUI.Modules.Observers.ArrayObserver}*/
        this.childListObserver = null;

        /**Object. The Binding placed inside the listElement that hosts all the child bindings for the user's child list content.
        @type {EVUI.Modules.Binding.Binding}*/
        this.childListBinding = null;

        /**A dummy list of empty objects used to create the childListBinding.
        @type {BindingStub[]}*/
        this.childListStubs = [];

        /**String. The current operational state of the node. Must be a value from TreeViewNodeState.
        @type {String}*/
        this.nodeState = EVUI.Modules.TreeView.TreeViewNodeState.None;

        /**String. The previous state of the node. Must be a value from TreeViewNodeState. Used when cancelling an operation before it completes to restore the previous state of the node.
        @type {String}*/
        this.previousCompletedNodeState = EVUI.Modules.TreeView.TreeViewNodeState.None;

        /**Object. The operation that is curretly being executed by this node.
        @type {OperationSession}*/
        this.operation = null;
        
        /**Object. The user's source object that is used for the basis of their Binding.
        @type {Object}*/
        this.source = null;

        /**A dummy object to use for the child list binder.
        @type {BindingStub}*/
        this.bindingStub = new BindingStub();

        /**Actions that will be executed after the current action's callback stack is called.
        @type {OperationSession[]}*/
        this.continuations = [];

        /**Event handlers that have been bound to the DOM for opening or closing the Node.
        @type {EventHandlerBinding[]}*/
        this.eventBindings = [];

        /**Function. A callback function to call once a transition operation has been completed.
        @type {Function}*/
        this.transitionCallback = null;

        /**Number. The timeout ID given to us by the browser that we can use to cancel a transition in progress's timed callback.
        @type {Number}*/
        this.transitionTimeoutID = -1;

        /**String. A CSS selector used to apply to the node that adds the transition effect to the node.
        @type {String}*/
        this.transitionSelector = null;

        /**Boolean. Whether or not the BindingTemplate for the node has been re-set by the user since it was originally set.
        @type {Boolean}*/
        this.bindingTemplateChanged = false;

        /**Boolean. Indicates that the user's source object's list of children to make nodes for has changed. Signals to the TreeViewNode wrapper to re-populate the public array of children.
        @type {Boolean}*/
        this.childListChanged = false;

        /**Booleab. Whether or not the user has set the options object since it was originally set. Used for determining which options object to use for new nodes in certain situations.
        @type {Boolean}*/
        this.optionsChanged = false;

        /**Boolean. Whether or not the node's child list is currently visible (if it has one).
        @type {Boolean}*/
        this.expanded = false;

        /**Triggers the expansion of this node.*/
        this.expandNode = triggerExpand;

        /**Triggers the collapsing of this node.*/
        this.collapseNode = triggerCollapse;

        /**Triggers the toggling of this node from expanded to collapsed and vice-versa.*/
        this.toggleNode = triggerToggle;

        /**Triggers the building of this node and its child list.*/
        this.buildNode = triggerBuild;

        /**Triggers the disposal of this node.*/
        this.dispose = disposeTreeViewNode;
    };

    /**Represents one of the objects used by the internal Binding to stamp out a tree view child node list for each child source object in the user's source object
    @class*/
    var BindingStub = function ()
    {
        /**Number. The ID of the node being bound.
        @type {Number}*/
        this.nodeId = -1;

        /**Number. The numnber of hierarchical levels there are above this node.
        @type {Number}*/
        this.depth = -1;

        /**Number. The index of this node in its child list of nodes.
        @type {Number}*/
        this.ordinal = -1;
    }

    /**Represents a wrapper for a callback fucntion and the OperationSession it is associated with. 
    @class*/
    var CallbackEntry = function ()
    {
        /**Object. The OperationSession that was queued with the callback function.
        @type {Object}*/
        this.operationSession = null;

        /**Function. The callback function to call once the operationSession is completed.
        @type {Function}*/
        this.callback = null;
    };

    /**Action commands for nodes to perform.
    @enum*/
    var NodeAction =
    {
        /**Default.*/
        None: "none",
        /**Node has been instructed to expand.*/
        Expand: "expand",
        /**Node has been instructed to collapse.*/
        Collapse: "collapse",
        /**Node has been instructed to build itself.*/
        Build: "build",
        /**Node should do the opposite of what it is currently doing or change to the opposite visibility state as its current state.*/
        Toggle: "toggle",
        /**Node should dispose of itself and release all of its resources.*/
        Dispose: "dispose"
    };

    /**Represents all the information available about an operation in progress.
    @class*/
    var OperationSession = function ()
    {
        /**Number. The ID of the operation and its sequence number in terms of when this operation was queued relative to other concurrent operations.
        @type {Number}*/
        this.operationId = _operationCounter++;

        /**Boolean. Whether or not this Operation is a continuation of another operation and had its execution deferred until another operatoin has completed.
        @type {Boolean}*/
        this.isContinuation = false;

        /**Object. The callback entry associated with this operation.
        @type {CallbackEntry}*/
        this.callback = null;

        /**String. The action that this operation is asking the node to perform.
        @type {String}*/
        this.action = NodeAction.None;

        /**Object. The TreeViewNodeEntry that is the target of this operation.
        @type {TreeViewNodeEntry}*/
        this.nodeEntry = null;

        /**Object. The event stream driving the operation.
        @type {EVUI.Modules.EventStream.EventStream}*/
        this.eventStream = null;

        /**Object. If this operation involved a "build" step, these are the arguments for configuring the build.
        @type {EVUI.Modules.TreeView.BuildTreeViewNodeArgs}*/
        this.buildArgs = null;

        /**Object. If this operation involves an "expand" or "collapse" action, this is the configuration options for that action.
        @type {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs}*/
        this.expandCollapseArgs = null;

        /**Boolean. Whether or not this operation has been canceled and should cease operating.
        @type {Boolean}*/
        this.canceled = false;

        /**Object. The continuation operation session that will execute after this operation has completed.
        @type {OperationSession}*/
        this.continuation = null;

        /**Object. In the event of continuations or skipped operations queued while an operation is in progress, this is the combined set of callbacks that should be executed once the operation finishes.
        @type {CallbackEntry[]}*/
        this.callbackStack = [];

        /**Object. Any contextual information to carry between events.
        @type {Object}*/
        this.context = {};
    };

    /**Represents an automatically bound event handler that performs an expand, collapse, or toggle operation. Used to ensure redundant handlers for expand, collapse, and toggle are not registered.
    @class*/
    var EventHandlerBinding = function ()
    {
        /**Function. The actual event handling function.
        @type {Function}*/
        this.handler = null;

        /**Element. The element that had the event handler attached to it
        @type {Element}*/
        this.element = null;

        /**String. The name of the event that was attached.
        @type {String}*/
        this.eventName = null;
    };

    //ensure we have a valid _services object.
    ensureServices();

    //make sure our CSS for expand/collapse exists
    buildExpandCollapseCSSRules();
};

/**Object that contains a collection of hierarchical expandable or collapseable nodes organized into a parent-child tree structure.
@class*/
EVUI.Modules.TreeView.TreeView = function (tvEntry)
{
    if (tvEntry == null) throw Error("Object expected.");

    var _self = this;
    var _treeViewEntry = tvEntry;
    var _nodes = [];

    /**String. The unique ID of the TreeView.
    @type {String}*/
    this.id = null;
    Object.defineProperty(this, "id", {
        get: function ()
        {
            return _treeViewEntry.treeViewId;
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The HTMLElement under which the TreeView will be appended under.
    @type {Element}*/
    this.element = null;
    Object.defineProperty(this, "element", {
        get: function ()
        {
            return _treeViewEntry.element;
        },
        set: function (value)
        {
            if (value == null)
            {
                _treeViewEntry.element = null;
                return;
            }

            _treeViewEntry.element = _treeViewEntry.getValidElement(value);
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The OL/UL Element that wraps the entire TreeView's collection of nodes.
    @type {Element}*/
    this.rootListElement = null;
    Object.defineProperty(this, "rootListElement", {
        get: function ()
        {
            return _treeViewEntry.rootListElement;
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The root TreeViewNode of the TreeView.
    @type {EVUI.Modules.TreeView.TreeViewNode}*/
    this.rootNode = null;
    Object.defineProperty(this, "rootNode", {
        get: function ()
        {
            if (_treeViewEntry.rootNode != null)
            {
                return _treeViewEntry.rootNode.node;
            }
            else
            {
                return null;
            }
        },
        configurable: false,
        enumerable: true
    });

    /**Gets the collection of TreeViewNodes contained by the TreeView. */
    this.getNodes = function ()
    {
        var nodes = [];
        var numNodes = _treeViewEntry.nodes.length;

        nodes.push(_self.rootNode);

        for (var x = 0; x < numNodes; x++)
        {
            nodes.push(_treeViewEntry.nodes[x].node)
        }

        return nodes;
    };

    /**Expands a TreeViewNode in the TreeView, showing its children.
    @param {Number|EVUI.Modules.TreeView.TreeViewNode|EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} nodeOrId Can either be the id of the TreeViewNode to expand, or the actual TreeViewNodem to expand. If no node is specified, the rootNode is used instead. Can also be a YOLO ExpandCollapseTreeViewNodeArgs or just a callback function.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} expandArgs Either a YOLO ExpandCollapseTreeViewNodeArgs args object, or a callback function to call once the operation completes. 
    @param {Function} callback A callback function to call once the operation is complete.*/
    this.expandNode = function (nodeOrId, expandArgs, callback)
    {
        _treeViewEntry.expand(_treeViewEntry, nodeOrId, expandArgs, callback)
    };

    /**Collapses a TreeViewNode in the TreeView, hiding its children.
    @param {Number|EVUI.Modules.TreeView.TreeViewNode|EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} nodeOrId Can either be the id of the TreeViewNode to collapse, or the actual TreeViewNodem to expand. If no node is specified, the rootNode is used instead. Can also be a YOLO ExpandCollapseTreeViewNodeArgs or just a callback function.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} expandArgs Either a YOLO ExpandCollapseTreeViewNodeArgs args object, or a callback function to call once the operation completes. 
    @param {Function} callback A callback function to call once the operation is complete.*/
    this.collapseNode = function (nodeOrId, collapseArgs, callback)
    {
        _treeViewEntry.collapse(_treeViewEntry, nodeOrId, collapseArgs, callback);
    };

    /**Builds a TreeViewNode in the TreeView, refreshing its display and building its child list if applicable.
    @param {Number|EVUI.Modules.TreeView.TreeViewNode|EVUI.Modules.TreeView.BuildTreeViewNodeArgs|Function} nodeOrId Can either be the id of the TreeViewNode to collapse, or the actual TreeViewNodem to expand. If no node is specified, the rootNode is used instead. Can also be a YOLO BuildTreeViewNodeArgs or just a callback function.
    @param {EVUI.Modules.TreeView.BuildTreeViewNodeArgs|Function} buildArgs A YOLO BuildTreeViewNodeArgs object, or a callback function to call when the operation completes.
    @param {Function} callback A function to call once the operation is complete.*/
    this.buildNode = function (nodeOrId, buildArgs, callback)
    {
        _treeViewEntry.build(_treeViewEntry, nodeOrId, buildArgs, callback);
    };

    /**Collapses a TreeViewNode that is expanded or expands a TreeViewNode that is collapsed.
    @param {Number|EVUI.Modules.TreeView.TreeViewNode|EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} nodeOrId Can either be the id of the TreeViewNode to collapse, or the actual TreeViewNodem to expand. If no node is specified, the rootNode is used instead. Can also be a YOLO ExpandCollapseTreeViewNodeArgs or just a callback function.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} expandCollapseArgs Either a YOLO ExpandCollapseTreeViewNodeArgs args object, or a callback function to call once the operation completes. 
    @param {Function} callback A callback function to call once the operation is complete.*/
    this.toggleNode = function (nodeOrId, expandCollapseArgs, callback)
    {
        _treeViewEntry.toggle(_treeViewEntry, nodeOrId, expandCollapseArgs, callback);
    };

    /**Awaitable. Expands a TreeViewNode in the TreeView, showing its children.
    @param {Number|EVUI.Modules.TreeView.TreeViewNode|EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs} nodeOrId Can either be the id of the TreeViewNode to expand, or the actual TreeViewNodem to expand. If no node is specified, the rootNode is used instead. Can also be a YOLO ExpandCollapseTreeViewNodeArgs.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs} expandArgs A YOLO ExpandCollapseTreeViewNodeArgs args object.
    @returns {Promise}*/
    this.expandNodeAsync = function (nodeOrId, expandArgs)
    {
        return new Promise(function (resolve)
        {
            _self.expandNode(nodeOrId, expandArgs, function ()
            {
                resolve();
            });
        });
    };

    /**Awaitable. Collapses a TreeViewNode in the TreeView, hiding its children.
    @param {Number|EVUI.Modules.TreeView.TreeViewNode|EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs} nodeOrId Can either be the id of the TreeViewNode to collapse, or the actual TreeViewNodem to expand. If no node is specified, the rootNode is used instead. Can also be a YOLO ExpandCollapseTreeViewNodeArgs.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs} expandArgs A YOLO ExpandCollapseTreeViewNodeArgs args object.
    @returns {Promise}*/
    this.collapseNodeAsync = function (nodeOrId, collapseArgs)
    {
        return new Promise(function (resolve)
        {
            _self.collapseNode(nodeOrId, collapseArgs, function ()
            {
                resolve();
            });
        });
    };

    /**Awaitable. Builds a TreeViewNode in the TreeView, refreshing its display and building its child list if applicable.
    @param {Number|EVUI.Modules.TreeView.TreeViewNode|EVUI.Modules.TreeView.BuildTreeViewNodeArgs} nodeOrId Can either be the id of the TreeViewNode to collapse, or the actual TreeViewNodem to expand. If no node is specified, the rootNode is used instead. Can also be a YOLO BuildTreeViewNodeArgs object.
    @param {EVUI.Modules.TreeView.BuildTreeViewNodeArgs} buildArgs A YOLO BuildTreeViewNodeArgs object.*/
    this.buildNodeAsync = function (nodeOrId, buildArgs)
    {
        return new Promise(function (resolve)
        {
            _self.buildNode(nodeOrId, buildArgs, function ()
            {
                resolve();
            });
        });
    };

    /**Awaitable. Collapses a TreeViewNode that is expanded or expands a TreeViewNode that is collapsed.
    @param {Number|EVUI.Modules.TreeView.TreeViewNode|EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} nodeOrId Can either be the id of the TreeViewNode to collapse, or the actual TreeViewNodem to expand. If no node is specified, the rootNode is used instead. Can also be a YOLO ExpandCollapseTreeViewNodeArgs.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} expandCollapseArgs Either a YOLO ExpandCollapseTreeViewNodeArgs args object, or a callback function to call once the operation completes. 
    @returns {Promise}*/
    this.toggleNodeAsync = function (nodeOrId, expandCollapseArgs)
    {
        return new Promise(function (resolve)
        {
            _self.toggleNode(nodeOrId, expandCollapseArgs, function ()
            {
                resolve();
            });
        });
    };

    /**Disposes of a TreeViewNode in the TreeView, removing it from the TreeView permanently.
    @param {Number|EVUI.Modules.TreeView.TreeViewNode} nodeOrId Either the ID of the TreeViewNode to dispose, or the TreeViewNode to dispose.*/
    this.disposeNode = function (nodeOrId)
    {
        tvEntry.dispose(tvEntry, nodeOrId);
    };

    /**Builds the TreeView, starting with the rootNode.
    @param {EVUI.Modules.TreeView.BuildTreeViewNodeArgs|Function} buildArgs Either a YOLO BuildTreeViewNodeArgs object or a callback function.
    @param {Function} callback A callback function to call once the operation is complete.*/
    this.build = function (buildArgs, callback)
    {
        tvEntry.build(tvEntry, tvEntry.rootNode, buildArgs, callback);
    };

    /**Awaitable. Builds the TreeView, starting with the rootNode.
    @param {EVUI.Modules.TreeView.BuildTreeViewNodeArgs|Function} buildArgs A YOLO BuildTreeViewNodeArgs object.*/
    this.buildAsync = function (buildArgs)
    {
        return new Promise(function (resolve)
        {
            return _self.build(buildArgs, function ()
            {
                resolve();
            });
        });
    };

    /**Disposes of the entire TreeView, releasing all resources used by all TreeViewNodes in the TreeView.*/
    this.dispose = function ()
    {
        tvEntry.dispose(tvEntry, null);
    };

    /**Event that fires before an expand operation begins.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onExpand = null;

    /**Event that fires after an expand operation has completed.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onExpanded = null;

    /**Event that fires before a build operation begins.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onBuild = null;

    /**Event that fires before the list of children for a TreeViewNode is bound,.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onBuildChildren = null;

    /**Event that fires after the list of children for a TreeViewNode has been bound.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onChildrenBuilt = null;

    /**Event that fires once a TreeViewNode and all its children have been built.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onBuilt = null;

    /**Event that fires before a collapse operation begins.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onCollapse = null;

    /**Event that fires after a collapse operation completes.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onCollapsed = null;
};

/**Expands all the TreeViewNodes in the TreeView.
@param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} expandArgs Either a YOLO ExpandCollapseTreeViewNodeArgs object or a callback function to call once the operation is complete.
@param {Function} callback A callback function to call once the operation is complete.*/
EVUI.Modules.TreeView.TreeView.prototype.expandAll = function (expandArgs, callback)
{
    if (typeof expandArgs === "function")
    {
        callback = expandArgs;
        expandArgs = null;
    }

    if (typeof callback !== "function")
    {
        callback = function () { };
    }

    var nodesExecuted = 0;

    var nodes = this.getNodes();
    var numNodes = nodes.length;
    for (var x = 0; x < numNodes; x++)
    {
        var curNode = nodes[x];
        curNode.expand(expandArgs, function ()
        {
            nodesExecuted++;
            if (nodesExecuted === numNodes)
            {
                callback();
            }
        });
    }
};

/**Awaitabke. Expands all the TreeViewNodes in the TreeView.
@param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} expandArgs Either a YOLO ExpandCollapseTreeViewNodeArgs object or a callback function to call once the operation is complete.
@returns {Promise}*/
EVUI.Modules.TreeView.TreeView.prototype.expandAllAsync = function (expandArgs)
{
    return new Promise(function (resolve)
    {
        this.expandAll(expandArgs, function ()
        {
            resolve();
        })
    });
};

/**Collapses all nodes in the TreeView.
@param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} collapseArgs Either a YOLO ExpandCollapseTreeViewNodeArgs object or a callback function to call once the operation is complete.
@param {Function} callback A callback function to call once the operation is complete.*/
EVUI.Modules.TreeView.TreeView.prototype.collapseAll = function (collapseArgs, callback)
{
    if (typeof collapseArgs === "function")
    {
        callback = collapseArgs;
        collapseArgs = null;
    }

    if (typeof callback !== "function")
    {
        callback = function () { };
    }

    var nodesExecuted = 0;

    var nodes = this.getNodes();
    var numNodes = nodes.length;
    for (var x = 0; x < numNodes; x++)
    {
        var curNode = nodes[x];
        curNode.collapse(collapseArgs, function ()
        {
            nodesExecuted++;
            if (nodesExecuted === numNodes)
            {
                callback();
            }
        });
    }
};

/**Awaitable. Collapses all nodes in the TreeView.
@param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} collapseArgs Either a YOLO ExpandCollapseTreeViewNodeArgs object or a callback function to call once the operation is complete.
@returns {Promise}*/
EVUI.Modules.TreeView.TreeView.prototype.collapseAllAsync = function (collapseArgs)
{
    return new Promise(function (resolve)
    {
        this.collapseAll(collapseArgs, function ()
        {
            resolve();
        })
    });
};

/**Gets either a TreeViewNode with the matching ID, or any nodes that satisfy the predicate function.
@param {Number|EVUI.Modules.TreeView.Constants.Fn_TreeViewNodeSelector} nodeIdOrPredicate Either the ID of a TreeViewNode to get, or a predicate fucntion used to get a selection of TreeViewNodes.
@param {Boolean} getAllMatches Whether or not to return only the first match of the predicate function, or to return all matches of the predicate function.
@returns {EVUI.Modules.TreeView.TreeViewNode|EVUI.Modules.TreeView.TreeViewNode[]} */
EVUI.Modules.TreeView.TreeView.prototype.getNode = function (nodeIdOrPredicate, getAllMatches)
{
    var results = null;

    var nodeList = this.getNodes();
    var isPredicate = typeof nodeIdOrPredicate === "function";

    var numNodes = nodeList.length;
    for (var x = 0; x < numNodes; x++)
    {
        var curNode = nodeList[x];
        if (isPredicate === true)
        {
            var shouldInclude = nodeIdOrPredicate(curNode);
            if (shouldInclude === true)
            {
                if (getAllMatches === true)
                {
                    if (results == null) results = [];
                    results.push(curNode);
                }
                else
                {
                    results = curNode;
                    break;
                }
            }
        }
        else
        {
            if (curNode.id === nodeIdOrPredicate)
            {
                if (getAllMatches === true)
                {
                    if (results == null) results = [];
                    results.push(curNode);
                }
                else
                {
                    results = curNode;
                    break;
                }
            }
        }
    }

    return results;
};

/**A node in a TreeView.
@class*/
EVUI.Modules.TreeView.TreeViewNode = function (nodeEntry)
{
    if (nodeEntry == null) throw Error("Object expected.");

    var _nodeEntry = nodeEntry;
    var _childNodes = [];
    var _self = this;

    /**Numnber. The unique identifier for this TreeViewNode.
    @type {Number}*/
    this.id = null;
    Object.defineProperty(this, "id", {
        get: function ()
        {
            return _nodeEntry.nodeId;
        },
        enumerable: true,
        configurable: false
    });

    /**Object. The root Element of the TreeViewNode that contains the user Binding and the child node list (if one exists).
    @type {Element}*/
    this.element = null;
    Object.defineProperty(this, "element", {
        get: function ()
        {
            return _nodeEntry.rootElement;
        },
        enumerable: true,
        configurable: false
    });

    /**Object. The source object used to generate the user Binding for the TreeViewNode's content. Must be an object.
    @type {{}}*/
    this.source = null;
    Object.defineProperty(this, "source", {
        get: function ()
        {
            return _nodeEntry.source;
        },
        set: function (value)
        {
            if (value != null && typeof value !== "object") throw Error("source must be an object.")
            _nodeEntry.source = value;
        },
        enumerable: true,
        configurable: false
    });

    /**String|Object. Either the name of the BindingTemplate used to generate user content for the interior of the TreeViewNode, or a YOLO BindingTemplate.
    @type {String|EVUI.Modules.Binding.BindingTemplate}*/
    this.bindingTemplate = null;
    Object.defineProperty(this, "bindingTemplate", {
        get: function ()
        {
            return _nodeEntry.bindingTemplate;
        },
        set: function (value)
        {
            _nodeEntry.bindingTemplate = value;
        },
        configurable: false,
        enumerable: true
    });

    /**String|Function. Either the property name of the souce object's list of objects to make into child TreeViewNodes, or a function that returns an array of objects to make into child TreeViewNodes.
    @type {String|EVUI.Modules.TreeView.Constants.Fn_ChildListGetter}*/
    this.childListName = null;

    /**Object. The TreeViewNode that contains this TreeViewNode.
    @type {EVUI.Modules.TreeView.TreeViewNode}*/
    this.parentNode = null;
    Object.defineProperty(this, "parentNode", {
        get: function ()
        {

            if (_nodeEntry.parentNodeEntry == null) return null;
            return _nodeEntry.parentNodeEntry.node;
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The TreeView that owns this TreeViewNode.
    @type {EVUI.Modules.TreeView.TreeView}*/
    this.treeView = null;
    Object.defineProperty(this, "treeView", {
        get: function ()
        {
            return _nodeEntry.treeViewEntry.treeView;
        },
        configurable: false,
        enumerable: true
    });

    /**Number. The number of layers deep this TreeViewNode is in the TreeView hierarchy.
    @type {Number}*/
    this.depth = 0;
    Object.defineProperty(this, "depth", {
        get: function ()
        {
            return _nodeEntry.depth;
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The options for how this TreeViewNode will behave when expanding, collapsing, or being built. Cannot be null.
    @type {EVUI.Modules.TreeView.TreeViewOptions}*/
    this.options = null;
    Object.defineProperty(this, "options", {
        get: function ()
        {
            return _nodeEntry.options;
        },
        set: function (value)
        {
            if (value == null || typeof value !== "object") throw Error("options must be an object.");

            if (EVUI.Modules.Core.Utils.instanceOf(value, EVUI.Modules.TreeView.TreeViewOptions) === false)
            {
                _nodeEntry.options = EVUI.Modules.Core.Utils.shallowExtend(value, new EVUI.Modules.TreeView.TreeViewOptions());
            }
            else
            {
                _nodeEntry.options = value;
            }

            _nodeEntry.optionsChanged = true;
        },
        configurable: false,
        enumerable: true
    });

    /**String. The way in which the options object is shared between child TreeViewNodes. Must be a value from TreeViewOptionsShareMode.
    @type {String}*/
    this.optionsMode = EVUI.Modules.TreeView.TreeViewOptionsShareMode.TreeShared;

    /**String. The current state of the TreeViewNode (expanded, collapsing, etc). Will always be a value from TreeViewNodeState.
    @type {String}*/
    this.nodeState = EVUI.Modules.TreeView.TreeViewNodeState.None;
    Object.defineProperty(this, "nodeState", {
        get: function ()
        {
            return _nodeEntry.nodeState;
        },
        configurable: false,
        enumerable: true
    });

    /**Boolean. Whether or not the TreeViewNode is expanded and its child list is visible.
    @type {Boolean}*/
    this.expanded = false;
    Object.defineProperty(this, "expanded", {
        get: function ()
        {
            return _nodeEntry.expanded;
        },
        configurable: false,
        enumerable: true
    });

    /**Boolean. Whether or not the TreeViewNode is visible by means of having it's parent nodes (parent, grandparent, etc) be expanded.
    @type {Boolean}*/
    this.isVisible = false;
    Object.defineProperty(this, "isVisible", {
        get: function ()
        {
            if (_nodeEntry.rootElement == null) return false;

            var parentNode = _nodeEntry.parentNodeEntry;
            if (parentNode == null) //the only node for which this is true is the top node of the hierarchy
            {
                if (_nodeEntry.options.noTopNode === true) return false;
                return true;
            }
            else
            {
                while (parentNode != null)
                {
                    if (parentNode.expanded === false) return false;
                    parentNode = parentNode.parentNodeEntry;
                }

                return true;
            }
        },
        configurable: false,
        enumerable: true
    });


    /**Gets a copy of the array of child TreeViewNodes contained by this TreeViewNode.
    @returns {EVUI.Modules.TreeView.TreeViewNode[]}*/
    this.getChildNodes = function ()
    {
        var childNodes = [];

        var numNodes = _nodeEntry.childNodeEntries.length;
        for (var x = 0; x < numNodes; x++)
        {
            childNodes.push(_nodeEntry.childNodeEntries[x].node);
        }

        return childNodes;
    };

    /**Expands and builds the TreeViewNode and its child list.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} expandArgs Either a YOLO ExpandCollapseTreeViewNodeArgs or a callback function to call once the expand operation is complete.
    @param {Function} callback A callback function to call once the operation is complete.*/
    this.expand = function (expandArgs, callback)
    {
        return _nodeEntry.expandNode(_nodeEntry, expandArgs, callback);
    };

    /**Awaitable. Expands and builds the TreeViewNode and its child list.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs} expandArgs A YOLO ExpandCollapseTreeViewNodeArgs.
    @returns {Promise}*/
    this.expandAsync = function (expandArgs)
    {
        return new Promise(function (resolve)
        {
            return _self.expand(expandArgs, function ()
            {
                resolve();
            });
        });
    };

    /**Collapses the TreeViewNode.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs|Function} expandArgs Either a YOLO ExpandCollapseTreeViewNodeArgs or a callback function to call once the collapse operation is complete.
    @param {Function} callback A callback function to call once the operation is complete.*/
    this.collapse = function (collapseArgs, callback)
    {
        return _nodeEntry.collapseNode(_nodeEntry, collapseArgs, callback);
    };

    /**Awaitable. ECollapses the TreeViewNode.
    @param {EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs} expandArgs A YOLO ExpandCollapseTreeViewNodeArgs.
    @returns {Promise}*/
    this.collapseAsync = function (collapseArgs)
    {
        return new Promise(function (resolve)
        {
            _self.collapse(collapseArgs, function ()
            {
                resolve();
            });
        });
    }

    /**Builds the TreeViewNode and its child list.
    @param {EVUI.Modules.TreeView.BuildTreeViewNodeArgs|Function} buildArgs A YOLO BuildTreeViewNodeArgs object or a callback function to call once the operation is complete.
    @param {Function} callback A callback to call once the operation is complete.*/
    this.build = function (buildArgs, callback)
    {
        return _nodeEntry.buildNode(_nodeEntry, buildArgs, callback)
    };

    /**Awaitable. Builds the TreeViewNode and its child list.
    @param {EVUI.Modules.TreeView.BuildTreeViewNodeArgs|Function} buildArgs A YOLO BuildTreeViewNodeArgs object.
    @returns {Promise}*/
    this.buildAsync = function (buildArgs)
    {
        return new Promise(function (resolve)
        {
            _self.build(buildArgs, function ()
            {
                resolve();
            });
        });
    }


    /**Event that fires before an expand operation begins.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onExpand = null;

    /**Event that fires after an expand operation has completed.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onExpanded = null;

    /**Event that fires before a build operation begins.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onBuild = null;

    /**Event that fires before the list of children for a TreeViewNode is bound,.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onBuildChildren = null;

    /**Event that fires after the list of children for a TreeViewNode has been bound.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onChildrenBuilt = null;

    /**Event that fires once a TreeViewNode and all its children have been built.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onBuilt = null;

    /**Event that fires before a collapse operation begins.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onCollapse = null;

    /**Event that fires after a collapse operation completes.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onCollapsed = null;
};

/**Object for containing configuration options for a TreeView and its TreeViewNodes.
@class*/
EVUI.Modules.TreeView.TreeViewOptions = function ()
{
    /**String. The type of element that the TreeView's list hierarchy will be made from. Must be a value from TreeViewListElementType. Unordered by default.
    @type {String}*/
    this.listElementType = EVUI.Modules.TreeView.TreeViewListElementType.Unordered;

    /**String. The way in which the TreeView is manipulated. Must be a value from TreeViewListBindingType. ListBound by default.
    @type {String}*/
    this.bindingType = EVUI.Modules.TreeView.TreeViewListBindingType.ListBound;

    /**Object. A CSS transition to apply when a TreeViewNode's child list is expanded.
    @type {EVUI.Modules.TreeView.TreeViewNodeTransition}*/
    this.expandTransition = null;

    /**Object. A CSS transition to apply when a TreeViewNode's child list is collapsed.
    @type {EVUI.Modules.TreeView.TreeViewNodeTransition}*/
    this.collapseTransition = null;

    /**Boolean. Whether or not the construction of child nodes is done ad-hoc when their parent is expanded, or if the entire TreeView is built from the start. True by default. 
    @type {Boolean}*/
    this.lazy = true;

    /**String. The Binder mode used to sync the TreeViewNodes with their underlying data model when they are expanded. Update by default.
    @type {String}*/
    this.expandMode = EVUI.Modules.TreeView.TreeViewNodeBuildMode.Update;

    /**Boolean. Whether or not the TreeView has a single top node, or if the "top" of the TreeView is a list of child TreeViewNodes.
    @type {Boolean}*/
    this.noTopNode = false;

    /**Boolean. Whether or not to use the default "click" event to toggle TreeNewNodes expand/collapse functionality if no other event handlers were registered.*/
    this.autoToggle = true;
};

/**Object containing the configuration options for making a new TreeView.
@class*/
EVUI.Modules.TreeView.AddTreeViewArgs = function ()
{
    /**String. The human-readable name of the TreeView.
    @type {String}*/
    this.id = null;

    /**Object. The element under which the root element of the TreeView will be appended under.
    @type {Element}*/
    this.element = null;

    /**Object. A BindingTemplate used to tell the TreeView how to use the Binder to generate the HTML content for the TreeViewNodes.
    @type {EVUI.Modules.Binding.BindingTemplate}*/
    this.bindingTemplate = null;

    /**Object. The object to use as the data source for the root TreeViewNode in the TreeView.
    @type {Object}*/
    this.source = null;

    /**String. The name of the property on the source that is an array of objects to be bound as children to the TreeViewNodes recursively.
    @type {String}*/
    this.childListName = null;

    /**Object. The TreeViewOptions object that will be used to determine the default behavior of the TreeView.
    @type {EVUI.Modules.TreeView.TreeViewOptions}*/
    this.options = null;

    /**String. The way in which the options object is shared amongst the TreeViewNodes. Must be a value from TreeViewOptionsMode.
    @type {String}*/
    this.optionsMode = EVUI.Modules.TreeView.TreeViewOptionsShareMode.TreeShared;

    /**Event that fires before an expand operation begins.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onExpand = null;

    /**Event that fires after an expand operation has completed.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onExpanded = null;

    /**Event that fires before a build operation begins.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onBuild = null;

    /**Event that fires before the list of children for a TreeViewNode is bound,.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onBuildChildren = null;

    /**Event that fires after the list of children for a TreeViewNode has been bound.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onChildrenBuilt = null;

    /**Event that fires once a TreeViewNode and all its children have been built.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onBuilt = null;

    /**Event that fires before a collapse operation begins.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onCollapse = null;

    /**Event that fires after a collapse operation completes.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onCollapsed = null;
};

/**Object containing the configuration options for adding a new TreeViewNode.
@class*/
EVUI.Modules.TreeView.AddTreeViewNodeArgs = function ()
{
    /**Object. A BindingTemplate used to tell the TreeView how to use the Binder to generate the HTML content for the TreeViewNodes.
    @type {EVUI.Modules.Binding.BindingTemplate}*/
    this.bindingTemplate = null;

    /**Object. The object to use as the data source for the root TreeViewNode in the TreeView.
    @type {Object}*/
    this.source = null;

    /**String. The name of the property on the source that is an array of objects to be bound as children to the TreeViewNodes recursively.
    @type {String}*/
    this.childListName = null;

    /**Object. The TreeViewOptions object that will be used to determine the default behavior of the TreeView.
    @type {EVUI.Modules.TreeView.TreeViewOptions}*/
    this.options = null;

    /**String. The way in which the options object is shared amongst the TreeViewNodes. Must be a value from TreeViewOptionsMode.
    @type {String}*/
    this.optionsMode = EVUI.Modules.TreeView.TreeViewOptionsShareMode.TreeShared;

    /**Event that fires before an expand operation begins.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onExpand = null;

    /**Event that fires after an expand operation has completed.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onExpanded = null;

    /**Event that fires before a build operation begins.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onBuild = null;

    /**Event that fires before the list of children for a TreeViewNode is bound,.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onBuildChildren = null;

    /**Event that fires after the list of children for a TreeViewNode has been bound.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onChildrenBuilt = null;

    /**Event that fires once a TreeViewNode and all its children have been built.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onBuilt = null;

    /**Event that fires before a collapse operation begins.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onCollapse = null;

    /**Event that fires after a collapse operation completes.
    @type {EVUI.Modules.TreeView.Constants.Fn_TreeViewEventHandler}*/
    this.onCollapsed = null;
};

/**Object for containing the options to build a TreeViewNode.
@class*/
EVUI.Modules.TreeView.BuildTreeViewNodeArgs = function ()
{
    /**Object. A BindingTemplate used to tell the TreeView how to use the Binder to generate the HTML content for the TreeViewNodes.
    @type {EVUI.Modules.Binding.BindingTemplate}*/
    this.bindingTemplate = null;

    /**Object. The object to use as the data source for the root TreeViewNode in the TreeView.
    @type {Object}*/
    this.source = null;

    /**String. The name of the property on the source that is an array of objects to be bound as children to the TreeViewNodes recursively.
    @type {String}*/
    this.childListName = null;

    /**String. The mode in which to tell the inner Binding of the TreeView node to build itself. Update by default.
    @type {String}*/
    this.buildMode = EVUI.Modules.TreeView.TreeViewNodeBuildMode.Update;

    /**Object. The TreeViewOptions object that will be used to determine the default behavior of the TreeView.
    @type {EVUI.Modules.TreeView.TreeViewOptions}*/
    this.options = null;

    /**String. The way in which the options object is shared amongst the TreeViewNodes. Must be a value from TreeViewOptionsMode.
    @type {String}*/
    this.optionsMode = EVUI.Modules.TreeView.TreeViewOptionsShareMode.TreeShared;

    /**Boolean. Whether or not to recursively build all child TreeViewNodes under the TreeViewNode being built. False by default.
    @type {Boolean}*/
    this.recursive = false;

    /**Object. Any contextual information to carry between events.
    @type {Object}*/
    this.context = {};
};

/**Arguments for expanding or collapsing a TreeViewNode.
@class*/
EVUI.Modules.TreeView.ExpandCollapseTreeViewNodeArgs = function ()
{
    /**Boolean. Whether or not to recursively expand or collapse all TreeViewNodes under the target TreeViewNode.
    @type {Boolean}*/
    this.recursive = false;

    /**Object. A transition effect to apply to the TreeViewNode while it is expanding or collapsing.
    @type {EVUI.Modules.TreeView.TreeViewNodeTransition}*/
    this.transition = null;

    /**Object. In the event that the TreeViewNode is being expanded, these are the arugments that contorl how the TreeViewNode or its children will be built.
    @type {EVUI.Modules.TreeView.BuildTreeViewNodeArgs}*/
    this.buildArgs = null;

    /**Object. Any contextual information to carry between events.
    @type {Object}*/
    this.context = {};
};

/**Object for containing the CSS details of the transition to apply to a TreeViewNode as it expands or collaposes.
@class*/
EVUI.Modules.TreeView.TreeViewNodeTransition = function ()
{
    /**Object or String. Either class names, a string of CSS rules (without a selector), or an object of key-value pairs of CSS properties to generate a runtime CSS class for.
    @type {Object|String}*/
    this.css = null;

    /**String. CSS definition for a keyframe animation to apply. Note that the keyframe animation's name must appear in the css property in order to be applied.
    @type {String}*/
    this.keyframes = null;

    /**The duration (in milliseconds) of the transition so that the appropate events are only fired once the transition is complete.
    @type {Number}*/
    this.duration = 0;
};

/**Event arguements object for all TreeView and TreeViewNode events.
@class*/
EVUI.Modules.TreeView.TreeViewEventArgs = function (nodeEntry)
{
    var _nodeEntry = nodeEntry;

    /**Object. The TreeView that is the subject of the event.
    @type {EVUI.Modules.TreeView.TreeView}*/
    this.treeView = null;
    Object.defineProperty(this, "treeView", {
        get: function ()
        {
            return _nodeEntry.treeViewEntry.treeView;
        },
        configurable: false,
        enumerable: true
    });

    /**Object. The TreeViewNode that is the subject of the evdent.
    @type {EVUI.Modules.TreeView.TreeViewNode}*/
    this.node = null;
    Object.defineProperty(this, "node", {
        get: function ()
        {
            return _nodeEntry.node;
        },
        configurable: false,
        enumerable: true
    });

    /**String. The unique key current step in the EventStream.
    @type {String}*/
    this.key = null;

    /**Pauses the EventStream, preventing the next step from executing until resume is called.*/
    this.pause = function () { };

    /**Resumes the EventStream, allowing it to continue to the next step.*/
    this.resume = function () { };

    /**Cancels the EventStream and aborts the execution of the operation.*/
    this.cancel = function () { }

    /**Stops the EventStream from calling any other event handlers with the same name.*/
    this.stopPropagation = function () { };

    /**Object. Any state value to carry between events.
    @type {Object}*/
    this.context = {};
};

/**Object to inject the standard dependencies used by the DialogController into it via its constructor.
@class*/
EVUI.Modules.TreeView.TreeViewControllerServices = function ()
{
    /**Object. An instance of the Binding module's BindingController object.
    @type {EVUI.Modules.Binding.BindingController*/
    this.bindingController = null;

    /**Object. An instance of the Styles module's StylesheetManager object.
    @type {EVUI.Modules.Styles.StyleSheetManager}*/
    this.stylesheetManager = null;
};

/**Enum for switching between the different types of HTML list elements (UL or OL).
@enum*/
EVUI.Modules.TreeView.TreeViewListElementType =
{
    Unordered: "ul",
    Ordered: "ol"
};
Object.freeze(EVUI.Modules.TreeView.TreeViewListElementType);

/**Enum for describing the way in which child TreeViewNodes are generated for the TreeView.
@enum*/
EVUI.Modules.TreeView.TreeViewListBindingType =
{
    /**TreeViewNodes are entirely sourced from the property whose name is the childListName in the source object. Building causes the list of TreeViewNodes to be synced with the array of objects pointed at by the childListName on the source object.*/
    ListBound: "bound",
    ///**TreeViewNodes are added/removed manually and not derived from a property on the source object. Building causes the manually added TreeViwNodes's Bindings to be recalculated.*/
    //Manual: "manual",
    ///**TreeViewNodes can be either sourced from the source object or added/removed manually. Building causes anything that was ListBound to be synced and everything that was Manually added to be recalculated and kept at its same index it was manually added at relative to the changes in the ListBound array.*/
    //Hybrid: "hybrid"
};
Object.freeze(EVUI.Modules.TreeView.TreeViewListBindingType);

/**Enum for describing the way in which a TreeViewNode will rebuilt itself when instructed to do so.
@enum*/
EVUI.Modules.TreeView.TreeViewNodeBuildMode =
{
    /**Only rebuids when build/buildAsync is called.*/
    Manual: "manual",
    /**Utilizes the Bindder's rebind mode to rebuild the entire TreeViewNode during build or expand operation.*/
    Rebuild: "rebuild",
    /**Utilizes the Binder's update mode to selectively update the TreeViewNode during a build or expand operation.*/
    Update: "update"
};
Object.freeze(EVUI.Modules.TreeView.TreeViewNodeBuildMode);

/**Enum for describing the mode in which the options object is shared between child TreeViewNodes of a TreeViewNode.
@enum*/
EVUI.Modules.TreeView.TreeViewOptionsShareMode =
{
    /**Every TreeViewNode in the tree shares the same instance of the TreeViewOptions object.*/
    TreeShared: "tree",
    /**Every peer node under a given node shares a single cloned copy of their parent's TreeViewOption object.*/
    PeerNodeShared: "peers",
    /**Every node has its own clone of its parent node's TreeViewOptions object.*/
    Cloned: "cloned"
};
Object.freeze(EVUI.Modules.TreeView.TreeViewOptionsShareMode);

/**Enum for describing the current state of a TreeViewNode.
@enum*/
EVUI.Modules.TreeView.TreeViewNodeState =
{
    None: "none",
    Collapsed: "collapsed",
    Collapsing: "collapsing",
    Expanded: "expanded",
    Expanding: "expanding",
    Building: "building",
    Disposed: "disposed"
};
Object.freeze(EVUI.Modules.TreeView.TreeViewNodeState);

/**Enum for describing the current state of an entire TreeView. 
@enum*/
EVUI.Modules.TreeView.TreeViewState =
{
    None: "none",
    Ready: "ready",
    Disposed: "disposed"
};
Object.freeze(EVUI.Modules.TreeView.TreeViewState);

/**Global instance of the TreeViewController.
@type {EVUI.Modules.TreeView.TreeViewController}*/
EVUI.Modules.TreeView.Manager = null;
(function ()
{
    var manager = null;
    var ctor = EVUI.Modules.TreeView.TreeViewController;

    Object.defineProperty(EVUI.Modules.TreeView, "Manager", {
        get: function ()
        {
            if (manager == null)
            {
                manager = new ctor();
            }

            return manager;
        },
        configurable: false,
        enumerable: true
    });
})();

delete $evui.treeViews;

/**Controller for creating and managing TreeViews.
@type {EVUI.Modules.TreeView.TreeViewController}*/
$evui.treeViews = null;
Object.defineProperty($evui, "treeViews", {
    get: function ()
    {
        return EVUI.Modules.TreeView.Manager;
    }
});


/**Creates and adds a TreeView to the controller's list of managed TreeViews.
@param {String|EVUI.Modules.TreeView.AddTreeViewArgs|EVUI.Modules.TreeView.TreeView} makeTreeViewArgsOrId Either the string name of the TreeView to make, a YOLO TreeView object describing the tree, or a YOLO AddTreeViewArgs object describing the tree.
@param {EVUI.Modules.TreeView.AddTreeViewNodeArgs|EVUI.Modules.TreeView.TreeViewNode} rootNodeArgs Optional. Arguments for making the root TreeViewNode of the TreeView. Can either be a YOLO TreeViewNode or a YOLO AddTreeViewNodeArgs object.
@returns {EVUI.Modules.TreeView.TreeView} */
$evui.addTreeView = function (makeTreeViewArgsOrId, rootNodeArgs)
{
    return $evui.treeViews.addTreeView(makeTreeViewArgsOrId, rootNodeArgs);
};

/**Gets a TreeView or TreeViews from the TreeViewController.
@param {String|EVUI.Modules.TreeView.Constants.Fn_TreeViewSelector} treeViewIdOrPredicate Either the string ID of a TreeView to get, or a predicate function used to select TreeViews from the controller's collection of TreeViews.
@param {Boolean} getAllMatches Optional. Whether or not to return all the matches that satisfied the predicate function. If omitted only the first TreeView to satisfy the predicate is returned.
@returns {TreeView|TreeView[]} */
$evui.getTreeView = function (treeViewIdOrPredicate, getAllMatches)
{
    return $evui.treeViews.getTreeView(treeViewIdOrPredicate, getAllMatches)
};

/**Removes and optionally disposes of one of the TreeViews being managed by this controller.
@param {String} treeViewId The ID of the TreeView to remove.
@param {Boolean} dispose LOptional. Whether or not to dispose of and destroy the TreeView once it has been removed. False by default.
@returns {Boolean} */
$evui.removeTreeView = function (treeViewId, dispose)
{
    return $evui.treeViews.removeTreeView(treeViewId, dispose)
};

/*#ENDWRAP(TreeView)#*/


/********************************************************UIHandler.js********************************************************/
/**Copyright (c) 2023 Richard H Stannard

This source code is licensed under the MIT license found in the
LICENSE file in the root directory of this source tree.*/

/*#INCLUDES#*/

/*#BEGINWRAP(EVUI.Modules.UIHandler|UI)#*/
/*#REPLACE(EVUI.Modules.UIHandler|UI)#*/

/**Module for responding directly to UI events via in-lined event handlers.
@module*/
EVUI.Modules.UIHandler = {};

/*#MODULEDEF(UI|"1.0";|"UI")#*/
/*#VERSIONCHECK(EVUI.Modules.UIHandler|UI)#*/

EVUI.Modules.UIHandler.Dependencies =
{
    Core: Object.freeze({ version: "1.0", required: true }),
};

(function ()
{
    var checked = false;

    Object.defineProperty(EVUI.Modules.UIHandler.Dependencies, "checked",
        {
            get: function () { return checked; },
            set: function (value)
            {
                if (typeof value === "boolean") checked = value;
            },
            configurable: false,
            enumberable: true
        });
})();


Object.freeze(EVUI.Modules.UIHandler.Dependencies);

EVUI.Modules.UIHandler.Constants = {};

/**Callback function for handling a UI event.
@param {EVUI.Modules.UIHandler.UIHandlerEventArgs} args An instance of EVUI.Resources.UIHandlerEventArgs*/
EVUI.Modules.UIHandler.Constants.Fn_Handle = function (args) { };

Object.freeze(EVUI.Modules.UIHandler.Constants);

/**Object for managing UIHandles and their invocation.
@class*/
EVUI.Modules.UIHandler.UIHandlerManager = function ()
{
    if (EVUI.Modules.Core == null) throw Error("Dependency missing: EVUI.Modules.Core is required.");
    EVUI.Modules.Core.Utils.requireAll(EVUI.Modules.UIHandler.Dependencies);

    var _self = this;

    /**Array. The list of internal UIHandlers.
    @type {EVUI.Modules.UIHandler.UIHandle[]}*/
    var _handlers = {};

    /**Adds a UIHandler to the manager.
    @param {String|EVUI.Modules.UIHandler.UIHandle} keyOrHandle Either the string key of the handler, or a YOLO UIHandle object.
    @param {EVUI.Modules.UIHandler.UIHandler.Fn_Handle} handler The handling function that will be invoked with handle is called with the given key.*/
    this.addHandler = function (keyOrHandle, handler)
    {
        var handle = null;
        if (keyOrHandle == null) throw Error("Invalid input, object or string expected.");

        if (typeof keyOrHandle === "object")
        {
            handle = EVUI.Modules.Core.Utils.shallowExtend(new EVUI.Modules.UIHandler.UIHandle(keyOrHandle.key, keyOrHandle.handle), keyOrHandle, ["key", "handle"]);
        }
        else if (typeof keyOrHandle === "string" && EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(keyOrHandle) === false)
        {
            handle = new EVUI.Modules.UIHandler.UIHandle(keyOrHandle, handler);
        }
        else
        {
            throw Error("Invalid input, object or string expected.");
        }

        var existing = this.getHandler(handle.key);
        if (existing != null) throw Error("A UIHandle with the name \"" + handle.key + "\" already exists.");

        _handlers[handle.key] = handle;
    };

    /**Removes a UIHandler from the manager.
    @param {String} key The key of the UIHandler to remove.
    @returns {Boolean}*/
    this.removeHandler = function (key)
    {
        if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(key) === true) return false;
        var existing = this.getHandler(key);

        if (existing == null) return false;

        var index = _handlers.indexOf(existing);
        if (index !== -1) _handlers.splice(index, 1);

        return true;
    };

    /**Event that fires ever time an event is routed through the manager. Can prevent that UIHandle's handler from being called via calling cancel on the event args.
    @param {EVUI.Modules.UIHandler.UIHandlerEventArgs} uiHandlerEventArgs The event arguments for the event.*/
    this.onHandle = function (uiHandlerEventArgs)
    {

    };

    /**Handles a UI event by calling the UIHandler with the matching key.
    @param {String} key The key of the UIHandler to call.
    @param {Event|Any} eventArgsOrData Either the browser's event arguments or custom data to pass into the UIHandler's handle.
    @param {Any} data Custom data to pass into the UIHandler's handle.*/
    this.handle = function (key, eventArgsOrData, data)
    {
        var uiEvent = null;
        var handlerName = null;
        var handlerData = null;

        if (typeof key !== "string" || EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(key) === true)  throw Error("Invalid input, no handler name provided.");
        
        handlerName = key;
        if (eventArgsOrData != null)
        {
            if (eventArgsOrData instanceof Event)
            {
                uiEvent = eventArgsOrData;
                if (data != null) handlerData = data;   
            }
            else
            {
                handlerData = eventArgsOrData;
            }         
        }
        else
        {
            if (data != null) handlerData = data;
        }           

        var handler = this.getHandler(handlerName);
        if (handler == null) throw Error("No handler present for event \"" + key + "\"");

        var canceled = false;
        var args = new EVUI.Modules.UIHandler.UIHandlerEventArgs(handlerName, uiEvent);
        args.data = handlerData;
        args.cancel = function ()
        {
            canceled = true;
        };

        var onHandleWrapper = function (uiManagerArgs)
        {
            if (typeof _self.onHandle === "function")
            {
                return _self.onHandle(uiManagerArgs);
            }
        };

        var eventHandlerWrapper = function (uiManagerArgs)
        {
            if (typeof handler.handler === "function" && canceled === false)
            {
                return handler.handler(uiManagerArgs);
            }
        };

        var exeArgs = new EVUI.Modules.Core.AsyncSequenceExecutionArgs();
        exeArgs.functions = [onHandleWrapper, eventHandlerWrapper];
        exeArgs.parameter = args;

        EVUI.Modules.Core.AsyncSequenceExecutor.execute(exeArgs, function (error)
        {
            if (error instanceof Error) throw error;
        });
    };

    /**Gets a UIHandler based on its key.
    @param {String} key The key of the UIHandler to get.
    @returns {EVUI.Modules.UIHandler.UIHandle}*/
    this.getHandler = function (key)
    {
        return _handlers[key];
    };
};


/**Object representing a key-value pair of an event handler to a key name, as well as an executing context.
@class*/
EVUI.Modules.UIHandler.UIHandle = function (key, handler)
{
    if (EVUI.Modules.Core.Utils.stringIsNullOrWhitespace(key) === true) throw new Error("key must be a valid string with at least one non-whitespace character.");
    if (handler != null && typeof handler !== "function") throw new Error("handler must be a function.")

    var _key = key;
    var _handler = (typeof handler === "function") ? handler : null;

    /**String. Read-only. The key by which this event is referenced.
    @type {String}*/
    this.key = null;
    Object.defineProperty(this, "key",
    {
        get: function () { return _key; },
        configurable: false,
        enumerable: true
    });

    /**Function. The function that will fire when this command is called from the UI.
    @type {EVUI.Modules.UIHandler.UIHandler.Fn_Handle}*/
    this.handler = null;
    Object.defineProperty(this, "handler",
    {
        get: function () { return _handler; },
        set: function (value) { if (value != null && typeof value !== "function") throw Error("handler must be a function."); },
        configurable: false,
        enumerable: true
    });
};

/**Object representing the event arguments that the handler will receive.
@class*/
EVUI.Modules.UIHandler.UIHandlerEventArgs = function (key, eventArgs)
{
    var _key = key;
    var _eventArgs = eventArgs;
    var _currentTargetAttributes = null;
    var _targetAttributes = null;    

    /**Object. An instance of EVUI.Resources.UIHandler representing the event handler being called.
    @type {String}*/
    this.key = null;
    Object.defineProperty(this, "key",
    {
        get: function () { return _key; },
        configurable: false,
        enumerable: true
    });

    /**Object. The browser's event arguments.
    @type {Event}*/
    this.eventArgs = null;
    Object.defineProperty(this, "eventArgs",
    {
        get: function () { return _eventArgs; },
        configurable: false,
        enumerable: true
    });

    /**Any. Any data passed into the handle function that is to be used in processing the event.
    @type {Any}*/
    this.data = null;

    /**Object. An object containing all the attributes that were attached to the currentTarget property of the eventArgs.
    @type {EVUI.Modules.Core.CaseInsensitiveObject}*/
    this.currentTargetAttributes = null;
    Object.defineProperty(this, "currentTargetAttributes", {
        get: function ()
        {
            if (_currentTargetAttributes == null)
            {
                if (_eventArgs.currentTarget != null) _currentTargetAttributes = EVUI.Modules.Core.Utils.getElementAttributes(_eventArgs.currentTarget);
            }

            return _currentTargetAttributes;
        },
        enumerable: true,
        configurable: false
    });

    /**Object. An object containing all the attributes that were attached to the target property of the eventArgs.
    @type {EVUI.Modules.Core.CaseInsensitiveObject}*/
    this.targetAttributes = null;
    Object.defineProperty(this, "targetAttributes", {
        get: function ()
        {
            if (_targetAttributes == null)
            {
                if (_eventArgs.target != null) _targetAttributes = EVUI.Modules.Core.Utils.getElementAttributes(_eventArgs.target);
            }

            return _targetAttributes;
        },
        enumerable: true,
        configurable: false
    });

    /**If called in the global onHandle event, this prevents the UIHandler's handle from firing.*/
    this.cancel = function ()
    {

    };
};

/**Global instance of the UIHandler, used for routing all UI events through the same codepath.
@type {EVUI.Modules.UIHandler.UIHandlerManager}*/
EVUI.Modules.UIHandler.Manager = null;
(function ()
{
    var ctor = EVUI.Modules.UIHandler.UIHandlerManager;
    var manager = null;

    Object.defineProperty(EVUI.Modules.UIHandler, "Manager", {
        get: function ()
        {
            if (manager == null) manager = new ctor();
            return manager;
        },
        configurable: false,
        enumberable: true
    });
})();

delete $evui.uiHandler;

/**Global instance of the UIHandler.
@type {EVUI.Modules.UIHandler.UIHandlerManager}*/
$evui.uiHandler = null;
Object.defineProperty($evui, "uiHandler", {
    get: function ()
    {
        return EVUI.Modules.UIHandler.Manager;
    },
    enumerable: true
});

/**Handles a UI event by calling the UIHandler with the matching key.
@param {String} key The key of the UIHandler to call.
@param {Event|Any} eventArgsOrData Either the browser's event arguments or custom data to pass into the UIHandler's handle.
@param {Any} data Custom data to pass into the UIHandler's handle.*/
$evui.handle = function (key, eventArgsOrData, data)
{
    return $evui.uiHandler.handle(key, eventArgsOrData, data);
};

/**Adds a UIHandler to the manager.
@param {String|EVUI.Modules.UIHandler.UIHandle} keyOrHandle Either the string key of the handler, or a YOLO UIHandle object.
@param {EVUI.Modules.UIHandler.Constants.Fn_Handle} handler The handling function that will be invoked with handle is called with the given key.*/
$evui.addUIHandler = function (keyOrHandle, handler)
{
    return $evui.uiHandler.addHandler(keyOrHandle, handler);
};

/**Removes a UIHandler from the manager.
@param {String} key The key of the UIHandler to remove.
@returns {Boolean}*/
$evui.removeUIHandler = function (key)
{
    return $evui.uiHandler.removeHandler(key);
};

Object.freeze(EVUI.Modules.UIHandler);

/*#ENDWRAP(UI)#*/
